{*******************************************************************}
{                                                                   }
{       Developer Express Visual Component Library                  }
{       ExpressBars components                                      }
{                                                                   }
{       Copyright (c) 1998-2009 Developer Express Inc.              }
{       ALL RIGHTS RESERVED                                         }
{                                                                   }
{   The entire contents of this file is protected by U.S. and       }
{   International Copyright Laws. Unauthorized reproduction,        }
{   reverse-engineering, and distribution of all or any portion of  }
{   the code contained in this file is strictly prohibited and may  }
{   result in severe civil and criminal penalties and will be       }
{   prosecuted to the maximum extent possible under the law.        }
{                                                                   }
{   RESTRICTIONS                                                    }
{                                                                   }
{   THIS SOURCE CODE AND ALL RESULTING INTERMEDIATE FILES           }
{   (DCU, OBJ, DLL, ETC.) ARE CONFIDENTIAL AND PROPRIETARY TRADE    }
{   SECRETS OF DEVELOPER EXPRESS INC. THE REGISTERED DEVELOPER IS   }
{   LICENSED TO DISTRIBUTE THE EXPRESSBARS AND ALL ACCOMPANYING VCL }
{   CONTROLS AS PART OF AN EXECUTABLE PROGRAM ONLY.                 }
{                                                                   }
{   THE SOURCE CODE CONTAINED WITHIN THIS FILE AND ALL RELATED      }
{   FILES OR ANY PORTION OF ITS CONTENTS SHALL AT NO TIME BE        }
{   COPIED, TRANSFERRED, SOLD, DISTRIBUTED, OR OTHERWISE MADE       }
{   AVAILABLE TO OTHER INDIVIDUALS WITHOUT EXPRESS WRITTEN CONSENT  }
{   AND PERMISSION FROM DEVELOPER EXPRESS INC.                      }
{                                                                   }
{   CONSULT THE END USER LICENSE AGREEMENT FOR INFORMATION ON       }
{   ADDITIONAL RESTRICTIONS.                                        }
{                                                                   }
{*******************************************************************}

unit dxBar;

{$I cxVer.inc}

interface

uses
{$IFDEF DELPHI6}
  Types,
{$ENDIF}
  SysUtils, TypInfo, Windows, Messages, Graphics, Controls, Forms, Classes,
  ImgList, ActnList, Menus, StdCtrls, dxCommon,
  dxThemeManager, cxLookAndFeels, cxLookAndFeelPainters, cxControls, cxContainer,
  IniFiles, cxClasses, cxGraphics, Contnrs, cxStyles, dxFading,
  cxAccessibility, cxLibraryConsts;

type
  TdxBarItemPosition = (ipBeginsNewRow, ipBeginsNewColumn, ipContinuesRow);
  TdxByteSet = set of Byte;

  TdxBarItemViewLevel = (ivlLargeIconWithText, ivlSmallIconWithText,
    ivlSmallIcon, ivlControlOnly, ivlDefault{D10 bug});
  TdxBarItemRealViewLevel = ivlLargeIconWithText..ivlControlOnly;
  TdxBarItemViewLevels = set of TdxBarItemRealViewLevel;

  TdxBarButtonGroupPosition = (bgpNone, bgpStart, bgpMember);
  TdxBarButtonGroupRealPosition = (bgrpNone, bgrpStart, bgrpMember, bgrpFinish,
    bgrpSingle);

  TdxBarItemAlign = (iaLeft, iaCenter, iaRight, iaClient);
  TdxBarGlyphLayout = (glLeft, glRight, glTop, glBottom);

  TdxBarMenuItemSize = (misNormal, misLarge);

  TdxBarBehaviorOption = (bboAllowDetach,
    bboAllowSelectWindowItemsWithoutFocusing, bboAllowShowHints,
    bboClickItemsBySpaceKey, bboExtendItemWhenAlignedToClient,
    bboNeedsFocusWhenActive, bboMouseCantUnselectNavigationItem, bboUnmoved,
    bboItemCustomizePopup, bboSubMenuCaptureMouse);
  TdxBarBehaviorOptions = set of TdxBarBehaviorOption;

  TdxBarItemCachedWidthInfo = record
    Calculated: Boolean;
    Width: Integer;
  end;

  TdxBarItemStyleData = record
    AssignedValues: TcxStyleValues;
    Color: TColor;
    FontData: TFontData;
    TextColor: TColor;

    Style: TcxStyle;
  end;

  TdxBarMouseWheelEventReceiver = (mwrNone, mwrActiveBarControl,
    mwrFocusedItemControl, mwrWindow);

  TdxBarMDIButton = (mdibMinimize, mdibRestore, mdibClose);
  TdxBarMDIButtons = set of TdxBarMDIButton;

  TdxBarKind = (bkBarControl, bkBarQuickControl, bkSubMenu);
  TdxBarKinds = set of TdxBarKind;

const
  WM_REPAINTBAR = WM_DX + 1;

  dxBarDefaultButtonArrowWidth = 11;
  dxBarDefaultLargeButtonArrowWidth = 13;//4;
  dxBarTransparentShadowSize = 4;
  dxBarOpaqueShadowSize = 2;

  dxBarItemAllViewLevels = [ivlLargeIconWithText..ivlControlOnly];// Builder 2009 error [Low(TdxBarItemRealViewLevel)..High(TdxBarItemRealViewLevel)];
  dxBarItemDefaultPosition = ipBeginsNewRow;
  MDIButtonCommands: array[TdxBarMDIButton] of Integer =
    (SC_MINIMIZE, SC_RESTORE, SC_CLOSE);
  dxBarKindAny = [Low(TdxBarKind)..High(TdxBarKind)];

type
  TCustomdxBarControl = class;
  TCustomdxBarControlClass = class of TCustomdxBarControl;
  TCustomdxBarControlDesignHelper = class;
  TCustomdxBarControlDesignHelperClass = class of TCustomdxBarControlDesignHelper;
  TCustomdxBarControlViewInfo = class;
  TCustomdxBarControlViewInfoClass = class of TCustomdxBarControlViewInfo;
  TCustomdxBarSubItem = class;
  TdxBar = class;
  TdxBarAccessibilityHelper = class;
  TdxBarCustomApplicationMenu = class;
  TdxBarButton = class;
  TdxBarButtonLikeControlDrawParams = class;
  TdxBarApplicationMenuButtonItem = class;
  TdxBarButtonLikeControl = class;
  TdxBarCaptionButtons = class;
  TdxBarComponentList = class;
  TdxBarControl = class;
  TdxBarControlClass = class of TdxBarControl;
  TdxBarCustomizingPopup = class;
  TdxBarCustomEditControl = class;
  TdxBarCustomStaticControl = class;
  TdxBarDockControl = class;
  TdxBarDockControlClass = class of TdxBarDockControl;
  TdxBarEditControl = class;
  TdxBarItem = class;
  TdxBarItemClass = class of TdxBarItem;
  TdxBarItemControl = class;
  TdxBarItemControlClass = class of TdxBarItemControl;
  TdxBarItemControlViewInfo = class;
  TdxBarItemLink = class;
  TdxBarItemLinks = class;
  TdxBarItemLinksClass = class of TdxBarItemLinks;
  TdxBarManager = class;
  TdxBarPainter = class;
  TdxBarPainterClass = class of TdxBarPainter;
  TdxBarPopupMenu = class;
  TdxBarPopupMenuLink = class;
  TdxBarQuickControl = class;
  TdxBarExtraPaneListItem = class;
  TdxBars = class;
  TdxBarShadow = class;
  TdxBarSubItem = class;
  TdxBarSubMenuControl = class;
  TdxDockControl = class;
  TdxDockRow = class;
  TdxObjectList = class;
  TdxBarScreenTip = class;
  TdxBarCustomHintViewInfo = class;
  TdxBarCustomHintViewInfoClass = class of TdxBarCustomHintViewInfo;
  TdxBarScreenTipViewInfo = class;
  TdxBarScreenTipCollection = class;
  TdxBarScreenTipBand = class;
  TdxBarScreenTipBandViewInfo = class;
  TdxBarHintWindow = class;
  TdxBarHintWindowClass = class of TdxBarHintWindow;
  TdxBarScreenTipRepository = class;

  TdxBarItemSeparatorKind = (skHorizontal, skVertical);

  TdxBarItemSeparatorData = record
    AssociatedItemControl: TObject;
    Bounds: TRect;
    Kind: TdxBarItemSeparatorKind;
  end;

  {--------------------------
      Nonvisual components
   --------------------------}
  TdxBarSelectionStatus = (ssUnselected, ssActiveSelected, ssInactiveSelected);
  TdxBarSelectionOperation = (soAdd, soExclude, soExclusive);
  TdxBarCustomizationAction = (caReset, caDelete, caDeleteItem, caDeleteLink,
    caChangeCaption, caChangeButtonPaintStyle, caChangePosition, caChangeViewLevels,
    caChangeButtonGroup, caChangeDistributed, caChangeBeginGroup, caChangeVisible, caChangeRecentList);
  TdxBarCustomizationActions = set of TdxBarCustomizationAction;

  IdxBarSelectableItem = interface
  ['{6DCCAA42-48D0-4D7D-BEDF-1EADC2197131}']
    function CanDelete(ADestruction: Boolean = False): Boolean;
    procedure DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean);
    procedure ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction);
    function GetBarManager: TdxBarManager;
    function GetInstance: TPersistent;
    procedure GetMasterObjects(AList: TdxObjectList);
    function GetNextSelectableItem: IdxBarSelectableItem;
    function GetSelectableParent: TPersistent;
    function GetSelectionStatus: TdxBarSelectionStatus;
    function GetSupportedActions: TdxBarCustomizationActions;
    procedure Invalidate;
    function IsComplex: Boolean;
    function IsComponentSelected: Boolean;
    procedure SelectComponent(ASelectionOperation: TdxBarSelectionOperation = soExclusive);
    function SelectParentComponent: Boolean;
    procedure SelectionChanged;
  end;

  IdxBarDesigner = interface
  ['{B364658F-B4CE-46C3-83D5-D537F34B9482}']
    function CanDeleteComponent(AComponent: TComponent): Boolean;
    procedure GetSelection(AList: TList);
    function GetSelectionStatus(AComponent: TPersistent): TdxBarSelectionStatus;
    function IsComponentSelected(AComponent: TPersistent): Boolean;
    procedure SelectComponent(AComponent: TPersistent; ASelectionOperation: TdxBarSelectionOperation = soExclusive);
    procedure SetSelection(AList: TList);
    procedure ShowDefaultEventHandler(AItem: TdxBarItem);
    function UniqueName(const BaseName: string): string;
  end;

  IdxBarLinksOwner = interface
  ['{1CB4E538-769E-45F4-9BE3-20814F440106}']
    function CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
    function CreateBarControl: TCustomdxBarControl;
    function GetInstance: TComponent;
    function GetItemLinks: TdxBarItemLinks;
  end;

  IdxBarSubMenuOwner = interface
  ['{218A3250-D279-44EA-9E87-3D5443B3C0ED}']
    function GetBarSize: Integer;
    procedure DoPaintBar(ACanvas: TCanvas; const R: TRect);
  end;

  IdxBarMultiColumnItemControlViewInfo = interface
  ['{B92D58D1-3251-4816-A43F-D4D4AF2F02EE}']
    function CanCollapse: Boolean;
    function GetCollapsed: Boolean;
    function GetColumnCount: Integer;
    function GetMaxColumnCount: Integer;
    function GetMinColumnCount: Integer;
    function GetWidthForColumnCount(AColumnCount: Integer): Integer;
    procedure SetCollapsed(Value: Boolean);
    procedure SetColumnCount(Value: Integer);
  end;

  IdxBarItemControlViewInfo = interface
  ['{99C4A703-E6D2-43AF-987E-F5DA81718295}']
    procedure CalculateFinalize;
    function GetAlign: TdxBarItemAlign;
    function GetAllowedViewLevels: TdxBarItemViewLevels;
    function GetBounds: TRect;
    function GetColumnRowCount: Integer;
    function GetDistributed: Boolean;
    function GetPosition: TdxBarItemPosition;
    function GetPositionInButtonGroup: TdxBarButtonGroupPosition;
    function GetRealPositionInButtonGroup: TdxBarButtonGroupRealPosition;
    function GetRow: Integer;
    function GetViewLevel: TdxBarItemViewLevel;
    function GetViewLevelForButtonGroup: TdxBarItemRealViewLevel;
    function GetWidth(AViewLevel: TdxBarItemRealViewLevel): Integer;
    function HasSeparator: Boolean;
    function IsPrimaryForDistribution: Boolean;
    function IsMultiColumnItemControl(ACheckCollapsed: Boolean;
      out AIMultiColumnItemControlViewInfo: IdxBarMultiColumnItemControlViewInfo): Boolean;
    procedure SetBounds(const Value: TRect);
    procedure SetColumnRowCount(Value: Integer);
    procedure SetDistributed(Value: Boolean);
    procedure SetRealPositionInButtonGroup(Value: TdxBarButtonGroupRealPosition);
    procedure SetRow(Value: Integer);
    procedure SetViewLevel(Value: TdxBarItemViewLevel);
  end;

  IdxBarHintKeeper = interface
  ['{587A00C4-A7E0-4032-98E5-4DB8F3918ADF}']
    function DoHint(var ANeedDeactivate: Boolean; out AHintText: string; out AShortCut: string): Boolean;
    function CreateHintViewInfo(const AHintText, AShortCut: string): TdxBarCustomHintViewInfo;
    function GetEnabled: Boolean;
    function GetHintPosition(const ACursorPos: TPoint; AHeight: Integer): TPoint;
  end;

  IdxBarKeyTipWindowsManager = interface
  ['{ABA47F3E-5F8B-4A4B-863F-B70AC02F3C1D}']
    procedure Add(const ACaption: string; const ABasePoint: TPoint;
      AHorzAlign: TAlignment; AVertAlign: TcxAlignmentVert; AEnabled: Boolean;
      out AWindow: TObject);
    procedure Delete(AWindow: TObject);
    procedure Show;
  end;

  { TdxBarKeyTipInfo }

  TdxBarKeyTipInfo = record
    KeyTip: string;
    BasePoint: TPoint;
    HorzAlign: TAlignment;
    VertAlign: TcxAlignmentVert;
    Visible: Boolean;
    Enabled: Boolean;
    OnExecute: TNotifyEvent;
  end;

  { TdxBarKeyTipData }

  TdxBarKeyTipData = class
  private
    FKeyTipInfo: TdxBarKeyTipInfo;
    FKeyTipWindow: TObject;
    function GetNormalizedKeyTip: string;
  public
    constructor Create(const AKeyTipInfo: TdxBarKeyTipInfo);
    procedure HideKeyTipWindow(AKeyTipWindowsManager: IdxBarKeyTipWindowsManager);
    procedure ShowKeyTipWindow(AKeyTipWindowsManager: IdxBarKeyTipWindowsManager);

    property BasePoint: TPoint read FKeyTipInfo.BasePoint;
    property Enabled: Boolean read FKeyTipInfo.Enabled;
    property HorzAlign: TAlignment read FKeyTipInfo.HorzAlign;
    property KeyTip: string read FKeyTipInfo.KeyTip write FKeyTipInfo.KeyTip;
    property NormalizedKeyTip: string read GetNormalizedKeyTip;
    property VertAlign: TcxAlignmentVert read FKeyTipInfo.VertAlign;
    property Visible: Boolean read FKeyTipInfo.Visible write FKeyTipInfo.Visible;
    property OnExecute: TNotifyEvent read FKeyTipInfo.OnExecute;
  end;

  IdxBarAccessibilityHelper = interface(IcxAccessibilityHelper)
  ['{5AE17753-A04D-4496-B5A3-08B2CEDE40F7}']
    function AreKeyTipsSupported(
      out AKeyTipWindowsManager: IdxBarKeyTipWindowsManager): Boolean;
    function CanNavigateToChildren(AKey: Word): Boolean;
    function GetBarHelper: TdxBarAccessibilityHelper;
    function GetBarManager: TdxBarManager;
    function GetDefaultAccessibleObject: IdxBarAccessibilityHelper;
    function GetNextAccessibleObject(
      ADirection: TcxAccessibilityNavigationDirection): IdxBarAccessibilityHelper;
    function GetRootAccessibleObject: IdxBarAccessibilityHelper;
    function HandleNavigationKey(var AKey: Word): Boolean;
    function IsNavigationKey(AKey: Word): Boolean;
    function IsSelected: Boolean;
    function LogicalNavigationGetNextAccessibleObject(AGoForward: Boolean): IdxBarAccessibilityHelper;
    procedure Select(ASetFocus: Boolean);
    procedure Unselect(ANextSelectedObject: IdxBarAccessibilityHelper);
  end;

  IdxBarAccessibleObject = interface
  ['{6411B5B8-FFF8-42BD-BFD4-0B53151C97DC}']
    function GetAccessibilityHelper: IdxBarAccessibilityHelper;
  end;

  IdxSkin = interface
  ['{ABCD2B3A-5F77-45A1-ADE2-3C028D4DB64C}']
    procedure DrawBackground(DC: HDC; const ARect: TRect; APart: Integer; AState: Integer = 0);
    procedure DrawCaption(DC: HDC; const ACaption: string; const ARect: TRect;
      APart: Integer; AState: Integer = 0);
    function GetCaptionRect(const ARect: TRect; APart: Integer): TRect;
    function GetContentOffsets(APart: Integer): TRect;
    function GetName: string;
    function GetPartColor(APart: Integer; AState: Integer = 0): TColor;
    function GetPartOffset(APart: Integer): Integer;
  end;

  { TdxBarPersistent }

  TdxBarPersistent = class(TPersistent)
  private
    FBarManager: TdxBarManager;
  protected
    function GetOwner: TPersistent; override;
  public
    constructor Create(ABarManager: TdxBarManager); virtual;
    property BarManager: TdxBarManager read FBarManager;
  end;

{$IFNDEF DELPHI6}
  TComponentList = class(Contnrs.TComponentList)
  public
    destructor Destroy; override;
  end;
{$ENDIF}  

  { TdxBarControlEditors }

  TdxBarControlEditor = class
  protected
    class function GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass; virtual;
    class function GetPopupItemCaption: string; virtual;
    class procedure InitializePopupItem(AItemLink: TdxBarItemLink); virtual;
    class function PopupItemClass: TdxBarItemClass; virtual;

    class procedure AddItem(AClickedButton: TdxBarButton);
    class procedure InitializeAddedItem(AItemLink: TdxBarItemLink; AAddedItemName: string); virtual;
    class procedure OnButtonClick(Sender: TObject);
  public
    class procedure InitCustomizationPopup(AItemLinks: TdxBarItemLinks); virtual;
  end;
  TdxBarControlEditorClass = class of TdxBarControlEditor;

  TdxAddSubItemEditor = class(TdxBarControlEditor)
  protected
    class function GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass; override;
    class function GetPopupItemCaption: string; override;
    class procedure InitializePopupItem(AItemLink: TdxBarItemLink); override;
    class function PopupItemClass: TdxBarItemClass; override;
  end;

  TdxAddButtonEditor = class(TdxAddSubItemEditor)
  protected
    class function GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass; override;
    class function GetPopupItemCaption: string; override;
  end;

  TdxAddSeparatorEditor = class(TdxAddSubItemEditor)
  protected
    class function GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass; override;
    class function GetPopupItemCaption: string; override;
  end;

  TdxItemsEditorEx = class(TdxBarControlEditor)
  protected
    class procedure InitSubItem(AItemLinks: TdxBarItemLinks); virtual;
    class function GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass; override;
    class function GetPopupItemCaption: string; override;
    class procedure InitializePopupItem(AItemLink: TdxBarItemLink); override;
    class function PopupItemClass: TdxBarItemClass; override;
  end;

  { TdxBarCustomizingPopup }

  TdxChangeViewLevelAction = (vlaChangeLargeIconWithText, vlaChangeSmallIconWithText,
    vlaChangeSmallIcon, vlaChangeControl, vlaSetAll, vlaSetLargeIconWithTextOnly,
    vlaSetSmallIconWithTextOnly, vlaSetSmallIconOnly, vlaControlOnly);

  TdxChangeButtonGroupAction = (bgaNone, bgaStart, bgaMember, bgaGroup, bgaUngroup);

  { TdxBarDesignController }

  TdxDesignState = (dsKeyAlreadyProcessed);
  TdxDesignStates = set of TdxDesignState;
  TInitPopupProc = procedure (AItemLinks: TdxBarItemLinks) of object;

  TdxBarDesignController = class(TcxDesignController)
  private
    FCustomizingBarControl: TCustomdxBarControl;
    FCustomizingBarManager: TdxBarManager;
    FCustomizingItemLink: TdxBarItemLink;
    FCustomizingItemLinks: TdxBarItemLinks;
    FInternalItems: TComponentList;
    FRegisteredBarControlDesignHelpers: TcxRegisteredClassList;
    FRegisteredBarControlEditors: TList;

    FLastSelectedItem: IdxBarSelectableItem;

    FCustomizationPopup: TdxBarCustomizingPopup;
    FQuickControl: TdxBarControl;

    FNotifyComponent: TcxFreeNotificator;

    function CanDeleteSelectedObjects: Boolean;
    procedure GetSelection(ASelection: TdxObjectList);
    function IsObjectUnbound(AObject: TObject; AMasterObjects: TdxObjectList): Boolean;
    procedure RemoveIrrelevantObjectsForDelete(ASelection: TdxObjectList; ADestruction: Boolean = False);

    procedure ClearOwnedItems(AItemLinks: TdxBarItemLinks);

    procedure CustomizeItemClick(Sender: TObject);

    // CustomizationPopup
    procedure TextItemChange(Sender: TObject);
    procedure CustomizationPopupCloseUp(Sender: TObject);
    procedure CustomizationPopupDestroy(Sender: TObject);
    procedure CustomizationPopupItemClick(Sender: TObject);
    procedure InitCustomizationPopup(AItemLinks: TdxBarItemLinks);
    procedure SynchronizeAction(ABasicAction: TdxBarCustomizationAction);
    procedure UpdateViewLevelsSubItemButtonStates(AItemLinks: TdxBarItemLinks);

    // ToolbarsPopup
    procedure ToolbarsPopupClick(Sender: TObject);

    // QuickControl
    procedure QuickControlDestroy(Sender: TObject);

    function CanCustomize(ABarManager: TdxBarManager; AIsKeyboardAction: Boolean): Boolean;
    procedure FindCustomizingBarManager;
    procedure SetLastSelectedItem(Value: IdxBarSelectableItem);

    procedure FreeNotification(AComponent: TComponent);
  protected
    FDesignStates: TdxDesignStates;
  public
    constructor Create;
    destructor Destroy; override;

    procedure AddCustomizeItem(AItemLinks: TdxBarItemLinks;
      AItemClass: TdxBarItemClass; ABeginGroup: Boolean = True);
    function AddInternalItem(AItemLinks: TdxBarItemLinks;
      AItemClass: TdxBarItemClass; ACaption: string; AOnClick: TNotifyEvent = nil;
      ATag: Integer = 0; ABeginGroup: Boolean = False): TdxBarItemLink; overload;
    procedure AddInternalItem(AItem: TdxBarItem; AList: TList = nil); overload;
    procedure ClearInternalItems;
    procedure RemoveItemFromBarManagerList(AItem: TdxBarItem);

    function AddItem(ABarItemClass: TdxBarItemClass): TdxBarItemLink;
    procedure SelectItemLink(AItemLink: TdxBarItemLink);

    procedure DesignerModified; overload;

    function IsCustomizedByPopup: Boolean;
    procedure RegisterBarControlDesignHelper(ABarControlClass: TCustomdxBarControlClass;
      AHelperClass: TCustomdxBarControlDesignHelperClass);
    procedure RegisterBarControlEditor(AEditor: TdxBarControlEditorClass);
    procedure UnregisterBarControlDesignHelper(ABarControlClass: TCustomdxBarControlClass;
      AHelperClass: TCustomdxBarControlDesignHelperClass);
    procedure UnregisterBarControlEditor(AEditor: TdxBarControlEditorClass);

    procedure DropSelection(ASelectableItem: IdxBarSelectableItem);
    function IsItemCustomized(ASelectableItem: IdxBarSelectableItem): Boolean;
    function IsItemLastSelected(ASelectableItem: IdxBarSelectableItem): Boolean;
    function IsItemLinkCustomized: Boolean;
    function IsItemSingleSelected(ASelectableItem: IdxBarSelectableItem): Boolean;
    function IsSelectionComplex(ABarManager: TdxBarManager): Boolean;
    function IsSelectionSingle(ABarManager: TdxBarManager): Boolean;
    function NeedDefaultSelection(ASelectableItem: IdxBarSelectableItem): Boolean;
    procedure SelectItem(ASelectableItem: IdxBarSelectableItem;
      ASelectionOperation: TdxBarSelectionOperation = soExclusive);
    procedure SelectObject(AObject: TPersistent;
      ASelectionOperation: TdxBarSelectionOperation = soExclusive);
    procedure SynchronizeLastSelectedItem;

    function DeleteSelectedObjects(ADestruction, AIsKeyboardAction: Boolean): Boolean;
    procedure DeleteCustomizingItem;
    procedure DeleteCustomizingItemLink;
    function SelectParentComponent: Boolean;

    // CustomCustomizePopup
    procedure ShowCustomCustomizePopup(ABarManager: TdxBarManager;
      AInitPopupProc: TInitPopupProc; APainter: TdxBarPainter;
      ACustomizingBarControl: TCustomdxBarControl = nil; ACustomizingItemLink: TdxBarItemLink = nil);
    // CustomizePopup
    procedure ShowCustomizePopup(ABarControl: TCustomdxBarControl;
      ACustomizingItemLink: TdxBarItemLink);
    procedure SetCustomizePopupTopMosts(AShow: Boolean);

    // ToolbarsPopup
    procedure InitToolBarPopup(AItemLinks: TdxBarItemLinks);
    procedure ShowToolbarsPopup(ABarManager: TdxBarManager; APainter: TdxBarPainter);

    // QuickControl
    procedure ShowQuickControl(ABarControl: TdxBarControl; AOwnerRect: TRect);

    property CustomizingBarControl: TCustomdxBarControl read FCustomizingBarControl;
    property CustomizingItemLink: TdxBarItemLink read FCustomizingItemLink;
    property CustomizingBarManager: TdxBarManager read FCustomizingBarManager;
    property LastSelectedItem: IdxBarSelectableItem read FLastSelectedItem write SetLastSelectedItem;
    property QuickControl: TdxBarControl read FQuickControl;
  end;

  { TdxBarCanvas }

  TdxBarCanvasState = record
    PrevCanvas: TCanvas;
    PrevDC: THandle;
    NewDC: THandle;
    NewDCIndex: Integer;
  end;
  TdxBarCanvasStates = array of TdxBarCanvasState;

  TdxBarCanvas = class(TcxCanvas)
  private
    FCounter: Integer;
    FSavedDCs: TdxBarCanvasStates;
    function HandleValid: Boolean;
  public
    constructor Create; reintroduce;
    destructor Destroy; override;
    procedure BeginPaint(ADC: THandle); overload;
    procedure BeginPaint(ACanvas: TCanvas); overload;
    procedure EndPaint;
  end;

  { TdxBarComponent }

  TdxBarItemVisible = (ivNever, ivInCustomizing, ivAlways);

  TdxBarComponent = class(TComponent, {$IFNDEF DELPHI6}IUnknown,{$ENDIF} IdxBarSelectableItem)
  protected
    FBarManager: TdxBarManager;
    FChangeNotifies: TObjectList;
    FEnabled: Boolean;
    FVisible: TdxBarItemVisible;

    procedure AddChangeNotify(AComponentList: TdxBarComponentList);
    procedure RemoveChangeNotify(AComponentList: TdxBarComponentList);
    procedure Changed(AllItems: Boolean = False); virtual;
    function GetEnabled: Boolean; virtual; abstract;
    procedure SetEnabled(Value: Boolean); virtual; abstract;
    procedure SetVisible(Value: TdxBarItemVisible); virtual; abstract;

    // IdxBarSelectableItem
    function CanDelete(ADestruction: Boolean = False): Boolean; virtual;
    procedure DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean); virtual;
    procedure ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction); virtual;
    function GetBarManager: TdxBarManager; virtual;
    function IdxBarSelectableItem.GetInstance = GetPersistentInstance;
    procedure GetMasterObjects(AList: TdxObjectList); virtual;
    function GetNextSelectableItem: IdxBarSelectableItem; virtual;
    function GetSelectableParent: TPersistent; virtual;
    function GetSelectionStatus: TdxBarSelectionStatus; virtual;
    function GetSupportedActions: TdxBarCustomizationActions; virtual;
    procedure Invalidate; virtual;
    function IsComplex: Boolean; virtual;
    function IsComponentSelected: Boolean; virtual;
    procedure SelectComponent(ASelectionOperation: TdxBarSelectionOperation = soExclusive); virtual;
    function SelectParentComponent: Boolean; virtual;
    procedure SelectionChanged; virtual;

    function GetPersistentInstance: TPersistent; virtual;
    function GetComponentInstance: TComponent; virtual;

    property Enabled: Boolean read GetEnabled write SetEnabled;
    property Visible: TdxBarItemVisible read FVisible write SetVisible;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    property BarManager: TdxBarManager read GetBarManager;
  end;

  { TdxList }

  TdxObjectList = class(TObjectList)
  private
    procedure AddFromList(ASource, AExcludedList: TList);
  protected
    procedure CopyList(ASource, ADestination: TList);
    function GetItem(AIndex: Integer): TObject;
  public
    constructor Create; overload;
    procedure Add(AObject: TObject);
    procedure AddList(AObjects: TList);
    procedure CopyFrom(ASource: TList);
    procedure CopyTo(ADestination: TList);
    procedure XorList(ASourceA, ASourceB: TList);
    function First: TObject;
    function Last: TObject;
  end;

  { TdxBarComponentList }

  TdxBarComponentList = class(TcxComponentList)
  protected
    procedure DoNotify(AItem: TComponent; AAction: TListNotification); override;
    function GetItemClass: TClass; override;
  end;

  { TdxBarGroup }

  TdxBarGroup = class(TdxBarComponent)
  private
    FItems: TdxBarComponentList;
    FItemsNames: TStringList;
    function GetCount: Integer;
    function GetIndex: Integer;
    function GetItem(Index: Integer): TComponent;

    function InternalGetCount: Integer;
    function InternalGetItemName(Index: Integer): string;

    procedure SetIndex(Value: Integer);
    procedure ReadItems(Reader: TReader);
    procedure WriteItems(Writer: TWriter);
  protected
    procedure DefineProperties(Filer: TFiler); override;
    function GetEnabled: Boolean; override;
    procedure Loaded; override;
    procedure SetName(const NewName: TComponentName); override;
    procedure SetEnabled(Value: Boolean); override;
    procedure SetVisible(Value: TdxBarItemVisible); override;
    property ItemList: TdxBarComponentList read FItems;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function GetParentComponent: TComponent; override;
    function HasParent: Boolean; override;
    procedure SetParentComponent(AParent: TComponent); override;

    procedure Add(AItem: TdxBarComponent);
    procedure Delete(Index: Integer);
    function IndexOf(AItem: TdxBarComponent): Integer;
    procedure Move(FromIndex, ToIndex: Integer);
    procedure Remove(AItem: TdxBarComponent);

    property Count: Integer read GetCount;
    property Index: Integer read GetIndex write SetIndex;
    property Items[Index: Integer]: TComponent read GetItem; default;
  published
    property Enabled default True;
    property Visible default ivAlways;
  end;

  TdxBarPopupMenuLinkActionEvent = procedure(Sender: TdxBarPopupMenuLink; var X, Y: Integer;
    ClickedByMouse: Boolean; var AllowPopup: Boolean) of object;

  TdxBarPopupMenuLink = class(TCollectionItem)
  private
    FControl: TControl;
    FPopupMenu: TdxBarPopupMenu;
    FPrevWndProc: TWndMethod;
    FProcessChildren: Boolean;
    FOnAction: TdxBarPopupMenuLinkActionEvent;

    FPrevOnContextPopup: TContextPopupEvent;

    function GetBarManager: TdxBarManager;
    function GetWinControl: TWinControl;
    procedure SetControl(Value: TControl);
    procedure SetPopupMenu(Value: TdxBarPopupMenu);
    procedure ContextPopup(Sender: TObject; MousePos: TPoint; var Handled: Boolean);
    property WinControl: TWinControl read GetWinControl;
  protected
    function DoAction(AClientPopupPoint: TPoint): Boolean; overload;
    function IsShortCut(AShortCut: TShortCut): Boolean;
    procedure NewWndProc(var Message: TMessage);
  public
    constructor Create(Collection: TCollection); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    function DoAction(Wnd: HWND; const P: TPoint): Boolean; overload;
    property BarManager: TdxBarManager read GetBarManager;
  published
    property Control: TControl read FControl write SetControl;
    property PopupMenu: TdxBarPopupMenu read FPopupMenu write SetPopupMenu;
    property ProcessChildren: Boolean read FProcessChildren write FProcessChildren default True;
    property OnAction: TdxBarPopupMenuLinkActionEvent read FOnAction write FOnAction;
  end;

  TdxBarPopupMenuLinks = class(TCollection)
  private
    FBarManager: TdxBarManager;
    function GetItem(Index: Integer): TdxBarPopupMenuLink;
    procedure SetItem(Index: Integer; Value: TdxBarPopupMenuLink);
  protected
    function GetOwner: TPersistent; override;
    function IsShortCut(AControl: TWinControl; AShortCut: TShortCut): Boolean;
  public
    constructor Create(ABarManager: TdxBarManager);
    function Add: TdxBarPopupMenuLink;
    function DoAction(AControl: TWinControl; Wnd: HWND; const P: TPoint): Boolean;
    property BarManager: TdxBarManager read FBarManager;
    property Items[Index: Integer]: TdxBarPopupMenuLink read GetItem write SetItem; default;
  end;

  TdxBarBackgrounds = class(TdxBarPersistent)
  private
    FBarBackgroundBitmap: TBitmap;
    FSubMenuBackgroundBitmap: TBitmap;
    procedure BitmapChanged(Sender: TObject);
    procedure SetBarBackgroundBitmap(Value: TBitmap);
    procedure SetSubMenuBackgroundBitmap(Value: TBitmap);
  protected
    procedure Changed;
  public
    constructor Create(ABarManager: TdxBarManager); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
  published
    property Bar: TBitmap read FBarBackgroundBitmap write SetBarBackgroundBitmap;
    property SubMenu: TBitmap read FSubMenuBackgroundBitmap write SetSubMenuBackgroundBitmap;
  end;

  TdxBarDockingStyle = (dsNone, dsLeft, dsTop, dsRight, dsBottom);
  TdxBarDockingStyles = set of TdxBarDockingStyle;
  TdxBarDockedDockingStyle = dsLeft..dsBottom;
  TdxBarManagerStyle = (bmsStandard, bmsEnhanced, bmsFlat, bmsXP, bmsOffice11,
    bmsUseLookAndFeel);
  TdxBarRealPaintStyle = (rpsStandard, rpsEnhanced, rpsFlat, rpsXP, rpsOffice11, rpsSkin);
  TdxBarMenuAnimations = (maNone, maRandom, maUnfold, maSlide, maFade);
  TdxBarEvent = procedure(Sender: TdxBarManager; ABar: TdxBar) of object;
  TdxBarItemLinkEvent = procedure(Sender: TdxBarManager; AItemLink: TdxBarItemLink) of object;
  TdxBarVisibleChangeEvent = procedure(Sender: TdxBarManager; ABar: TdxBar) of object;
  TdxBarCanDockingEvent = procedure(Sender: TdxBar; Style: TdxBarDockingStyle;
    DockControl: TdxDockControl; var CanDocking: Boolean) of object;
  TdxBarShowPopupEvent = procedure(Sender: TdxBarManager; PopupItemLinks: TdxBarItemLinks) of object;
  TdxBarClickItemEvent = procedure(Sender: TdxBarManager; ClickedItem: TdxBarItem) of object;
  TdxBarIniFileEvent = procedure(Sender: TObject; AIniFile: TCustomIniFile;
    const ADelimiter: string; const ASection: string) of object;

  TdxBarItemMergeKind = (mkAdd, mkMergeByCaption, mkNone);
  TdxBarStoringKind = (skIni, skReg);
  TdxBarMergeEvent = procedure(Sender, ChildBarManager: TdxBarManager;
    AddItems: Boolean) of object;
  TdxBarMenuMergeEvent = TdxBarMergeEvent;
  TdxBarMergeItemLinkEvent = procedure(Sender: TdxBarManager;
    ADstItemLinks, ASrcItemLinks: TdxBarItemLinks; ASrcItemLink: TdxBarItemLink;
    var AMergeKind: TdxBarItemMergeKind; var AMergeIndex: Integer) of object;

  TdxBarInternalState = (bisAfterLoading, bisBarsLoading, bisCreating, bisHandleCreating,
    bisModalActivating, bisFormActivating, bisToolbarsVisibleChanging, bisWasActive, bisStateSaving);
  TdxBarInternalStates = set of TdxBarInternalState;

  TdxBarMDIStateChange = (scChildActivated, scChildDeactivated, scMaximizedChanged);

  TdxBarDraggingState = (dsNoDrag, dsNoDrop, dsBeginGroup, dsCategory, dsCopy, dsDrag);

  TdxBarItemSeparatorInfo = record
    Bounds: TRect;
    Kind: TdxBarItemSeparatorKind;
  end;

  TdxBarIniFileEventData = record
    IniFile: TCustomIniFile;
    StoringKind: TdxBarStoringKind;
    BaseSection: string;
    Delimiter: string;
  end;

  TdxBarMDIStateChangeEventData = record
    Change: TdxBarMDIStateChange;
    Wnd: HWND;
  end;

  TCustomdxBarControlViewInfo = class
  private
    FItemControlViewInfos: TList;
    FSeparatorsData: array of TdxBarItemSeparatorData;
    function GetItemControlCount: Integer;
    function GetItemControlViewInfo(AIndex: Integer): TdxBarItemControlViewInfo;
    function GetSeparatorCount: Integer;
    function GetSeparatorInfo(AIndex: Integer): TdxBarItemSeparatorInfo;
    procedure SetSeparatorInfo(AIndex: Integer; const Value: TdxBarItemSeparatorInfo);
  protected
    FBarControl: TCustomdxBarControl;
    procedure AddItemControlViewInfo(AViewInfo: TdxBarItemControlViewInfo);
    procedure AddSeparatorInfo(const ARect: TRect; AKind: TdxBarItemSeparatorKind;
      AAssociatedItemControl: TdxBarItemControl);
    procedure Clear; virtual;
    procedure RemoveItemControlViewInfo(AViewInfo: TdxBarItemControlViewInfo);
    procedure RemoveSeparatorInfos;
  public
    constructor Create(ABarControl: TCustomdxBarControl); virtual;
    destructor Destroy; override;
    procedure Calculate; virtual;
    function GetItemControlIndex(AItemControl: TdxBarItemControl): Integer;
    function IsAssociatedWithSeparator(AItemControl: TdxBarItemControl;
      out ASeparatorIndex: Integer): Boolean;
    function IsItemControlVisible(AItemControl: TdxBarItemControl): Boolean;
    property BarControl: TCustomdxBarControl read FBarControl;
    property ItemControlCount: Integer read GetItemControlCount;
    property ItemControlViewInfos[AIndex: Integer]: TdxBarItemControlViewInfo read GetItemControlViewInfo;
    property SeparatorCount: Integer read GetSeparatorCount;
    property SeparatorInfos[AIndex: Integer]: TdxBarItemSeparatorInfo
      read GetSeparatorInfo write SetSeparatorInfo;
  end;

  TdxBarDragInfo = class
  private
    FBarManager: TdxBarManager;
    FLockCount: Integer;
    FModified: Boolean;

    FCaptureWnd: HWND;

    FDefaultCursor: TCursor;
    FDragDownPoint: TPoint;

    FDragLineVisible: Boolean;
    FDragLineBarControlLink: TcxObjectLink;
    FDragLineFirstPart: Boolean;
    FDragLineRect: TRect;
    FDragLineVerticalDirection: Boolean;

    FDraggingItem: TdxBarItem;
    FDraggingItemLink: TdxBarItemLink;
    FDraggingItemLinkParentHandle: HWND;
    FDraggingState: TdxBarDraggingState;

    FDragOverFirstPart: Boolean;
    FDragOverBeginGroup: Boolean;
    FDragOverVerticalDirection: Boolean;
    FDragOverBarControlLink: TcxObjectLink;
    FDragOverItemLink: TdxBarItemLink;

    procedure CalcDragOverItemParameters(var ACursorPos: TPoint);
    function CategoriesList: TListBox;
    procedure DragInfoChanged;
    procedure DrawDraggingLine(AVisible: Boolean);
    function HasTarget: Boolean;
    function IsDragCopy: Boolean;
    function NoNeedDragLine: Boolean;

    procedure ChangeBeginGroup;
    procedure CreateNewItemLink;
    procedure DeleteDraggingItemLink;
    procedure InternalDrawDraggingLine;
    procedure MoveItemToAnotherCategory;

    function GetDraggingControl: TdxBarItemControl;
    function GetDragLineBarControl: TCustomdxBarControl;
    function GetDragOverBarControl: TCustomdxBarControl;
    function GetDragOverBarItemLinks: TdxBarItemLinks;
    function GetDragOverItemControl: TdxBarItemControl;
    procedure SetDraggingState(Value: TdxBarDraggingState);
    procedure SetDragLineBarControl(Value: TCustomdxBarControl);
    procedure SetDragOverBarControl(Value: TCustomdxBarControl);
    procedure SetDragOverBeginGroup(Value: Boolean);
    procedure SetDragOverFirstPart(Value: Boolean);
    procedure SetDragOverVerticalDirection(Value: Boolean);
    procedure SetDragOverItemLink(Value: TdxBarItemLink);

    property DragLineBarControl: TCustomdxBarControl read GetDragLineBarControl write SetDragLineBarControl;
  public
    constructor Create(ABarManager: TdxBarmanager);
    destructor Destroy; override;
    procedure BeginDrag(AItem: TdxBarItem; AItemLink: TdxBarItemLink);
    procedure DragDrop;
    procedure EndDrag;
    procedure HandleDragging;

    procedure BeginUpdate;
    procedure EndUpdate;

    property DraggingControl: TdxBarItemControl read GetDraggingControl;
    property DraggingItem: TdxBarItem read FDraggingItem write FDraggingItem;
    property DraggingItemLink: TdxBarItemLink read FDraggingItemLink write FDraggingItemLink;
    property DraggingState: TdxBarDraggingState read FDraggingState write SetDraggingState;

    property DragOverBeginGroup: Boolean read FDragOverBeginGroup write SetDragOverBeginGroup;
    property DragOverFirstPart: Boolean read FDragOverFirstPart write SetDragOverFirstPart;
    property DragOverVerticalDirection: Boolean read FDragOverVerticalDirection write SetDragOverVerticalDirection;

    property DragOverBarControl: TCustomdxBarControl read GetDragOverBarControl write SetDragOverBarControl;
    property DragOverBarItemLinks: TdxBarItemLinks read GetDragOverBarItemLinks;
    property DragOverItemControl: TdxBarItemControl read GetDragOverItemControl;
    property DragOverItemLink: TdxBarItemLink read FDragOverItemLink write SetDragOverItemLink;
    property DraggingItemLinkParentHandle: HWND read FDraggingItemLinkParentHandle write FDraggingItemLinkParentHandle;
  end;

  TdxBarImageOptions = class(TdxBarPersistent)
  private
    FDisabledImages: TCustomImageList;
    FDisabledLargeImages: TCustomImageList;
    FHotImages: TCustomImageList;
    FImages: TCustomImageList;
    FLargeImages: TCustomImageList;

    FImagesChangeLink: TChangeLink;
    FLargeImagesChangeLink: TChangeLink;
    FHotImagesChangeLink: TChangeLink;
    FDisabledImagesChangeLink: TChangeLink;
    FDisabledLargeImagesChangeLink: TChangeLink;

    FCacheGlyphs: Boolean;
    FGlyphSize: Integer;
    FImageListBkColor: TColor;
    FLargeIcons: Boolean;
    FMakeDisabledImagesFaded: Boolean;
    FSmoothGlyphs: Boolean;
    FStretchGlyphs: Boolean;
    FUseLargeImagesForLargeIcons: Boolean;
    FUseLeftBottomPixelAsTransparent: Boolean;

    FOnImageOptionsChange: TNotifyEvent;
    FOnLargeIconsChange: TNotifyEvent;

    FNotifyComponent: TcxFreeNotificator;

    function GetIsLoading: Boolean;
    procedure SetImageList(var ANewValue, AOldValue: TCustomImageList; const AChangeLink: TChangeLink);
    procedure SetHotImages(Value: TCustomImageList);
    procedure SetImageListBkColor(Value: TColor);
    procedure SetImages(Value: TCustomImageList);
    procedure SetDisabledImages(Value: TCustomImageList);
    procedure SetDisabledLargeImages(Value: TCustomImageList);
    procedure SetLargeIcons(Value: Boolean);
    procedure SetLargeImages(Value: TCustomImageList);
    procedure SetMakeDisabledImagesFaded(Value: Boolean);
    procedure SetUseLargeImagesForLargeIcons(Value: Boolean);
    procedure SetUseLeftBottomPixelAsTransparent(Value: Boolean);

    procedure CalcGlyphSize;
    function IsLargeImagesForLargeIcons: Boolean;
    procedure FreeNotification(AComponent: TComponent);
  protected
    property IsLoading: Boolean read GetIsLoading;
  public
    constructor Create(ABarManager: TdxBarManager); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    property GlyphSize: Integer read FGlyphSize;
  published
    property CacheGlyphs: Boolean read FCacheGlyphs write FCacheGlyphs default True;
    property DisabledImages: TCustomImageList read FDisabledImages write SetDisabledImages;
    property DisabledLargeImages: TCustomImageList read FDisabledLargeImages write SetDisabledLargeImages;
    property HotImages: TCustomImageList read FHotImages write SetHotImages;
    property ImageListBkColor: TColor read FImageListBkColor write SetImageListBkColor default clFuchsia;
    property Images: TCustomImageList read FImages write SetImages;
    property LargeImages: TCustomImageList read FLargeImages write SetLargeImages;
    property LargeIcons: Boolean read FLargeIcons write SetLargeIcons default False;
    property MakeDisabledImagesFaded: Boolean read FMakeDisabledImagesFaded write SetMakeDisabledImagesFaded default False;
    property SmoothGlyphs: Boolean read FSmoothGlyphs write FSmoothGlyphs default False;
    property StretchGlyphs: Boolean read FStretchGlyphs write FStretchGlyphs default True;
    property UseLargeImagesForLargeIcons: Boolean read FUseLargeImagesForLargeIcons write SetUseLargeImagesForLargeIcons default False;
    property UseLeftBottomPixelAsTransparent: Boolean read FUseLeftBottomPixelAsTransparent write SetUseLeftBottomPixelAsTransparent default True;
  end;

  TdxBarItemChangeProc = procedure (AItem: TdxBarItem) of object;

  TdxBarManager = class(TComponent, {$IFNDEF DELPHI6}IUnknown,{$ENDIF} IdxBarDesigner, IdxSkinSupport)
  private
    FAllowCallFromAnotherForm: Boolean;
    FAllowReset: Boolean;
    FAlwaysMerge: Boolean;
    FAlwaysSaveText: Boolean;
    FAutoAlignBars: Boolean;
    FAutoDockColor: Boolean;
    FAutoHideEmptyBars: Boolean;
    FBackgrounds: TdxBarBackgrounds;
    FBarCaptionFont: TFont;
    FBarRestoringList: TList;
    FBars: TdxBars;
    FButtonArrowWidth: Integer;
    FCanCustomize: Boolean;
    FChangedSubMenuControl: TdxBarSubMenuControl;
    FChangingStyle: Boolean;
    FCategories: TStrings;
    FDefaultPainter: TdxBarPainter;
    FDesignerModifiedInvoked: Boolean;

    FDisabledToolBarsList: TList;
    FDockColor: TColor;
    FDockControls: TList;

    FDragInfo: TdxBarDragInfo;
    FImageOptions: TdxBarImageOptions;

    FEditFont: TFont;
    FFlatCloseButton: Boolean;
    FFlatToolbarsBorderBrush: HBRUSH;
    FFlatToolbarsBrush: HBRUSH;
    FFlatToolbarsDownedBrush: HBRUSH;
    FFlatToolbarsDownedSelBrush: HBRUSH;
    FFlatToolbarsSelBrush: HBRUSH;
    FFocusedBarControl: TCustomdxBarControl;
    FFont: TFont;

    FGroups: TdxBarComponentList; //#DG list

    FHelpButtonGlyph: TBitmap;
    FHelpContext: THelpContext;
    FHideFloatingBarsWhenInactive: Boolean;
    FHintObject: TObject;
    FIniFileName: string;
    FInternalFontChange: Boolean;
    FInternalState: TdxBarInternalStates;
    FIsCustomizing: Boolean;

    FInternalItems: TComponentList;
    FItems: TdxBarComponentList; //#DG list

    FLargeButtonArrowWidth: Integer;
    FLockDesignerModifiedCount: Integer;
    FLockUpdate: Boolean;
    FLockUpdateCount: Integer;
    FLookAndFeel: TcxLookAndFeel;
    FMainFormActive: Boolean;
    FMainMenuBar: TdxBar;
    FMenuAnimations: TdxBarMenuAnimations;
    FMenusShowRecentItemsFirst: Boolean;
    FModified: Boolean;
    FMostRecentItemsPercents: Byte;
    FMostRecentlyUsedUseCount: Integer;
    FMouseTrackingBarControl: TCustomdxBarControl;
    FNewItems: TStringList;
    FNotDocking: TdxBarDockingStyles;
    FPopupMenuLinks: TdxBarPopupMenuLinks;
    FPopupMenus: TComponentList;
    FPrevActiveMDIChild: HWND;
    FReadStateCount: Integer;
    FRegistryPath: string;

    FScaled: Boolean;

    FSelectedItem: TdxBarItemControl; // obsolete
    FChangingFocusedItemControlLockCount: Integer;
    FPrevFocusedControl: HWND;
//    FSelectedLink: TdxBarItemLink; // #DG new

    FShowCloseButton: Boolean;
    FShowFullMenusAfterDelay: Boolean;
    FShowHelpButton: Boolean;
    FShowHint: Boolean;
    FShowHintForDisabledItems: Boolean;
    FShowShortCutInHint: Boolean;
    FStoreInIniFile: Boolean;
    FStoreInRegistry: Boolean;
    FIniFileStream: TStream;
    FStyle: TdxBarManagerStyle;
    FSunkenBorder: Boolean;
    FThemeAvailable: Boolean;
    FThemeChangedNotificator: TdxThemeChangedNotificator;
    FThemeToolbarsBrush: HBRUSH;
//    FThemeToolbarsDownedBrush: HBRUSH;
//    FThemeToolbarsDownedSelBrush: HBRUSH;
//    FThemeToolbarsSelBrush: HBRUSH;
    FUseF10ForMenu: Boolean;
    FUseFullReset: Boolean;
    FUseSystemFont: Boolean;
    FWaitForDockingTime: Integer;
    FIsMDIMaximized: Boolean;

    FSavedState: TMemIniFile;

    FOnBarAdd: TdxBarEvent;
    FOnBarAfterReset: TdxBarEvent;
    FOnBarBeforeReset: TdxBarEvent;
    FOnBarClose: TdxBarEvent;
    FOnBarDelete: TdxBarEvent;
    FOnBarDockingStyleChange: TdxBarEvent;
    FOnBarVisibleChange: TdxBarVisibleChangeEvent;

    FOnItemLinkAdd: TdxBarItemLinkEvent;
    FOnItemLinkChange: TdxBarItemLinkEvent;
    FOnItemLinkDelete: TdxBarItemLinkEvent;

    FOnCloseButtonClick: TNotifyEvent;
    FOnDocking: TdxBarCanDockingEvent;
    FOnHelpButtonClick: TNotifyEvent;
    FOnHideCustomizingForm: TNotifyEvent;
    FOnMenuMerge: TdxBarMenuMergeEvent;
    FOnMerge: TdxBarMergeEvent;
    FOnMergeItemLink: TdxBarMergeItemLinkEvent;
    FOnShowCustomizingForm: TNotifyEvent;
    FOnShowCustomizingPopup: TdxBarShowPopupEvent;
    FOnShowToolbarsPopup: TdxBarShowPopupEvent;

    FOnClickItem: TdxBarClickItemEvent;

    FReadIniFileHandlers: TcxEventHandlerCollection;
    FWriteIniFileHandlers: TcxEventHandlerCollection;
    FSystemFontChangedHandlers: TcxEventHandlerCollection;
    FMDIStateChangedHandlers: TcxEventHandlerCollection;

    procedure InternalSetSelectedItem(Value: TdxBarItemControl);

    function GetBarControlFocused: Boolean;
    function GetBarsLoading: Boolean;
    function GetCanModifyDesigner: Boolean;
    function GetCategoryItemsVisible(AIndex: Integer): TdxBarItemVisible;
    function GetCategoryVisible(AIndex: Integer): Boolean;
    function GetDesigning: Boolean;
    function GetDockColor: TColor;
    function GetDockControl(Index: Integer): TdxDockControl;
    function GetDockControlCount: Integer;
    function GetDragging: Boolean;
    function GetDraggingItem: TdxBarItem;
    function GetDraggingItemLink: TdxBarItemLink;
    function GetFlat: Boolean;
    function GetFlatToolbarsBorderColor: COLORREF;
    function GetFlatToolbarsColor: COLORREF;
    function GetFlatToolbarsDownedColor: COLORREF;
    function GetFlatToolbarsDownedSelColor: COLORREF;
    function GetFlatToolbarsSelColor: COLORREF;
    function GetGroup(Index: Integer): TdxBarGroup;
    function GetGroupCount: Integer;
    function GetInternalDockControl(ADockingStyle: TdxBarDockedDockingStyle): TdxDockControl;
    function GetIsCustomizing: Boolean;
    function GetIsDestroying: Boolean;
    function GetIsHandleCreating: Boolean;
    function GetIsInitializing: Boolean;
    function GetIsLoading: Boolean;
    function GetIsRecreating: Boolean;
    function GetIsStateSaving: Boolean;
    function GetItemCount: Integer;
    function GetItem(Index: Integer): TdxBarItem;
    function GetLastSelectedLinkAtDesign: TdxBarItemLink;
    function GetMainForm: TCustomForm;
    function GetMainMenuControl: TdxBarControl;
    function GetMasterForm: TCustomForm;
    function GetNotDocking: TdxBarDockingStyles;
    function GetParentBarManager: TdxBarManager;
    function GetParentedOwner: TWinControl;
    function GetParentForm: TCustomForm;
    function GetRestoringListBar(Index: Integer): TdxBar;
    function GetRestoringListBarCount: Integer;
    function GetTabOrder: Integer;
    procedure IniFileCollectionCallMethods(ACollection: TcxEventHandlerCollection;
      AIniFile: TCustomIniFile; AStoringKind: TdxBarStoringKind; ASection: string);
    function InternalGetPainterClass: TdxBarPainterClass;
    procedure SetAutoAlignBars(Value: Boolean);
    procedure SetAutoDockColor(Value: Boolean);
    procedure SetAutoHideEmptyBars(Value: Boolean);
    procedure SetBackgrounds(Value: TdxBarBackgrounds);
    procedure SetButtonArrowWidth(Value: Integer);
    procedure SetCategories(Value: TStrings);
    procedure SetCategoryItemsVisible(AIndex: Integer; Value: TdxBarItemVisible);
    procedure SetCategoryVisible(AIndex: Integer; Value: Boolean);
    procedure SetDockColor(Value: TColor);
    procedure SetFlatCloseButton(Value: Boolean);
    procedure SetFont(Value: TFont);
    procedure SetHelpButtonGlyph(Value: TBitmap);
    procedure SetHideFloatingBarsWhenInactive(Value: Boolean);
    procedure SetDraggingItem(Value: TdxBarItem);
    procedure SetDraggingItemLink(Value: TdxBarItemLink);
    procedure SetLargeButtonArrowWidth(Value: Integer);
    procedure SetLockUpdate(Value: Boolean);
    procedure SetLookAndFeel(Value: TcxLookAndFeel);
    procedure SetMenuAnimations(Value: TdxBarMenuAnimations);
    procedure SetMenusShowRecentItemsFirst(Value: Boolean);
    procedure SetMostRecentItemsPercents(Value: Byte);
    procedure SetNotDocking(Value: TdxBarDockingStyles);
    procedure SetPopupMenuLinks(Value: TdxBarPopupMenuLinks);
    procedure SetRegistryPath(Value: string);
    procedure SetScaled(Value: Boolean);
    procedure SetSelectedItem(Value: TdxBarItemControl);
    procedure SetShowCloseButton(Value: Boolean);
    procedure SetShowFullMenusAfterDelay(Value: Boolean);
    procedure SetShowHelpButton(Value: Boolean);
    procedure SetShowHint(Value: Boolean);
    procedure SetShowShortCutInHint(Value: Boolean);
    procedure SetStyle(Value: TdxBarManagerStyle);
    procedure SetSunkenBorder(Value: Boolean);
    procedure SetTabOrder(Value: Integer);
    procedure SetUseSystemFont(Value: Boolean);
    procedure SetWaitForDockingTime(Value: Integer);

  // ImageOptions begin
    function GetDisabledImages: TCustomImageList;
    function GetDisabledLargeImages: TCustomImageList;
    function GetGlyphSize: Integer;
    function GetHotImages: TCustomImageList;
    function GetImageListBkColor: TColor;
    function GetImages: TCustomImageList;
    function GetLargeImages: TCustomImageList;
    function GetLargeIcons: Boolean;
    function GetMainMenuBar: TdxBar;
    function GetMakeDisabledImagesFaded: Boolean;
    function GetStretchGlyphs: Boolean;
    function GetUseLargeImagesForLargeIcons: Boolean;
    procedure SetDisabledImages(Value: TCustomImageList);
    procedure SetDisabledLargeImages(Value: TCustomImageList);
    procedure SetGlyphSize(Value: Integer);
    procedure SetHotImages(Value: TCustomImageList);
    procedure SetImageListBkColor(Value: TColor);
    procedure SetImages(Value: TCustomImageList);
    procedure SetLargeIcons(Value: Boolean);
    procedure SetLargeImages(Value: TCustomImageList);
    procedure SetMakeDisabledImagesFaded(Value: Boolean);
    procedure SetStretchGlyphs(Value: Boolean);
    procedure SetUseLargeImagesForLargeIcons(Value: Boolean);

    procedure DisabledImageListChange(Sender: TObject);
    procedure DisabledLargeImageListChange(Sender: TObject);
    procedure HotImageListChange(Sender: TObject);
    procedure ImageListChange(Sender: TObject);
    procedure ImageOptionsChange(Sender: TObject);
    procedure LargeIconsChange(Sender: TObject);
    procedure LargeImageListChange(Sender: TObject);
  // ImageOptions end

    function BarByNewName(const AName: string): TdxBar;
    procedure FontChanged(Sender: TObject);
    procedure CreateMDIChildSystemMenu(AWnd: HWND);
    procedure DestroyMDIChildSystemMenu;
    function IsMDIChildSystemMenuExist: Boolean;
    procedure MDIStateChanged(AChange: TdxBarMDIStateChange; AWnd: HWND);
//    function LoadMainFormFromBin: TForm;
    procedure CheckToolbarsVisibility;

    class function IsFormBroadcastMessage(AMsg: UINT): Boolean;
    function IsOwnerMDIChild(ARecursive: Boolean): Boolean;
    procedure MainFormClientWndProc(Msg: UINT; wParam: WPARAM; lParam: LPARAM);
    procedure OwnerWndProc(AWnd: HWND; AMsg: UINT; wParam: WPARAM; lParam: LPARAM);
    class procedure SendFormBroadcastMessage(AOwnerHandle: HWND; AMsg: UINT;
      wParam: WPARAM; lParam: LPARAM);

    procedure DisplayHint;
    procedure DoActivateHint(AShow: Boolean; const CustomHint: string; AHintObject: TObject = nil);
    function IsHintActive: Boolean;

    procedure DestroyItems;
    procedure HelpButtonGlyphChanged(Sender: TObject);
    procedure CalcMostRecentlyUsedUseCount;
    function ShowRecentItemsFirst: Boolean;

    procedure AddDockControl(ADockControl: TdxDockControl);
    procedure RemoveDockControl(ADockControl: TdxDockControl);

    procedure AddGroup(AGroup: TdxBarGroup);
//#DG    procedure RemoveGroup(AGroup: TdxBarGroup);

    function CorrectRegistryPath(var APath: string): Boolean;
    function GetSavedBarIndex(const ABarCaption: string): Integer;
    function IsDockColorStored: Boolean;
    procedure LoadLinkItemNames;
    procedure ReadBars(AReader: TReader);
    procedure ReadDockControlHeights(Reader: TReader);
    procedure WriteDockControlHeights(Writer: TWriter);

    procedure CreateFlatToolbarsBrushes;
    procedure DestroyFlatToolbarsBrushes;

    procedure CreateThemeToolbarsBrushes;
    procedure DestroyThemeToolbarsBrushes;
    procedure DestroyToolbarsBrushes;

    procedure CreateToolbarsBrushes;
    procedure RecreateToolbarsBrushes;
    procedure RefreshFloatingBarsShadows;
    procedure ResetBackgrounds;
    procedure InitPainter;
    procedure InternalStyleChanged;
    procedure ThemeChanged;
    procedure LFChanged(Sender: TcxLookAndFeel; AChangedValues: TcxLookAndFeelValues);

    procedure DoActivate(AState, AMinimized: WORD; AHandle, AWndPrevious: HWND);
    procedure DoActivateApp(AActivate: Boolean; AThreadID: DWORD);
    procedure DoCreate;
    procedure DoModalActivate;

    procedure DoLockUpdate(ALock: Boolean; ACheckBarsChanges: Boolean);

    function GetItemLinkWithAccel(AKey: Word; AShift: TShiftState): TdxBarItemLink;
    function HandleShortCut(AShortCut: TShortCut): Boolean;
  protected
    FdxBarDesignHelper: IdxBarDesigner;

    // IdxBarDesigner
    function CanDeleteComponent(AComponent: TComponent): Boolean;
    procedure GetSelection(AList: TList);
    function GetSelectionStatus(AComponent: TPersistent): TdxBarSelectionStatus;
    function IsComponentSelected(AComponent: TPersistent): Boolean;
    procedure SelectComponent(AComponent: TPersistent; ASelectionOperation: TdxBarSelectionOperation = soExclusive);
    procedure SetSelection(AList: TList);
    procedure ShowDefaultEventHandler(AItem: TdxBarItem);
    function UniqueName(const BaseName: string): string;

    procedure CreateBarRestoringList;
    procedure DestroyBarRestoringList;
    function BarRestoringListExists: Boolean;
    procedure AddBarToRestoringList(ABar: TdxBar);
    procedure RemoveBarFromRestoringList(ABar: TdxBar);
    procedure ShowBarsFromRestoringList(ADockControl: TdxBarDockControl);
    function GetBarIndexInRestoringList(ABar: TdxBar): Integer;
    property RestoringListBarCount: Integer read GetRestoringListBarCount;
    property RestoringListBars[Index: Integer]: TdxBar read GetRestoringListBar;

    procedure AssignFont;
    function CanReset: Boolean;
    procedure DefineProperties(Filer: TFiler); override;
    procedure DesignerModified;
    procedure DoBarAfterReset(ABar: TdxBar); dynamic;
    procedure DoBarBeforeReset(ABar: TdxBar); dynamic;
    procedure DoBarClose(ABar: TdxBar); dynamic;
    procedure DoBarDockingStyleChanged(ABar: TdxBar); dynamic;
    procedure DoClickItem(AItem: TdxBarItem); virtual;
    procedure DoCloseButtonClick; dynamic;
    function DoDocking(ABar: TdxBar; AStyle: TdxBarDockingStyle;
      ADockControl: TdxDockControl): Boolean; virtual;
    procedure DoItemLinkChange(AItemLink: TdxBarItemLink);
    procedure DoHelpButtonClick; dynamic;
    procedure DoMergeItemLink(ADstItemLinks, ASrcItemLinks: TdxBarItemLinks;
      ASrcItemLink: TdxBarItemLink; var AMergeKind: TdxBarItemMergeKind;
      var AMergeIndex: Integer);
    procedure DoShowCustomizingPopup(PopupItemLinks: TdxBarItemLinks); dynamic;
    procedure DoShowToolbarsPopup(PopupItemLinks: TdxBarItemLinks); dynamic;
    procedure DragAndDrop(AItem: TdxBarItem; AItemLink: TdxBarItemLink);
    function FindDockControl(APath: string): TdxBarDockControl;
    function GetCategoryRealIndex(AIndex: Integer): Integer;
    procedure GetChildren(Proc: TGetChildProc; Root: TComponent); override;
    function GetChildOwner: TComponent; override;
    function GetPainterClass: TdxBarPainterClass; virtual;
    procedure GetRealLookAndFeel(ALookAndFeel: TcxLookAndFeel);
    function GetRealPaintStyle: TdxBarRealPaintStyle;
    function GetWindowForMouseCapturing: HWND;
    procedure SetChildOrder(Child: TComponent; Order: Integer); override;

//    function IsLinkSelected(AItemLink: TdxBarItemLink): Boolean;
//    procedure SelectLink(AItemLink: TdxBarItemLink;
//      ASelectionOperation: TdxBarSelectionOperation = soExclusive);
//    procedure SynchronizeSelectedLink;

    // ImageOptions
    procedure CustomImagesChanged(AChangeProc: TdxBarItemChangeProc);
    procedure DisabledImagesChanged(AItem: TdxBarItem);
    procedure DisabledLargeImagesChanged(AItem: TdxBarItem);
    procedure HotImagesChanged(AItem: TdxBarItem);
    procedure ImagesChanged(AItem: TdxBarItem);
    function IsLargeImagesForLargeIcons: Boolean;
    procedure LargeImagesChanged(AItem: TdxBarItem);
    property GlyphSize: Integer read GetGlyphSize write SetGlyphSize;

    procedure DisableFloatToolBars;
    procedure EnableFloatToolBars;

    procedure ActivateFloatToolbars(AActivate, AForceOperation: Boolean; AActiveWindow: HWND);
    function IsInternalDockControl(ADockControl: TdxDockControl): Boolean;
    function IsUpdateLocked: Boolean;
    procedure Loaded; override;
    procedure LockDesignerModified(ALock: Boolean;
      AInvokeDesignerModifiedOnUnlock: Boolean = True);
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
    procedure ReadState(Reader: TReader); override;
    procedure SetName(const NewName: TComponentName); override;
    procedure ShowToolbars(AShow, AForceOperation: Boolean; AActiveWindow: HWND);

    function GetBarManagerSection(const ABaseSection: string;
      AStoringKind: TdxBarStoringKind): string;
    function GetBaseIniSection: string;
    procedure LoadBarManager(ASource: TCustomIniFile; const ASection: string; AStoringKind: TdxBarStoringKind);
    procedure SaveBarManager(ADestination: TCustomIniFile; const ASection: string; AStoringKind: TdxBarStoringKind);
    procedure SaveState;

    function CreateBarAsByMerging: TdxBar;
    procedure InternalUnmerge(ABarManager: TdxBarManager; AForCustomization: Boolean);
    procedure RestoreMergeState;

    procedure GetActiveSelection(AList: TList);

    procedure BeginMouseTracking(ABarControl: TCustomdxBarControl);
    procedure EndMouseTracking(ABarControl: TCustomdxBarControl);
    function IsMouseTracking(ABarControl: TCustomdxBarControl): Boolean;

    property BarControlFocused: Boolean read GetBarControlFocused;
    property LastSelectedLinkAtDesign: TdxBarItemLink read GetLastSelectedLinkAtDesign;
    property GroupList: TdxBarComponentList read FGroups; //#DG
    property ItemList: TdxBarComponentList read FItems; //#DG
    property InternalState: TdxBarInternalStates read FInternalState;

    property DraggingItem: TdxBarItem read GetDraggingItem write SetDraggingItem;
    property DraggingItemLink: TdxBarItemLink read GetDraggingItemLink write SetDraggingItemLink;
    property Dragging: Boolean read GetDragging;
    property DragInfo: TdxBarDragInfo read FDragInfo;

    function IsOwnerVisible: Boolean;
    function IsUncustomizable: Boolean;
    property FocusedBarControl: TCustomdxBarControl read FFocusedBarControl;
    property IsDestroying: Boolean read GetIsDestroying;
    property IsHandleCreating: Boolean read GetIsHandleCreating;
    property IsInitializing: Boolean read GetIsInitializing;
    property IsLoading: Boolean read GetIsLoading;
    property IsRecreating: Boolean read GetIsRecreating;
    property IsStateSaving: Boolean read GetIsStateSaving;
    property MainFormActive: Boolean read FMainFormActive;
    property SavedState: TMemIniFile read FSavedState;
    property TabOrder: Integer read GetTabOrder write SetTabOrder; // TODO make published, default 0

    function CanAddComponents: Boolean;
    function GetLightColor(ABtnFaceColorPart, AHighlightColorPart, AWindowColorPart: Integer): COLORREF;
    property BarCaptionFont: TFont read FBarCaptionFont;
    property CanModifyDesigner: Boolean read GetCanModifyDesigner;
    property Flat: Boolean read GetFlat;
    property FlatToolbarsBorderBrush: HBRUSH read FFlatToolbarsBorderBrush;
    property FlatToolbarsBrush: HBRUSH read FFlatToolbarsBrush;
    property FlatToolbarsDownedBrush: HBRUSH read FFlatToolbarsDownedBrush;
    property FlatToolbarsDownedSelBrush: HBRUSH read FFlatToolbarsDownedSelBrush;
    property FlatToolbarsSelBrush: HBRUSH read FFlatToolbarsSelBrush;
    property FlatToolbarsBorderColor: COLORREF read GetFlatToolbarsBorderColor;
    property FlatToolbarsColor: COLORREF read GetFlatToolbarsColor;
    property FlatToolbarsDownedColor: COLORREF read GetFlatToolbarsDownedColor;
    property FlatToolbarsDownedSelColor: COLORREF read GetFlatToolbarsDownedSelColor;
    property FlatToolbarsSelColor: COLORREF read GetFlatToolbarsSelColor;
    property ThemeToolbarsBrush: HBRUSH read FThemeToolbarsBrush;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    procedure ActivateHint(AShow: Boolean; const CustomHint: string; AHintObject: TObject = nil);
    procedure HideHint;
    function ActiveMDIChild: HWND;

    procedure BeginUpdate;
    procedure EndUpdate(ACheckBarsChanges: Boolean = True);

    function BarByCaption(const ACaption: string): TdxBar;
    function BarByComponentName(const AName: string): TdxBar;
    function BarByOldName(const AName: string): TdxBar;
//    function CheckBarName(const AName: string): string;
    function GetUniqueToolbarCaption(const ABaseName: string): string;
    function GetUniqueToolbarName(const ABaseName: string): string;

    function GetAllItemsByCategory(ACategory: Integer; List: TList): Integer;
    function GetCountByCategory(ACategory: Integer): Integer;
    function GetItemByCategory(ACategory, AIndex: Integer): TdxBarItem;
    function GetItemByName(const AName: string): TdxBarItem;
    function GetItemsByCategory(ACategory: Integer; List: TList): Integer;
    function GetUniqueItemName(ABarItemClass: TdxBarItemClass): string;

    function AddButton: TdxBarButton;
    function AddItem(AClass: TdxBarItemClass): TdxBarItem;
    function AddSubItem: TdxBarSubItem;
    function AddToolBar(AIsMainMenu: Boolean = False;
      ANeedEditCaption: Boolean = False): TdxBar;
    procedure DeleteToolBar(ABar: TdxBar; AConfirmation: Boolean);
    procedure ExchangeItems(Index1, Index2: Integer);
//    procedure FocusItem(AItem: TdxBarItem);
    procedure MoveItem(CurIndex, NewIndex: Integer);
    procedure RenameToolBar(ABar: TdxBar);
    procedure ResetToolBar(ABar: TdxBar);

    procedure Merge(ABarManager: TdxBarManager; ACanCreateNewBar: Boolean = True);
    procedure Unmerge(ABarManager: TdxBarManager = nil);

    procedure Customizing(Show: Boolean);
    procedure HideAll;
    procedure ResetUsageData;
    procedure ResetUsageDataWithConfirmation;
    //procedure WhatIsThis;

    procedure LoadFromRegistry(ARegistryPath: string);
    procedure SaveToRegistry(ARegistryPath: string);
    procedure LoadFromIniFile(const AFileName: string);
    procedure SaveToIniFile(const AFileName: string);
    procedure LoadFromStream(AStream: TStream);
    procedure SaveToStream(AStream: TStream);

    function CreateGroup: TdxBarGroup;

    function CanShowRecentItems: Boolean;
    function GetPaintStyle: TdxBarManagerStyle;

    property Bars: TdxBars read FBars;
    property BarsLoading: Boolean read GetBarsLoading;
    property CategoryItemsVisible[AIndex: Integer]: TdxBarItemVisible
      read GetCategoryItemsVisible write SetCategoryItemsVisible;
    property CategoryVisible[AIndex: Integer]: Boolean read GetCategoryVisible
      write SetCategoryVisible;
    property DefaultPainter: TdxBarPainter read FDefaultPainter;
    property Designing: Boolean read GetDesigning;
    property DockControlCount: Integer read GetDockControlCount;
    property DockControls[Index: Integer]: TdxDockControl read GetDockControl;
    property GroupCount: Integer read GetGroupCount;
    property Groups[Index: Integer]: TdxBarGroup read GetGroup;
    property InternalDockControls[ADockingStyle: TdxBarDockedDockingStyle]: TdxDockControl
      read GetInternalDockControl;
    property IsCustomizing: Boolean read GetIsCustomizing;
    property ItemCount: Integer read GetItemCount;
    property Items[Index: Integer]: TdxBarItem read GetItem;
    property IsMDIMaximized: Boolean read FIsMDIMaximized;
    property LockUpdate: Boolean read FLockUpdate write SetLockUpdate;
    property MainForm: TCustomForm read GetParentForm; { obsolete }
    property MasterForm: TCustomForm read GetMasterForm;
    property MainMenuControl: TdxBarControl read GetMainMenuControl;
    property MainMenuBar: TdxBar read GetMainMenuBar;
    property Modified: Boolean read FModified write FModified;  // only for Standard style
    property Owner: TWinControl read GetParentedOwner;
    property PainterClass: TdxBarPainterClass read InternalGetPainterClass;
    property ParentBarManager: TdxBarManager read GetParentBarManager;
    property ParentForm: TCustomForm read GetParentForm;
    property SelectedItem: TdxBarItemControl read FSelectedItem write SetSelectedItem;

    property ReadIniFileHandlers: TcxEventHandlerCollection read FReadIniFileHandlers;
    property WriteIniFileHandlers: TcxEventHandlerCollection read FWriteIniFileHandlers;
    property MDIStateChangedHandlers: TcxEventHandlerCollection read FMDIStateChangedHandlers;
    property SystemFontChangedHandlers: TcxEventHandlerCollection read FSystemFontChangedHandlers;
  published
    property AllowCallFromAnotherForm: Boolean read FAllowCallFromAnotherForm
      write FAllowCallFromAnotherForm default False;
    property AllowReset: Boolean read FAllowReset write FAllowReset default True;
    property AlwaysMerge: Boolean read FAlwaysMerge write FAlwaysMerge default False;
    property AlwaysSaveText: Boolean read FAlwaysSaveText write FAlwaysSaveText default False;
    property AutoAlignBars: Boolean read FAutoAlignBars write SetAutoAlignBars default False;
    property AutoDockColor: Boolean read FAutoDockColor write SetAutoDockColor default True;
    property AutoHideEmptyBars: Boolean read FAutoHideEmptyBars write SetAutoHideEmptyBars default False;
    property Scaled: Boolean read FScaled write SetScaled default True; // must be before Font
    property Font: TFont read FFont write SetFont; // must be before Bars
    property Backgrounds: TdxBarBackgrounds read FBackgrounds write SetBackgrounds;
    property ButtonArrowWidth: Integer read FButtonArrowWidth write SetButtonArrowWidth
      default dxBarDefaultButtonArrowWidth;
    property CanCustomize: Boolean read FCanCustomize write FCanCustomize default True;
    property Categories: TStrings read FCategories write SetCategories;
    property DockColor: TColor read GetDockColor write SetDockColor stored IsDockColorStored;
    property FlatCloseButton: Boolean read FFlatCloseButton write SetFlatCloseButton default False;
    property HelpButtonGlyph: TBitmap read FHelpButtonGlyph write SetHelpButtonGlyph;
    property HelpContext: THelpContext read FHelpContext write FHelpContext default 0;
    property HideFloatingBarsWhenInactive: Boolean read FHideFloatingBarsWhenInactive
      write SetHideFloatingBarsWhenInactive default True;

    // ImageOptions
    property ImageOptions: TdxBarImageOptions read FImageOptions write FImageOptions;
    // obsolete
    property DisabledImages: TCustomImageList read GetDisabledImages write SetDisabledImages stored False;
    property DisabledLargeImages: TCustomImageList read GetDisabledLargeImages write SetDisabledLargeImages stored False;
    property HotImages: TCustomImageList read GetHotImages write SetHotImages stored False;
    property ImageListBkColor: TColor read GetImageListBkColor write SetImageListBkColor stored False;
    property Images: TCustomImageList read GetImages write SetImages stored False;
    property LargeImages: TCustomImageList read GetLargeImages write SetLargeImages stored False;
    property LargeIcons: Boolean read GetLargeIcons write SetLargeIcons stored False;
    property MakeDisabledImagesFaded: Boolean read GetMakeDisabledImagesFaded write SetMakeDisabledImagesFaded stored False;
    property StretchGlyphs: Boolean read GetStretchGlyphs write SetStretchGlyphs stored False;
    property UseLargeImagesForLargeIcons: Boolean read GetUseLargeImagesForLargeIcons write SetUseLargeImagesForLargeIcons stored False;

    property IniFileName: string read FIniFileName write FIniFileName;
    property LargeButtonArrowWidth: Integer read FLargeButtonArrowWidth write
      SetLargeButtonArrowWidth default dxBarDefaultLargeButtonArrowWidth;
    property LookAndFeel: TcxLookAndFeel read FLookAndFeel write SetLookAndFeel;
    property MenuAnimations: TdxBarMenuAnimations read FMenuAnimations
      write SetMenuAnimations default maNone;
    property MenusShowRecentItemsFirst: Boolean read FMenusShowRecentItemsFirst
      write SetMenusShowRecentItemsFirst default True;
    property MostRecentItemsPercents: Byte read FMostRecentItemsPercents
      write SetMostRecentItemsPercents default 95;
    property NotDocking: TdxBarDockingStyles read GetNotDocking write SetNotDocking default [];
    property PopupMenuLinks: TdxBarPopupMenuLinks read FPopupMenuLinks write SetPopupMenuLinks;
    property RegistryPath: string read FRegistryPath write SetRegistryPath;
    property ShowCloseButton: Boolean read FShowCloseButton write SetShowCloseButton default False;
    property ShowFullMenusAfterDelay: Boolean read FShowFullMenusAfterDelay
      write SetShowFullMenusAfterDelay default True;
    property ShowHelpButton: Boolean read FShowHelpButton write SetShowHelpButton default False;
    property ShowHint: Boolean read FShowHint write SetShowHint default True;
    property ShowHintForDisabledItems: Boolean read FShowHintForDisabledItems
      write FShowHintForDisabledItems default True;
    property ShowShortCutInHint: Boolean read FShowShortCutInHint
      write SetShowShortCutInHint default False;
    property StoreInIniFile: Boolean read FStoreInIniFile write FStoreInIniFile default False;
    property StoreInRegistry: Boolean read FStoreInRegistry write FStoreInRegistry default False;
    property Style: TdxBarManagerStyle read FStyle write SetStyle default bmsEnhanced;
    property SunkenBorder: Boolean read FSunkenBorder write SetSunkenBorder default False;
    property UseF10ForMenu: Boolean read FUseF10ForMenu write FUseF10ForMenu default True;
    property UseFullReset: Boolean read FUseFullReset write FUseFullReset default False;
    property UseSystemFont: Boolean read FUseSystemFont write SetUseSystemFont;
    property WaitForDockingTime: Integer read FWaitForDockingTime write SetWaitForDockingTime default 21;

    property OnBarAdd: TdxBarEvent read FOnBarAdd write FOnBarAdd;
    property OnBarAfterReset: TdxBarEvent read FOnBarAfterReset write FOnBarAfterReset;
    property OnBarBeforeReset: TdxBarEvent read FOnBarBeforeReset write FOnBarBeforeReset;
    property OnBarClose: TdxBarEvent read FOnBarClose write FOnBarClose;
    property OnBarDelete: TdxBarEvent read FOnBarDelete write FOnBarDelete;
    property OnBarDockingStyleChange: TdxBarEvent read FOnBarDockingStyleChange
      write FOnBarDockingStyleChange;
    property OnBarVisibleChange: TdxBarVisibleChangeEvent read FOnBarVisibleChange
      write FOnBarVisibleChange;

    property OnItemLinkAdd: TdxBarItemLinkEvent read FOnItemLinkAdd
      write FOnItemLinkAdd;
    property OnItemLinkChange: TdxBarItemLinkEvent read FOnItemLinkChange
      write FOnItemLinkChange;
    property OnItemLinkDelete: TdxBarItemLinkEvent read FOnItemLinkDelete
      write FOnItemLinkDelete;
    property OnMergeItemLink: TdxBarMergeItemLinkEvent read FOnMergeItemLink
      write FOnMergeItemLink;

    property OnCloseButtonClick: TNotifyEvent read FOnCloseButtonClick
      write FOnCloseButtonClick;
    property OnDocking: TdxBarCanDockingEvent read FOnDocking write FOnDocking;
    property OnHelpButtonClick: TNotifyEvent read FOnHelpButtonClick write FOnHelpButtonClick;
    property OnHideCustomizingForm: TNotifyEvent read FOnHideCustomizingForm
      write FOnHideCustomizingForm;
    property OnMenuMerge: TdxBarMenuMergeEvent read FOnMenuMerge write FOnMenuMerge;
    property OnMerge: TdxBarMergeEvent read FOnMerge write FOnMerge;
    property OnShowCustomizingForm: TNotifyEvent read FOnShowCustomizingForm
      write FOnShowCustomizingForm;
    property OnShowCustomizingPopup: TdxBarShowPopupEvent read FOnShowCustomizingPopup
      write FOnShowCustomizingPopup;
    property OnShowToolbarsPopup: TdxBarShowPopupEvent read FOnShowToolbarsPopup
      write FOnShowToolbarsPopup;

    property OnClickItem: TdxBarClickItemEvent read FOnClickItem write FOnClickItem;
  end;

  TdxBarManagerList = class(TdxObjectList)
  private
    function GetBarManager(Index: Integer): TdxBarManager;
    function GetCustomizingBarManager: TdxBarManager;
  public
    destructor Destroy; override;
    function NextActive(ABarManager: TdxBarManager;
      AGoForward: Boolean): TdxBarManager;
    property BarManagers[Index: Integer]: TdxBarManager read GetBarManager; default;
    property CustomizingBarManager: TdxBarManager read GetCustomizingBarManager;
  end;

  TdxBarBorderStyle = (bbsNone, bbsSingle);
  TdxBarStaticBorderStyle = (sbsNone, sbsLowered, sbsRaised, sbsEtched, sbsBump);
  TdxBarSpinEditButton = (sbNone, sbUp, sbDown);
  TdxBarSpinEditButtons = set of TdxBarSpinEditButton;

  TdxBarMergeData = class
  private
    FFreeNotificator: TcxFreeNotificator;
    FMergedBarList: TList;
    FSavedMergedBarList: TList;
    procedure FreeNotification(Sender: TComponent);
    function GetSavedMergedBar(AIndex: Integer): TdxBar;
    function GetSavedMergedBarListCount: Integer;
    procedure SetFreeNotifications;
  protected
    property FreeNotificator: TcxFreeNotificator read FFreeNotificator;
  public
    CreatedByMerging: Boolean;
    CreatedByMergingBarVisibleBeforeCustomization: Boolean;
    MergedWith: TdxBar;
    VisibleBeforeMerging: Boolean;
    constructor Create;
    destructor Destroy; override;
    procedure ClearSavedMergedBarList;
    procedure SaveMergedBarList(AList: TList = nil);
    property MergedBarList: TList read FMergedBarList;
    property SavedMergedBarCount: Integer read GetSavedMergedBarListCount;
    property SavedMergedBars[AIndex: Integer]: TdxBar read GetSavedMergedBar;
  end;

  { TdxBarAccessibilityHelper }

  TdxBarAccessibilityHelper = class(TcxAccessibilityHelper, IdxBarAccessibilityHelper)
  private
    function InternalGetChild(AIndex: Integer): TdxBarAccessibilityHelper;
    function InternalGetParent: TdxBarAccessibilityHelper;
  protected
    // IcxAccessibilityHelper
    procedure OwnerObjectDestroyed; override;

    // IdxBarAccessibilityHelper
    function AreKeyTipsSupported(
      out AKeyTipWindowsManager: IdxBarKeyTipWindowsManager): Boolean; virtual;
    function CanNavigateToChildren(AKey: Word): Boolean; virtual;
    function GetBarHelper: TdxBarAccessibilityHelper;
    function GetBarManager: TdxBarManager; virtual;
    function GetDefaultAccessibleObject: IdxBarAccessibilityHelper; virtual;
    function GetNextAccessibleObject(
      ADirection: TcxAccessibilityNavigationDirection): IdxBarAccessibilityHelper; overload; virtual;
    function GetRootAccessibleObject: IdxBarAccessibilityHelper;
    function HandleNavigationKey(var AKey: Word): Boolean; virtual;
    function IsNavigationKey(AKey: Word): Boolean; virtual;
    function IsSelected: Boolean;
    function LogicalNavigationGetNextAccessibleObject(
      AGoForward: Boolean): IdxBarAccessibilityHelper; virtual;
    procedure Select(ASetFocus: Boolean); virtual;
    procedure Unselect(ANextSelectedObject: IdxBarAccessibilityHelper); virtual;

    procedure GetChildrenForNavigation(
      ASelectedObject, AParentObject: TdxBarAccessibilityHelper;
      const ASelectedObjectScreenBounds: TRect;
      ADirection: TcxAccessibilityNavigationDirection;
      AAreOnlyNearObjectsAccepted: Boolean; AObjects: TList);

    procedure GetChilds(AChilds: TList; AOnlyVisible: Boolean = True);

    function GetAssignedKeyTip: string; virtual; abstract;
    function GetDefaultKeyTip: string; virtual; abstract;
    function GetKeyTip: string; virtual;

    function CreateKeyTipData: TdxBarKeyTipData; virtual;
    procedure GetKeyTipInfo(out AKeyTipInfo: TdxBarKeyTipInfo); virtual;
    procedure GetKeyTipData(AKeyTipsData: TList); virtual;
    procedure DoGetKeyTipsData(AKeyTipsData: TList); virtual;
    procedure GetKeyTipsData(AKeyTipsData: TList);
    procedure GenerateUniqueKeyTips(AKeyTipsData: TList);

    function GetParentForKeyTip: TdxBarAccessibilityHelper; virtual;
    function IsKeyTipContainer: Boolean; virtual;
    procedure KeyTipHandler(Sender: TObject); virtual;
    procedure KeyTipsEscapeHandler; virtual;
    function LogicalNavigationGetChild(AIndex: Integer): TdxBarAccessibilityHelper; virtual;
    function LogicalNavigationGetChildCount: Integer; virtual;
    function LogicalNavigationGetChildIndex(
      AChild: TdxBarAccessibilityHelper): Integer; virtual;
    function LogicalNavigationGetNextChild(AChildIndex: Integer;
      AGoForward: Boolean): TdxBarAccessibilityHelper;

    property ParentForKeyTip: TdxBarAccessibilityHelper read GetParentForKeyTip;
  public
    function GetFirstSelectableObject: TdxBarAccessibilityHelper;
    property BarManager: TdxBarManager read GetBarManager;
    property Childs[AIndex: Integer]: TdxBarAccessibilityHelper read InternalGetChild;
    property Parent: TdxBarAccessibilityHelper read InternalGetParent;
  end;

  TdxBarAccessibilityHelperClass = class of TdxBarAccessibilityHelper;

  TdxBarCaptionButton = class(TcxInterfacedCollectionItem, IdxBarHintKeeper)
  private
    FEnabled: Boolean;
    FGlyph: TBitmap;
    FHint: string;
    FIAccessibilityHelper: IdxBarAccessibilityHelper;
    FKeyTip: string;
    FNotifyComponent: TcxFreeNotificator;
    FRect: TRect;
    FScreenTip: TdxBarScreenTip;
    FState: Integer;
    FOnClick: TNotifyEvent;
    function GetCollection: TdxBarCaptionButtons;
    function GetIAccessibilityHelper: IdxBarAccessibilityHelper;
    function GetParent: TdxBarControl;
    procedure GlyphChanged(Sender: TObject);
    procedure SetEnabled(Value: Boolean);
    procedure SetGlyph(Value: TBitmap);
    procedure SetScreenTip(Value: TdxBarScreenTip);
    procedure SetState(Value: Integer);
    procedure SetOnClick(Value: TNotifyEvent);

    procedure FreeNotification(AComponent: TComponent);

    property Parent: TdxBarControl read GetParent;
  protected
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; virtual;
    // IdxBarHintKeeper
    function DoHint(var ANeedDeactivate: Boolean; out AHintText: string; out AShortCut: string): Boolean;
    function CreateHintViewInfo(const AHintText, AShortCut: string): TdxBarCustomHintViewInfo;
    function GetEnabled: Boolean;
    function GetHintPosition(const ACursorPos: TPoint; AHeight: Integer): TPoint;
  public
    constructor Create(Collection: TCollection); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    procedure Click;
    property Collection: TdxBarCaptionButtons read GetCollection;
    property Glyph: TBitmap read FGlyph write SetGlyph;
    property IAccessibilityHelper: IdxBarAccessibilityHelper read GetIAccessibilityHelper;
    property Rect: TRect read FRect write FRect;
    property State: Integer read FState write SetState;
  published
    property Enabled: Boolean read FEnabled write SetEnabled default True;
    property Hint: string read FHint write FHint;
    property KeyTip: string read FKeyTip write FKeyTip;
    property ScreenTip: TdxBarScreenTip read FScreenTip write SetScreenTip;
    property OnClick: TNotifyEvent read FOnClick write SetOnClick;
  end;

  TdxBarCaptionButtons = class(TcxOwnedInterfacedCollection)
  private
    FIAccessibilityHelper: IdxBarAccessibilityHelper;
    function GetBar: TdxBar;
    function GetIAccessibilityHelper: IdxBarAccessibilityHelper;
    function GetItem(Index: Integer): TdxBarCaptionButton;
    function GetRect: TRect;
    procedure SetItem(Index: Integer; Value: TdxBarCaptionButton);
  protected
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; virtual;
    function GetButtonIndex(const APoint: TPoint): Integer;
  public
    constructor Create(ABar: TdxBar);
    destructor Destroy; override;
    function Add: TdxBarCaptionButton;
    procedure UpdateButtonStates(const AMousePos: TPoint; AMousePressed: Boolean = False);
    property Bar: TdxBar read GetBar;
    property IAccessibilityHelper: IdxBarAccessibilityHelper read GetIAccessibilityHelper;
    property Items[Index: Integer]: TdxBarCaptionButton read GetItem write SetItem; default;
    property Rect: TRect read GetRect;
  end;

  TdxBar = class(TcxComponentCollectionItem, {$IFNDEF DELPHI6}IUnknown,{$ENDIF} IdxBarSelectableItem, IdxBarLinksOwner)
  private
    FAllowClose: Boolean;
    FAllowCustomizing: Boolean;
    FAllowQuickCustomizing: Boolean;
    FAllowReset: Boolean;
    FAlphaBlendValue: Byte;
    FBackgroundBitmap: TBitmap;
    FBorderStyle: TdxBarBorderStyle;
    FCaption: string;
    FCaptionButtons: TdxBarCaptionButtons;
    FChanged: Boolean;
    FColor: TColor;
    FChangingDockingStyle: Boolean;
    FDockControl: TdxBarDockControl;
    FDockedDockControl: TdxBarDockControl;
    FDockedDockingStyle: TdxBarDockingStyle;
    FDockedLeft: Integer;
    FDockedTop: Integer;
    FDockingStyle: TdxBarDockingStyle;
    FDockRow: TdxDockRow;
    FEditFont: TFont;
    FFloatLeft: Integer;
    FFloatTop: Integer;
    FFloatClientWidth: Integer;
    FFloatClientHeight: Integer;
    FFont: TFont;
    FFreeNotificationItems: TList;
    FGlyph: TBitmap;
    FHidden: Boolean;  // if True, then doesn't show in customizing form in run-time
    FInternalFontChange: Boolean;
    FInternallyHidden: Boolean;
    FIsMainMenu: Boolean;
    FIsNameLocked: Boolean;
    FIsPredefined: Boolean;
    FItemLinks: TdxBarItemLinks;
    FKeyTip: string;
    FLoadedDockControl: TdxBarDockControl;
    FLoadedDockingStyle: TdxBarDockingStyle;
    FLoadedVisible: Boolean;
    FLockUpdate: Boolean;
    FMergeData: TdxBarMergeData;
    FNeedUpdateControlPosition: Boolean;
//    FName: TComponentName;
    FNotDocking: TdxBarDockingStyles;
    FMultiLine: Boolean;
    FOneOnRow: Boolean;
    FOldName: string;
    FRotateWhenVertical: Boolean;
    FRow: Integer;
    FShouldNotBeDestroyedIfEmptyAfterUnmerge: Boolean;
    FShowMark: Boolean;
    FSizeGrip: Boolean;
    FUseOwnFont: Boolean;
    FUseRestSpace: Boolean;
    FVisible: Boolean;  // is it currently visible or not?
    FWholeRow: Boolean;
    FOnDestroy: TNotifyEvent;

    procedure BitmapChanged(Sender: TObject);
    procedure DoDestroy;
    function GetBars: TdxBars;
    function GetControl: TdxBarControl;
    function GetDockControl: TdxBarDockControl;
    function GetDockedDockingStyle: TdxBarDockingStyle;
    function GetDockingStyle: TdxBarDockingStyle;
    function GetNext: TdxBar;
    function GetNotDocking: TdxBarDockingStyles;
    function GetPainter: TdxBarPainter;
    function GetRealDockControl: TdxDockControl;
    function GetRow: Integer;
    function GetUseRecentItems: Boolean;
    function GetVisible: Boolean;
    procedure GlyphChanged(Sender: TObject);
    procedure SetAllowClose(Value: Boolean);
    procedure SetAllowQuickCustomizing(Value: Boolean);
    procedure SetAlphaBlendValue(Value: Byte);
    procedure SetBackgroundBitmap(Value: TBitmap);
    procedure SetBorderStyle(Value: TdxBarBorderStyle);
    procedure SetCaption(Value: string);
    procedure SetCaptionButtons(Value: TdxBarCaptionButtons);
    procedure SetColor(Value: TColor);
    procedure SetDockControl(Value: TdxBarDockControl);
    procedure SetDockedDockControl(Value: TdxBarDockControl);
    procedure SetDockedValue(Index: Integer; Value: Integer);
    procedure SetDockingStyle(Value: TdxBarDockingStyle);
    procedure SetDockRow(Value: TdxDockRow);
    procedure SetFloatValue(Index: Integer; Value: Integer);
    procedure SetFont(Value: TFont);
    procedure SetGlyph(Value: TBitmap);
    procedure SetHidden(Value: Boolean);
    procedure SetIsMainMenu(Value: Boolean);
    procedure SetItemLinks(Value: TdxBarItemLinks);
    procedure SetLockUpdate(Value: Boolean);
    procedure SetMultiLine(Value: Boolean);
    procedure SetNotDocking(Value: TdxBarDockingStyles);
    procedure SetOneOnRow(Value: Boolean);
    procedure SetRotateWhenVertical(Value: Boolean);
    procedure SetRow(Value: Integer);
    procedure SetShowMark(Value: Boolean);
    procedure SetSizeGrip(Value: Boolean);
    procedure SetUseOwnFont(Value: Boolean);
    procedure SetUseRecentItems(Value: Boolean);
    procedure SetUseRestSpace(Value: Boolean);
    procedure SetVisible(Value: Boolean);
    procedure SetWholeRow(Value: Boolean);

    procedure FontChanged(Sender: TObject);

    procedure UpdateControlPosition;

    function IsDockedDockingStyleStored: Boolean;
    function IsDockingStyleStored: Boolean;
  protected
    procedure AddFreeNotification(AItem: TdxBarItem);
    procedure RemoveFreeNotification(AItem: TdxBarItem);
    procedure MakeFreeNotification;
    procedure RemoveFromDockRow(ADestroyEmptyDockRow: Boolean);
    procedure SetName(const NewName: TComponentName); override;
    procedure Updated; override;
    procedure Updating; override;

    function CreateControl: TdxBarControl;
    function GetControlClass: TdxBarControlClass; virtual;
    procedure ShowControl;

    class function GetIniSection(const ABaseSection: string; ABarIndex: Integer): string;
    procedure LoadFromIni(ASource: TCustomIniFile; const ABaseSection: string;
      ABarIndex: Integer; AStoringKind: TdxBarStoringKind; AFullLoad: Boolean = True);
    procedure LoadUsageData(ASource: TCustomIniFile; const ABaseSection: string; ABarIndex: Integer);
    procedure SaveToIni(ADestination: TCustomIniFile; const ABaseSection: string;
      ABarIndex: Integer; AStoringKind: TdxBarStoringKind);

    procedure InternalMerge(ABar: TdxBar; ASaveMergingBarVisibility: Boolean);
    procedure InternalUnmergeFromBar(ABar: TdxBar;
      ARestoreMergedBarsVisibility: Boolean);
    procedure InternalUnmergeFromBarManager(ABarManager: TdxBarManager;
      ARestoreMergedBarsVisibility: Boolean);
    procedure RestoreMergeState;
    procedure SaveMergeState;
    procedure SetVisibility(Value: Boolean);

    procedure CaptionButtonsNotification(Sender: TObject; AItem: TCollectionItem); virtual;
    procedure DoChanged;

    function BarNCSizeX(AStyle: TdxBarDockingStyle): Integer;
    function BarNCSizeY(AStyle: TdxBarDockingStyle): Integer;
    function CanClose: Boolean;
    function CanMoving: Boolean;
    function CanReset: Boolean;
    function GetDockedPosition: Integer;
    function HasSizeGrip: Boolean;
    function IsFloat: Boolean;
    function IsShortCut(AShortCut: TShortCut): Boolean;
    function IsStatusBar: Boolean;

    // IdxBarSelectableItem
    function CanDelete(ADestruction: Boolean = False): Boolean;
    procedure DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean);
    procedure ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction);
    function GetBarManager: TdxBarManager;
    function IdxBarSelectableItem.GetInstance = GetPersistentInstance;
    procedure GetMasterObjects(AList: TdxObjectList);
    function GetNextSelectableItem: IdxBarSelectableItem;
    function GetSelectableParent: TPersistent;
    function GetSelectionStatus: TdxBarSelectionStatus;
    function GetSupportedActions: TdxBarCustomizationActions;
    procedure Invalidate;
    function IsComplex: Boolean;
    function IsComponentSelected: Boolean;
    procedure SelectComponent(ASelectionOperation: TdxBarSelectionOperation = soExclusive);
    function SelectParentComponent: Boolean;
    procedure SelectionChanged;

    // IdxBarLinksOwner
    function CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
    function CreateBarControl: TCustomdxBarControl;
    function IdxBarLinksOwner.GetInstance = GetComponentInstance;
    function GetItemLinks: TdxBarItemLinks;

    function GetComponentInstance: TComponent;
    function GetPersistentInstance: TPersistent;

    property MergeData: TdxBarMergeData read FMergeData;
    property Painter: TdxBarPainter read GetPainter;
    property ShouldNotBeDestroyedIfEmptyAfterUnmerge: Boolean read FShouldNotBeDestroyedIfEmptyAfterUnmerge
      write FShouldNotBeDestroyedIfEmptyAfterUnmerge;
    property OnDestroy: TNotifyEvent read FOnDestroy write FOnDestroy;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    procedure ChangeDockingStyle(AStyle: TdxBarDockingStyle;
      ADockControl: TdxDockControl);
    function GetCollectionFromParent(AParent: TComponent): TcxComponentCollection; override;
    function IsVertical: Boolean;
    procedure Move(X, Y: Integer); overload;
    procedure Move(ADockControl: TdxDockControl; ARow, APosition: Integer); overload;
    procedure Move(ADockingStyle: TdxBarDockedDockingStyle; ARow, APosition: Integer); overload;
    procedure Move(ABar: TdxBar; AInsertAfter: Boolean = True); overload;
    procedure Reset;
    procedure ResetWithConfirmation;
    procedure SetParentComponent(AParent: TComponent); override;

    procedure Merge(ABar: TdxBar);
    procedure Unmerge(ABar: TdxBar = nil);

    property BarManager: TdxBarManager read GetBarManager;
    property Bars: TdxBars read GetBars;
    property Control: TdxBarControl read GetControl;
    property DockRow: TdxDockRow read FDockRow write SetDockRow;
    property IsPredefined: Boolean read FIsPredefined;
    property LockUpdate: Boolean read FLockUpdate write SetLockUpdate;
    property RealDockControl: TdxDockControl read GetRealDockControl;
  published
    property AllowClose: Boolean read FAllowClose write SetAllowClose default True;
    property AllowCustomizing: Boolean read FAllowCustomizing write FAllowCustomizing
      default True;
    property AllowQuickCustomizing: Boolean read FAllowQuickCustomizing
      write SetAllowQuickCustomizing default True;
    property AllowReset: Boolean read FAllowReset write FAllowReset default True;
    property BorderStyle: TdxBarBorderStyle read FBorderStyle write SetBorderStyle
      default bbsSingle;
    property Caption: string read FCaption write SetCaption;
    property CaptionButtons: TdxBarCaptionButtons read FCaptionButtons write SetCaptionButtons;
    property Color: TColor read FColor write SetColor default clDefault;
    property DockControl: TdxBarDockControl read GetDockControl write SetDockControl;
    property DockedDockControl: TdxBarDockControl read FDockedDockControl
      write SetDockedDockControl;
    property DockedDockingStyle: TdxBarDockingStyle read GetDockedDockingStyle
      write FDockedDockingStyle stored IsDockedDockingStyleStored;
    property DockedLeft: Integer index 1 read FDockedLeft write SetDockedValue;
    property DockedTop: Integer index 2 read FDockedTop write SetDockedValue;
    property DockingStyle: TdxBarDockingStyle read GetDockingStyle write SetDockingStyle
      stored IsDockingStyleStored;
    property FloatLeft: Integer index 1 read FFloatLeft write SetFloatValue;
    property FloatTop: Integer index 2 read FFloatTop write SetFloatValue;
    property FloatClientWidth: Integer index 3 read FFloatClientWidth write SetFloatValue;
    property FloatClientHeight: Integer index 4 read FFloatClientHeight write SetFloatValue;
    property Font: TFont read FFont write SetFont stored FUseOwnFont;
    property Glyph: TBitmap read FGlyph write SetGlyph;
    property Hidden: Boolean read FHidden write SetHidden default False;
    property IsMainMenu: Boolean read FIsMainMenu write SetIsMainMenu default False;
    property ItemLinks: TdxBarItemLinks read GetItemLinks write SetItemLinks;
    property KeyTip: string read FKeyTip write FKeyTip;
    property MultiLine: Boolean read FMultiLine write SetMultiLine default False;
//    property Name: TComponentName read FName write SetName;
    property NotDocking: TdxBarDockingStyles read GetNotDocking write SetNotDocking default [];
    property OldName: string read FOldName write FOldName;
    property OneOnRow: Boolean read FOneOnRow write SetOneOnRow;
    property RotateWhenVertical: Boolean read FRotateWhenVertical write SetRotateWhenVertical
      default True;
    property Row: Integer read GetRow write SetRow;
    property ShowMark: Boolean read FShowMark write SetShowMark default True;
    property SizeGrip: Boolean read FSizeGrip write SetSizeGrip default True;
    property UseOwnFont: Boolean read FUseOwnFont write SetUseOwnFont;
    property UseRecentItems: Boolean read GetUseRecentItems write SetUseRecentItems default True;
    property UseRestSpace: Boolean read FUseRestSpace write SetUseRestSpace default False;
    property Visible: Boolean read GetVisible write SetVisible;
    property WholeRow: Boolean read FWholeRow write SetWholeRow;
    property BackgroundBitmap: TBitmap read FBackgroundBitmap write SetBackgroundBitmap;
    property AlphaBlendValue: Byte read FAlphaBlendValue write SetAlphaBlendValue default 255;
  end;

  TdxDockControls = array[dsLeft..dsBottom] of TdxDockControl;

  TdxBars = class(TcxComponentCollection)
  private
    FDockControls: TdxDockControls;
    FDocking: Boolean;
    FDockingZoneSize: Integer;
    FBarManager: TdxBarManager;
    FMoving: Boolean;
    FMovingBarControl: TdxBarControl;
    FMovingBarOriginalDockingStyle: TdxBarDockingStyle;
    FMovingOffset: TPoint;
    FMovingStaticOffset: TPoint;

    function GetDockControl(Index: TdxBarDockingStyle): TdxDockControl;
    function GetItem(Index: Integer): TdxBar;
    procedure SetItem(Index: Integer; Value: TdxBar);
  protected
//    function GetOwner: TPersistent; override;

    procedure RegInDock(AStyle: TdxBarDockingStyle; ADockControl: TdxDockControl;
      ABarControl: TdxBarControl; APos: TPoint);
    procedure UnregFromDock(AStyle: TdxBarDockingStyle;
      ADockControl: TdxDockControl; ABarControl: TdxBarControl);

    procedure ChangeBarControlPos(ABarControl: TdxBarControl; APos: TPoint);
    function GetDockingStyleAtPos(Bar: TdxBar; Pos: TPoint;
      var DockControl: TdxDockControl): TdxBarDockingStyle;
    procedure Moving(AMovingBarControl: TdxBarControl);
    procedure Repaint;
    procedure SetItemName(AItem: TcxComponentCollectionItem); override;
    procedure Update(AItem: TcxComponentCollectionItem; AAction: TcxComponentCollectionNotification); override;

    property DockingZoneSize: Integer read FDockingZoneSize write FDockingZoneSize;
  public
    constructor Create(ABarManager: TdxBarManager); reintroduce;
    destructor Destroy; override;
    function Add: TdxBar;
    function GetUniqueToolbarName(const ABaseName: string): string;
    function Insert(Index: Integer): TdxBar;

    property BarManager: TdxBarManager read FBarManager;
    property DockControls[Index: TdxBarDockingStyle]: TdxDockControl read GetDockControl;
    property IsMoving: Boolean read FMoving;
    property Items[Index: Integer]: TdxBar read GetItem write SetItem; default;
  end;

  TdxBarUserDefine = (udCaption, udGlyph, udPaintStyle, udWidth);
  TdxBarUserDefines = set of TdxBarUserDefine;

  TdxBarPaintStyle = (psStandard, psCaption, psCaptionInMenu, psCaptionGlyph);

  TdxBarItemControlPart = (cpIcon, cpText);
  TdxBarItemControlViewStructure = set of TdxBarItemControlPart;
  TdxBarItemControlViewSize = (cvsSmall, cvsMedium, cvsLarge);

  TdxBarItemOptionValue = (ioShowDescriptions, ioShowShortCuts, ioSize);
  TdxBarItemOptionValues = set of TdxBarItemOptionValue;

  TdxBarItemOptions = class(TPersistent)
  private
    FItemLinks: TdxBarItemLinks;

    FAssignedValues: TdxBarItemOptionValues;
    FShowDescriptions: Boolean;
    FShowShortCuts: Boolean;
    FSize: TdxBarMenuItemSize;

    function GetAssignedValues: TdxBarItemOptionValues;
    function GetDefaultValue(AOption: TdxBarItemOptionValue): Variant;
    function GetValue(AOption: TdxBarItemOptionValue): Variant;
    function GetShowDescriptions: Boolean;
    function GetShowShortCuts: Boolean;
    function GetSize: TdxBarMenuItemSize;
    procedure SetAssignedValues(AValue: TdxBarItemOptionValues);
    procedure SetShowDescriptions(AValue: Boolean);
    procedure SetShowShortCuts(AValue: Boolean);
    procedure SetSize(AValue: TdxBarMenuItemSize);

    function IsValueStored(AOption: TdxBarItemOptionValue): Boolean;
    function IsShowDescriptionsStored: Boolean;
    function IsShowShortCutsStored: Boolean;
    function IsSizeStored: Boolean;
  public
    constructor Create(AItemLinks: TdxBarItemLinks);
    procedure Assign(Source: TPersistent); override;
  published
    property AssignedValues: TdxBarItemOptionValues read GetAssignedValues write SetAssignedValues stored False;
    property ShowDescriptions: Boolean read GetShowDescriptions write SetShowDescriptions stored IsShowDescriptionsStored;
    property ShowShortCuts: Boolean read GetShowShortCuts write SetShowShortCuts stored IsShowShortCutsStored;
    property Size: TdxBarMenuItemSize read GetSize write SetSize stored IsSizeStored;
  end;

  TdxBarItemLink = class(TcxInterfacedCollectionItem, IdxBarSelectableItem)
  private
    FBeginGroup: Boolean;
    FButtonGroup: TdxBarButtonGroupPosition;
    FControl: TdxBarItemControl;
    FCreatedFromMergingWith: TdxBar;
    FData: Integer;
    FDistributed: Boolean;
    FIsMarkedForDeletion: Boolean;
    FItem: TdxBarItem;
    FItemRect: TRect;
    FLoadedItemName: string;
    FLoadedRecentIndex: Integer;
    FLoadedUseCount: Integer;
    FLoadedVisible: Boolean;
    FMostRecentlyUsed: Boolean;
    FOriginalItemLink: TdxBarItemLink;
    FPosition: TdxBarItemPosition;
    FPrevItemName: string;
    FPrevRecentIndex: Integer;
    FRowHeight: Integer;
    FUseCount: Integer;
    FUserCaption: string;
    FUserDefine: TdxBarUserDefines;
    FUserGlyph: TBitmap;
    FUserPaintStyle: TdxBarPaintStyle;
    FUserWidth: Integer;
    FViewLevels: TdxBarItemViewLevels;
    FVisible: Boolean;

    function GetAllowedViewLevels: TdxBarItemViewLevels;
    function GetAvailableIndex: Integer;
    function GetBarControl: TCustomdxBarControl;
    function GetBeginGroup: Boolean;
    function GetCanVisibleIndex: Integer;
    function GetCaption: string;
    function GetCollection: TdxBarItemLinks;
    function GetGlyph: TBitmap;
    function GetItem: TdxBarItem;
    function GetNext: TdxBarItemLink;
    function GetOwnerValue: TdxBarItemLinks;
    function GetPaintStyle: TdxBarPaintStyle;
    function GetUserDefine: TdxBarUserDefines;
    function GetVisibleIndex: Integer;
    function GetWidth: Integer;
    procedure ReadItemName(AReader: TReader);
    procedure SetBeginGroup(Value: Boolean);
    procedure SetButtonGroup(Value: TdxBarButtonGroupPosition);
    procedure SetCollection(Value: TdxBarItemLinks); reintroduce; virtual;
    procedure SetDistributed(const Value: Boolean);
    procedure SetDistributedByPrimaryLink(const Value: Boolean);
    procedure SetItem(Value: TdxBarItem);
    procedure SetItemRect(Value: TRect);
    procedure SetMostRecentlyUsed(Value: Boolean);
    procedure SetPosition(Value: TdxBarItemPosition);

    procedure ForceSetUserDefine(AValue: TdxBarUserDefine);
    procedure SetUserDefine(Value: TdxBarUserDefines);
    procedure SetUserCaption(const Value: string);
    procedure SetUserGlyph(Value: TBitmap);
    procedure SetUserPaintStyle(Value: TdxBarPaintStyle);
    procedure SetUserWidth(Value: Integer);

    procedure SetViewLevels(Value: TdxBarItemViewLevels);
    procedure SetVisible(Value: Boolean);
    procedure WriteItemName(AWriter: TWriter);

    procedure AddToRecentList;
    procedure RemoveFromRecentList;
    procedure RestoreRecentIndex;
    procedure SaveRecentIndex;
    procedure InternalBringToTopInRecentList(IncCount: Boolean);
    function IsPrimaryForDistribution: Boolean;
    procedure Synchronize(AItemLink: TdxBarItemLink);
    procedure CheckMostRecentlyUsed;
    function GetRecentIndex: Integer;
    procedure SetRecentIndex(Value: Integer);
    property RecentIndex: Integer read GetRecentIndex write SetRecentIndex;

    function CanVisible: Boolean;
    function GetRealItemLink: TdxBarItemLink;
    procedure OnUserGlyphChanged(Sender: TObject);
  protected
    procedure DefineProperties(Filer: TFiler); override;
    procedure LoadItemName;

    class function GetIniSection(const ABaseSection: string; ALinkIndex: Integer;
      AStoringKind: TdxBarStoringKind): string;
    procedure LoadFromIni(ASource: TCustomIniFile; const ABaseSection: string;
      ALinkIndex: Integer; AStoringKind: TdxBarStoringKind);
    procedure LoadUsageData(ASource: TCustomIniFile; ABaseSection: string;
      ALinkIndex: Integer);
    procedure SaveToIni(ADestination: TCustomIniFile; const ABaseSection: string;
      ALinkIndex: Integer; AStoringKind: TdxBarStoringKind);

    procedure InitiateAction;

    function CanChangePaintStyle: Boolean;
    function HasItem(AItem: TdxBarItem): Boolean;
    function IsReferencedBy(ALinksOwner: IdxBarLinksOwner): Boolean;
    function IsAccel(Key: Word; Shift: TShiftState): Boolean;
    procedure MoveBeginGroupItemIfNeeded;
    function ScreenToClient(const AScreenPos: TPoint): TPoint;
    procedure UserGlyphChanged; virtual;
    procedure VisibleChanged;

    // IdxBarSelectableItem
    function CanDelete(ADestruction: Boolean = False): Boolean;
    procedure DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean);
    procedure ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction);
    function GetBarManager: TdxBarManager;
    function GetInstance: TPersistent;
    procedure GetMasterObjects(AList: TdxObjectList);
    function GetNextSelectableItem: IdxBarSelectableItem;
    function GetSelectableParent: TPersistent;
    function GetSelectionStatus: TdxBarSelectionStatus;
    function GetSupportedActions: TdxBarCustomizationActions;
    procedure Invalidate;
    function IsComplex: Boolean;
    function IsComponentSelected: Boolean;
    procedure SelectComponent(ASelectionOperation: TdxBarSelectionOperation = soExclusive);
    function SelectParentComponent: Boolean;
    procedure SelectionChanged;

    property IsMarkedForDeletion: Boolean read FIsMarkedForDeletion;
    property RowHeight: Integer read FRowHeight write FRowHeight;
  public
    constructor Create(Collection: TCollection); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    procedure BringToTopInRecentList(IncCount: Boolean);
    procedure CreateControl;
    procedure DestroyControl;
    procedure RecreateControl;
    procedure SendToBottomInRecentList;

    property AvailableIndex: Integer read GetAvailableIndex;
    property BarControl: TCustomdxBarControl read GetBarControl;
    property BarManager: TdxBarManager read GetBarManager;
    property CanVisibleIndex: Integer read GetCanVisibleIndex;
    property Caption: string read GetCaption;
    property Collection: TdxBarItemLinks read GetCollection write SetCollection;
    property Control: TdxBarItemControl read FControl;
    property Data: Integer read FData write FData default 0;
    property Glyph: TBitmap read GetGlyph;
    property ItemRect: TRect read FItemRect write SetItemRect;
    property OriginalItemLink: TdxBarItemLink read FOriginalItemLink;
    property Owner: TdxBarItemLinks read GetOwnerValue;
    property PaintStyle: TdxBarPaintStyle read GetPaintStyle;
    property RealItemLink: TdxBarItemLink read GetRealItemLink;
    property VisibleIndex: Integer read GetVisibleIndex;
    property Width: Integer read GetWidth;
  published
    property BeginGroup: Boolean read GetBeginGroup write SetBeginGroup default False;
    property ButtonGroup: TdxBarButtonGroupPosition read FButtonGroup
      write SetButtonGroup default bgpNone;
    property Distributed: Boolean read FDistributed write SetDistributed default True;
    property Item: TdxBarItem read GetItem write SetItem stored False;
    property MostRecentlyUsed: Boolean read FMostRecentlyUsed
      write SetMostRecentlyUsed default True;
    property Position: TdxBarItemPosition read FPosition write SetPosition default dxBarItemDefaultPosition;
    property UserCaption: string read FUserCaption write SetUserCaption;
    property UserDefine: TdxBarUserDefines read GetUserDefine write SetUserDefine default [];
    property UserGlyph: TBitmap read FUserGlyph write SetUserGlyph;
    property UserPaintStyle: TdxBarPaintStyle read FUserPaintStyle
      write SetUserPaintStyle default psStandard;
    property UserWidth: Integer read FUserWidth write SetUserWidth default 0;
    property ViewLevels: TdxBarItemViewLevels read FViewLevels
      write SetViewLevels default dxBarItemAllViewLevels;
    property Visible: Boolean read FVisible write SetVisible;
  end;

  TdxBarIterationProc = procedure(Index: Integer; ItemLink: TdxBarItemLink;
    var Stop: Boolean; var Data: Pointer) of object;

  TdxBarItemLinks = class(TCollection)
  private
    FAssigning: Boolean;
    FAvailableItems, FCanVisibleItems, FVisibleItems: TList;
    FBarControl: TCustomdxBarControl;
    FBarManager: TdxBarManager;
    FInternal: Boolean;
    FItemOptions: TdxBarItemOptions;
    FPrimaryForDistributionItems: TList;
    FLinksOwner: IdxBarLinksOwner;
    FPrevRecentItemCount: Integer;
    FRecentItems: TList;
    FRecentItemCount: Integer;
    FUseRecentItems: Boolean;
    FOnChange: TNotifyEvent;

    procedure DesignerModified;

    function GetAvailableItem(Index: Integer): TdxBarItemLink;
    function GetAvailableItemCount: Integer;
    function GetCanVisibleItem(Index: Integer): TdxBarItemLink;
    function GetCanVisibleItemCount: Integer;
    function GetIndexByItemName(const AItemName: string): Integer;
    function GetItem(Index: Integer): TdxBarItemLink;
    function GetMostRecentItemCount: Integer;
    function GetParentLinks: TdxBarItemLinks;
    function GetRealVisibleItemCount: Integer;
    function GetItemShowDescriptions: Boolean;
    function GetItemShowShortCuts: Boolean;
    function GetItemSize: TdxBarMenuItemSize;
    function GetVisibleItem(Index: Integer): TdxBarItemLink;
    function GetVisibleItemCount: Integer;
    procedure SetItem(Index: Integer; Value: TdxBarItemLink);
    procedure SetItemOptions(AValue: TdxBarItemOptions);
    procedure SetRecentItemCount(Value: Integer);

    function IsUpdateLocked: Boolean;
    procedure RefreshVisibilityLists;
    property MostRecentItemCount: Integer read GetMostRecentItemCount;
    procedure RestoreRecentItemCount;
    property RecentItemCount: Integer read FRecentItemCount write SetRecentItemCount;

    procedure Loaded(CheckVisible: Boolean);
    procedure CheckVisibleIntegrity;

    property ParentLinks: TdxBarItemLinks read GetParentLinks;
  protected
    procedure EmptyItemRects;

    function CanUseRecentItems: Boolean;
    procedure InitiateActions;
    function IsShortCut(AShortCut: TShortCut): Boolean;
    function IsScrollable: Boolean; virtual;

    function DoFindItemWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink; virtual; abstract;
    function FindItemWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink;
    function First: TdxBarItemLink;
    function Last: TdxBarItemLink;
    function Next(Current: TdxBarItemLink; AAnyone: Boolean = False): TdxBarItemLink;
    function Prev(Current: TdxBarItemLink; AAnyone: Boolean = False): TdxBarItemLink;

    procedure CheckLinks(ASource: TCustomIniFile; const ABaseSection: string);
    procedure LoadFromIni(ASource: TCustomIniFile; const ASection: string; AStoringKind: TdxBarStoringKind);
    procedure LoadUsageData(ASource: TCustomIniFile; ASection: string);
    procedure SaveToIni(ADestination: TCustomIniFile; const ASection: string; AStoringKind: TdxBarStoringKind);

    procedure Merge(AItemLinks: TdxBarItemLinks);
    procedure Unmerge(ABar: TdxBar);

    function AddItem(AItemClass: TdxBarItemClass; AOwner: TComponent): TdxBarItemLink; overload;

    function GetOwner: TPersistent; override;
    function GetOwnerComponent: TComponent;
    procedure LoadItemNames;
    procedure Update(Item: TCollectionItem); override;

    property Internal: Boolean read FInternal write FInternal;
    property RealVisibleItemCount: Integer read GetRealVisibleItemCount;

    function GetDefaultValue(AOption: TdxBarItemOptionValue): Variant; virtual;
    function GetOptionsValue(AOption: TdxBarItemOptionValue; AItemLinks: TdxBarItemLinks): Variant; virtual;
    property ItemShowDescriptions: Boolean read GetItemShowDescriptions;
    property ItemShowShortCuts: Boolean read GetItemShowShortCuts;
    property ItemSize: TdxBarMenuItemSize read GetItemSize;
    property LinksOwner: IdxBarLinksOwner read FLinksOwner;
  public
    constructor Create(ABarManager: TdxBarManager; ALinksOwner: IdxBarLinksOwner);
    destructor Destroy; override;
    function Add: TdxBarItemLink; overload;
    function Add(AItem: TdxBarItem): TdxBarItemLink; overload;
    function AddItem(AItemClass: TdxBarItemClass): TdxBarItemLink; overload;
    function AddButton: TdxBarItemLink;
    function AddSubItem: TdxBarItemLink;
    procedure Assign(Source: TPersistent); override;
    function AvailableIndexOf(Value: TdxBarItemLink): Integer;
    function CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean; virtual;
    function CanVisibleIndexOf(Value: TdxBarItemLink): Integer;
    procedure CreateBarControl;
    procedure DestroyBarControl;
    procedure FreeForeignItems(ForeignBarManager: TdxBarManager);
    function HasItem(AItem: TdxBarItem): Boolean;
    function IsControlExists(AItem: TdxBarItemControl): Boolean;
    function IsReferencedBy(ALinksOwner: IdxBarLinksOwner): Boolean;
    function IndexOf(Value: TdxBarItemLink): Integer;
    function Insert(AIndex: Integer): TdxBarItemLink;
    function VisibleIndexOf(Value: TdxBarItemLink): Integer;
    procedure Move(ACurIndex, ANewIndex: Integer);

    property AvailableItems[Index: Integer]: TdxBarItemLink read GetAvailableItem;
    property AvailableItemCount: Integer read GetAvailableItemCount;
    property BarControl: TCustomdxBarControl read FBarControl write FBarControl;
    property BarManager: TdxBarManager read FBarManager;
    property CanVisibleItems[Index: Integer]: TdxBarItemLink read GetCanVisibleItem;
    property CanVisibleItemCount: Integer read GetCanVisibleItemCount;
    property Items[Index: Integer]: TdxBarItemLink read GetItem write SetItem; default;
    property ItemOptions: TdxBarItemOptions read FItemOptions write SetItemOptions;
    property VisibleItems[Index: Integer]: TdxBarItemLink read GetVisibleItem;
    property VisibleItemCount: Integer read GetVisibleItemCount;

  {$WARNINGS OFF}
    property Owner: TComponent read GetOwnerComponent;  // TdxBar, TdxBarCustomPopupMenu, TCustomdxBarSubItem, nil
  {$WARNINGS ON}

    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TdxBarControlItemLinks = class(TdxBarItemLinks)
  protected
    function DoFindItemWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink; override;
  end;

  TdxBarSubMenuControlItemLinks = class(TdxBarItemLinks)
  protected
    function DoFindItemWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink; override;
    function IsScrollable: Boolean; override;
  end;

  TdxBarPaintSubMenuBarEvent = procedure(Sender: TObject;
    Canvas: TCanvas; const R: TRect) of object;

  TdxBarCustomPopupMenu = class(TdxBarComponent, IcxPopupMenu, IdxBarLinksOwner, IdxBarSubMenuOwner)
  private
    FBackgroundBitmap: TBitmap;
    FBarSize: Integer;
    FEditFont: TFont;
    FFont: TFont;
    FInternalFontChange: Boolean;
    FItemLinks: TdxBarItemLinks;
    FOwnerBounds: PRect;
    FOwnerItemControl: TdxBarItemControl;
    FOwnerControl: TWinControl;
    FOwnerWidth, FOwnerHeight: Integer;
    FPopupMenuVisible: Boolean;
    FShowAnimation: Boolean;
    FUseOwnFont: Boolean;
    FUseOwnMessageLoop: Boolean;
    FOnCloseUp: TNotifyEvent;
    FOnPaintBar: TdxBarPaintSubMenuBarEvent;
    FOnPopup: TNotifyEvent;

    function GetItemOptions: TdxBarItemOptions;
    function GetSubMenuControl: TdxBarSubMenuControl;
    function GetUseRecentItems: Boolean;
    procedure SetBackgroundBitmap(Value: TBitmap);
    procedure SetBarManager(Value: TdxBarManager);
    procedure SetBarSize(Value: Integer);
    procedure SetFont(Value: TFont);
    procedure SetItemLinks(Value: TdxBarItemLinks);
    procedure SetItemOptions(Value: TdxBarItemOptions);
    procedure SetUseOwnFont(Value: Boolean);
    procedure SetUseRecentItems(Value: Boolean);

    procedure FontChanged(Sender: TObject);
    procedure SubMenuCloseUp(Sender: TObject);
    procedure SubMenuPopup(Sender: TObject);
    procedure OwnerDesignerModified;
  protected
    function GetEnabled: Boolean; override;
    procedure SetEnabled(Value: Boolean); override;
    procedure SetVisible(Value: TdxBarItemVisible); override;

    procedure DoCloseUp;
    procedure DoPopup;
    function GetControlClass: TCustomdxBarControlClass; virtual;
    function GetItemLinksClass: TdxBarItemLinksClass; virtual;
    function IsShortCut(AShortCut: TShortCut): Boolean; virtual;
    function IsShortCutKey(var Message: TWMKey): Boolean;
    procedure Loaded; override;

    // IdxBarLinksOwner
    function CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
    function CreateBarControl: TCustomdxBarControl; virtual;
    function IdxBarLinksOwner.GetInstance = GetComponentInstance;
    function GetItemLinks: TdxBarItemLinks;

    // IdxBarSubMenuOwner
    function GetBarSize: Integer;
    procedure DoPaintBar(Canvas: TCanvas; const R: TRect); virtual;

    property ItemOptions: TdxBarItemOptions read GetItemOptions write SetItemOptions;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Popup(X, Y: Integer);
    procedure PopupEx(X, Y, AOwnerWidth, AOwnerHeight: Integer;
      AShowAnimation: Boolean; AOwnerBounds: PRect; AUseOwnMessageLoop: Boolean = True;
      AOwnerControl: TWinControl = nil);
    procedure PopupFromCursorPos;

    property BackgroundBitmap: TBitmap read FBackgroundBitmap write SetBackgroundBitmap;
    property BarManager: TdxBarManager read GetBarManager write SetBarManager;
    property BarSize: Integer read GetBarSize write SetBarSize default 0;
    property Font: TFont read FFont write SetFont stored FUseOwnFont;
    property ItemLinks: TdxBarItemLinks read GetItemLinks write SetItemLinks;
    property SubMenuControl: TdxBarSubMenuControl read GetSubMenuControl;
    property UseOwnFont: Boolean read FUseOwnFont write SetUseOwnFont;
    property UseRecentItems: Boolean read GetUseRecentItems write SetUseRecentItems default False;
    property Visible: Boolean read FPopupMenuVisible;

    property OnCloseUp: TNotifyEvent read FOnCloseUp write FOnCloseUp;
    property OnPaintBar: TdxBarPaintSubMenuBarEvent read FOnPaintBar write FOnPaintBar;
    property OnPopup: TNotifyEvent read FOnPopup write FOnPopup;
  end;

  TdxBarPopupMenu = class(TdxBarCustomPopupMenu)
  published
    property BackgroundBitmap;
    property BarManager;
    property BarSize;
    property Font;
    property ItemLinks;
    property ItemOptions;
    property UseOwnFont;
    property UseRecentItems;

    property OnCloseUp;
    property OnPaintBar;
    property OnPopup;
  end;

  { TdxBarCustomApplicationMenu }

  TdxBarExtraPaneNotifyEvent = procedure(Sender: TObject; AIndex: Integer) of object;
  TdxBarExtraPaneGetDisplayTextEvent = procedure(Sender: TObject; AIndex: Integer; var ADisplayText: string) of object;

  TdxBarExtraPaneItem = class(TCollectionItem)
  private
    FData: Integer;
    FDisplayText: string;
    FImageIndex: Integer;
    FText: string;
    procedure SetDisplayText(const Value: string);
    procedure SetText(const Value: string);
  public
    constructor Create(Collection: TCollection); override;
    procedure Assign(Source: TPersistent); override;

    property Data: Integer read FData write FData;
  published
    property ImageIndex: Integer read FImageIndex write FImageIndex default -1;
    property DisplayText: string read FDisplayText write SetDisplayText;
    property Text: string read FText write SetText;
  end;

  TdxBarExtraPaneItems = class(TCollection)
  private
    FApplicationMenu: TdxBarCustomApplicationMenu;

    function GetItem(Index: Integer): TdxBarExtraPaneItem;
    procedure SetItem(Index: Integer; Value: TdxBarExtraPaneItem);
  protected
    function GetOwner: TPersistent; override;
  public
    constructor Create(AApplicationMenu: TdxBarCustomApplicationMenu);
    function Add: TdxBarExtraPaneItem;
    function IndexOf(const AItemText: string): Integer;
    function Insert(AIndex: Integer): TdxBarExtraPaneItem;

    property Items[Index: Integer]: TdxBarExtraPaneItem read GetItem write SetItem; default;
  end;

  TdxBarApplicationMenuExtraPane = class(TPersistent)
  private
    FApplicationMenu: TdxBarCustomApplicationMenu;
    FSize: Integer;
    FWidthRatio: Double;
    FItems: TdxBarExtraPaneItems;
    FListItem: TdxBarExtraPaneListItem;
    FOnItemClick: TdxBarExtraPaneNotifyEvent;
    FOnGetItemDisplayText: TdxBarExtraPaneGetDisplayTextEvent;

    function IsHeaderStored: Boolean;
    function IsWidthRatioStored: Boolean;
    function GetHeader: string;
    function GetListItem: TdxBarExtraPaneListItem;
    procedure SetItems(AValue: TdxBarExtraPaneItems);
    procedure SetHeader(AValue: string);
    procedure SetSize(AValue: Integer);
    procedure SetWidthRatio(AValue: Double);

    procedure ItemClick(Sender: TObject);
    procedure GetItemDisplayText(Sender: TObject; AIndex: Integer; var ADisplayText: string);

    property ListItem: TdxBarExtraPaneListItem read GetListItem;
  protected
    function GetOwner: TPersistent; override;
  public
    constructor Create(AnApplicationMenu: TdxBarCustomApplicationMenu);
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
  published
    property WidthRatio: Double read FWidthRatio write SetWidthRatio stored IsWidthRatioStored;
    property Size: Integer read FSize write SetSize default 0;
    property Items: TdxBarExtraPaneItems read FItems write SetItems;
    property Header: string read GetHeader write SetHeader stored IsHeaderStored;

    property OnItemClick: TdxBarExtraPaneNotifyEvent read FOnItemClick write FOnItemClick;
    property OnGetItemDisplayText: TdxBarExtraPaneGetDisplayTextEvent read FOnGetItemDisplayText write FOnGetItemDisplayText;
  end;

  TdxBarApplicationMenuButtons = class;

  TdxBarApplicationMenuButton = class(TCollectionItem)
  private
    FInternalItem: TdxBarApplicationMenuButtonItem;
    FExternalItem: TdxBarButton;
    FNotifyList: TdxBarComponentList;

    function GetCollection: TdxBarApplicationMenuButtons;
    function GetWidth: Integer;
    procedure SetItem(Value: TdxBarButton);
    procedure SetWidth(Value: Integer);
    procedure ButtonClick(Sender: TObject);

    procedure ExternalItemChanged(Sender: TObject; AComponent: TComponent; AAction: TcxComponentCollectionNotification);
    procedure UpdateInternalItem;
  protected
    property InternalItem: TdxBarApplicationMenuButtonItem read FInternalItem;
  public
    constructor Create(Collection: TCollection); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;

    property Collection: TdxBarApplicationMenuButtons read GetCollection;
  published
    property Item: TdxBarButton read FExternalItem write SetItem;
    property Width: Integer read GetWidth write SetWidth default 0;
  end;

  TdxBarApplicationMenuButtons = class(TCollection)
  private
    FApplicationMenu: TdxBarCustomApplicationMenu;

    function GetItem(Index: Integer): TdxBarApplicationMenuButton;
    procedure SetItem(Index: Integer; Value: TdxBarApplicationMenuButton);
    procedure PopulateItemLinks(AItemLinks: TdxBarItemLinks);
  protected
    function GetOwner: TPersistent; override;
  public
    constructor Create(AApplicationMenu: TdxBarCustomApplicationMenu);
    function Add: TdxBarApplicationMenuButton;
    function Insert(AIndex: Integer): TdxBarApplicationMenuButton;

    property Items[Index: Integer]: TdxBarApplicationMenuButton read GetItem write SetItem; default;
  end;

  TdxBarApplicationMenuButtonItemLinks = class(TdxBarSubMenuControlItemLinks)
  protected
    procedure CalcItemsRects(ARect: TRect);
    function IsScrollable: Boolean; override;
  end;

  TdxBarCustomApplicationMenu = class(TdxBarCustomPopupMenu)
  private
    FButtons: TdxBarApplicationMenuButtons;
    FExtraPane: TdxBarApplicationMenuExtraPane;
    FExtraPaneEvents: TNotifyEvent;

    // ExtraPane
    function GetExtraPaneWidthRatio: Double;
    function GetExtraPaneSize: Integer;
    function GetExtraPaneItems: TdxBarExtraPaneItems;
    function GetExtraPaneHeader: string;
    function GetOnExtraPaneItemClick: TdxBarExtraPaneNotifyEvent;
    procedure SetExtraPaneWidthRatio(AValue: Double);
    procedure SetExtraPaneSize(AValue: Integer);
    procedure SetExtraPaneItems(AValue: TdxBarExtraPaneItems);
    procedure SetExtraPaneHeader(AValue: string);
    procedure SetOnExtraPaneItemClick(AValue: TdxBarExtraPaneNotifyEvent);

    procedure SetButtons(AValue: TdxBarApplicationMenuButtons);
    procedure SetExtraPane(AValue: TdxBarApplicationMenuExtraPane);
  protected
    function GetControlClass: TCustomdxBarControlClass; override;
    function GetItemLinksClass: TdxBarItemLinksClass; override;
    function IsShortCut(AShortCut: TShortCut): Boolean; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    property Buttons: TdxBarApplicationMenuButtons read FButtons write SetButtons;
    property ExtraPane: TdxBarApplicationMenuExtraPane read FExtraPane write SetExtraPane;
    property ExtraPaneEvents: TNotifyEvent read FExtraPaneEvents write FExtraPaneEvents;

    // obsolete
    property ExtraPaneWidthRatio: Double read GetExtraPaneWidthRatio write SetExtraPaneWidthRatio;
    property ExtraPaneSize: Integer read GetExtraPaneSize write SetExtraPaneSize;
    property ExtraPaneItems: TdxBarExtraPaneItems read GetExtraPaneItems write SetExtraPaneItems;
    property ExtraPaneHeader: string read GetExtraPaneHeader write SetExtraPaneHeader;
    property OnExtraPaneItemClick: TdxBarExtraPaneNotifyEvent read GetOnExtraPaneItemClick write SetOnExtraPaneItemClick;
  end;

  {-----------------------
      Visual components
   -----------------------}

  { dock controls }

  TdxDockControl = class(TCustomControl)
  private
    FAllowDocking: Boolean;
    FBackgroundBitmap: TBitmap;
    FBackgroundTempBitmap: TBitmap;
    FBarManager: TdxBarManager;
    FDockingStyle: TdxBarDockingStyle;
    FIAccessibilityHelper: IdxBarAccessibilityHelper;
    FIsBarHandleDestroying: Boolean;
    FRowList: TList;
    FRowMarginSize: Integer;

    procedure BitmapChanged(Sender: TObject);
    function GetBars: TdxBars;
    function GetDockingStyle: TdxBarDockingStyle;
    function GetHorizontal: Boolean;
    function GetIAccessibilityHelper: IdxBarAccessibilityHelper;
    function GetIsDesigning: Boolean;
    function GetIsLoading: Boolean;
    function GetMain: Boolean;
    function GetRow(Index: Integer): TdxDockRow;
    function GetRowCount: Integer;
    function GetTopLeft: Boolean;
    function GetVertical: Boolean;
    procedure SetBarManager(Value: TdxBarManager);
    procedure SetBackgroundBitmap(Value: TBitmap);
    procedure WMDestroy(var Message: TMessage); message WM_DESTROY;
    procedure WMEraseBkgnd(var Message: TWMEraseBkgnd); message WM_ERASEBKGND;
    procedure WMGetObject(var Message: TMessage); message WM_GETOBJECT;
    procedure WMLButtonDblClk(var Message: TWMLButtonDblClk); message WM_LBUTTONDBLCLK;
    procedure WMMouseActivate(var Message: TWMMouseActivate); message WM_MOUSEACTIVATE;
    procedure WMNCCalcSize(var Message: TWMNCCalcSize); message WM_NCCALCSIZE;
    procedure WMNCPaint(var Message: TWMNCPaint); message WM_NCPAINT;
    procedure WMRButtonDown(var Message: TWMRButtonDown); message WM_RBUTTONDOWN;
    procedure WMSize(var Message: TWMSize); message WM_SIZE;
    procedure WMWindowPosChanged(var Message: TWMWindowPosChanged); message WM_WINDOWPOSCHANGED;
    procedure CMSysColorChange(var Message: TMessage); message CM_SYSCOLORCHANGE;
  protected
    procedure AlignControls(AControl: TControl; var Rect: TRect); override;
    procedure CreateParams(var Params: TCreateParams); override;
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
    procedure RequestAlign; override;

    procedure AddBarControl(ABarControl: TdxBarControl; APos: TPoint; Update: Boolean);
    procedure DeleteBarControl(ABarControl: TdxBarControl; ADockCol: TObject; Update: Boolean);
    procedure MoveBarControl(ABarControl: TdxBarControl; APos: TPoint);

    procedure AssignPositions;
    procedure BarManagerChanged; virtual;
    procedure CalcLayout; virtual;
    procedure CalcRowToolbarPositions(ARowIndex: Integer; AClientSize: Integer); virtual;
    function CanDocking(Bar: TdxBar): Boolean; virtual;
    procedure ColorChanged; virtual;
    function GetDockZoneBounds: TRect;
    procedure GetDockZoneMargins(Row, ZoneNumber: Integer; var M1, M2: Integer);
    function GetRectForRow(ARow: Integer): TRect;
    function GetClientSize: Integer; virtual;
    function GetSize: Integer;
    function GetRowAtPos(APos: TPoint; var Insert: Boolean): Integer;
    function GetColAtPos(ARow: Integer; APos: TPoint): Integer;
    procedure GetPosForRow(Row: Integer; OneOnRow: Boolean; var P: TPoint);
    function GetSunkenBorder: Boolean; virtual;
    function GetMainForm: TCustomForm;
    function GetMasterForm: TCustomForm;
    function GetParentForm: TCustomForm;
    function IsMultiRow: Boolean; virtual;
    procedure NCChanged;
    procedure PaintBarControls;
    procedure SetSize; virtual;
    procedure ShowCustomizePopup; virtual;
    procedure UpdateDock;

    function GetDockedBarControlClass: TdxBarControlClass; virtual;
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; virtual;
    function GetPainter: TdxBarPainter; virtual;

    procedure FillBackground(DC: HDC; const ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor); virtual;
    function IsBackgroundBitmap: Boolean; virtual;
    function IsDrawDesignBorder: Boolean; virtual;
    function IsTransparent: Boolean; virtual;
    procedure RepaintBarControls; virtual;
    procedure ResetBackground; virtual;
    procedure UpdateDoubleBuffered; virtual;
    property BackgroundTempBitmap: TBitmap read FBackgroundTempBitmap;

    property AllowDocking: Boolean read FAllowDocking write FAllowDocking default True;
    property BackgroundBitmap: TBitmap read FBackgroundBitmap write SetBackgroundBitmap;
    property Horizontal: Boolean read GetHorizontal;
    property IsBarHandleDestroying: Boolean read FIsBarHandleDestroying write FIsBarHandleDestroying;
    property IsDesigning: Boolean read GetIsDesigning;
    property IsLoading: Boolean read GetIsLoading;
    property Main: Boolean read GetMain;
    property MainForm: TCustomForm read GetMainForm;
    property MasterForm: TCustomForm read GetMasterForm;
    property Painter: TdxBarPainter read GetPainter;
    property ParentForm: TCustomForm read GetParentForm;
    property RowMarginSize: Integer read FRowMarginSize write FRowMarginSize;
    property SunkenBorder: Boolean read GetSunkenBorder;
    property TopLeft: Boolean read GetTopLeft;
    property Vertical: Boolean read GetVertical;
  public
    constructor Create(AOwner: TComponent); override;
    constructor CreateEx(AOwner: TComponent; ABarManager: TdxBarManager;
      ADockStyle: TdxBarDockingStyle);
    destructor Destroy; override;

    procedure InitiateAction; override;

    property BarManager: TdxBarManager read FBarManager write SetBarManager;
    property Bars: TdxBars read GetBars;
    property DockingStyle: TdxBarDockingStyle read GetDockingStyle;
    property IAccessibilityHelper: IdxBarAccessibilityHelper read GetIAccessibilityHelper;
    property RowCount: Integer read GetRowCount;
    property RowList: TList read FRowList;
    property Rows[Index: Integer]: TdxDockRow read GetRow;
  end;

  TdxBarDockAlign = (dalNone, dalTop, dalBottom, dalLeft, dalRight);

  TdxBarDockControl = class(TdxDockControl)
  private
    FAllowZeroSizeInDesignTime: Boolean;
    FSunkenBorder: Boolean;
    FUseOwnColor: Boolean;
    FUseOwnSunkenBorder: Boolean;
    function GetAlign: TdxBarDockAlign;
    function GetColor: TColor;
    function GetIsLoading: Boolean;
    function GetParentColor: Boolean;
    procedure SetAlign(Value: TdxBarDockAlign);
    procedure SetAllowZeroSizeInDesignTime(Value: Boolean);
    procedure SetColor(Value: TColor);
    procedure SetParentColor(Value: Boolean);
    procedure SetSunkenBorder(Value: Boolean);
    procedure SetUseOwnColor(Value: Boolean);
    procedure SetUseOwnSunkenBorder(Value: Boolean);
    function IsColorStored: Boolean;
    procedure WMCreate(var Message: TWMCreate); message WM_CREATE;
    procedure WMSize(var Message: TWMSize); message WM_SIZE;
  protected
    function AllowUndockWhenLoadFromIni: Boolean; virtual;
    procedure CreateParams(var Params: TCreateParams); override;
    procedure Paint; override;
    procedure BarManagerChanged; override;
    function CanDocking(Bar: TdxBar): Boolean; override;
    procedure ColorChanged; override;
    function GetClientSize: Integer; override;
    function GetMinSize: Integer;
    function GetSunkenBorder: Boolean; override;
    property IsLoading: Boolean read GetIsLoading;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property Align: TdxBarDockAlign read GetAlign write SetAlign;
    property AllowDocking;
    property AllowZeroSizeInDesignTime: Boolean read FAllowZeroSizeInDesignTime
      write SetAllowZeroSizeInDesignTime default False;
    property Anchors;
    property BarManager;
    property Color read GetColor write SetColor stored IsColorStored;
    property ParentColor: Boolean read GetParentColor write SetParentColor
      stored IsColorStored;
    property SunkenBorder: Boolean read GetSunkenBorder write SetSunkenBorder
      stored FUseOwnSunkenBorder;
    property UseOwnColor: Boolean read FUseOwnColor write SetUseOwnColor default False;
    property UseOwnSunkenBorder: Boolean read FUseOwnSunkenBorder
      write SetUseOwnSunkenBorder default False;
    property Visible;
    property BackgroundBitmap;

    property OnClick;
    property OnDblClick;
    property OnMouseDown;
    property OnMouseMove;
    property OnMouseUp;
    property OnResize;
  end;

  { TdxBarExtraPaneDockControl }

  TdxBarExtraPaneDockControl = class(TdxBarDockControl)
  protected
    procedure CalcRowToolbarPositions(ARowIndex: Integer; AClientSize: Integer); override;
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; override;
    function GetDockedBarControlClass: TdxBarControlClass; override;
  public
    constructor Create(AOwner: TComponent); override;
  end;

  { shadow support }

  TdxBarShadowCorner = (scLeft, scRight, scTop);
  TdxBarShadowCorners = set of TdxBarShadowCorner;

  TdxBarShadowPartKind = (spHorizontal, spVertical);

  TdxBarShadowPart = class(TCustomControl)
  private
    FCorners: TdxBarShadowCorners;
    FImage: TBitmap;
    FKind: TdxBarShadowPartKind;
    FOwner: TdxBarShadow;
    function GetControl: TWinControl;
    function GetShadowSize: Integer;
    function GetTransparent: Boolean;
    procedure WMNCHitTest(var Message: TWMNCHitTest); message WM_NCHITTEST;
  protected
    function CanShow: Boolean;
    procedure CreateParams(var Params: TCreateParams); override;
    procedure Paint; override;
    procedure UpdateImage;
    property Control: TWinControl read GetControl;
    property Image: TBitmap read FImage;
    property Owner: TdxBarShadow read FOwner;
    property ShadowSize: Integer read GetShadowSize;
    property Transparent: Boolean read GetTransparent;
  public
    constructor CreateEx(AOwner: TdxBarShadow;
      AKind: TdxBarShadowPartKind; ACorners: TdxBarShadowCorners);
    destructor Destroy; override;
    procedure Hide;
    procedure Show;
    procedure UpdateBounds(const ABounds: TRect);
    property Corners: TdxBarShadowCorners read FCorners;
    property Kind: TdxBarShadowPartKind read FKind;
  end;

  TdxBarShadow = class
  private
    FHorizontal: Boolean;
    FOwner: TWinControl;
    FParts: array[0..4] of TdxBarShadowPart;
    FVisible: Boolean;
    function GetShadowSize: Integer;
    function GetTransparent: Boolean;
    procedure SetVisible(Value: Boolean);
  protected
    R1, R2: TRect;
    procedure CreateParts;
    procedure DestroyParts;
    procedure Hide;
    procedure Show;
    property Transparent: Boolean read GetTransparent;
  public
    constructor Create(AOwner: TWinControl);
    destructor Destroy; override;
    procedure Refresh;
    procedure SetOwnerBounds(AR1, AR2: TRect);
    property Horizontal: Boolean read FHorizontal;
    property Owner: TWinControl read FOwner;
    property ShadowSize: Integer read GetShadowSize;
    property Visible: Boolean read FVisible write SetVisible;
  end;

  { TCustomdxBarControl }

  TdxBarMarkState = (msNone, msSelected, msPressed);
  TdxBarItemControlParentKind = (pkBar, pkSubItemOrPopupMenu);
  TdxBarPaintType = (ptHorz, ptMenu, ptVert);
  TdxBarState = (bsCreatingControls, bsDestroyingControls, bsDestroyingWindow, bsHideAll, bsPaintItem, bsRepaintBar, bsUpdatingCanvasFont);
  TdxBarStates = set of TdxBarState;
  TdxBarViewState = (bvsNormal, bvsHot);

  TCustomdxBarControl = class(TCustomControl, IcxMouseTrackingCaller, IcxMouseTrackingCaller2)
  private
    FActiveCanvas: TcxCanvas;
    FBackgroundTempBitmap: TBitmap;
    FBkBrush: HBRUSH;
    FCanvas: TcxCanvas;
    FChildBar: TCustomdxBarControl;
    FClickedControl: TdxBarItemControl;
    FClosedByEscape: Boolean;
    FCurrentMessage: TMessage;
    FDockControl: TdxDockControl;
    FDockingStyle: TdxBarDockingStyle;
    FDragDown: Boolean;
    FDragPoint: TPoint;
    FExpandedItemLinks: TList;
    FIAccessibilityHelper: IdxBarAccessibilityHelper;
    FIgnoreMouseClick: Boolean;
    FIsActive: Boolean;
    FIsDowned: Boolean;
    FItemLinks: TdxBarItemLinks;
    FMovingChanging: Boolean;
    FOwnerBounds: TRect;
    FOwnerControl: TWinControl;
    FParentBar: TCustomdxBarControl;
    FPrevActiveBarControl: TCustomdxBarControl;

    FPrevTrackedLink: TdxBarItemLink; //#DG !!

//#DG    FSelectedItem: TdxBarItemControl; // obsolete
    FSelectedLink: TdxBarItemLink; // to replace obsolete SelectedItem
    FShadow: TdxBarShadow;

    FTextSize, FEditTextSize: Integer;
    FMarkSize: Integer;
    FMenuArrowHeight, FMenuArrowWidth: Integer;
    FComboBoxArrowWidth: Integer;
    FIconAreaSize: Integer;
    FRatio: Double;

    FOnDestroy: TNotifyEvent;

    procedure MouseDownNotifyControls(ALinkAtPos: TdxBarItemLink; const AMousePos: TPoint; Button: TMouseButton; Shift: TShiftState);
    procedure MouseNotifyControls(ALinkAtPos: TdxBarItemLink; const AMousePos: TPoint; Shift: TShiftState);
    procedure MouseUpNotifyControls(ALinkAtPos: TdxBarItemLink; const AMousePos: TPoint; Button: TMouseButton; Shift: TShiftState);

    function GetActiveCanvas: TcxCanvas;
    function GetBarControlOwnerBrush: HBRUSH;
    function GetBarManager: TdxBarManager;
    function GetCanvas: TcxCanvas;
    function GetFlat: Boolean;
    function GetIAccessibilityHelper: IdxBarAccessibilityHelper;
    function GetIsDestroying: Boolean;
    function GetOwnerLinkBounds(AOwnerPart: Boolean): TRect;
    function GetPainterClass: TdxBarPainterClass;
    function GetSelectedControlAtDesign: TdxBarItemControl;
    function GetSelectedControl: TdxBarItemControl;
    function ItemAtMousePos: TdxBarItemControl;
    procedure SetChildBar(Value: TCustomdxBarControl);
    procedure SetDockControl(Value: TdxDockControl);
    procedure SetIsActive(Value: Boolean);
    procedure SetParentBar(Value: TCustomdxBarControl);
    procedure SetViewState(Value: TdxBarViewState);

    procedure WMCaptureChanged(var Message: TMessage); message WM_CAPTURECHANGED;
    procedure WMDestroy(var Message: TMessage); message WM_DESTROY;
    procedure WMEraseBkgnd(var Message: TWMEraseBkgnd); message WM_ERASEBKGND;
    procedure WMKeyDown(var Message: TWMKeyDown); message WM_KEYDOWN;
    procedure WMLButtonDblClk(var Message: TWMLButtonDblClk); message WM_LBUTTONDBLCLK;
    procedure WMLButtonDown(var Message: TWMLButtonDown); message WM_LBUTTONDOWN;
    procedure WMLButtonUp(var Message: TWMLButtonUp); message WM_LBUTTONUP;
    procedure WMMouseActivate(var Message: TWMMouseActivate); message WM_MOUSEACTIVATE;
    procedure WMMouseMove(var Message: TWMMouseMove); message WM_MOUSEMOVE;
    procedure WMNCPaint(var Message: TMessage); message WM_NCPAINT;
    procedure WMPaint(var Message: TWMPaint); message WM_PAINT;
    procedure WMPrint(var Message: TMessage); message WM_PRINT;
    procedure WMPrintClient(var Message: TMessage); message WM_PRINTCLIENT;
    procedure WMRepaintBar(var Message: TMessage); message WM_REPAINTBAR;
    procedure WMSetCursor(var Message: TWMSetCursor); message WM_SETCURSOR;
    procedure WMSize(var Message: TWMSize); message WM_SIZE;
    procedure WMWindowPosChanged(var Message: TWMWindowPosChanged); message WM_WINDOWPOSCHANGED;
  protected
    FItemsRect: TRect;
    FLastMousePos: TPoint;
    FMarkState: TdxBarMarkState;
    FPainter: TdxBarPainter;
    FState: TdxBarStates;
    FViewInfo: TCustomdxBarControlViewInfo;
    FViewState: TdxBarViewState;
    FVisibleItemsRect: TRect;

    procedure AdjustSize; override;
    procedure AdjustHintWindowPosition(var APos: TPoint; const ABoundsRect: TRect; AHeight: Integer); virtual;
    procedure AfterControlEscape(AControl: TdxBarItemControl); virtual;
    procedure AfterMouseMove(Shift: TShiftState; X, Y: Integer); virtual;
    procedure CreateWindowHandle(const Params: TCreateParams); override;
    procedure CreateWnd; override;
    procedure DestroyWindowHandle; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
    procedure MouseLeave; dynamic; { IcxMouseTrackingCaller }
    procedure MouseMove(Shift: TShiftState; X, Y: Integer); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;
    function NeedsMouseWheel: Boolean; virtual;
    procedure ProcessMouseDownMessageForMeaningParent(AWnd: HWND; AMsg: UINT;
      const AMousePos: TPoint); virtual;
    function PtInCaller(const P: TPoint): Boolean; { IcxMouseTrackingCaller2 }
    procedure Resize; override;
    procedure WindowPosChanged(var Message: TWMWindowPosChanged); virtual;
    procedure WndProc(var Message: TMessage); override;

    function CalcChildBarBounds(out ARect: TRect): Boolean; virtual;
    procedure CalcControlsPositions; virtual;
    procedure CalcDragOverParameters(const ACursorPos: TPoint;
      var ADragOverItemLink: TdxBarItemLink;
      var AIsBeginGroup, AIsFirstPart, AIsVerticalDirection: Boolean); virtual;
    procedure CalcDrawingConsts; virtual;
    procedure CalcItemsRect; virtual;
    procedure CalcColumnItemRects(ATopIndex: Integer;
      out ALastItemBottom: Integer); virtual;
    procedure CalcRowItemRects; virtual;
    procedure CalcItemRects(APaintStyle: TdxBarPaintType; ATopIndex: Integer = 0); virtual;
    procedure CalcLayout; virtual;

    procedure BeforeDestroyHandle;
    procedure CreateControls; virtual;
    procedure DestroyControls; virtual;
    procedure ExpandContainerItems;
    procedure CollapseContainerItems;
    procedure LayoutChanged; virtual;
    procedure RecreateControls;
    procedure UpdateControlByMouse;

    // MessageHandler
    procedure DoKeyDown(var Message: TWMKey); virtual;

    function CanActiveChange: Boolean; virtual;
    function CanAlignControl(AControl: TdxBarItemControl): Boolean; virtual;
    function CanCallInheritedNCCalcSize: Boolean; virtual; // obsolete
    function CanControlPaint(AControl: TdxBarItemControl): Boolean; virtual;
    //function CanCallInheritedNCPaint: Boolean; virtual;
    function CanCustomizing: Boolean; virtual;
    function CanDeactivate(ABarManager: TdxBarManager; AActiveWindow: HWND): Boolean; virtual;
    function CanDrawClippedItem(AItemRect: TRect): Boolean; virtual;
    function CanHide: Boolean;
    function CanProcessMouseMessage: Boolean; virtual;
    function CanShowPopupMenuOnMouseClick(AMousePressed: Boolean): Boolean; virtual;
    function CanShowHint: Boolean; virtual;
    function CheckLockUpdate: Boolean; virtual;
    function ChildrenHaveShadows: Boolean; virtual;
    procedure CorrectVisibleItemsRectTop; virtual;
    procedure CorrectVisibleItemsRectBottom; virtual;
    procedure CustomizePrepare(APoint: TPoint; ASecondClick: Boolean); virtual;
    procedure DblClickOnItem(AItemControl: TdxBarItemControl); dynamic;
    procedure DoBarGetFocus(ASelectedItem: TdxBarItemControl); virtual;
    procedure DoBarLostFocus; virtual;
    procedure DoBarMouseEnter(Shift: TShiftState; const APoint: TPoint; AItemControl: TdxBarItemControl); virtual;
    procedure DoBarMouseDown(Button: TMouseButton; Shift: TShiftState;
      const APoint: TPoint; AItemControl: TdxBarItemControl; APointInClientRect: Boolean); virtual;
    procedure DoBarMouseLeave; virtual;
    procedure DoBarMouseMove(Shift: TShiftState; const APoint: TPoint; AItemControl: TdxBarItemControl); virtual;
    procedure DoBarMouseUp(Button: TMouseButton; Shift: TShiftState;
      const APoint: TPoint; AItemControl: TdxBarItemControl; APointInClientRect: Boolean); virtual;
    procedure DoCreateControls; virtual;
    procedure DoDestroy; virtual;
    procedure DoDestroyControls; virtual;
    procedure DoDropFocus; virtual;
    procedure DoHideAll; virtual;
    procedure DoPaintItem(AControl: TdxBarItemControl; ACanvas: TcxCanvas; const AItemRect: TRect); virtual;
    procedure DoRepaintBar(ARecreateControls: Boolean); virtual;
    procedure DoSetIsActive(AValue: Boolean); virtual;
    procedure DrawItems; virtual;
    procedure DrawSelectedItem(ADC: HDC; AControl: TdxBarItemControl; const AItemRect: TRect);
    procedure DragOver(X, Y: Integer; var Accept: Boolean); reintroduce; virtual;
    function DoFindLinkWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink; virtual;
    function FindLinkWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink; out ADuplicate: Boolean): TdxBarItemLink; virtual;
    procedure FocusItemControl(AItemControl: TdxBarItemControl); virtual;
    procedure FocusNextBarControl(AForward: Boolean);
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; virtual; abstract;
    function GetBackgroundBitmap: TBitmap; virtual; abstract;
    function GetBeginGroupSize: Integer; virtual; abstract;
    function GetBehaviorOptions: TdxBarBehaviorOptions; virtual;
    function GetClientOffset: TPoint;
    function GetDefaultItemHeight(AItem: TdxBarItemControl): Integer; virtual;
    function GetDefaultItemGlyph: TBitmap; virtual;
    function GetEditFont: TFont; virtual;
    function GetEditFontHandle: HFONT;
    function GetEquivalentParentBar: TCustomdxBarControl;
    function GetFader: TdxFader; virtual;
    function GetFullItemRect(Item: TdxBarItemControl): TRect; virtual;
    function GetIsCustomizing: Boolean; virtual;
    function GetIsFocused: Boolean;
    function GetIsMainMenu: Boolean; virtual; abstract;
    function GetIsShadowVisible: Boolean; virtual;
    function GetIsStatusBar: Boolean; virtual; abstract;
    function GetItemControlDefaultViewLevel(AItemControl: TdxBarItemControl): TdxBarItemViewLevel; virtual;
    function GetItemControlOffset(AItemLink: TdxBarItemLink): Integer; virtual;
    function GetItemRectEx(Item: TdxBarItemControl; IsBeginGroup: Boolean): TRect; virtual;
    function GetItemRegion(Item: TdxBarItemControl): HRGN; virtual;
    function GetItemScreenRect(Item: TdxBarItemControl): TRect;
    function GetMarkDrawState: TdxBarMarkState; virtual;
    function GetMarkSize: Integer; virtual;
    function GetNormalItemHeight: Integer; virtual;
    function GetOwnerControl: TWinControl; virtual;
    function GetPainter: TdxBarPainter; virtual;
    function GetPaintType: TdxBarPaintType; virtual;
    function GetSelectableObject: TPersistent; virtual;
    function GetSelectionOperation(AButton: TMouseButton; AShift: TShiftState;
      ASelectableItem: IdxBarSelectableItem): TdxBarSelectionOperation;
    function GetToolbarBrush: HBRUSH; virtual;
    function GetToolbarDownedBrush: HBRUSH; virtual;
    function GetToolbarDownedSelBrush: HBRUSH; virtual;
    function GetToolbarSelBrush: HBRUSH; virtual;
    function GetViewInfoClass: TCustomdxBarControlViewInfoClass; virtual; abstract;
    procedure RepaintBarEx(ARecreateControls: Boolean);
    procedure SetControlVisible(AControl: TdxBarItemControl); virtual;
    procedure SetItemLinks(Value: TdxBarItemLinks); virtual;

    function GetNCDrawingDC(AUpdatedRgn: HRGN): HDC; virtual;
    procedure ReleaseNCDrawingDC(ADC: HDC); virtual;

    function GetBorderSize: Integer; virtual;
    function GetIconAreaSize: Integer; virtual;
    function GetTextSize: Integer; virtual;

    function GetClientBounds: TRect;
    function GetMouseTrackingBounds: TRect; virtual;
    function GetNCRect: TRect;
    function GetWindowRect: TRect;
    function GetWindowPoint(const AClientPoint: TPoint): TPoint;

    function HasShadow: Boolean; virtual;
    procedure HideAllByEscape; virtual;
    function HideOnClick: Boolean; virtual;
    function IsChildBar(Value: TCustomdxBarControl): Boolean; virtual;
    function IsChildWindow(AWnd: HWND): Boolean;
    function IsControlExists(ABarItemControl: TdxBarItemControl): Boolean; virtual;
    function IsLinkedToOwner: Boolean; virtual;
    function IsMeaningParent(AWnd: HWND): Boolean; virtual;
    function IsPopup: Boolean; virtual;
    function IsVerticalDirection: Boolean; virtual;
    function IsWindowEnabled: Boolean; virtual;
    procedure MakeItemControlFullyVisible(AItemControl: TdxBarItemControl); virtual;

    function MarkExists: Boolean; virtual;
    function MarkRect: TRect; virtual;
    function MouseOnMark(const AMousePos: TPoint): Boolean; overload;
    function MouseOnMark: Boolean; overload;
    procedure SetMarkState(Value: TdxBarMarkState); virtual; abstract;

    procedure ActivateHint(AShow: Boolean; const ACustomHint: string; AHintObject: TObject = nil);
    function CreateHintViewInfo(const AHintText, AShortCut: string; AScreenTip: TdxBarScreenTip): TdxBarCustomHintViewInfo;
    function GetHintPosition(const AItemBounds: TRect; const ACursorPos: TPoint; AHeight: Integer): TPoint;

    function NeedShowGlyphAndCheckForItem: Boolean; virtual;
    function NotHandleMouseMove(ACheckLastMousePos: Boolean = True): Boolean; virtual;
    procedure PaintItem(ACanvas: TcxCanvas; AControl: TdxBarItemControl); virtual;
    procedure ResizeShadow;
    procedure SetCursorForMoving(AMoving: Boolean);
    procedure SetDockingStyle(Value: TdxBarDockingStyle); virtual;
    procedure SetFont; virtual; abstract;
    procedure SetLayeredAttributes; virtual;

    function SelectedItemWantsKey(Key: Word): Boolean;
    procedure SelectItemControl(AItemControl: TdxBarItemControl; AButton: TMouseButton; AShift: TShiftState); virtual;
    procedure SetAccelSelectedItem(AItemControl: TdxBarItemControl; ADuplicate: Boolean); virtual;
    procedure SetKeySelectedItem(Value: TdxBarItemControl); virtual;
    procedure SetMouseSelectedItem(Value: TdxBarItemControl); virtual;
    procedure SetSelectedControl(Value: TdxBarItemControl); virtual;

    procedure Show;
    procedure UpdateCanvasFont;
    procedure UpdateControlStyle;
    procedure UpdateItem(AControl: TdxBarItemControl); virtual; abstract;
    procedure ViewStateChanged(APrevValue: TdxBarViewState); virtual;
    function WantMouse: Boolean;

    procedure DoShowPopup(ASelectedControl: TdxBarItemControl);
    procedure InitCustomizationPopup(AItemLinks: TdxBarItemLinks); virtual;
    procedure ShowPopup(AItem: TdxBarItemControl); virtual;

    function AllowNCPaint: Boolean; virtual;
    procedure FillBackground(DC: HDC; const ARect: TRect; ABrush: HBRUSH; AColor: TColor;
      AIsClientArea: Boolean); virtual; abstract;
    procedure FillBackgroundRgn(DC: HDC; ARgn: HRGN; ABrush: HBRUSH; AIsClientArea: Boolean); virtual;
    procedure FullInvalidate;
    procedure FullRepaint;
    procedure InvalidateNCRect(ARect: TRect);
    function IsInternal: Boolean; virtual;
    function IsBackgroundBitmap: Boolean; virtual;
    function IsNeedBufferedOnGlass(AControl: TdxBarItemControl): Boolean;
    function IsTransparent: Boolean; virtual;
    function NCOffset: TPoint; virtual;
    procedure NCPaint(ADC: HDC); virtual;
    function PointBarToDock(const APoint: TPoint): TPoint;
    procedure ResetBackground; virtual;
    procedure UpdateDoubleBuffered; virtual;

    property BackgroundTempBitmap: TBitmap read FBackgroundTempBitmap;

    property ChildBar: TCustomdxBarControl read FChildBar write SetChildBar;
    property ClosedByEscape: Boolean read FClosedByEscape write FClosedByEscape;
    property DockControl: TdxDockControl read FDockControl write SetDockControl;
    property DockingStyle: TdxBarDockingStyle read FDockingStyle write SetDockingStyle;
    property Flat: Boolean read GetFlat; // TODO: obsolete
    property IgnoreMouseClick: Boolean read FIgnoreMouseClick write FIgnoreMouseClick;
    property IsDestroying: Boolean read GetIsDestroying;
    property IsDowned: Boolean read FIsDowned write FIsDowned;
    property IsMainMenu: Boolean read GetIsMainMenu;
    property IsStatusBar: Boolean read GetIsStatusBar;
    property IsShadowVisible: Boolean read GetIsShadowVisible;
    property MarkSize: Integer read FMarkSize;
    property MarkState: TdxBarMarkState read FMarkState write SetMarkState;
    property MarkDrawState: TdxBarMarkState read GetMarkDrawState;
    property SelectedControlAtDesign: TdxBarItemControl read GetSelectedControlAtDesign;
    property SelectedControl: TdxBarItemControl read GetSelectedControl write SetSelectedControl;
    property SelectedLink: TdxBarItemLink read FSelectedLink write FSelectedLink;
    property Shadow: TdxBarShadow read FShadow;
    property ViewState: TdxBarViewState read FViewState write SetViewState;

    property IconAreaSize: Integer read FIconAreaSize;
    property BeginGroupSize: Integer read GetBeginGroupSize;
    property OwnerBounds: TRect read FOwnerBounds write FOwnerBounds;
    property OwnerControl: TWinControl read GetOwnerControl write FOwnerControl;
    property OwnerLinkBounds[AOwnerPart: Boolean]: TRect read GetOwnerLinkBounds;
    property RealOwnerControl: TWinControl read FOwnerControl;

    property BarControlOwnerBrush: HBRUSH read GetBarControlOwnerBrush;
    property EditFont: TFont read GetEditFont;
    property Painter: TdxBarPainter read GetPainter;
    property PainterClass: TdxBarPainterClass read GetPainterClass;
    property ToolbarBrush: HBRUSH read GetToolbarBrush;
    property ToolbarDownedBrush: HBRUSH read GetToolbarDownedBrush;
    property ToolbarDownedSelBrush: HBRUSH read GetToolbarDownedSelBrush;
    property ToolbarSelBrush: HBRUSH read GetToolbarSelBrush;

    property ItemsRect: TRect read FItemsRect;
    property NCRect: TRect read GetNCRect;
    property VisibleItemsRect: TRect read FVisibleItemsRect;
    property WindowRect: TRect read GetWindowRect;

    property ActiveCanvas: TcxCanvas read GetActiveCanvas;
    property Ratio: Double read FRatio;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure BarGetFocus(ASelectedItem: TdxBarItemControl);
    procedure BarLostFocus;
    procedure BeforeDestruction; override;
    function GetItemRect(Item: TdxBarItemControl): TRect;
    procedure Hide; virtual; abstract;
    procedure HideAll; virtual;
    function IsOnGlass: Boolean; virtual;
    function IsRealVertical: Boolean; virtual;
    function IsVertical: Boolean; virtual;
    function ItemAtPos(const APos: TPoint): TdxBarItemControl;
    function Kind: TdxBarKind; virtual; abstract;
    procedure RepaintBar; virtual;

    property BarManager: TdxBarManager read GetBarManager;
    property BkBrush: HBRUSH read FBkBrush;
    property BehaviorOptions: TdxBarBehaviorOptions read GetBehaviorOptions;
    property Canvas: TcxCanvas read GetCanvas;
    property ClientBounds: TRect read GetClientBounds;
    property ComboBoxArrowWidth: Integer read FComboBoxArrowWidth;
    property EditFontHandle: HFONT read GetEditFontHandle;
    property EditTextSize: Integer read FEditTextSize;
    property Font;
    property IAccessibilityHelper: IdxBarAccessibilityHelper read GetIAccessibilityHelper;
    property IsActive: Boolean read FIsActive write SetIsActive;
    property IsCustomizing: Boolean read GetIsCustomizing;
    property IsFocused: Boolean read GetIsFocused;
    property ItemLinks: TdxBarItemLinks read FItemLinks write SetItemLinks;
    property MenuArrowHeight: Integer read FMenuArrowHeight;
    property MenuArrowWidth: Integer read FMenuArrowWidth;
    property ParentBar: TCustomdxBarControl read FParentBar write SetParentBar;
    property TextSize: Integer read FTextSize;
    property ViewInfo: TCustomdxBarControlViewInfo read FViewInfo;

    property OnDestroy: TNotifyEvent read FOnDestroy write FOnDestroy;
  end;

  { IdxFadingPainterHelper }

  IdxFadingPainterHelper = interface
  ['{B97FA518-6C2E-4219-9430-19546EF91A1F}']
    function BarMarkIsOpaque: Boolean;
    procedure DrawBarMarkState(ABarControl: TdxBarControl; DC: HDC; const R: TRect;
      AState: TdxBarMarkState);
    procedure DrawButtonBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams);
  end;

  { TCustomdxBarControlDesignHelper }

  TCustomdxBarControlDesignHelper = class
  public
    class procedure FilterItemActions(var ASupportedActions: TdxBarCustomizationActions); virtual;
    class procedure GetEditors(AEditors: TList); virtual;
    class function GetForbiddenActions: TdxBarCustomizationActions; virtual;
  end;

  TdxBarControlDesignHelper = class(TCustomdxBarControlDesignHelper)
  public
    class function GetForbiddenActions: TdxBarCustomizationActions; override;
  end;

  TdxBarSubMenuControlDesignHelper = class(TCustomdxBarControlDesignHelper)
  public
    class procedure GetEditors(AEditors: TList); override;
    class function GetForbiddenActions: TdxBarCustomizationActions; override;
  end;

  TdxDockCol = class
  private
    FBarControl: TdxBarControl;
    FDockRow: TdxDockRow;
    FPos: TPoint;
  public
    constructor Create(ADockRow: TdxDockRow; ABarControl: TdxBarControl);
    procedure AssignPosition;
    property BarControl: TdxBarControl read FBarControl;
    property DockRow: TdxDockRow read FDockRow;
    property Pos: TPoint read FPos write FPos;
  end;

  TdxDockRow = class
  protected
    FBars: TList;
    FColList: TList;
    FDockControl: TdxDockControl;
    procedure AddBar(ABar: TdxBar);
    procedure DeleteBar(ABar: TdxBar; ADestroyEmptyDockRow: Boolean);
    function GetCol(Index: Integer): TdxDockCol;
    function GetColCount: Integer;
    function GetVisible: Boolean;
    procedure UpdateOneOnRows;
  public
    constructor Create(ADockControl: TdxDockControl);
    destructor Destroy; override;
    function AddCol(ABarControl: TdxBarControl): TdxDockCol;
    procedure DeleteCol(ABarControl: TdxBarControl); overload;
    procedure DeleteCol(AIndex: Integer); overload;
    property ColCount: Integer read GetColCount;
    property ColList: TList read FColList;
    property Cols[Index: Integer]: TdxDockCol read GetCol;
    property DockControl: TdxDockControl read FDockControl;
    property Visible: Boolean read GetVisible;
  end;

  TXDirection = (xdLeft, xdRight);
  TYDirection = (ydTop, ydBottom);

  { TdxBarControlMarkFadingHelper }

  TdxBarControlMarkFadingHelper = class(TdxFadingObjectHelper)
  private
    FOwner: TdxBarControl;
  protected
    function CanFade: Boolean; override;
    procedure DrawFadeImage; override;
    procedure GetFadingParams(out AFadeOutImage: TcxBitmap;
      out AFadeInImage: TcxBitmap; var AFadeInAnimationFrameCount: Integer;
      var AFadeInAnimationFrameDelay: Integer; var AFadeOutAnimationFrameCount: Integer;
      var AFadeOutAnimationFrameDelay: Integer); override;
  public
    constructor Create(AOwner: TdxBarControl); virtual;
    destructor Destroy; override;
    property Owner: TdxBarControl read FOwner;
  end;

  { TdxBarControlMDIButtonFadingHelper }

  TdxBarControlMDIButtonFadingHelper = class(TdxFadingObjectHelper)
  private
    FMDIButton: TdxBarMDIButton;
    FOwner: TdxBarControl;
  protected
    function CanFade: Boolean; override;
    procedure DrawFadeImage; override;
    procedure GetFadingParams(out AFadeOutImage: TcxBitmap;
      out AFadeInImage: TcxBitmap; var AFadeInAnimationFrameCount: Integer;
      var AFadeInAnimationFrameDelay: Integer; var AFadeOutAnimationFrameCount: Integer;
      var AFadeOutAnimationFrameDelay: Integer); override;
  public
    constructor Create(AOwner: TdxBarControl; AMDIButton: TdxBarMDIButton); virtual;
    destructor Destroy; override;
    procedure FadeIn;
    procedure FadeOut;

    property Owner: TdxBarControl read FOwner;
    property MDIButton: TdxBarMDIButton read FMDIButton;
  end;

  { TdxBarControl }

  TdxBarControl = class(TCustomdxBarControl)
  private
    FBar: TdxBar;
    FBeforeBarGetFocusFocusedWnd: HWND;
    FCloseButtonState: TdxBarMarkState;
    FDockedHandle, FFloatingHandle: HWND;
    FDrawBitmap: TBitmap;
    FIsResizing: Boolean;
    FHasSizeGrip: Boolean;
    FHitTest: Longint;
    FInternalLockCount: Integer;
    FMarkFadingHelper: TdxBarControlMarkFadingHelper;
    FMarkIAccessibilityHelper: IdxBarAccessibilityHelper;
    FMDIButtonFadingHelper: array[TdxBarMDIButton] of TdxBarControlMDIButtonFadingHelper;
    FMDIButtonWidth, FMDIButtonHeight: Integer;
    FMinSize, FMaxSize: Integer;
    FMoreButtonsHintTimer: UINT;
    FMoving: Boolean;
    FPopupBar: TdxBar;
    FPosSaving: Boolean;
    FPrevClipRgn: TcxRegion;
    FPrevFocusedBarControlLink: TcxObjectLink;
    FQuickPopup: TdxBarControl;
    FTruncated: Boolean;
    NewLeft, NewTop, NewWidth, NewHeight: Integer;
    RX, RY: TPoint;
    function GetCaptionBkColor: COLORREF;
    function GetCaptionButtons: TdxBarCaptionButtons;
    function GetCaptionColor: COLORREF;
    function GetHorizontal: Boolean;
    function GetInternallyLocked: Boolean;
    function GetIsFadingAvailable: Boolean;
    function GetMarkIAccessibilityHelper: IdxBarAccessibilityHelper;
    function GetVertical: Boolean;
    procedure SetCloseButtonState(Value: TdxBarMarkState);
    procedure SetNewBounds;
    procedure SetMoving(Value: Boolean);

    procedure ChangeStyleWinTo(AStyle: TdxBarDockingStyle;
      ADockControl: TdxDockControl);
    function GetDragPointOffset(Style: TdxBarDockingStyle): TPoint;
    function GetCaptionNCRect: TRect;

    procedure DrawCloseButton(DC: HDC);
    procedure DrawMark(DC: HDC);

    procedure DrawMDIButton(AButton: TdxBarMDIButton; ASelected, APressed: Boolean);
    function GetMDIWidth: Integer;
    function GetMDIHeight: Integer;
    function RectMDI(Button: TdxBarMDIButton): TRect;
    function MDIButtonsOnBar: Boolean;
    function MDIButtonEnabled(AButton: TdxBarMDIButton; State: Integer): Boolean;

    procedure StartMoreButtonsHintTimer;
    procedure FinishMoreButtonsHintTimer;

    function CanResizeSelectedLink(APoint: TPoint): Boolean;

    procedure WMCaptureChanged(var Message: TMessage); message WM_CAPTURECHANGED;
    procedure WMDestroy(var Message: TMessage); message WM_DESTROY;
    procedure WMGetDlgCode(var Message: TWMGetDlgCode); message WM_GETDLGCODE;
    procedure WMGetMinMaxInfo(var Message: TWMGetMinmaxInfo); message WM_GETMINMAXINFO;
    procedure WMGetObject(var Message: TMessage); message WM_GETOBJECT;
    procedure WMLButtonDblClk(var Message: TWMLButtonDblClk); message WM_LBUTTONDBLCLK;
    procedure WMLButtonUp(var Message: TWMLButtonUp); message WM_LBUTTONUP;
    procedure WMMouseActivate(var Message: TWMMouseActivate); message WM_MOUSEACTIVATE;
    procedure WMNCCalcSize(var Message: TWMNCCalcSize); message WM_NCCALCSIZE;
    procedure WMNCHitTest(var Message: TWMNCHitTest); message WM_NCHITTEST;
    procedure WMNCLButtonDown(var Message: TWMNCLButtonDown); message WM_NCLBUTTONDOWN;
    procedure WMSetCursor(var Message: TWMSetCursor); message WM_SETCURSOR;
    procedure WMSize(var Message: TWMSize); message WM_SIZE;
    procedure WMSizing(var Message: TMessage); message WM_SIZING;
    procedure WMWindowPosChanging(var Message: TWMWindowPosChanging); message WM_WINDOWPOSCHANGING;
    procedure CMFontChanged(var Message: TMessage); message CM_FONTCHANGED;
  protected
    procedure CreateParams(var Params: TCreateParams); override;
    procedure CreateWnd; override;
    procedure Paint; override;
    procedure Resize; override;
    procedure WindowPosChanged(var Message: TWMWindowPosChanged); override;
    procedure WndProc(var Message: TMessage); override;

    procedure BeginInternal;
    procedure EndInternal;
    property InternallyLocked: Boolean read GetInternallyLocked;

    procedure LayoutChanged; override;

    // MessageHandler
    procedure DoKeyDown(var Message: TWMKey); override;

    procedure CalcControlsPositions; override;
    procedure CalcRowItemRects; override;
    procedure CalcDrawingConsts; override;
    procedure CalcDragOverParameters(const ACursorPos: TPoint;
      var ADragOverItemLink: TdxBarItemLink;
      var AIsBeginGroup, AIsFirstPart, AIsVerticalDirection: Boolean); override;

    // Conditions
    function CanAlignControl(AControl: TdxBarItemControl): Boolean; override;
    function CanCallInheritedNCCalcSize: Boolean; override; // obsolete
    function CanCustomizing: Boolean; override;
    function CanHideAllItemsInSingleLine: Boolean; virtual;
    function CanMoving: Boolean; virtual;
    function CanProcessShortCut: Boolean; virtual;

    function CheckLockUpdate: Boolean; override;
    procedure CustomizePrepare(APoint: TPoint; ASecondClick: Boolean); override;
    procedure DoBarGetFocus(ASelectedItem: TdxBarItemControl); override;
    procedure DoBarLostFocus; override;
    procedure DoBarMouseDown(Button: TMouseButton; Shift: TShiftState;
      const APoint: TPoint; AItemControl: TdxBarItemControl; APointInClientRect: Boolean); override;
    procedure DoBarMouseLeave; override;
    procedure DoBarMouseMove(Shift: TShiftState; const APoint: TPoint; AItemControl: TdxBarItemControl); override;
    procedure DoHideAll; override;
    procedure DoRepaintBar(ARecreateControls: Boolean); override;
    procedure DoSetIsActive(AValue: Boolean); override;
    procedure FocusItemControl(AItemControl: TdxBarItemControl); override;
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; override;

    procedure CaptionButtonClick(AIndex: Integer); virtual;
    function GetCaptionRect: TRect;
    procedure CheckMarkState(const P: TPoint);
    function CloseButtonRect: TRect;
    function CloseButtonRectNC: TRect;
    function HasCaptionButtons: Boolean; virtual;

    function GetAlphaBlendValue: Byte;
    function GetBackgroundBitmap: TBitmap; override;
    function GetBeginGroupSize: Integer; override;
    function GetCol: Integer;
    function GetDockCol: TdxDockCol;
    function GetIsMainMenu: Boolean; override;
    function GetIsStatusBar: Boolean; override;
    function GetMarkAccessibilityHelperClass: TdxBarAccessibilityHelperClass; virtual;
    function GetMarkDrawState: TdxBarMarkState; override;
    function GetMoreButtonsHint: string; virtual;
    function GetMultiLine: Boolean; virtual;
    function GetQuickControlClass: TdxBarControlClass; virtual;
    function GetRow: Integer;
    function GetViewInfoClass: TCustomdxBarControlViewInfoClass; override;

    function GetNCDrawingDC(AUpdatedRgn: HRGN): HDC; override;
    procedure ReleaseNCDrawingDC(ADC: HDC); override;

    function GetMasterForm: TCustomForm;
    function GetParentForm: TCustomForm; virtual;
    function GetSelectableObject: TPersistent; override;

    function AllowQuickCustomizing: Boolean; virtual;
    procedure HandleQuickAccessSubItemPopup(Sender: TObject);
    procedure InitQuickControl(AQuickControlItemLinks: TdxBarItemLinks); virtual;
    procedure InitQuickCustomizeItemLinks(AQuickControlItemLinks: TdxBarItemLinks); virtual;
    procedure InitAddRemoveSubItemPopup(AItemLinks: TdxBarItemLinks); virtual;
    procedure ResetToolbarClick(Sender: TObject);

    function GetMinWidth(AStyle: TdxBarDockingStyle): Integer; virtual;
    function GetMinHeight(AStyle: TdxBarDockingStyle): Integer; virtual;
    function GetMaxWidth(AStyle: TdxBarDockingStyle): Integer;
    function GetMaxHeight(AStyle: TdxBarDockingStyle): Integer;
    procedure GetMultiLineBarSize(AStyle: TdxBarDockingStyle;
      ASize: Integer; var Result: TPoint);
    function GetSizeAllCursorBounds: TRect; virtual;
    function GetSizeForWidth(AStyle: TdxBarDockingStyle; AWidth: Integer): TPoint; virtual;
    function GetSizeForHeight(AStyle: TdxBarDockingStyle; AHeight: Integer): TPoint;
    function GetSizeForPopup: TSize; virtual;
    function GetTrackSize(AStyle: TdxBarDockingStyle): TPoint;
    function HasCaption: Boolean; virtual;
    function HasCloseButton: Boolean; virtual;
    function HideOnClick: Boolean; override;
    function IgnoreClickAreaWhenHidePopup: TRect; virtual;
    procedure InvalidateMark;
    function IsMarkAccessible: Boolean;
    function IsInternal: Boolean; override;

    function GetMouseTrackingBounds: TRect; override;

    function MarkExists: Boolean; override;
    function MarkNCRect: TRect;
    function MarkRect: TRect; override;
    function MarkScreenRect: TRect;
    procedure SetMarkState(Value: TdxBarMarkState); override;

    function RealMDIButtonsOnBar: Boolean; virtual;

    procedure SelectItemControl(AItemControl: TdxBarItemControl; AButton: TMouseButton; AShift: TShiftState); override;
    procedure ShowPopup(AItem: TdxBarItemControl); override;
    function SizeGripRect: TRect;
    procedure UpdateCaptionButton(ACaptionButton: TdxBarCaptionButton); virtual;
    procedure UpdateCaptionButtons(const AMousePos: TPoint; AMousePressed: Boolean = False);
    procedure UpdateItem(AControl: TdxBarItemControl); override;

    function AllowNCPaint: Boolean; override;
    procedure BarManagerStyleChanged;
    procedure CaptionChanged; virtual;
    procedure DoDrawBeginGroup(const ASeparatorRect: TRect; AHorz: Boolean); virtual;
    procedure DoNCPaint(DC: HDC); virtual;
    procedure DoPaint; virtual;
    procedure DrawBeginGroups;
    procedure DrawContentBackground; virtual;
    procedure DrawMarks;
    procedure DrawMDIButtons(AButtons: TdxBarMDIButtons; AExcludeClipRect: Boolean = False);
    procedure DrawSelection(ADC: HDC);
    procedure FillBackground(ADC: HDC; const ARect: TRect; ABrush: HBRUSH; AColor: TColor;
      AIsClientArea: Boolean); override;
    procedure FrameChanged;
    function GetCaption: TCaption; virtual;
    function GetEditFont: TFont; override;
    function GetFont: TFont; virtual;
    function GetFullItemRect(Item: TdxBarItemControl): TRect; override;
    function GetItemRegion(Item: TdxBarItemControl): HRGN; override;
    function GetToolbarBrush: HBRUSH; override;
    procedure GlyphChanged; virtual;
    function IsBackgroundBitmap: Boolean; override;
    function IsTransparent: Boolean; override;
    function LockHotTrackWhenPopup: Boolean; virtual;
    function NCOffset: TPoint; override;
    procedure NCPaint(ADC: HDC); override;
    function NeedHideOnNCMouseClick: Boolean; virtual;
    function NotHandleMouseMove(ACheckLastMousePos: Boolean = True): Boolean; override;
    procedure RebuildBar;
    procedure RefreshShadow;
    procedure RepaintMDIButtons;
    procedure SavePos;
    procedure SetFont; override;
    procedure SetDockingStyle(Value: TdxBarDockingStyle); override;
    procedure SetKeySelectedItem(Value: TdxBarItemControl); override;
    procedure SetLayeredAttributes; override;
    property CaptionBkColor: COLORREF read GetCaptionBkColor;
    property CaptionButtons: TdxBarCaptionButtons read GetCaptionButtons;
    property CaptionColor: COLORREF read GetCaptionColor;
    property CloseButtonState: TdxBarMarkState read FCloseButtonState
      write SetCloseButtonState;

    property HitTest: Longint read FHitTest write FHitTest;
    property Horizontal: Boolean read GetHorizontal;
    property Moving: Boolean read FMoving write SetMoving;
    property MultiLine: Boolean read GetMultiLine;
    property Truncated: Boolean read FTruncated write FTruncated;
    property Vertical: Boolean read GetVertical;

    property MDIButtonWidth: Integer read FMDIButtonWidth;
    property MDIButtonHeight: Integer read FMDIButtonHeight;

    property Fader: TdxFader read GetFader;
    property IsFadingAvailable: Boolean read GetIsFadingAvailable;
    property MarkFadingHelper: TdxBarControlMarkFadingHelper read FMarkFadingHelper;
    property MasterForm: TCustomForm read GetMasterForm;
    property ParentForm: TCustomForm read GetParentForm;
    property PopupBar: TdxBar read FPopupBar;
  public
    constructor Create(AOwner: TComponent); override;
    constructor CreateEx(AOwner: TComponent; ABar: TdxBar); virtual;
    constructor CreateForPopup(AParentBarControl: TdxBarControl;
      ABar: TdxBar); virtual;
    destructor Destroy; override;
    function ClientToScreen(const APoint: TPoint): TPoint;
    procedure CloseUp; virtual;
    procedure Hide; override;
    function IsRealVertical: Boolean; override;
    function IsVertical: Boolean; override;
    function Kind: TdxBarKind; override;
    procedure Popup(const AOwnerRect: TRect); virtual;
    procedure PopupEx(const AOwnerRect: TRect; APopupDirection: TXDirection);
    procedure Repaint; override;
    procedure UpdateFont;
    property Bar: TdxBar read FBar write FBar;
    property DockControl;
    property MarkIAccessibilityHelper: IdxBarAccessibilityHelper
      read GetMarkIAccessibilityHelper;
  end;

  TdxBarControlViewInfo = class(TCustomdxBarControlViewInfo)
  private
    function GetBarControl: TdxBarControl;
  protected
    procedure CalcSeparatorInfo(AItemLink: TdxBarItemLink); virtual;
    function CanShowButtonGroups: Boolean; virtual;
    function CanShowSeparators: Boolean; virtual;
    procedure DoCalcSeparatorInfo(AItemLink: TdxBarItemLink; const AItemRect: TRect); virtual;
    function IsLastVisibleItemControl(AItemControl: TdxBarItemControl): Boolean; virtual;
  public
    procedure Calculate; override;
    property BarControl: TdxBarControl read GetBarControl;
  end;

  { TdxBarSubMenuControl }

  TdxBarButtonControl = class;
  TdxBarSubItemControl = class;

  TdxBarSubMenuControl = class(TCustomdxBarControl)
  private
    FAnimationThread: TThread;
    FDetachCaptionSelected: Boolean;
    FExpandingMenu: Boolean;
    FExpandMenuTimer: UINT;
    FLightBrush: HBRUSH;
    FLightPalette: HPALETTE;
    FLockChangeSizeByChildItemControl: Boolean;
    FMenuAnimations: TdxBarMenuAnimations;
    FNonRecent: Boolean;
    FOnShowLeft, FOnShowTop: Integer;
    FOwnerWidth, FOwnerHeight: Integer;
    FScrollTimerID: UINT;
    FShowAnimation: Boolean;
    FTopIndex: Integer;
    FXDirection: TXDirection;
    FYDirection: TYDirection;

    FDropDownButton: TdxBarButtonControl;
    FSubItem: TdxBarSubItemControl;

    FOnCloseUp: TNotifyEvent;
    FOnPopup: TNotifyEvent;

    function GetBandSize: Integer;
    function GetBarSize: Integer;
    function GetBarRect: TRect;
    function GetBottomVisibleItemIndex: Integer;
    function GetContentRect: TRect;
    function GetDetachCaptionSize: Integer;
    function GetMaxVisibleCount: Integer;
    function GetParentItemControl: TdxBarItemControl;
    function GetSubMenuOwner: IdxBarSubMenuOwner;
    function GetToolbarItemsBrush: HBRUSH;
    function GetTopVisibleItemIndex: Integer;
    procedure SetDetachCaptionSelected(AValue: Boolean);
    procedure SetTopIndex(AValue: Integer);

    procedure CalcBounds(out ASize: TSize);
    procedure CalcSize(out ASize: TSize);

    procedure CreateLightBrush;
    procedure DestroyLightBrush;
    procedure PreparePalette(DC: HDC);
    procedure UnpreparePalette(DC: HDC);
    procedure ExpandMenu;
    function ExtendedView: Boolean;
    procedure InvalidateItemsRect;
    procedure InvalidateDetachCaption;
    function MouseOnArrow(AArrowDirection: TcxArrowDirection): Boolean;
    function MouseOnUpArrow: Boolean;
    function MouseOnDownArrow: Boolean;
    procedure SetExpandMenuTimer(Time: UINT; ExpandAfterDelay: Boolean);
    procedure KillExpandMenuTimer;
    procedure KillScrollTimer;

    function IsAnimationRunning: Boolean;
    procedure OnTerminateAnimation(Sender: TObject);

    procedure WMGetDlgCode(var Message: TWMGetDlgCode); message WM_GETDLGCODE;
    procedure WMKeyDown(var Message: TWMKeyDown); message WM_KEYDOWN;
    procedure WMLButtonDown(var Message: TWMLButtonDown); message WM_LBUTTONDOWN;
    procedure WMNCCalcSize(var Message: TWMNCCalcSize); message WM_NCCALCSIZE;
    procedure WMNCHitTest(var Message: TWMNCHitTest); message WM_NCHITTEST;
    procedure WMPrint(var Message: TMessage); message WM_PRINT;
    procedure WMPrintClient(var Message: TMessage); message WM_PRINTCLIENT;
    procedure WMRButtonDown(var Message: TWMRButtonDown); message WM_RBUTTONDOWN;
    procedure WMRButtonUp(var Message: TWMRButtonUp); message WM_RBUTTONUP;
    procedure WMTimer(var Message: TWMTimer); message WM_TIMER;
    procedure CMFontChanged(var Message: TMessage); message CM_FONTCHANGED;
  protected
    FParentWnd: HWND;

    procedure CreateParams(var Params: TCreateParams); override;
    procedure CreateWnd; override;
    procedure DestroyWindowHandle; override;
    procedure DestroyWnd; override;
    procedure DoCloseUp; dynamic;
    procedure DoPopup; dynamic;
    procedure Paint; override;
    procedure NCPaint(ADC: HDC); override;

    // MessageHandler
    procedure DoKeyDown(var Message: TWMKey); override;

    procedure CalcControlsPositions; override;
    procedure CalcDrawingConsts; override;
    procedure CalcDragOverParameters(const ACursorPos: TPoint;
      var ADragOverItemLink: TdxBarItemLink;
      var AIsBeginGroup, AIsFirstPart, AIsVerticalDirection: Boolean); override;
    procedure CalcItemsRect; override;
    function CanActiveChange: Boolean; override;
    function CanCustomizing: Boolean; override;
    function CanDrawClippedItem(AItemRect: TRect): Boolean; override;
    function CanShowHint: Boolean; override;
    function CheckLockUpdate: Boolean; override;
    function ChildrenHaveShadows: Boolean; override;
    procedure CorrectVisibleItemsRectBottom; override;
    procedure CorrectVisibleItemsRectTop; override;
    procedure DoCreateControls; override;
    procedure DoDestroyControls; override;
    procedure DoBarMouseLeave; override;
    procedure DoBarMouseMove(Shift: TShiftState; const APoint: TPoint; AItemControl: TdxBarItemControl); override;
    procedure DoDropFocus; override;
    procedure DoNCPaint(DC: HDC; const ARect: TRect); virtual;
    procedure DoHideAll; override;
    procedure DoPaintItem(AControl: TdxBarItemControl; ACanvas: TcxCanvas; const AItemRect: TRect); override;
    procedure DoRepaintBar(ARecreateControls: Boolean); override;
    procedure DoSetIsActive(AValue: Boolean); override;
    procedure DragOver(X, Y: Integer; var Accept: Boolean); override;

    function ChangeSizeByChildItemControl(out ASize: TSize): Boolean; virtual;
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; override;
    function GetBeginGroupSize: Integer; override;
    function GetBehaviorOptions: TdxBarBehaviorOptions; override;
    function GetBottomItemControl: TdxBarItemControl;
    function GetDefaultItemHeight(AItem: TdxBarItemControl): Integer; override;
    function GetEditFont: TFont; override;
    function GetIsContextMenu: Boolean; virtual;
    function GetIsCustomizing: Boolean; override;
    function GetIsMainMenu: Boolean; override;
    function GetIsStatusBar: Boolean; override;
    function GetIsShadowVisible: Boolean; override;
    function GetItemControlOffset(AItemLink: TdxBarItemLink): Integer; override;
    function GetItemRectEx(Item: TdxBarItemControl; IsBeginGroup: Boolean): TRect; override;
    function GetItemsPaneSize: TSize; virtual;
    function GetPaintType: TdxBarPaintType; override;
    function GetSelectableObject: TPersistent; override;
    function GetTextSize: Integer; override;
    function GetTopItemControl: TdxBarItemControl;
    function GetViewInfoClass: TCustomdxBarControlViewInfoClass; override;
    procedure HideByEscape;
    function HideOnClick: Boolean; override;
    function IsInternal: Boolean; override;
    function IsMeaningParent(AWnd: HWND): Boolean; override;
    function IsPopup: Boolean; override;
    function IsVerticalDirection: Boolean; override;
    function MustFitInWorkAreaWidth: Boolean; virtual;
    function NeedBufferedRepaint: Boolean;
    function NeedsSelectFirstItemOnDropDownByKey: Boolean; virtual;
    procedure SetFont; override;
    procedure SetRecentItemCount;
    procedure SetAccelSelectedItem(AItemControl: TdxBarItemControl; ADuplicate: Boolean); override;
    procedure SetControlVisible(AControl: TdxBarItemControl); override;
    procedure SetSelectedControl(Value: TdxBarItemControl); override;
    procedure SetSizeAndCheckBounds(const APredefinedSize: TSize; out AChangeXDirection, AChangeYDirection: Boolean);
    procedure TerminateAnimation;
    procedure UpdateItem(AControl: TdxBarItemControl); override;

    procedure InitCustomizationPopup(AItemLinks: TdxBarItemLinks); override;
    procedure ShowPopup(AItem: TdxBarItemControl); override;

    function CanDetach: Boolean;
    function Detachable: Boolean;
    function DetachCaptionAreaSize: Integer;
    function DetachCaptionRect: TRect;
    function MouseOnDetachCaption: Boolean;
    procedure DoDetachMenu;

    function MarkArrowSize: Integer;
    function MarkExists: Boolean; override;
    function MarkRect: TRect; override;
    procedure SetMarkState(Value: TdxBarMarkState); override;

    function DownArrowExists: Boolean;
    function GetScrollTime: Integer; virtual;
    function UpArrowExists: Boolean;
    function UseScrollButtons: Boolean;

    procedure DoCalcSize(out ASize: TSize); virtual;
    procedure DoCorrectSize(var ASize: TSize);
    procedure DoShow; virtual;

    procedure DrawBar;
    procedure DrawContent; virtual;
    procedure DrawItems; override;
    procedure DrawScrollArea;
    procedure FillBackground(DC: HDC; const ARect: TRect; ABrush: HBRUSH; AColor: TColor;
      AIsClientArea: Boolean); override;
    procedure DoFillBackgroundEx(ACanvas: TcxCanvas; const ARect: TRect; ABrush: HBRUSH; AColor: TColor;
      AIsClientArea: Boolean); virtual;
    procedure FillBackgroundEx(ACanvas: TcxCanvas; const ARect: TRect; ABrush: HBRUSH; AColor: TColor;
      AIsClientArea: Boolean);

    function GetBackgroundBitmap: TBitmap; override;
    function GetBorderSize: Integer; override;
    function GetClientOffset(
      AIncludeDetachCaption: Boolean = True): TRect; virtual;
    function GetIndent1: Integer;
    function GetIndent2: Integer;
    function GetItemsRectOffset: TRect; virtual;
    function IsTransparent: Boolean; override;

    function GetMouseTrackingBounds: TRect; override;

    property BandSize: Integer read GetBandSize;
    property BarSize: Integer read GetBarSize;
    property BorderSize: Integer read GetBorderSize;
    property DetachCaptionSelected: Boolean read FDetachCaptionSelected
      write SetDetachCaptionSelected;
    property DetachCaptionSize: Integer read GetDetachCaptionSize;

    property BarRect: TRect read GetBarRect;
    property ContentRect: TRect read GetContentRect;

    property ToolbarItemsBrush: HBRUSH read GetToolbarItemsBrush;

    property BottomItemControl: TdxBarItemControl read GetBottomItemControl;
    property BottomVisibleItemIndex: Integer read GetBottomVisibleItemIndex;
    property IsContextMenu: Boolean read GetIsContextMenu;
    property TopIndex: Integer read FTopIndex write SetTopIndex;
    property TopItemControl: TdxBarItemControl read GetTopItemControl;
    property TopVisibleItemIndex: Integer read GetTopVisibleItemIndex;
    property MaxVisibleCount: Integer read GetMaxVisibleCount;
    property NonRecent: Boolean read FNonRecent;
    property OnShowLeft: Integer read FOnShowLeft;
    property OnShowTop: Integer read FOnShowTop;

    property OnCloseUp: TNotifyEvent read FOnCloseUp write FOnCloseUp;
    property OnPopup: TNotifyEvent read FOnPopup write FOnPopup;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Hide; override;
    function Kind: TdxBarKind; override;
    procedure Show;

    property OwnerWidth: Integer read FOwnerWidth write FOwnerWidth;
    property OwnerHeight: Integer read FOwnerHeight write FOwnerHeight;
    property ParentItemControl: TdxBarItemControl read GetParentItemControl;
  end;

  TdxBarSubMenuControlViewInfo = class(TCustomdxBarControlViewInfo)
  private
    function GetBarControl: TdxBarSubMenuControl;
  public
    procedure Calculate; override;
    property BarControl: TdxBarSubMenuControl read GetBarControl;
  end;

  { TdxBarInternalSubMenuControl }

  TdxBarInternalSubMenuControl = class(TdxBarSubMenuControl, IdxBarLinksOwner)
  protected
    function GetIsCustomizing: Boolean; override;
    function IsInternal: Boolean; override;

    // IdxBarLinksOwner
    function CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
    function CreateBarControl: TCustomdxBarControl;
    function GetInstance: TComponent;
    function GetItemLinks: TdxBarItemLinks;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  end;

  { TdxBarCustomizingPopup }

  TdxBarCustomizingPopup = class(TdxBarInternalSubMenuControl)
  public
    constructor Create(AOwner: TComponent); override;
    procedure DoShowCustomizingPopup;
  end;

  { TdxBarApplicationMenuControl }

  TdxBarApplicationMenuControl = class(TdxBarSubMenuControl)
  private
    FBar: TdxBar;
    FDockControl: TdxBarDockControl;
    FTotalItemLinks: TdxBarItemLinks;

    FButtonLinks: TdxBarApplicationMenuButtonItemLinks;
    FButtonsRect: TRect;
    FExtraPaneRect: TRect;
    FExtraPaneSize: Integer;

    function GetApplicationMenu: TdxBarCustomApplicationMenu;
    function GetExtraPaneItemLinks: TdxBarItemLinks;
    function GetTotalItemLinks: TdxBarItemLinks;
    function NeedExtraPane: Boolean;

    property TotalItemLinks: TdxBarItemLinks read GetTotalItemLinks;
  protected
    function CalcChildBarBounds(out ARect: TRect): Boolean; override;
    procedure CalcItemRects(APaintStyle: TdxBarPaintType; ATopIndex: Integer); override;
    procedure CalcItemsRect; override;
    procedure DoCalcSize(out ASize: TSize); override;

    function GetViewInfoClass: TCustomdxBarControlViewInfoClass; override;
    function GetExtraPaneDockControlClass: TdxBarDockControlClass; virtual;

    procedure DoNCPaint(DC: HDC; const ARect: TRect); override;
    procedure DoShow; override;

    procedure DrawContent; override;
    procedure DrawContentArea(ACanvas: TcxCanvas);
    procedure DoFillBackgroundEx(ACanvas: TcxCanvas; const ARect: TRect; ABrush: HBRUSH; AColor: TColor;
      AIsClientArea: Boolean); override;

    function DoFindLinkWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink; override;
    function FindLinkWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink; out ADuplicate: Boolean): TdxBarItemLink; override;
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; override;
    function GetBehaviorOptions: TdxBarBehaviorOptions; override;
    function GetItemsRectOffset: TRect; override;
    function IsControlExists(ABarItemControl: TdxBarItemControl): Boolean; override;
    procedure SetAccelSelectedItem(AItemControl: TdxBarItemControl; ADuplicate: Boolean); override;
    procedure SetControlVisible(AControl: TdxBarItemControl); override;
    procedure SetItemLinks(Value: TdxBarItemLinks); override;
    procedure InitializeExtraPaneControl;
    procedure ShowExtraPaneControl;

    property ApplicationMenu: TdxBarCustomApplicationMenu read GetApplicationMenu;
    property ButtonLinks: TdxBarApplicationMenuButtonItemLinks read FButtonLinks;
    property ExtraPaneControlDockControl: TdxBarDockControl read FDockControl;
    property ExtraPaneItemLinks: TdxBarItemLinks read GetExtraPaneItemLinks;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  end;

  TdxBarApplicationMenuControlViewInfo = class(TdxBarSubMenuControlViewInfo)
  private
    function GetBarControl: TdxBarApplicationMenuControl;
  public
    procedure Calculate; override;
    property BarControl: TdxBarApplicationMenuControl read GetBarControl;
  end;  

  { TdxBarExtraPaneControl }

  TdxBarExtraPaneControl = class(TdxBarControl)
  private
    FIsControlsCreated: Boolean;
    procedure DrawBackground(ACanvas: TcxCanvas; const ARect: TRect; ABrush: HBRUSH; AColor: TColor);
    function GetBasicControl: TCustomdxBarControl;

    procedure WMNCCalcSize(var Message: TWMNCCalcSize); message WM_NCCALCSIZE;
  protected
    procedure CalcControlsPositions; override;
    procedure CalcItemsRect; override;
    function CanMoving: Boolean; override;
    function CanProcessMouseMessage: Boolean; override;
    procedure DoCreateControls; override;
    procedure DoDestroyControls; override;
    procedure DoDrawBeginGroup(const ASeparatorRect: TRect; AHorz: Boolean); override;
    procedure DoNCPaint(DC: HDC); override;
    procedure DoHideAll; override;
    procedure DrawContentBackground; override;
    procedure FillBackground(ADC: HDC; const ARect: TRect; ABrush: HBRUSH; AColor: TColor;
      AIsClientArea: Boolean); override;
    function FindLinkWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink; out ADuplicate: Boolean): TdxBarItemLink; override;
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; override;
    function GetBehaviorOptions: TdxBarBehaviorOptions; override;
    function GetPainter: TdxBarPainter; override;
    function GetViewInfoClass: TCustomdxBarControlViewInfoClass; override;
    procedure HideAllByEscape; override;
    procedure LayoutChanged; override;
    procedure SetAccelSelectedItem(AItemControl: TdxBarItemControl; ADuplicate: Boolean); override;

    function CanShowPopupMenuOnMouseClick(AMousePressed: Boolean): Boolean; override;
    procedure InitCustomizationPopup(AItemLinks: TdxBarItemLinks); override;
    procedure ShowPopup(AItem: TdxBarItemControl); override;

    property BasicControl: TCustomdxBarControl read GetBasicControl;
  public
    destructor Destroy; override;
  end;

  TdxBarExtraPaneControlViewInfo = class(TdxBarControlViewInfo)
  protected
    procedure DoCalcSeparatorInfo(AItemLink: TdxBarItemLink; const AItemRect: TRect); override;
  end;

  {--------------------------------------
                   Items
   --------------------------------------}

  TdxBarItemActionLink = class(TActionLink)
  protected
    FClient: TdxBarItem;
    procedure AssignClient(AClient: TObject); override;
    function IsCaptionLinked: Boolean; override;
    function IsCheckedLinked: Boolean; override;
    function IsEnabledLinked: Boolean; override;
    function IsHelpContextLinked: Boolean; override;
    function IsHintLinked: Boolean; override;
    function IsImageIndexLinked: Boolean; override;
    function IsShortCutLinked: Boolean; override;
    function IsVisibleLinked: Boolean; override;
    function IsOnExecuteLinked: Boolean; override;
    procedure SetCaption(const Value: string); override;
    procedure SetChecked(Value: Boolean); override;
    procedure SetEnabled(Value: Boolean); override;
    procedure SetHelpContext(Value: THelpContext); override;
    procedure SetHint(const Value: string); override;
    procedure SetImageIndex(Value: Integer); override;
    procedure SetShortCut(Value: TShortCut); override;
    procedure SetVisible(Value: Boolean); override;
    procedure SetOnExecute(Value: TNotifyEvent); override;
  end;

  TdxBarItemActionLinkClass = class of TdxBarItemActionLink;

  { TdxBarItemStylesData }

  TdxBarItemStyleChangeKind = (sckDrawing, sckStructure, sckNone);
  TdxBarItemStylesDataChangeEvent = procedure(AChangeKind: TdxBarItemStyleChangeKind) of object;

  TdxBarItemStylesData = class(TcxInterfacedPersistent, IcxStyleChangeListener)
  private
    FChangeEventLockCount: Integer;
    FChangeKind: TdxBarItemStyleChangeKind;
    FIsDestroying: Boolean;
    FOnChange: TdxBarItemStylesDataChangeEvent;
    FStyleCount: Integer;
    FStylesData: array of TdxBarItemStyleData;

    // IcxStyleChangeListener
    procedure StyleChanged(AStyle: TcxCustomStyle);
    procedure StyleRemoved(AStyle: TcxCustomStyle);

    procedure DoChange(AChangeKind: TdxBarItemStyleChangeKind);
    function GetStyle(AIndex: Integer): TcxStyle;
    function GetStyleReferenceCount(AStyle: TcxStyle): Integer;
    procedure InternalSetStyle(AIndex: Integer; Value: TcxStyle);
    procedure InternalStyleChanged(AIndex: Integer); overload;
    procedure InternalStyleChanged(AStyle: TcxStyle); overload;
    procedure InternalStyleRemoved(AStyle: TcxStyle);
    function IsChangeEventLocked: Boolean;
    procedure LockChangeEvent(ALock: Boolean);
    procedure SetStyle(AIndex: Integer; Value: TcxStyle);
  protected
    property IsDestroying: Boolean read FIsDestroying;
    property StyleCount: Integer read FStyleCount;
  public
    constructor Create(AStyleCount: Integer); reintroduce;
    destructor Destroy; override;
    property Styles[AIndex: Integer]: TcxStyle read GetStyle write SetStyle;
    property OnChange: TdxBarItemStylesDataChangeEvent read FOnChange
      write FOnChange;
  end;

  TdxBarScreenTipBandTextAlign = (stbtaLeft, stbtaRight);
  TdxBarScreenTipBandType = (stbHeader, stbDescription, stbFooter);

  { TdxBarCustomScreenTipBand }

  TdxBarCustomScreenTipBand = class(TPersistent)
  private
    FBandType: TdxBarScreenTipBandType;
    FGlyph: TBitmap;
    FText: string;
    FTextAlign: TdxBarScreenTipBandTextAlign;
    FOnChange: TNotifyEvent;
    procedure SetGlyph(Value: TBitmap);
    procedure SetText(const Value: string);
    procedure SetTextAlign(Value: TdxBarScreenTipBandTextAlign);
  protected
    procedure Changed; virtual;
    function GetFont: TFont; virtual; abstract;
    function IsVisible(const AHintText: string): Boolean;

    property BandType: TdxBarScreenTipBandType read FBandType write FBandType;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  public
    constructor Create(ABandType: TdxBarScreenTipBandType);
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;

    property Font: TFont read GetFont;
  published
    property Glyph: TBitmap read FGlyph write SetGlyph;
    property Text: string read FText write SetText;
    property TextAlign: TdxBarScreenTipBandTextAlign read FTextAlign write SetTextAlign default stbtaRight;
  end;

  { TdxBarScreenTipBand }

  TdxBarScreenTipBand = class(TdxBarCustomScreenTipBand)
  private
    FScreenTip: TdxBarScreenTip;
  protected
    function GetFont: TFont; override;
  public
    constructor Create(AScreenTip: TdxBarScreenTip; ABandType: TdxBarScreenTipBandType); virtual;

    property ScreenTip: TdxBarScreenTip read FScreenTip;
  end;

  { TdxBarScreenTipFooterBand }

  TdxBarScreenTipFooterBand = class(TdxBarCustomScreenTipBand)
  private
    FRepository: TdxBarScreenTipRepository;
  protected
    function GetFont: TFont; override;
  public
    constructor Create(ARepository: TdxBarScreenTipRepository);

    property Repository: TdxBarScreenTipRepository read FRepository;
  end;

  { TdxBarScreenTip }

  TdxBarScreenTip = class(TcxComponentCollectionItem)
  private
    FBands: array[TdxBarScreenTipBandType] of TdxBarScreenTipBand;
    FUseHintAsHeader: Boolean;
    FUseStandardFooter: Boolean;
    FWidth: Integer;
    function GetBand(Index: Integer): TdxBarScreenTipBand;
    procedure SetBand(Index: Integer; Value: TdxBarScreenTipBand);
  protected
    function GetBandForCalculation(Index: TdxBarScreenTipBandType): TdxBarCustomScreenTipBand;
    function GetCollection: TdxBarScreenTipCollection; virtual;
    function GetCollectionFromParent(AParent: TComponent): TcxComponentCollection; override;
    function GetDisplayName: string; override;
    function GetWidth: Integer; virtual;
    procedure SetName(const Value: TComponentName); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;

    property Collection: TdxBarScreenTipCollection read GetCollection;
  published
    property Header: TdxBarScreenTipBand index stbHeader read GetBand write SetBand;
    property Description: TdxBarScreenTipBand index stbDescription read GetBand write SetBand;
    property Footer: TdxBarScreenTipBand index stbFooter read GetBand write SetBand;
    property UseHintAsHeader: Boolean read FUseHintAsHeader write FUseHintAsHeader default False;
    property UseStandardFooter: Boolean read FUseStandardFooter write FUseStandardFooter default False;
    property Width: Integer read FWidth write FWidth default 0;
  end;

  { TdxBarScreenTipCollection }

  TdxBarScreenTipCollection = class(TcxComponentCollection)
  private
    FRepository: TdxBarScreenTipRepository;
    function GetItem(Index: Integer): TdxBarScreenTip;
    procedure SetItem(Index: Integer; Value: TdxBarScreenTip);
  protected
    procedure SetItemName(AItem: TcxComponentCollectionItem); override;
    procedure UpdateFonts;
  public
    constructor Create(AParentComponent: TComponent; AItemClass: TcxComponentCollectionItemClass); override;
    function Add: TdxBarScreenTip;

    property Repository: TdxBarScreenTipRepository read FRepository;
    property Items[Index: Integer]: TdxBarScreenTip read GetItem write SetItem; default;
  end;

  { TdxBarScreenTipRepository }

  TdxScreenTipRepositoryFonts = set of TdxBarScreenTipBandType;

  TdxBarScreenTipRepository = class(TComponent)
  private
    FAssignedFonts: TdxScreenTipRepositoryFonts;
    FFonts: array[TdxBarScreenTipBandType] of TFont;
    FItems: TdxBarScreenTipCollection;
    FShowDescription: Boolean;
    FStandardFooter: TdxBarScreenTipFooterBand;
    FSystemFont: TFont;
    procedure CreateFonts;
    procedure FontChanged(Sender: TObject);
    function GetFont(Index: Integer): TFont;
    function IsFontStored(Index: Integer): Boolean;
    procedure SetFont(Index: Integer; Value: TFont);
    procedure SetItems(AValue: TdxBarScreenTipCollection);
    procedure SetStandardFooter(Value: TdxBarScreenTipFooterBand);
  protected
    function CreateScreenTips: TdxBarScreenTipCollection; virtual;
    function GetBandFont(ABandType: TdxBarScreenTipBandType): TFont; virtual;
    procedure GetChildren(Proc: TGetChildProc; Root: TComponent); override;
    function GetSystemFont(ABandType: TdxBarScreenTipBandType): TFont;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
  published
    property AssignedFonts: TdxScreenTipRepositoryFonts
      read FAssignedFonts write FAssignedFonts default [];
    property Items: TdxBarScreenTipCollection read FItems write SetItems;
    property DescriptionFont: TFont index stbDescription read GetFont write SetFont stored IsFontStored;
    property FooterFont: TFont index stbFooter read GetFont write SetFont stored IsFontStored;
    property HeaderFont: TFont index stbHeader read GetFont write SetFont stored IsFontStored;
    property StandardFooter: TdxBarScreenTipFooterBand
      read FStandardFooter write SetStandardFooter;
    property ShowDescription: Boolean read FShowDescription write FShowDescription default True; 
  end;

  { TdxBarCustomHintViewInfo }

  TdxBarCustomHintViewInfo = class
  private
    FBarManager: TdxBarManager;
    FBoundsRect: TRect;
  protected
    procedure Calculate(ACanvas: TCanvas); virtual; abstract;
    function IsScreenTip: Boolean; virtual;
    procedure Paint(ACanvas: TCanvas); virtual; abstract;
    procedure SetWindowDrawParams(AWindow: TdxBarHintWindow); virtual;

  public
    constructor Create(ABarManager: TdxBarManager);

    property BarManager: TdxBarManager read FBarManager;
    property BoundsRect: TRect read FBoundsRect write FBoundsRect;
  end;

  { TdxBarHintViewInfo }

  TdxBarHintViewInfo = class(TdxBarCustomHintViewInfo)
  private
    FText: string;
    FPos: TPoint;
    function CalculateMinSize(ACanvas: TCanvas): TSize;
  protected
    procedure CorrectMinSize(var ASize: TSize); virtual;
    function GetTextRect: TRect; virtual;
    procedure DrawText(ACanvas: TCanvas); virtual;
    procedure SetWindowDrawParams(AWindow: TdxBarHintWindow); override;
    procedure SetWindowFont(AWindow: TdxBarHintWindow); virtual;

    property Text: string read FText write FText;
    property Pos: TPoint read FPos write FPos;
  public
    constructor Create(ABarManager: TdxBarManager; const AHint, AShortCut: string; const ACursorPos: TPoint);
    procedure Calculate(ACanvas: TCanvas); override;
    procedure Paint(ACanvas: TCanvas); override;
  end;

  { TdxBarLikeHintScreenTipViewInfo }

  TdxBarLikeHintScreenTipViewInfo = class(TdxBarHintViewInfo)
  private
    FPainter: TdxBarPainter;
  protected
    procedure CorrectMinSize(var ASize: TSize); override;
    function GetTextRect: TRect; override;
    function IsScreenTip: Boolean; override;
  public
    constructor Create(ABarManager: TdxBarManager; APainter: TdxBarPainter; const AHint, AShortCut: string; const ACursorPos: TPoint);
    procedure Paint(ACanvas: TCanvas); override;
  end;

  { TdxBarScreenTipBandViewInfo }

  TdxBarScreenTipBandViewInfo = class
  private
    FBand: TdxBarCustomScreenTipBand;
    FBandBounds: TRect;
    FGlyphBounds: TRect;
    FGlyphSize: TSize;
    FHintText: string;
    FShortCut: string;
    FTextBounds: TRect;
    FTextSize: TSize;
    FTop: Integer;
    FWidth: Integer;
  protected
    function GetAvailGlyphWidth: Integer;
    function GetHorzIndent: Integer;
    function GetVertIndent(APainter: TdxBarPainter): Integer;
    function GetText: string;
    function HasGlyph: Boolean;
    function HasText: Boolean;
    function HeightToCurrentDpi(AValue: Integer): Integer;
    function WidthToCurrentDpi(AValue: Integer): Integer;
    function HorzPixelsPerInch: Integer;
    function VertPixelsPerInch: Integer;
    procedure Paint(ACanvas: TcxCanvas; APainter: TdxBarPainter);

    property BandBounds: TRect read FBandBounds;
    property GlyphBounds: TRect read FGlyphBounds;
    property TextBounds: TRect read FTextBounds;
    property TextSize: TSize read FTextSize;
    property Top: Integer read FTop;
    property Width: Integer read FWidth;
  public
    constructor Create(ABand: TdxBarCustomScreenTipBand; const AHintText, AShortCut: string);
    procedure Calculate(AWidth: Integer; var ATop: Integer; AHeight: Integer; APainter: TdxBarPainter);
    function GetHeight(ACanvas: TCanvas; const AWidth: Integer; APainter: TdxBarPainter): Integer;
    function IsVisible: Boolean;

    property Band: TdxBarCustomScreenTipBand read FBand;
  end;

  { TdxBarScreenTipViewInfo }

  TdxBarScreenTipViewInfo = class(TdxBarCustomHintViewInfo)
  private
    FPainter: TdxBarPainter;
    FScreenTip: TdxBarScreenTip;
    FHintText: string;
    FShortCut: string;
    FBandViewInfos: array of TdxBarScreenTipBandViewInfo;
    FWidth: Integer;
    procedure DestroyBandViewInfos;
    function GetBandViewInfos(Index: Integer): TdxBarScreenTipBandViewInfo;
    function GetBandViewInfosCount: Integer;
  protected
    function CreateBandViewInfo(ABand: TdxBarCustomScreenTipBand): TdxBarScreenTipBandViewInfo; virtual;
    function IsScreenTip: Boolean; override;
  public
    constructor Create(AScreenTip: TdxBarScreenTip; APainter: TdxBarPainter;
      const AHintText: string; AShortCut: string = '');
    destructor Destroy; override;
    procedure Calculate(ACanvas: TCanvas); override;
    procedure Paint(ACanvas: TCanvas); override;

    property ScreenTip: TdxBarScreenTip read FScreenTip;
    property BandViewInfosCount: Integer read GetBandViewInfosCount;
    property BandViewInfos[Index: Integer]: TdxBarScreenTipBandViewInfo read GetBandViewInfos;
  end;

  { TdxBarHintWindow }

  TdxBarHintWindow = class(TcxBaseHintWindow)
  private
    FIsScreenTipWindow: Boolean;
    FViewInfo: TdxBarCustomHintViewInfo;
    procedure SetIsScreenTipWindow(Value: Boolean);
    procedure WMShowWindow(var Message: TWMShowWindow); message WM_SHOWWINDOW;
    procedure WMSize(var Message: TWMSize); message WM_SIZE;
  protected
    function GetHintObject(ABarManager: TdxBarManager): IdxBarHintKeeper; virtual;
    function GetHideHintTime: Integer; virtual;
    function GetShowHintTime: Integer; virtual;
    procedure Paint; override;
    procedure RecreateWindow; virtual;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function ActivateHint(ABarManager: TdxBarManager; const AHintText, AShortCut: string): Boolean; reintroduce; virtual;

    property ShowHintTime: Integer read GetShowHintTime;
    property HideHintTime: Integer read GetHideHintTime;
    property IsScreenTipWindow: Boolean read FIsScreenTipWindow write SetIsScreenTipWindow;
  end;

  { TdxBarItem }

  TdxBarItem = class(TdxBarComponent)
  private
    FActionLink: TdxBarItemActionLink;
    FAlign: TdxBarItemAlign;
    FCanSelect: Boolean;
    FCaption: string;
    FCategory: Integer;
    FCheckDefaults: Boolean;
    FClickItemLink: TdxBarItemLink;
    FData: TObject;
    FDescription: string;
    FGlyph: TBitmap;
    FHelpContext: THelpContext;
    FHint: string;
    FImageIndex: Integer;
    FKeyTip: string;
    FLargeGlyph: TBitmap;
    FLargeImageIndex: Integer;
    FLinks: TList;  // the list of the itemlinks
    FLoadedVisible: TdxBarItemVisible;
    FMergeKind: TdxBarItemMergeKind;
    FMergeOrder: Integer;
    FPaintStyle: TdxBarPaintStyle;
    FShortCut: TShortCut;
    FStylesData: TdxBarItemStylesData;
    FScreenTip: TdxBarScreenTip;
    FUnclickAfterDoing: Boolean;
    FWidth: Integer;

    FOnClick: TNotifyEvent;
    FOnCreate: TNotifyEvent;
    FOnDestroy: TNotifyEvent;
    function GetAction: TBasicAction;
    function GetActiveLink: TdxBarItemLink;
    function GetActuallyVisible: Boolean;
    function GetCurItemLink: TdxBarItemLink;
    function GetFlat: Boolean;
    function GetIndex: Integer;
    function GetIsDesigning: Boolean;
    function GetIsDestroying: Boolean;
    function GetIsLoading: Boolean;
    function GetLinkCount: Integer;
    function GetLinks(Index: Integer): TdxBarItemLink;
    function GetPainterClass: TdxBarPainterClass;
    function GetVisibleForUser: Boolean;
    procedure SetAction(Value: TBasicAction);
    procedure SetAlign(Value: TdxBarItemAlign);
    procedure SetCategory(Value: Integer);
    procedure SetDescription(Value: string);
    procedure SetGlyph(Value: TBitmap);
    procedure SetGlyphLayout(Value: TdxBarGlyphLayout);
    procedure SetIndex(Value: Integer);
    procedure SetLargeGlyph(Value: TBitmap);
    procedure SetMergeOrder(Value: Integer);
    procedure SetPaintStyle(Value: TdxBarPaintStyle);
    procedure SetScreenTip(Value: TdxBarScreenTip);
    procedure SetShowCaption(Value: Boolean);
    procedure SetShortCut(Value: TShortCut);

    procedure DestroyLinks;
    procedure DoActionChange(Sender: TObject);
    function IsEnabledStored: Boolean;
    function IsHelpContextStored: Boolean;
    function IsHintStored: Boolean;
    function IsImageIndexStored: Boolean;
    function IsShortCutStored: Boolean;
    function IsVisibleStored: Boolean;
    function IsOnClickStored: Boolean;
    function GetHintFromCaption: string;
    procedure OnGlyphChanged(Sender: TObject);
    procedure OnLargeGlyphChanged(Sender: TObject);
  protected
    FGlyphLayout: TdxBarGlyphLayout;
    FShowCaption: Boolean;
  
    procedure AssignTo(Dest: TPersistent); override;
    function GetEnabled: Boolean; override;
    function GetWidth: Integer; virtual;
    procedure Loaded; override;
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
    procedure ReadState(Reader: TReader); override;
    procedure SelectionChanged; override;
    procedure SetName(const NewName: TComponentName); override;
    procedure SetEnabled(Value: Boolean); override;
    procedure SetVisible(Value: TdxBarItemVisible); override;
    procedure SetWidth(Value: Integer); virtual;

    // IdxBarSelectableItem
    function CanDelete(ADestruction: Boolean = False): Boolean; override;
    procedure ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction); override;
    procedure GetMasterObjects(AList: TdxObjectList); override;
    function GetNextSelectableItem: IdxBarSelectableItem; override;
    function GetSelectableParent: TPersistent; override;
    function GetSupportedActions: TdxBarCustomizationActions; override;
    procedure DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean); override;
    procedure Invalidate; override;
    function IsComplex: Boolean; override;
    function SelectParentComponent: Boolean; override;

    procedure ActionChange(Sender: TObject; CheckDefaults: Boolean); dynamic;
    procedure BarManagerChanged; virtual;
    function CanBePlacedOn(AParentKind: TdxBarItemControlParentKind;
      AToolbar: TdxBar; out AErrorText: string): Boolean; virtual;
    function CanChangePaintStyle: Boolean; virtual;
    function CanClicked: Boolean; virtual;
    function CanMergeWith(AItem: TdxBarItem): Boolean;
    property CanSelect: Boolean read FCanSelect write FCanSelect default True;
    function CurImageIndexLinked: Boolean;
    procedure DrawCustomizingImage(ACanvas: TCanvas; const ARect: TRect;
      AState: TOwnerDrawState); virtual;
    procedure DrawCustomizingImageContent(ACanvas: TCanvas; const ARect: TRect;
      ASelected: Boolean); virtual;
    function GetActionLinkClass: TdxBarItemActionLinkClass; dynamic;
    function GetActionImageIndex: Integer; virtual;
    procedure SetActionImageIndex(Value: Integer); virtual;
    function GetControlClass(AIsVertical: Boolean): TdxBarItemControlClass; virtual;
    function GetHidden: Boolean; virtual;
    function GetItemLinks: TdxBarItemLinks; virtual;
    class function GetStyleCount: Integer; virtual;
    function GetStyleValue(AIndex: Integer): TcxStyle;
    function HasAccel(AItemLink: TdxBarItemLink): Boolean; virtual;
    function HasControls: Boolean;
    procedure HideControl(AControl: TdxBarItemControl); virtual;
    function InternalActuallyVisible: Boolean; virtual;
    function InternalCanMergeWith(AItem: TdxBarItem): Boolean; virtual;
    function IsHintFromCaption: Boolean;
    function IsImageIndexLinked(AImageList: TCustomImageList; AImageIndex: Integer): Boolean;
    function IsShortCut(AShortCut: TShortCut): Boolean; virtual;
    function IsStyleColorSupported: Boolean; virtual;
    function NeedToBeHidden: Boolean; virtual;
    procedure ObjectNotification(AOperation: TOperation; AObject: TObject); virtual;
    procedure Recalculate; virtual;
    procedure SetImageIndex(Value: Integer); virtual;
    procedure SetLargeImageIndex(Value: Integer); virtual;
    procedure SetStyleValue(AIndex: Integer; Value: TcxStyle);
    procedure ShowDefaultEventHandler;
    procedure Update; virtual;
    procedure UpdateEx(AParentKinds: TdxBarKinds = dxBarKindAny); virtual;
    function UseHotImages: Boolean; virtual;
    function UseLargeImages: Boolean; virtual;

    // Change Group
    procedure CaptionChanged; virtual;
    procedure EnabledChanged; virtual;
    procedure GlyphChanged; virtual;
    procedure HotGlyphChanged; virtual;
    procedure InternalStyleChanged(AChangeKind: TdxBarItemStyleChangeKind);
    procedure LargeGlyphChanged; virtual;
    procedure PaintStyleChanged; virtual;
    procedure ShortCutChanged; virtual;
    procedure VisibleChanged; virtual;
    procedure WidthChanged; virtual;

    function GetCaption: string; virtual;
    function IsCaptionStored: Boolean; virtual;
    procedure SetCaption(const Value: string); virtual;

    procedure CheckLinks(ASource: TCustomIniFile; const ABaseSection: string); virtual;
    procedure LoadFromIni(ASource: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind); virtual;
    procedure LoadUsageData(ASource: TCustomIniFile; const ABaseSection: string); virtual;
    procedure SaveToIni(ADestination: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind); virtual;

    procedure GetTextViewParams(out AViewParams: TcxViewParams);
    procedure GetViewParams(AStyle: TcxStyle; out AViewParams: TcxViewParams);

    class function GetNewCaption: string; virtual;

    property ActionLink: TdxBarItemActionLink read FActionLink write FActionLink;
    property ActionImageIndex: Integer read GetActionImageIndex write SetActionImageIndex;
    property Flat: Boolean read GetFlat;
    property GlyphLayout: TdxBarGlyphLayout read FGlyphLayout write SetGlyphLayout;
    property Hidden: Boolean read GetHidden;
    property IsDesigning: Boolean read GetIsDesigning;
    property IsDestroying: Boolean read GetIsDestroying;
    property IsLoading: Boolean read GetIsLoading;
    property PainterClass: TdxBarPainterClass read GetPainterClass;
    property PaintStyle: TdxBarPaintStyle read FPaintStyle write SetPaintStyle default psStandard;
    property ShowCaption: Boolean read FShowCaption write SetShowCaption;
    property StylesData: TdxBarItemStylesData read FStylesData;
    property Width: Integer read GetWidth write SetWidth;
    property OnCreate: TNotifyEvent read FOnCreate write FOnCreate;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    procedure BeforeDestruction; override;
    procedure Click; dynamic;
    procedure DirectClick; dynamic;
    procedure DoClick; dynamic;
    function GetAddMessageName: string; virtual;
    function GetCurImages: TCustomImageList; virtual;
    function GetParentComponent: TComponent; override;
    function HasParent: Boolean; override;
    procedure SetParentComponent(AParent: TComponent); override;

    property ActuallyVisible: Boolean read GetActuallyVisible;
    property ClickItemLink: TdxBarItemLink read FClickItemLink;
    property CurItemLink: TdxBarItemLink read GetCurItemLink;
    property Data: TObject read FData write FData;
    property Glyph: TBitmap read FGlyph write SetGlyph;
    property ImageIndex: Integer read FImageIndex write SetImageIndex
      stored IsImageIndexStored default -1;
    property Index: Integer read GetIndex write SetIndex;
    property LargeGlyph: TBitmap read FLargeGlyph write SetLargeGlyph;
    property LargeImageIndex: Integer read FLargeImageIndex write SetLargeImageIndex default -1;
    property LinkCount: Integer read GetLinkCount;
    property Links[Index: Integer]: TdxBarItemLink read GetLinks;
    property ShortCut: TShortCut read FShortCut write SetShortCut
      stored IsShortCutStored default 0;
    property UnclickAfterDoing: Boolean read FUnclickAfterDoing write FUnclickAfterDoing
      default False;
    property VisibleForUser: Boolean read GetVisibleForUser;

    property OnClick: TNotifyEvent read FOnClick write FOnClick stored IsOnClickStored;
  published
    property Action: TBasicAction read GetAction write SetAction;
    property Align: TdxBarItemAlign read FAlign write SetAlign default iaLeft;
    property Caption: string read GetCaption write SetCaption stored IsCaptionStored;
    property Category: Integer read FCategory write SetCategory;
    property Description: string read FDescription write SetDescription;
    property Enabled stored IsEnabledStored default True;
    property HelpContext: THelpContext read FHelpContext write FHelpContext
      stored IsHelpContextStored default 0;
    property Hint: string read FHint write FHint stored IsHintStored;
    property KeyTip: string read FKeyTip write FKeyTip;
    property MergeKind: TdxBarItemMergeKind read FMergeKind write FMergeKind
      default mkAdd;
    property MergeOrder: Integer read FMergeOrder write SetMergeOrder default 0;
    property Style: TcxStyle index 0 read GetStyleValue write SetStyleValue;
    property ScreenTip: TdxBarScreenTip read FScreenTip write SetScreenTip;
    property Visible stored IsVisibleStored;

    property OnDestroy: TNotifyEvent read FOnDestroy write FOnDestroy;
  end;

  TdxBarLabel = class(TdxBarItem)
  public
    constructor Create(AOwner: TComponent); override;
  end;

  TdxBarSeparator = class(TdxBarLabel)
  protected
    function CanBePlacedOn(AParentKind: TdxBarItemControlParentKind;
      AToolbar: TdxBar; out AErrorText: string): Boolean; override;
    class function GetNewCaption: string; override;
    function GetSupportedActions: TdxBarCustomizationActions; override;
  published
    property ShowCaption default True;
  end;

  TdxBarWindowItem = class(TdxBarItem)
  private
    FEmptyWindow: Boolean;
    FText: string;

    FOnChange: TNotifyEvent;
    FOnCurChange: TNotifyEvent;
    FOnEnter: TNotifyEvent;
    FOnExit: TNotifyEvent;
    FOnKeyDown: TKeyEvent;
    FOnKeyPress: TKeyPressEvent;
    FOnKeyUp: TKeyEvent;

    function GetCurText: string;
    function GetFocusedItemLink: TdxBarItemLink;
    procedure SetCurText(Value: string);
  protected
    function CanClicked: Boolean; override;
    procedure Change; dynamic;
    procedure CurChange; dynamic;
    procedure DoEnter; dynamic;
    procedure DoExit; dynamic;
    function GetControlClass(AIsVertical: Boolean): TdxBarItemControlClass; override;
    function GetText: string; virtual;
    procedure KeyDown(var Key: Word; Shift: TShiftState); dynamic;
    procedure KeyPress(var Key: Char); dynamic;
    procedure KeyUp(var Key: Word; Shift: TShiftState); dynamic;
    procedure SetText(Value: string); virtual;
    property CurText: string read GetCurText write SetCurText;
    property EmptyWindow: Boolean read FEmptyWindow write FEmptyWindow;
    property Text: string read GetText write SetText;
  public
    procedure SetFocus(ACheckBarControlVisibility: Boolean = False); virtual;
    property FocusedItemLink: TdxBarItemLink read GetFocusedItemLink;
  published
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    property OnCurChange: TNotifyEvent read FOnCurChange write FOnCurChange;
    property OnEnter: TNotifyEvent read FOnEnter write FOnEnter;
    property OnExit: TNotifyEvent read FOnExit write FOnExit;
    property OnKeyDown: TKeyEvent read FOnKeyDown write FOnKeyDown;
    property OnKeyPress: TKeyPressEvent read FOnKeyPress write FOnKeyPress;
    property OnKeyUp: TKeyEvent read FOnKeyUp write FOnKeyUp;
  end;

  TdxBarButtonState = (bstChecked, bstDropDown);
  TdxBarButtonStates = set of TdxBarButtonState;
  TdxBarButtonStyle = (bsDefault, bsChecked, bsDropDown, bsCheckedDropDown);

  TdxBarButton = class(TdxBarItem, IdxBarLinksOwner)
  private
    FAllowAllUp: Boolean;
    FCloseSubMenuOnClick: Boolean;
    FDown: Boolean;
    FDropDownEnabled: Boolean;
    FDropDownMenu: TdxBarPopupMenu;
    FGroupIndex: Integer;
    FInternalStates: TdxBarButtonStates;
    FLowered: Boolean;

    function  GetButtonStyle: TdxBarButtonStyle;
    procedure SetAllowAllUp(Value: Boolean);
    procedure SetButtonStyle(Value: TdxBarButtonStyle);
    procedure SetDown(Value: Boolean);
    procedure SetDropDownEnabled(Value: Boolean);
    procedure SetDropDownMenu(Value: TdxBarPopupMenu);
    procedure SetGroupIndex(Value: Integer);
    procedure SetLowered(Value: Boolean);

    function IsDownStored: Boolean;
  protected
    function CanChangePaintStyle: Boolean; override;
    procedure DoDropDown(AControl: TdxBarButtonControl; X, Y: Integer;
      ByMouse: Boolean); dynamic;
    function HasAccel(AItemLink: TdxBarItemLink): Boolean; override;
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
    procedure PaintStyleChanged; override;

    // IdxBarLinksOwner
    function CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
    function CreateBarControl: TCustomdxBarControl;
    function IdxBarLinksOwner.GetInstance = GetComponentInstance;
    function GetItemLinks: TdxBarItemLinks; override;

    // IdxBarSelectableItem
    function GetSupportedActions: TdxBarCustomizationActions; override;

    class function GetNewCaption: string; override;
  public
    constructor Create(AOwner: TComponent); override;
    procedure Click; override;
  published
    property AllowAllUp: Boolean read FAllowAllUp write SetAllowAllUp default False;
    property ButtonStyle: TdxBarButtonStyle read GetButtonStyle write SetButtonStyle
      default bsDefault;
    property CloseSubMenuOnClick: Boolean read FCloseSubMenuOnClick write FCloseSubMenuOnClick
      default True;
    property DropDownEnabled: Boolean read FDropDownEnabled write SetDropDownEnabled default True;
    property GroupIndex: Integer read FGroupIndex write SetGroupIndex default 0;  // must be here
    property Down: Boolean read FDown write SetDown
      stored IsDownStored default False;
    property DropDownMenu: TdxBarPopupMenu read FDropDownMenu write SetDropDownMenu;
    property Glyph;
    property ImageIndex;
    property LargeGlyph;
    property LargeImageIndex;
    property Lowered: Boolean read FLowered write SetLowered default False;
    property PaintStyle;
    property ShortCut;
    property UnclickAfterDoing default True;

    property OnClick;
  end;

  TdxBarApplicationMenuButtonItem = class(TdxBarItem);

  TdxCustomBarEdit = class(TdxBarWindowItem)
  private
    FGlyphLoaded: Boolean;
    
  protected
    procedure ReadState(Reader: TReader); override;

    procedure DrawCustomizingImage(ACanvas: TCanvas; const ARect: TRect;
      AState: TOwnerDrawState); override;
    procedure GetEditViewParams(out AViewParams: TcxViewParams);
    class function GetStyleCount: Integer; override;
    function HasAccel(AItemLink: TdxBarItemLink): Boolean; override;
    procedure SetWidth(Value: Integer); override;
    property StyleEdit: TcxStyle index 1 read GetStyleValue write SetStyleValue;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property Glyph;
    property ImageIndex;
    property ShowCaption default False;
    property Width;
    property OnClick;
  end;

  TdxBarEdit = class(TdxCustomBarEdit)
  private
    FMaxLength: Integer;
    FReadOnly: Boolean;

    procedure SetMaxLength(Value: Integer);
  protected
    procedure DrawInterior(ABarEditControl: TdxBarEditControl; ACanvas: TCanvas;
      R: TRect; ItemLink: TdxBarItemLink); virtual;
  public
    property CurText;
  published
    property MaxLength: Integer read FMaxLength write SetMaxLength default 0;
    property ReadOnly: Boolean read FReadOnly write FReadOnly default False;
    property StyleEdit;
    property Text;
  end;

  TCustomdxBarCombo = class;

  TdxBarCheckKeyForDropDownWindowEvent = procedure (Sender: TCustomdxBarCombo;
    Key: Word; Shift: TShiftState; var AcceptKey: Boolean) of object;
  TdxBarGetDropDownWindowEvent = procedure (Sender: TCustomdxBarCombo;
    var Window: HWND) of object;

  TCustomdxBarCombo = class(TdxBarEdit)
  private
    FOnCheckKeyForDropDownWindow: TdxBarCheckKeyForDropDownWindowEvent;
    FOnCloseUp: TNotifyEvent;
    FOnDropDown: TNotifyEvent;
    FOnGetDropDownWindow: TdxBarGetDropDownWindowEvent;
    function GetDroppedDown: Boolean;
    function GetShowEditor: Boolean;
    procedure SetDroppedDown(Value: Boolean);
    procedure SetShowEditor(Value: Boolean);
  protected
    procedure AfterDropDown; dynamic;
    procedure CheckDropDownPoint(var X, Y: Integer);
    function CheckKeyForDropDownWindow(Key: Word; Shift: TShiftState): Boolean; virtual;
    procedure CloseUp; dynamic;
    procedure DrawCustomizingImage(ACanvas: TCanvas; const ARect: TRect;
      AState: TOwnerDrawState); override;
    procedure DropDown(X, Y: Integer); dynamic;
    function GetDropDownWindow: HWND; virtual;
    procedure InitDropDownWindow; virtual;
    procedure InternalInitDropDownWindow(ADropDownWindow: TWinControl);
  public
    property DropDownWindow: HWND read GetDropDownWindow;
    property DroppedDown: Boolean read GetDroppedDown write SetDroppedDown;
  published
    property ShowEditor: Boolean read GetShowEditor write SetShowEditor default True;

    property OnCheckKeyForDropDownWindow: TdxBarCheckKeyForDropDownWindowEvent
      read FOnCheckKeyForDropDownWindow write FOnCheckKeyForDropDownWindow;
    property OnCloseUp: TNotifyEvent read FOnCloseUp write FOnCloseUp;
    property OnDropDown: TNotifyEvent read FOnDropDown write FOnDropDown;
    property OnGetDropDownWindow: TdxBarGetDropDownWindowEvent
      read FOnGetDropDownWindow write FOnGetDropDownWindow;
  end;

  TdxBarCustomCombo = class;

  TdxBarDrawItemEvent = procedure(Sender: TdxBarCustomCombo; AIndex: Integer;
    ARect: TRect; AState: TOwnerDrawState) of object;

  TdxBarMeasureItemEvent = procedure(Sender: TdxBarCustomCombo; AIndex: Integer;
    var AHeight: Integer) of object;

  TdxBarCustomCombo = class(TCustomdxBarCombo)
  private
    FDropDownCount: Integer;
    FDropDownWidth: Integer;
    FInteriorIsDrawing: Boolean;
    FItemHeight: Integer;
    FItemIndex: Integer;
    FItems: TStrings;
    FListBox: TCustomListBox;
    FSorted: Boolean;
    FOnDrawItem: TdxBarDrawItemEvent;
    FOnMeasureItem: TdxBarMeasureItemEvent;

    function GetCurItemIndex: Integer;
    function GetItemsHeight(Index: Integer): Integer;
    procedure SetCurItemIndex(Value: Integer);
    procedure SetItemIndex(Value: Integer);
    procedure SetItems(Value: TStrings);
    procedure SetSorted(Value: Boolean);

    procedure CheckLocalPos;
    procedure ItemsChanged(Sender: TObject);
    procedure ListBoxDrawItem(Control: TWinControl; Index: Integer; Rect: TRect;
      State: TOwnerDrawState);
    procedure ListBoxMeasureItem(Control: TWinControl; Index: Integer; var Height: Integer);
  protected
    FCanvas: TCanvas;
    procedure AfterDropDown; override;
    function CheckKeyForDropDownWindow(Key: Word; Shift: TShiftState): Boolean; override;
    procedure CloseUp; override;
    procedure CurChange; override;
    procedure DrawInterior(ABarEditControl: TdxBarEditControl; ACanvas: TCanvas;
      R: TRect; ItemLink: TdxBarItemLink); override;
    procedure DrawItem(APainter: TdxBarPainter; AIndex: Integer; ARect: TRect;
      AState: TOwnerDrawState); virtual;
    procedure DropDown(X, Y: Integer); override;
    function GetCanvas: TCanvas; virtual;
    function GetDropDownWidth: Integer; virtual;
    function GetDropDownWindow: HWND; override;
    function GetNearestItemIndex(AText: string): Integer;
    procedure InitDropDownWindow; override;
    procedure MeasureItem(AIndex: Integer; var AHeight: Integer); virtual;
    procedure MeasureItemWidth(AIndex: Integer; var AWidth: Integer); virtual;
    procedure SetText(Value: string); override;
    property ListBox: TCustomListBox read FListBox;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    property Canvas: TCanvas read GetCanvas;
    property CurItemIndex: Integer read GetCurItemIndex write SetCurItemIndex;
    property ItemHeight: Integer read FItemHeight write FItemHeight default 0;
    property Items: TStrings read FItems write SetItems;
    property ItemsHeight[Index: Integer]: Integer read GetItemsHeight;
    property Sorted: Boolean read FSorted write SetSorted default False;
    property ItemIndex: Integer read FItemIndex write SetItemIndex;  // loading after all
  published
    property DropDownCount: Integer read FDropDownCount write FDropDownCount default 8;
    property DropDownWidth: Integer read FDropDownWidth write FDropDownWidth default 0;

    property OnDrawItem: TdxBarDrawItemEvent read FOnDrawItem write FOnDrawItem;
    property OnMeasureItem: TdxBarMeasureItemEvent read FOnMeasureItem write FOnMeasureItem;
  end;

  TdxBarCombo = class(TdxBarCustomCombo)
  published
    property ItemHeight;
    property Items;
    property Sorted;
    property ItemIndex;  // loading after all
  end;

  TCustomdxBarSubItem = class(TdxBarItem, IdxBarLinksOwner, IdxBarSubMenuOwner)
  private
    FBarSize: Integer;
    FDetachable: Boolean;
    FDetachingBar: TdxBar;
    FIsInternal: Boolean;
    FItemLinks: TdxBarItemLinks;
    FOnCloseUp: TNotifyEvent;
    FOnDetaching: TNotifyEvent;
    FOnPaintBar: TdxBarPaintSubMenuBarEvent;
    FOnPopup: TNotifyEvent;
    function GetDetachingBarIndex: Integer;
    function GetItemOptions: TdxBarItemOptions;
    procedure SetBarSize(Value: Integer);
    procedure SetDetachingBar(Value: Integer);
    procedure SetIsInternal(Value: Boolean);
    procedure SetItemLinks(Value: TdxBarItemLinks);
    procedure SetItemOptions(Value: TdxBarItemOptions);
  protected
    procedure BarManagerChanged; override;
    function CanClicked: Boolean; override;
    procedure DoCloseUp; dynamic;
    procedure DoDetaching; dynamic;
    procedure DoPopup; dynamic;
    procedure InternalDropDown(AItemControl: TdxBarSubItemControl; AByMouse: Boolean);
    procedure ObjectNotification(AOperation: TOperation; AObject: TObject); override;

    procedure CheckLinks(ASource: TCustomIniFile; const ABaseSection: string); override;
    function GetIniSection(const ABaseSection: string): string;
    procedure LoadFromIni(ASource: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind); override;
    procedure LoadUsageData(ASource: TCustomIniFile; const ABaseSection: string); override;
    procedure SaveToIni(ADestination: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind); override;

    // IdxBarLinksOwner
    function CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
    function CreateBarControl: TCustomdxBarControl; virtual;
    function IdxBarLinksOwner.GetInstance = GetComponentInstance;
    function GetItemLinks: TdxBarItemLinks; override;

    // IdxBarSelectableItem
    function GetSupportedActions: TdxBarCustomizationActions; override;

    // IdxBarSubMenuOwner
    function GetBarSize: Integer;
    procedure DoPaintBar(Canvas: TCanvas; const R: TRect); virtual;

    property IsInternal: Boolean read FIsInternal write SetIsInternal;
    property ItemOptions: TdxBarItemOptions read GetItemOptions write SetItemOptions;
    property OnCloseUp: TNotifyEvent read FOnCloseUp write FOnCloseUp;
    property OnPopup: TNotifyEvent read FOnPopup write FOnPopup;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function GetDetachingBar: TdxBar;
    procedure DropDown(AByMouse: Boolean = False);

    property ItemLinks: TdxBarItemLinks read GetItemLinks write SetItemLinks;
  published
    property BarSize: Integer read GetBarSize write SetBarSize default 0;
    property Detachable: Boolean read FDetachable write FDetachable default False;
    property DetachingBar: Integer read GetDetachingBarIndex write SetDetachingBar
      default -1;
    property Glyph;
    property ImageIndex;
    property LargeGlyph;
    property LargeImageIndex;
    property ShowCaption default True;
    property OnClick;
    property OnDetaching: TNotifyEvent read FOnDetaching write FOnDetaching;
    property OnPaintBar: TdxBarPaintSubMenuBarEvent read FOnPaintBar write FOnPaintBar;
  end;

  TdxBarSubItem = class(TCustomdxBarSubItem)
  private
    FAllowCustomizing: Boolean;
  protected
    class function GetNewCaption: string; override;
    function InternalCanMergeWith(AItem: TdxBarItem): Boolean; override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property AllowCustomizing: Boolean read FAllowCustomizing write FAllowCustomizing
      default True;
    property ItemLinks;
    property ItemOptions;
    property OnCloseUp;
    property OnPopup;
  end;

  TCustomdxBarContainerItem = class(TCustomdxBarSubItem)
  private
    FInOnGetData: Boolean;
    FNeedClearItemList: Boolean;
    FOnGetData: TNotifyEvent;
  protected
    procedure AddListedItemLinks(AItemLinks: TdxBarItemLinks; AIndex: Integer;
      FirstCall: Boolean; CallingItemLink: TdxBarItemLink); virtual;
    procedure DeleteListedItemLinks(AItemLinks: TdxBarItemLinks; AIndex: Integer); virtual;
    procedure ClearItemList; virtual;
    function HideWhenRun: Boolean; virtual;
    function InternalActuallyVisible: Boolean; override;
    procedure ItemsChanged(AItemLinks: TObject); virtual;
    procedure NeedClearItemList;
  published
    property OnGetData: TNotifyEvent read FOnGetData write FOnGetData;
  end;

  TdxBarListItem = class(TCustomdxBarContainerItem)
  private
    FItemIndex: Integer;
    FItemList: TComponentList;
    FItems: TStrings;
    FShowCheck: Boolean;
    FShowNumbers: Boolean;
    function GetDataIndex: Integer;
    function GetItemList: TList;
    procedure SetDataIndex(Value: Integer);
    procedure SetItems(Value: TStrings);
    procedure ClickItem(Sender: TObject);
  protected
    procedure AddListedItemLinks(AItemLinks: TdxBarItemLinks; AIndex: Integer;
      FirstCall: Boolean; CallingItemLink: TdxBarItemLink); override;
    procedure ClearItemList; override;
    procedure DeleteListedItemLinks(AItemLinks: TdxBarItemLinks; AIndex: Integer); override;
    function GetDisplayHint(const AText: string): string; virtual;
    function GetDisplayText(const AText: string): string; overload; virtual;
    function GetDisplayText(AItemIndex: Integer): string; overload; virtual;
    function InternalActuallyVisible: Boolean; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure DirectClick; override;
    property ItemList: TList read GetItemList;
  published
    property DataIndex: Integer read GetDataIndex write SetDataIndex stored False;
    property ItemIndex: Integer read FItemIndex write FItemIndex default -1;
    property Items: TStrings read FItems write SetItems;
    property LargeGlyph;
    property LargeImageIndex;
    property ShowCheck: Boolean read FShowCheck write FShowCheck default False;
    property ShowNumbers: Boolean read FShowNumbers write FShowNumbers default True;
  end;

  TdxBarContainerItem = class(TCustomdxBarContainerItem)
  protected
    procedure AddListedItemLinks(AItemLinks: TdxBarItemLinks; AIndex: Integer;
      FirstCall: Boolean; CallingItemLink: TdxBarItemLink); override;
    procedure DeleteListedItemLinks(AItemLinks: TdxBarItemLinks; AIndex: Integer); override;
    function InternalActuallyVisible: Boolean; override;
    function InternalCanMergeWith(AItem: TdxBarItem): Boolean; override;
    function IsItemsExist: Boolean; virtual;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property ItemLinks;
  end;

  TdxBarExtraPaneListItem = class(TdxBarListItem)
  private
    FOnGetDisplayText: TdxBarExtraPaneGetDisplayTextEvent;

    function GetExtraPaneItem(AIndex: Integer): TdxBarExtraPaneItem;
    property ExtraPaneItem[AIndex: Integer]: TdxBarExtraPaneItem read GetExtraPaneItem;
  protected
    procedure AddListedItemLinks(AItemLinks: TdxBarItemLinks; AIndex: Integer;
      FirstCall: Boolean; CallingItemLink: TdxBarItemLink); override;
    function GetDisplayHint(const AText: string): string; override;
    function GetDisplayText(AItemIndex: Integer): string; override;
    function InternalActuallyVisible: Boolean; override;

    property OnGetDisplayText: TdxBarExtraPaneGetDisplayTextEvent read FOnGetDisplayText write FOnGetDisplayText;
  end;

  {--------------------------------------
              Item's controls
   --------------------------------------}

  TdxBarSavedFont = record
    LogFont: TLogFont;
    Saved: Boolean;
  end;

  TdxBarItemControlDrawParams = class
  private
    FViewSize: TdxBarItemControlViewSize;
    FBarItemControl: TdxBarItemControl;

    procedure SetViewSize(Value: TdxBarItemControlViewSize);
  public
    Canvas: TcxCanvas;
    Caption: string;
    Description: string;
    ShortCut: string;
    PaintType: TdxBarPaintType;
    ViewStructure: TdxBarItemControlViewStructure;
    Enabled: Boolean;
    CanSelect: Boolean;
    DrawSelected: Boolean;
    DroppedDown: Boolean;
    IsDropDown: Boolean;
    HotPartIndex: Integer;
    IsCustomizing: Boolean;
    IsPressed: Boolean;
    SelectedByKey: Boolean;
    DefaultButtonSize: TSize;

    constructor Create(ABarItemControl: TdxBarItemControl);

    property BarItemControl: TdxBarItemControl read FBarItemControl;
    property ViewSize: TdxBarItemControlViewSize read FViewSize write SetViewSize;
  end;
  TdxBarItemControlDrawParamsClass = class of TdxBarItemControlDrawParams;

  TdxBarButtonLikeControlDrawParams = class(TdxBarItemControlDrawParams)
  public
    Downed: Boolean;
    DrawDowned: Boolean;
    DroppedDownFlat: Boolean;
    SplitDropDown: Boolean;
    DropDownEnabled: Boolean;
    IsTextSelected: Boolean;
    IsFlatText: Boolean;
    GrayScale: Boolean;
    IsLowered: Boolean;
    IsMenuItem: Boolean;
    ArrowSize: TSize;
    ButtonGroup: TdxBarButtonGroupRealPosition;
  end;

  TdxBarApplicationMenuButtonControlDrawParams = class(TdxBarButtonLikeControlDrawParams)
  public
    ContentWidth: Integer;
  end;

  TdxBarEditLikeControlDrawParams = class(TdxBarItemControlDrawParams)
  private
    function GetBarEditControl: TdxBarEditControl;
  public
    Focused: Boolean;
    IsTransparent: Boolean;
    property BarEditControl: TdxBarEditControl read GetBarEditControl;
  end;

  TdxBarStaticLikeControlDrawParams = class(TdxBarItemControlDrawParams)
  private
    function GetBarStaticControl: TdxBarCustomStaticControl;
  public
    Alignment: TAlignment;
    AllowCenter: Boolean;
    BorderOffsets: TRect;
    BorderStyle: TdxBarStaticBorderStyle;
    property BarStaticControl: TdxBarCustomStaticControl read GetBarStaticControl;
  end;

  TdxBarSeparatorControlDrawParams = class(TdxBarStaticLikeControlDrawParams)
  public
    IsTop: Boolean;
  end;

  TdxBarColorComboControlDrawParams = class(TdxBarEditLikeControlDrawParams)
  public
    IsShowCustomColorButton: Boolean;
  end;

  TdxBarSpinEditDrawParams = class(TdxBarEditLikeControlDrawParams)
  public
    ArrowSize: TSize;
    ActiveButtonIndex: Integer;
  end;

  TdxBarProgressControlDrawParams = class(TdxBarStaticLikeControlDrawParams)
  public
    Smooth: Boolean;
    Position: Integer;
    Min: Integer;
    Max: Integer;
  end;

  TdxBarInPlaceSubItemControlDrawParams = class(TdxBarButtonLikeControlDrawParams)
  public
    IsExpanded: Boolean;
  end;

  TdxBarItemControlViewInfo = class(TcxInterfacedPersistent, IdxBarItemControlViewInfo)
  private
    FAllowedViewLevels: TdxBarItemViewLevels;
    FBounds: TRect;
    FColumnRowCount: Integer;
    FImageBounds: TRect;
    FMinPossibleViewLevel: TdxBarItemRealViewLevel;
    FRealPositionInButtonGroup: TdxBarButtonGroupRealPosition;
    FRow: Integer;
    FViewLevel: TdxBarItemViewLevel;
    FViewLevelForButtonGroup: TdxBarItemRealViewLevel;
    FViewLevelInfos: array [TdxBarItemRealViewLevel] of TdxBarItemCachedWidthInfo;
  protected
    FControl: TdxBarItemControl;

    // IdxBarItemControlViewInfo
    procedure CalculateFinalize;
    function GetAlign: TdxBarItemAlign;
    function GetAllowedViewLevels: TdxBarItemViewLevels;
    function GetBounds: TRect;
    function GetColumnRowCount: Integer;
    function GetDistributed: Boolean;
    function GetPosition: TdxBarItemPosition;
    function GetPositionInButtonGroup: TdxBarButtonGroupPosition;
    function GetRealPositionInButtonGroup: TdxBarButtonGroupRealPosition;
    function GetRow: Integer;
    function GetViewLevel: TdxBarItemViewLevel;
    function GetViewLevelForButtonGroup: TdxBarItemRealViewLevel;
    function GetWidth(AViewLevel: TdxBarItemRealViewLevel): Integer;
    function HasSeparator: Boolean;
    function IsPrimaryForDistribution: Boolean;
    function IsMultiColumnItemControl(ACheckCollapsed: Boolean;
      out AIMultiColumnItemControlViewInfo: IdxBarMultiColumnItemControlViewInfo): Boolean;
    procedure SetBounds(const Value: TRect);
    procedure SetColumnRowCount(Value: Integer);
    procedure SetDistributed(Value: Boolean);
    procedure SetRealPositionInButtonGroup(Value: TdxBarButtonGroupRealPosition);
    procedure SetRow(Value: Integer);
    procedure SetViewLevel(Value: TdxBarItemViewLevel);

    procedure BoundsCalculated; virtual;
  public
    constructor Create(AControl: TdxBarItemControl); reintroduce; virtual;
    destructor Destroy; override;
    procedure ResetCachedValues; virtual;
    property Bounds: TRect read GetBounds;
    property Control: TdxBarItemControl read FControl;
    property ImageBounds: TRect read FImageBounds write FImageBounds;
    property MinPossibleViewLevel: TdxBarItemRealViewLevel read FMinPossibleViewLevel;
    property RealPositionInButtonGroup: TdxBarButtonGroupRealPosition
      read FRealPositionInButtonGroup;
    property ViewLevel: TdxBarItemViewLevel read GetViewLevel;
  end;

  TdxBarItemControlViewInfoClass = class of TdxBarItemControlViewInfo;

  TdxCachedImageOptions = class
  private
    FCached: Boolean;
    FGlyph: TcxBitmap;

    FCachedDrawMode: TcxImageDrawMode;
    FCachedImages: TCustomImageList;
    FCachedGlyph: TBitmap;
  public
    constructor Create;
    destructor Destroy; override;

    procedure Cache(const ARect: TRect; AGlyph: TBitmap;
      AImages: TCustomImageList; AImageIndex: Integer; ADrawMode: TcxImageDrawMode;
      ATransparentColor: TColor; ASmoothImage, AUseLeftBottomPixelAsTransparent: Boolean);
    function IsCached(ADrawMode: TcxImageDrawMode; AGlyph: TBitmap; AImages: TCustomImageList): Boolean;

    property Cached: Boolean read FCached write FCached;
    property Glyph: TcxBitmap read FGlyph;
  end;

  TdxBarItemControl = class(TcxIUnknownObject, IdxFadingObject, IdxBarHintKeeper)
  private
    FActiveCanvas: TcxCanvas;
    FBkBrush: HBRUSH;
    FBreakingRow: Boolean;
    FCachedImageOptions: TdxCachedImageOptions;
    FChangeRecentGroup: Boolean;
    FFadingElementData: IdxFadingElementData;
    FIAccessibilityHelper: IdxBarAccessibilityHelper;
    FIsActive: Boolean;
    FItemLink: TdxBarItemLink;
    FLastInRow: Boolean;
    FNonRecent: Boolean;
    FParent: TCustomdxBarControl;
    FPressed: Boolean;
    FSelectedByMouse: Boolean;
    FTextSize: Integer;

    procedure DoCalculateParts;
    function FindPartAtPos(APoint: TPoint): Integer;
    function GetAlign: TdxBarItemAlign;
    function GetBarManager: TdxBarManager;
    function GetBkBrush: HBRUSH;
    function GetCanvas: TcxCanvas;
    function GetFlat: Boolean;
    function GetIAccessibilityHelper: IdxBarAccessibilityHelper;
    function GetIsFadingAvailable: Boolean;
    function GetIsSelected: Boolean;
    function GetItem: TdxBarItem;
    function GetItemBarManager: TdxBarManager;
    function GetItemBounds: TRect;
    function GetPainterClass: TdxBarPainterClass;
    function GetRealHeight: Integer;
    function GetRealWidth: Integer;
    function GetShowDescription: Boolean;
    function GetSubMenuParent: TdxBarSubMenuControl;
    function GetUnclickAfterDoing: Boolean;
    function InternalGetPossibleViewLevels: TdxBarItemViewLevels;
    procedure SetPressed(Value: Boolean);
  protected
    FDrawParams: TdxBarItemControlDrawParams;
    FHotPartIndex: Integer;
    FParts: array of TRect;
    FViewInfo: TdxBarItemControlViewInfo;
    // IdxFadingObject
    function CanFade: Boolean; virtual;
    procedure DrawFadeImage; virtual;
    procedure FadingBegin(AData: IdxFadingElementData); virtual;
    procedure FadingEnd; virtual;
    procedure GetFadingParams(
      out AFadeOutImage, AFadeInImage: TcxBitmap;
      var AFadeInAnimationFrameCount, AFadeInAnimationFrameDelay: Integer;
      var AFadeOutAnimationFrameCount, AFadeOutAnimationFrameDelay: Integer); virtual;
    // IdxBarHintKeeper
    function DoHint(var ANeedDeactivate: Boolean; out AHintText: string; out AShortCut: string): Boolean; virtual;
    function CreateHintViewInfo(const AHintText, AShortCut: string): TdxBarCustomHintViewInfo; virtual;
    function GetEnabled: Boolean; virtual;
    function GetHintPosition(const ACursorPos: TPoint; AHeight: Integer): TPoint; virtual;

    // fading
    function GetFader: TdxFader; virtual;

    // Change Group
    procedure BeginGroupChanged; virtual;
    procedure CaptionChanged; virtual;
    procedure EnabledChanged; virtual;
    procedure GlyphChanged; virtual;
    procedure HotGlyphChanged; virtual;
    procedure LargeGlyphChanged; virtual;
    procedure PartsChanged; virtual;
    procedure PaintStyleChanged; virtual;
    procedure ParentVisibleChange(AIsShowing: Boolean); virtual;
    procedure PressedChanged; virtual;
    procedure RealVisibleChanging(AVisible: Boolean); virtual;
    procedure VisibleChanged; virtual;
    procedure WidthChanged; virtual;
    procedure ResetCachedValues(AFull: Boolean);

    function UseLargeGlyph(AViewSize: TdxBarItemControlViewSize): Boolean;
    function UseLargeIcons: Boolean;
    function UseLargeImageSource(AViewSize: TdxBarItemControlViewSize): Boolean;
    function UseLargeImageList(AViewSize: TdxBarItemControlViewSize): Boolean;
    procedure BeforeDestroyParentHandle; virtual;
    function CanBePartOfButtonGroup: Boolean; virtual;
    function CanClicked: Boolean; virtual;
    function CanCustomize: Boolean; virtual;
    function CanDeselect(ABarManager: TdxBarManager): Boolean; virtual;
    function CanHide: Boolean; virtual;
    function CanMouseSelect: Boolean; virtual;
    function CanSelect: Boolean; virtual;
    function CanShowShortCut: Boolean;
    function CanVisuallyPressed: Boolean;
    procedure CheckHotTrack(APoint: TPoint); virtual;
    procedure Click(AByMouse: Boolean; AKey: Char = #0); virtual;
    procedure ControlActivate(Immediately: Boolean); virtual;
    procedure ControlInactivate(Immediately: Boolean); virtual;
    procedure ControlClick(AByMouse: Boolean; AKey: Char = #0); virtual;
    procedure ControlUnclick(ByMouse: Boolean); virtual;
    procedure ControlGetFocus(AIsSelected: Boolean; var AProcessed: Boolean); virtual;
    procedure DblClick; dynamic;
    function DrawSelected: Boolean; virtual;
    function GetSelectableObject: TPersistent;
    function WantsDblClick: Boolean; dynamic;

    // User Events Group
    procedure KeyDown(var Key: Word; Shift: TShiftState); dynamic;
    procedure KeyUp(var Key: Word; Shift: TShiftState); dynamic;
    procedure KeyPress(var Key: Char); dynamic;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); dynamic;
    procedure MouseEnter(Shift: TShiftState; X, Y: Integer); dynamic;
    procedure MouseLeave; dynamic;
    procedure MouseMove(Shift: TShiftState; X, Y: Integer); dynamic;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); dynamic;
    function WantsKey(Key: Word): Boolean; virtual;

    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; virtual;
    function GetPossibleViewLevels: TdxBarItemViewLevels; virtual;
    function GetViewLevels: TdxBarItemViewLevels;
    function GetViewStructure: TdxBarItemControlViewStructure; virtual;
    function GetDefaultViewStructure: TdxBarItemControlViewStructure; virtual;
    function GetViewSize: TdxBarItemControlViewSize;
    function GetDefaultViewSize: TdxBarItemControlViewSize; virtual;
    function GetPaintType: TdxBarPaintType; virtual;
    function GetPartCount: Integer; virtual;
    function GetViewInfoClass: TdxBarItemControlViewInfoClass; virtual;
    function GrayScale: Boolean; virtual;
    function HasIcon(AViewSize: TdxBarItemControlViewSize; AViewStructure: TdxBarItemControlViewStructure): Boolean;
    function IconAssigned(AViewSize: TdxBarItemControlViewSize): Boolean;

    procedure FrameAndFillRect(DC: HDC; var R: TRect; Enabled, Selected, Pressed: Boolean);

    function GetCaption: string; virtual;
    function GetControl: TControl; virtual;
    function GetDrawParamsClass: TdxBarItemControlDrawParamsClass; virtual;
    function GetGlyph: TBitmap; virtual;
    function GetImageEnabled(APaintType: TdxBarPaintType): Boolean; virtual;
    function GetImageIndex: Integer; virtual;
    function GetImageList(AViewSize: TdxBarItemControlViewSize): TCustomImageList; virtual;
    function GetImages: TCustomImageList; virtual;
    function GetHint: string; virtual;
    function GetHotImages: TCustomImageList; virtual;
    function GetLargeGlyph: TBitmap; virtual;
    function GetLargeImageIndex: Integer; virtual;
    function GetLargeImages: TCustomImageList; virtual;
    function GetMenuItemSize: TdxBarMenuItemSize; virtual;
    function GetPainter: TdxBarPainter; virtual;
    function GetShortCut: TShortCut; virtual;
    function GetTextAreaOffset: Integer; virtual;

    // Draw Group
    procedure CalcDrawParams(AFull: Boolean = True); virtual;
    procedure CalcParts; virtual;
    procedure CalcDrawingConsts; virtual;
    procedure DoCalcDrawingConsts; virtual;
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); virtual;
    function IsTransparentOnGlass: Boolean; virtual;
    procedure PrepareCanvasFont(ABaseFont: HFONT; AStyle: TcxStyle;
      out ASavedFont: TdxBarSavedFont); virtual;
    procedure RestoreCanvasFont(const ASavedFont: TdxBarSavedFont); virtual;

    function GetOwnedBarControl: TCustomdxBarControl; virtual;

    function GetNonBufferedRect: TRect; virtual;
    function GetCaptionWidth: Integer; virtual;
    function GetCurrentImage(AViewSize: TdxBarItemControlViewSize; ASelected: Boolean;
      out ACurrentGlyph: TBitmap; out ACurrentImages: TCustomImageList; out ACurrentImageIndex: Integer): Boolean; virtual;
    function GetCurrentImageIndex(AViewSize: TdxBarItemControlViewSize): Integer; virtual;
    function GetGlyphSize(AViewSize: TdxBarItemControlViewSize; ASelected: Boolean = False): TSize; virtual;
    function GetIndents(ADrawAreaType: TdxBarItemControlPart): TRect; virtual;
    function GetRotationDependentHeight(ASourceSize: TSize): Integer;
    function GetRotationDependentWidth(ASourceSize: TSize): Integer;
    function GetTextExtent(const AText: string): TSize;
    function GetTextHeight: Integer;
    function GetTextSize: Integer; // TODO property
    function GetTextWidth(const AText: string): Integer;

    function GetCaptionAreaWidth: Integer; virtual;
    function GetControlAreaWidth: Integer; virtual;
    function GetGlyphAreaWidth: Integer; virtual;

    function GetControlCaptionOffset: Integer; virtual;
    function GetDefaultHeight: Integer; virtual;
    function GetDefaultWidth: Integer; virtual;
    function GetDefaultWidthHorzLayout: Integer; virtual;
    function GetDefaultWidthVertLayout: Integer; virtual;

    function GetDefaultHeightInSubMenu: Integer; virtual;
    function GetDefaultWidthInSubMenu: Integer; virtual;
    function GetMinHeight: Integer; virtual;
    function GetMinWidth: Integer; virtual;
    function GetHeight: Integer;
    function GetWidth: Integer;
    function GetWidthByViewLevel(AViewLevel: TdxBarItemRealViewLevel): Integer;
    function GetLargeHeight: Integer; virtual;
    function GetSmallHeight: Integer; virtual;
    function InternalGetDefaultHeight: Integer; virtual;
    function InternalGetDefaultWidth: Integer; virtual;

    // Ask Group
    function HasHint: Boolean; virtual;
    function HasShadow: Boolean; virtual;
    function HotPartWantMouse: Boolean; virtual;
    function IsBkColorAssigned: Boolean;
    function IsChildWindow(AWnd: HWND): Boolean; virtual;
    function IsDestroyOnClick: Boolean; virtual;
    function IsDropDown: Boolean; virtual;
    function IsEditTransparent: Boolean; virtual;
    function IsExpandable: Boolean; virtual;
    function IsHiddenForCustomization: Boolean; virtual;
    function IsInvertTextColor: Boolean; virtual;
    function IsMenuItem: Boolean; virtual;
    function IsRotated: Boolean; virtual;
    function IsSelectionForbidden: Boolean;
    function MousePressed: Boolean;
    function NeedCaptureMouse: Boolean; virtual;
    function WantMouse: Boolean;

    procedure CheckNonRecent;
    procedure UncheckNonRecent;

    // Resize Group
    procedure BeginResize(APoint: TPoint); virtual;
    function CanResize(APoint: TPoint): Boolean; virtual;
    procedure EndResize(AAllowResize: Boolean); virtual;
    procedure Resizing(APoint: TPoint); virtual;

    property Align: TdxBarItemAlign read GetAlign;
    property BkBrush: HBRUSH read GetBkBrush;
    property Canvas: TcxCanvas read GetCanvas;
    property Caption: string read GetCaption;
    property Control: TControl read GetControl;
    property DrawParams: TdxBarItemControlDrawParams read FDrawParams;
    property Fader: TdxFader read GetFader;
    property FadingElementData: IdxFadingElementData read FFadingElementData;
    property Flat: Boolean read GetFlat;
    property Glyph: TBitmap read GetGlyph;
    property Height: Integer read GetRealHeight;
    property Hint: string read GetHint;
    property HotImages: TCustomImageList read GetHotImages;
    property ImageIndex: Integer read GetImageIndex;
    property Images: TCustomImageList read GetImages;
    property IsFadingAvailable: Boolean read GetIsFadingAvailable;
    property LargeGlyph: TBitmap read GetLargeGlyph;
    property LargeImageIndex: Integer read GetLargeImageIndex;
    property LargeImages: TCustomImageList read GetLargeImages;
    property LastInRow: Boolean read FLastInRow write FLastInRow;
    property MenuItemSize: TdxBarMenuItemSize read GetMenuItemSize;
    property MinHeight: Integer read GetMinHeight;
    property MinWidth: Integer read GetMinWidth;
    property NonRecent: Boolean read FNonRecent;
    property OwnedBarControl: TCustomdxBarControl read GetOwnedBarControl;
    property PossibleViewLevels: TdxBarItemViewLevels read InternalGetPossibleViewLevels;
    property Pressed: Boolean read FPressed write SetPressed;
    property ShortCut: TShortCut read GetShortCut;
    property ShowDescription: Boolean read GetShowDescription;
    property SubMenuParent: TdxBarSubMenuControl read GetSubMenuParent;
    property TextAreaOffset: Integer read GetTextAreaOffset;
    property UnclickAfterDoing: Boolean read GetUnclickAfterDoing;
    property ViewLevels: TdxBarItemViewLevels read GetViewLevels;
    property Width: Integer read GetRealWidth;
  public
    constructor Create(AItemLink: TdxBarItemLink); virtual;
    destructor Destroy; override;

    class function HasWindow: Boolean; virtual;
    function IsDroppedDown: Boolean; virtual;
    procedure Paint(ACanvas: TcxCanvas; ARect: TRect; PaintType: TdxBarPaintType);
    procedure Repaint; virtual;

    property BarManager: TdxBarManager read GetBarManager;
    property Enabled: Boolean read GetEnabled;
    property IAccessibilityHelper: IdxBarAccessibilityHelper read GetIAccessibilityHelper;
    property IsActive: Boolean read FIsActive;
    property IsSelected: Boolean read GetIsSelected;
    property Item: TdxBarItem read GetItem;
    property ItemBounds: TRect read GetItemBounds;
    property ItemLink: TdxBarItemLink read FItemLink;
    property Painter: TdxBarPainter read GetPainter;
    property PainterClass: TdxBarPainterClass read GetPainterClass;
    property Parent: TCustomdxBarControl read FParent;
    property ViewInfo: TdxBarItemControlViewInfo read FViewInfo;
  end;

  TdxBarCustomStaticControl = class(TdxBarItemControl)
  private
    function GetDrawParams: TdxBarStaticLikeControlDrawParams;
  protected
    function CanClicked: Boolean; override;
    function CanSelect: Boolean; override;
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); override;
    procedure DrawInterior(ARect: TRect); virtual; abstract;
    function GetDefaultViewStructure: TdxBarItemControlViewStructure; override;
    function GetDrawParamsClass: TdxBarItemControlDrawParamsClass; override;
    property DrawParams: TdxBarStaticLikeControlDrawParams read GetDrawParams;
  end;

  TdxBarSeparatorControl = class(TdxBarCustomStaticControl)
  private
    function GetDrawParams: TdxBarSeparatorControlDrawParams;
  protected
    procedure CalcDrawParams(AFull: Boolean = True); override;
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); override;
    function GetIndents(ADrawAreaType: TdxBarItemControlPart): TRect; override;

    function GetMenuItemSize: TdxBarMenuItemSize; override;
    function GetGlyphAreaWidth: Integer; override;

    function GetDefaultHeightInSubMenu: Integer; override;
    function GetDefaultWidthInSubMenu: Integer; override;
    function GetMinWidth: Integer; override;
    function InternalGetDefaultHeight: Integer; override;
    function InternalGetDefaultWidth: Integer; override;

    procedure PrepareCanvasFont(ABaseFont: HFONT; AStyle: TcxStyle;
      out ASavedFont: TdxBarSavedFont); override;
    procedure RestoreCanvasFont(const ASavedFont: TdxBarSavedFont); override;

    function GetDefaultViewStructure: TdxBarItemControlViewStructure; override;
    function GetDrawParamsClass: TdxBarItemControlDrawParamsClass; override;
    property DrawParams: TdxBarSeparatorControlDrawParams read GetDrawParams;
  end;

  TdxBarWinControl = class(TdxBarItemControl)
  private
    FInnerControlBufferedPaint: Boolean;
    FDefWndProc: Pointer;
    FFocused: Boolean;
    FFocusing: Boolean;
    FKeyPressedInside: Integer;
    FOnGlass: Boolean;
    FPrevDefWndProc: Pointer;
    FWindowRect: TRect;
    function DoCallKeyboardHook(wParam: WParam; lParam: LParam): Boolean;
    function GetItem: TdxBarWindowItem;
    function GetWindowRect: TRect;
    procedure SetWindowRect(const Value: TRect);
  protected
    function CanClicked: Boolean; override;
    function CanDeselect(ABarManager: TdxBarManager): Boolean; override;
    function CanSelect: Boolean; override;
    procedure ControlInactivate(Immediately: Boolean); override;
    procedure ControlClick(AByMouse: Boolean; AKey: Char = #0); override;
    procedure ControlGetFocus(AIsSelected: Boolean; var AProcessed: Boolean); override;
    procedure EnabledChanged; override;
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; override;
    function IsChildWindow(AWnd: HWND): Boolean; override;
    function IsDestroyOnClick: Boolean; override;
    function IsWindowEnabled: Boolean;
    procedure KeyDown(var Key: Word; Shift: TShiftState); override;
    procedure KeyPress(var Key: Char); override;
    procedure KeyUp(var Key: Word; Shift: TShiftState); override;

    function ClientToParent(const APoint: TPoint): TPoint;
    function ParentToClient(const APoint: TPoint): TPoint;

    procedure CreateInnerEdit; virtual;
    procedure DestroyInnerEdit(AFullDestroy: Boolean = True); virtual;

    procedure DoEnter;
    procedure DoEscape;
    procedure DoNavigation;

    // MessageHandler
    function DoKeyDown(var Message: TWMKey): Boolean;
    function DoKeyPress(var Message: TWMKey): Boolean;
    function DoKeyUp(var Message: TWMKey): Boolean;
    procedure DoKillFocus(var Message: TMessage);
    procedure DoMouseDown(var Message: TWMMouse; AButton: TMouseButton;
      AShift: TShiftState);

    procedure ActivateEdit(AByMouse: Boolean; AKey: Char = #0); virtual;
    function GetHandle: HWND; virtual; abstract;
    function GetText: string; virtual;
    procedure Hide(AStoreDisplayValue: Boolean); virtual; abstract;
    procedure KillFocus(AHandle: THandle); dynamic;
    procedure MainWndProc(var Message: TMessage);
    procedure PrepareEditWnd; virtual;
    procedure RestoreDisplayValue; virtual;
    procedure SetFocused(Value: Boolean); virtual;
    procedure SetText(Value: string); virtual;
    procedure Show; virtual; 
    procedure StoreDisplayValue; virtual;
    procedure SysKeyDown(var Key: Word; Shift: TShiftState); virtual;
    procedure SysKeyUp(var Key: Word; Shift: TShiftState); virtual;
    procedure TransferMessage(AFromWindow: HWND; const Message: TMessage);
    procedure WndProc(var Message: TMessage); virtual;

    property InnerControlBufferedPaint: Boolean read FInnerControlBufferedPaint write FInnerControlBufferedPaint;
  public
    procedure DefaultHandler(var Message); override;
    class function HasWindow: Boolean; override;
    function HandleAllocated: Boolean;
    property Focused: Boolean read FFocused write SetFocused;
    property Handle: HWND read GetHandle;
    property Item: TdxBarWindowItem read GetItem;
    property OnGlass: Boolean read FOnGlass;
    property Text: string read GetText write SetText;
    property WindowRect: TRect read GetWindowRect write SetWindowRect;
  end;

  TdxBarButtonLikeControl = class(TdxBarItemControl)
  private
    FShowAnimation: Boolean;
    function GetDrawParams: TdxBarButtonLikeControlDrawParams;
  protected
    function CanFade: Boolean; override;
    procedure GetFadingParams(out AFadeOutImage: TcxBitmap;
      out AFadeInImage: TcxBitmap; var AFadeInAnimationFrameCount: Integer;
      var AFadeInAnimationFrameDelay: Integer; var AFadeOutAnimationFrameCount: Integer;
      var AFadeOutAnimationFrameDelay: Integer); override;

    function ArrowWidth: Integer; virtual;
    procedure CalcDrawParams(AFull: Boolean = True); override;
    function CanActivate: Boolean; virtual;
    function CanBePartOfButtonGroup: Boolean; override;
    procedure ControlActivate(Immediately: Boolean); override;
    procedure ControlInactivate(Immediately: Boolean); override;
    procedure ControlGetFocus(AIsSelected: Boolean; var AProcessed: Boolean); override;
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); override;
    procedure DropDown(AByMouse: Boolean); virtual;
    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; override;
    function GetDrawParamsClass: TdxBarItemControlDrawParamsClass; override;
    function GetSubMenuControl: TdxBarSubMenuControl; virtual;
    function IsFlatText: Boolean; virtual;
    function IsTextSelected: Boolean; virtual;

    procedure KeyDown(var Key: Word; Shift: TShiftState); override;
    function WantsKey(Key: Word): Boolean; override;

    procedure FinishSubMenuTracking;
    procedure StartSubMenuTracking(AActivation: Boolean);

    procedure DoCloseUp(AHadSubMenuControl: Boolean); dynamic;
    procedure DoDropDown(AByMouse: Boolean); dynamic; abstract;

    property DrawParams: TdxBarButtonLikeControlDrawParams read GetDrawParams;
  public
    destructor Destroy; override;
    property SubMenuControl: TdxBarSubMenuControl read GetSubMenuControl;
  end;

  TdxBarButtonControl = class(TdxBarButtonLikeControl)
  private
    FDroppedDown: Boolean;
    function GetButtonItem: TdxBarButton;
    function GetDown: Boolean;
    function GetDropDownEnabled: Boolean;
    function GetDroppedDownFlat: Boolean;
    function GetGroupIndex: Integer;
    function GetInternalStates: TdxBarButtonStates;
    function GetLowered: Boolean;
    function MouseOverArrow: Boolean;
  protected
    function ArrowPressed: Boolean;
    procedure CalcDrawParams(AFull: Boolean = True); override;
    procedure CalcParts; override;
    procedure ControlClick(AByMouse: Boolean; AKey: Char = #0); override;
    procedure ControlUnclick(ByMouse: Boolean); override;
    procedure ControlGetFocus(AIsSelected: Boolean; var AProcessed: Boolean); override;
    procedure DoCloseUp(AHadSubMenuControl: Boolean); override;
    procedure DoDropDown(AByMouse: Boolean); override;
    function DrawSelected: Boolean; override;
    procedure DropDown(AByMouse: Boolean); override;
    function GetSubMenuControl: TdxBarSubMenuControl; override;
    function IsFlatText: Boolean; override;
    function IsTextSelected: Boolean; override;

    function GetDefaultHeight: Integer; override;
    function GetDefaultWidth: Integer; override;
    function GetSmallHeight: Integer; override;

    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; override;
    function GetDefaultViewStructure: TdxBarItemControlViewStructure; override;
    function GetOwnedBarControl: TCustomdxBarControl; override;
    function GetPaintStyle: TdxBarPaintStyle; virtual;
    function GetPartCount: Integer; override;
    function GetViewStructure: TdxBarItemControlViewStructure; override;
    function IsDestroyOnClick: Boolean; override;
    function IsDropDown: Boolean; override;
    function IsPressed: Boolean;
    function NeedCaptureMouse: Boolean; override;
    procedure PaintStyleChanged; override;
    procedure PreparePaintStyleOnBar(var APaintStyle: TdxBarPaintStyle); virtual;

    property Down: Boolean read GetDown;
    property DropDownEnabled: Boolean read GetDropDownEnabled;
    property DroppedDown: Boolean read FDroppedDown;
    property DroppedDownFlat: Boolean read GetDroppedDownFlat; // TODO: obsolete
    property GroupIndex: Integer read GetGroupIndex;
    property InternalStates: TdxBarButtonStates read GetInternalStates;
    property Lowered: Boolean read GetLowered;
    property PaintStyle: TdxBarPaintStyle read GetPaintStyle;
  public
    function IsDroppedDown: Boolean; override;
    property ButtonItem: TdxBarButton read GetButtonItem;
  end;

  TdxBarApplicationMenuButtonControl = class(TdxBarButtonLikeControl)
  private
    function GetDrawParams: TdxBarApplicationMenuButtonControlDrawParams;
  protected
    procedure CalcDrawParams(AFull: Boolean = False); override;
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); override;
    function GetDefaultViewStructure: TdxBarItemControlViewStructure; override;
    function GetDrawParamsClass: TdxBarItemControlDrawParamsClass; override;
    function GetPaintType: TdxBarPaintType; override;
    function InternalGetDefaultWidth: Integer; override;

    procedure CaptionChanged; override;
    procedure GlyphChanged; override;
    procedure VisibleChanged; override;
    procedure WidthChanged; override;

    property DrawParams: TdxBarApplicationMenuButtonControlDrawParams read GetDrawParams;
  end;

  TdxBarCustomEditControl = class(TdxBarWinControl)
  private
    FBkBrush: TBrush;
    FEditTextSize: Integer;
    FSizingEditWidth: Integer;
    FRightBorderSizing: Boolean;
    function GetCaptionBkBrush: HBRUSH;
    function GetDrawParams: TdxBarEditLikeControlDrawParams;
    function GetEditBkBrush: HBRUSH;
    function GetEditFont: TFont;
    function GetItem: TdxCustomBarEdit;
    function LeftSizingRect: TRect;
    function RightSizingRect: TRect;
  protected
    procedure CalcParts; override;
    procedure CalcDrawParams(AFull: Boolean = True); override;
    procedure CorrectFrameRect(var ARect: TRect); virtual;
    procedure DoCalcDrawingConsts; override;
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); override;
    procedure DrawFrame; virtual;
    procedure DrawTextField; virtual; abstract;
    procedure DrawEditSizingFrame(AWidth: Integer);
    function DrawSelected: Boolean; override;
    function GetDefaultViewStructure: TdxBarItemControlViewStructure; override;
    function GetDrawParamsClass: TdxBarItemControlDrawParamsClass; override;
    function GetPartCount: Integer; override;
    function GetPossibleViewLevels: TdxBarItemViewLevels; override;

    function GetCaptionAreaWidth: Integer; override;
    function GetControlAreaWidth: Integer; override;
    function GetGlyphAreaWidth: Integer; override;

    function GetDefaultHeight: Integer; override;
    function GetDefaultWidth: Integer; override;
    function GetEditOffset: Integer;
    function GetEditRect: TRect; virtual;
    function GetEditTextSize: Integer; // TODO property
    function GetIndents(ADrawAreaType: TdxBarItemControlPart): TRect; override;
    function GetMinEditorWidth: Integer; virtual; abstract;
    function GetMinWidth: Integer; override;
    function GetShowCaption: Boolean; virtual;
    procedure InitEdit; virtual; abstract;
    procedure Show; override;

    procedure BeginResize(APoint: TPoint); override;
    function CanResize(APoint: TPoint): Boolean; override;
    procedure EndResize(AAllowResize: Boolean); override;
    procedure Resizing(APoint: TPoint); override;

    function HotPartWantMouse: Boolean; override;
    procedure RefreshBkBrush(var AHandle: HBRUSH); virtual;

    property CaptionBkBrush: HBRUSH read GetCaptionBkBrush;
    property DrawParams: TdxBarEditLikeControlDrawParams read GetDrawParams;
    property EditBkBrush: HBRUSH read GetEditBkBrush;
    property EditFont: TFont read GetEditFont;
    property ShowCaption: Boolean read GetShowCaption;
  public
    destructor Destroy; override;
    property Item: TdxCustomBarEdit read GetItem;
  end;

  TdxBarEditControl = class(TdxBarCustomEditControl)
  private
    FHandle: HWND;
    function GetItem: TdxBarEdit;
    function GetMaxLength: Integer;
    function GetReadOnly: Boolean;
  protected
    procedure CreateWindowHandle; virtual;
    procedure DestroyWindowHandle(ADestroyWindow: Boolean = True); virtual;
    function GetWindowStyle: DWORD; virtual;

    function CanDrawEditor: Boolean; virtual;
    procedure ControlClick(AByMouse: Boolean; AKey: Char = #0); override;

    procedure CreateInnerEdit; override;
    procedure DestroyInnerEdit(AFullDestroy: Boolean = True); override;
    procedure DrawTextField; override;
    function GetHandle: HWND; override;
    function GetMinEditorWidth: Integer; override;
    function GetNonBufferedRect: TRect; override;
    procedure Hide(AStoreDisplayValue: Boolean); override;
    procedure InitEdit; override;
    function IsTransparentOnGlass: Boolean; override;
    procedure PrepareEditWnd; override;
    procedure SetFocused(Value: Boolean); override;
    procedure SetText(Value: string); override;
    procedure Show; override;

    procedure WndProc(var Message: TMessage); override;

    property MaxLength: Integer read GetMaxLength;
    property ReadOnly: Boolean read GetReadOnly;
  public
    constructor Create(AItemLink: TdxBarItemLink); override;
    destructor Destroy; override;

    property Item: TdxBarEdit read GetItem;
  end;

  TCustomdxBarComboControl = class(TdxBarEditControl)
  private
    FOnPressDroppedDown: Boolean;
    FDroppedDown: Boolean;

    function GetDropDownWindow: HWND;
    function GetItem: TCustomdxBarCombo;
  protected
    procedure CalcDrawParams(AFull: Boolean = True); override;
    procedure CalcParts; override;
    function CanDrawEditor: Boolean; override;
    procedure ControlInactivate(Immediately: Boolean); override;
    procedure CorrectFrameRect(var ARect: TRect); override;
    procedure DrawTextField; override;
    procedure EnabledChanged; override;
    function GetPartCount: Integer; override;
    function IsChildWindow(AWnd: HWND): Boolean; override;
    procedure SysKeyDown(var Key: Word; Shift: TShiftState); override;
    procedure SysKeyUp(var Key: Word; Shift: TShiftState); override;
    procedure WndProc(var Message: TMessage); override;

    procedure CalcDropDownPos(out APoint: TPoint); virtual;
    procedure SetDroppedDown(Value: Boolean); virtual;

    property DropDownWindow: HWND read GetDropDownWindow;
  public
    destructor Destroy; override;
    function IsDroppedDown: Boolean; override;
    property DroppedDown: Boolean read FDroppedDown write SetDroppedDown;
    property Item: TCustomdxBarCombo read GetItem;
  end;

  TdxBarComboControl = class(TCustomdxBarComboControl)
  private
    FLocalItemIndex: Integer;
    function GetItem: TdxBarCustomCombo;
    function GetItemIndex: Integer;
    function GetItems: TStrings;
    function GetSorted: Boolean;
    procedure SetLocalItemIndex(Value: Integer);
  protected
    procedure RestoreDisplayValue; override;
    procedure SetFocused(Value: Boolean); override;
    procedure WndProc(var Message: TMessage); override;

    property ItemIndex: Integer read GetItemIndex;
    property Items: TStrings read GetItems;
    property Sorted: Boolean read GetSorted;
  public
    property Item: TdxBarCustomCombo read GetItem;
    property LocalItemIndex: Integer read FLocalItemIndex write SetLocalItemIndex;
  end;

  TdxBarSubItemControl = class(TdxBarButtonLikeControl)
  private
    function GetCaptionOffset: Integer;
    function GetItem: TCustomdxBarSubItem;
  protected
    function GetSubMenuControl: TdxBarSubMenuControl; override;
    procedure CalcDrawParams(AFull: Boolean = True); override;
    function CanActivate: Boolean; override;
    function CanClicked: Boolean; override;
    procedure ControlActivate(Immediately: Boolean); override;
    procedure ControlInactivate(Immediately: Boolean); override;
    procedure ControlClick(AByMouse: Boolean; AKey: Char = #0); override;
    procedure CreateSubMenuControl; virtual;
    procedure DoCreateSubMenuControl; virtual;
    procedure DoCloseUp(AHadSubMenuControl: Boolean); override;
    procedure DoDropDown(AByMouse: Boolean); override;
    procedure DropDown(AByMouse: Boolean); override;
    procedure GetSubMenuControlPositionParams(out P: TPoint;
      out AOwnerWidth, AOwnerHeight: Integer); virtual;
    function IsFlatText: Boolean; override;
    function IsTextSelected: Boolean; override;
    procedure ShowSubMenuControl;

    function GetCaptionAreaWidth: Integer; override;
    function GetControlCaptionOffset: Integer; override;

    function GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass; override;
    function GetOwnedBarControl: TCustomdxBarControl; override;
    function HasSubMenu: Boolean; virtual;
    function IsDestroyOnClick: Boolean; override;
    function IsDropDown: Boolean; override;
    function IsExpandable: Boolean; override;
    function IsMenuItem: Boolean; override;
    function IsPressed: Boolean;

    function WantsDblClick: Boolean; override;
    function WantsKey(Key: Word): Boolean; override;

    function GetPossibleViewLevels: TdxBarItemViewLevels; override;
    function GetDefaultViewStructure: TdxBarItemControlViewStructure; override;

    property CaptionOffset: Integer read GetCaptionOffset;
  public
    destructor Destroy; override;
    function IsDroppedDown: Boolean; override;
    property Item: TCustomdxBarSubItem read GetItem;
  end;

  TdxBarContainerItemControl = class(TdxBarSubItemControl)
  private
    function GetItem: TCustomdxBarContainerItem;
  protected
    procedure CreateSubMenuControl; override;
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); override;
    function DrawSelected: Boolean; override;
    function GetCaption: string; override;
    function IsExpandable: Boolean; override;
    function ShowRealCaption: Boolean;
  public
    property Item: TCustomdxBarContainerItem read GetItem;
  end;

  {--------------------------------------
              Item's painters
   --------------------------------------}
  TdxBarPainter = class(TcxIUnknownObject)
  private
    procedure InternalCalculateComboParts(const ADrawParams: TdxBarEditLikeControlDrawParams; var AParts: array of TRect);
  protected
    // New
    procedure DrawToolbarContentPart(ABarControl: TdxBarControl; ACanvas: TcxCanvas); virtual;
    procedure DrawToolbarNonContentPart(ABarControl: TdxBarControl; DC: HDC); virtual;
    function GetToolbarCaptionRect(const ARect: TRect): TRect; virtual;
    class function IsCompoundPainting: Boolean; virtual;
    class function NeedDoubleBuffer: Boolean; virtual;
    // Common
    function AllowLargeIcons: Boolean; virtual;
    procedure CorrectCaptionParams(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      var ATextBounds: TRect; const AImageBounds: TRect; out ATextAlignment: DWORD); virtual;
    procedure DrawGlyphBorder(ABarItemControl: TdxBarItemControl; DC: HDC; ABrush: HBRUSH;
      NeedBorder: Boolean; R: TRect; PaintType: TdxBarPaintType; IsGlyphEmpty,
      Selected, Down, DrawDowned, ADroppedDown, IsSplit: Boolean); virtual;
    procedure DrawGlyphCheckMark(ABarItemControl: TdxBarItemControl; DC: HDC;
      X, Y, DoubleSize: Integer); virtual;
    procedure DrawGlyphEmptyImage(ABarItemControl: TdxBarItemControl; DC: HDC; R: TRect;
      APaintType: TdxBarPaintType; ADown: Boolean); virtual;
    class procedure DrawItemArrow(DC: HDC; R: TRect; ArrowType: TcxArrowDirection;
      Enabled, Selected, Flat: Boolean; AColor: TColor = clDefault); virtual;
    procedure DrawLargeItemArrow(DC: HDC; R: TRect; ArrowType: TcxArrowDirection;
      Size: Integer; Selected, Enabled, Flat: Boolean; AColor: TColor = clDefault); virtual;
    class procedure FrameFlatSelRect(DC: HDC; const R: TRect); virtual;

    function GetDefaultEnabledTextColor(ABarItemControl: TdxBarItemControl;
      ASelected, AFlat: Boolean): TColor; virtual;
    procedure GetDisabledTextColors(ABarItemControl: TdxBarItemControl;
      ASelected, AFlat: Boolean; var AColor1, AColor2: TColor); virtual;
    function GetEnabledTextColor(ABarItemControl: TdxBarItemControl;
      ASelected, AFlat: Boolean): TColor; virtual;
    function GetItemArrowColor(const ADrawParams: TdxBarButtonLikeControlDrawParams): TColor; virtual;

    class function GetFaded(ABarControl: TCustomdxBarControl): Boolean; virtual;
    class function IgnoreGlyphOpaque: Boolean; virtual;
    class function IgnoreNonRecentColor: Boolean; virtual;
    class function IsFadingAvailable: Boolean; virtual;
    class function IsMenuItem(ABarItemControl: TdxBarItemControl): Boolean; virtual;
    class function UseTextColorForItemArrow: Boolean; virtual;

    // Hints
    class function GetBarItemContolHintPosition(ABarControl: TCustomdxBarControl;
      const AItemBounds: TRect; const ACursorPos: TPoint; AHeight: Integer): TPoint; virtual;
    function CreateHintViewInfo(ABarManager: TdxBarManager; AHintText: string; const AShortCut: string;
      AScreenTip: TdxBarScreenTip): TdxBarCustomHintViewInfo; virtual;
    // Bar
    class function BarIsBarSmall(ABarControl: TdxBarControl; const R: TRect): Boolean; virtual;
    class function BarCaptionBkColor(ABarControl: TdxBarControl; AMainFormActive: Boolean): COLORREF; virtual;
    function BarCaptionColor(ABarControl: TdxBarControl): COLORREF; virtual;
    class function BarMarkArrowColor(ABarControl: TdxBarControl; AState: TdxBarMarkState): COLORREF; virtual;
    procedure BarDrawGrip(ABarControl: TdxBarControl; DC: HDC; R: TRect;
      AToolbarBrush: HBRUSH); virtual;

    // Mark
    procedure BarDrawMarkArrow(ABarControl: TdxBarControl; DC: HDC; MarkR: TRect); virtual;
    class procedure BarDrawMarkAtPos(ABarControl: TdxBarControl; DC: HDC;
      const ItemRect: TRect; Offset: Integer); virtual;
    procedure BarDrawMarkBackground(ABarControl: TdxBarControl; DC: HDC;
      ItemRect: TRect; AToolbarBrush: HBRUSH); virtual;
    procedure BarDrawMarkElements(ABarControl: TdxBarControl; DC: HDC;
      ItemRect: TRect); virtual;

    class procedure BarOffsetFloatingBarCaption(ABarControl: TdxBarControl;
      var X: Integer; var R: TRect); virtual;
    class function GetDrawMarkElementColor(ABarControl: TdxBarControl): Integer; virtual;
    // ButtonLikeControl
    procedure ButtonLikeControlDoDrawCaption(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      const ATextBounds: TRect; ATextAlignment: DWORD; AFormat: DWORD = 0); virtual;
    class function GetControlTextIndents: TRect; virtual;
    class function GetControlCaptionRect(const ADrawParams: TdxBarItemControlDrawParams): TRect; virtual;
    procedure InflateSizeForArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; var ASize: Integer); virtual;
    // ColorCombo
      // Sizes
    function GetDotSpaceAfter(ADotWidth: Integer): Integer; virtual;
    function GetCustomColorButtonBounds(const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect): TRect; virtual;
    function GetCustomColorButtonWidth(APaintType: TdxBarPaintType; const ARect: TRect): Integer; virtual;
      // Draw
    procedure DrawDot(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect); virtual;
    procedure DrawDots(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect); virtual;

    // ComboControl
    class procedure ComboControlDrawArrow(const ADrawParams: TdxBarEditLikeControlDrawParams; const ARect: TRect; ASize: Integer; AColor: TColor); virtual;

    // SubMenuControl
    procedure SubMenuControlFillScrollArrow(ACanvas: TcxCanvas; ARect: TRect; AColor: TColor); virtual;
    procedure SubMenuControlDrawScrollArrow(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; const AArrowRect: TRect;
      AColor: COLORREF; AArrowDirection: TcxArrowDirection); virtual;
    procedure SubMenuControlDrawScrollBand(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection); virtual;
    procedure SubMenuControlDrawScrollBandBackground(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection); virtual;
    procedure SubMenuControlDrawNonRecentGroupSeparator(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection); virtual;
    function SubMenuControlGetScrollBandBounds(ABarSubMenuControl: TdxBarSubMenuControl; AArrowDirection: TcxArrowDirection): TRect; virtual;
    function SubMenuControlGetScrollBandSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; virtual;
    class function SubMenuControlGetScrollArrowSize(ATextSize: Integer): Integer; virtual;
    procedure SubMenuControlDrawMarkContent(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect; ASelected: Boolean); virtual;
    procedure SubMenuControlDrawMarkBand(ABarSubMenuControl: TdxBarSubMenuControl; const AMarkRect: TRect; ASelected: Boolean); virtual;
    procedure SubMenuControlDrawMarkSelection(ABarSubMenuControl: TdxBarSubMenuControl; ADC: HDC; const AMarkRect: TRect); virtual;
    class function SubMenuControlUseScrollButtons: Boolean; virtual;
    // Edit
    class procedure EditOffsetInteriorRect(ABarEditControl: TdxBarCustomEditControl; var R: TRect); virtual;
    // SpinEditControl
    procedure DrawSpinEditArrow(const ADrawParams: TdxBarSpinEditDrawParams; AArrowPos: TPoint; AButtonIndex: Integer); virtual;
    class procedure SpinEditControlDrawArrowByPoints(const ADrawParams: TdxBarSpinEditDrawParams;
      AStartPoint: TPoint; AColorIndex: Integer; AButtonIndex: Integer);
    // DateNavigator
    class procedure DateNavigatorDrawButtonCaption(DC: HDC; const R: TRect; AOffset: Integer;
      const ACaption: string; AOpaque: Boolean); virtual;
  public
    constructor Create(AData: Integer); virtual;

    // New
    procedure CalculateButtonParts(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      var AParts: array of TRect; const AItemRect: TRect); virtual;
    procedure CalculateColorComboParts(const ADrawParams: TdxBarColorComboControlDrawParams;
      var AParts: array of TRect; const AItemRect: TRect); virtual;
    procedure CalculateComboParts(const ADrawParams: TdxBarEditLikeControlDrawParams;
      var AParts: array of TRect; const AItemRect: TRect); virtual;
    procedure CalculateEditParts(const ADrawParams: TdxBarEditLikeControlDrawParams;
      var AParts: array of TRect; const AItemRect: TRect); virtual;
    procedure CalculateSpinEditParts(const ADrawParams: TdxBarSpinEditDrawParams;
      var AParts: array of TRect; const AItemRect: TRect); virtual;

    // Common
    class procedure CalculateArrowPoints(const ARect: TRect; AArrowSize: Integer; AArrowDirection: TcxArrowDirection; out P: TcxArrowPoints);
    class function GetArrowRectByPoints(const P: TcxArrowPoints; AArrowDirection: TcxArrowDirection): TRect;
    procedure GetTextColors(ABarItemControl: TdxBarItemControl; AEnabled,
      ASelected, AFlat: Boolean; var AColor1, AColor2: TColor); virtual;
    class procedure SetArrowRegion(ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection;
      P: TcxArrowPoints; AOperation: TcxRegionOperation);

    // Sizes
    function GetToolbarContentOffsets(ABar: TdxBar;
      ADockingStyle: TdxBarDockingStyle; AHasSizeGrip: Boolean): TRect; virtual;
    function GetToolbarsOffsetForAutoAlign: Integer; virtual;
    function GetBorderSize: Integer; virtual;
    function GetIconAreaSize(ABarControl: TCustomdxBarControl): Integer; virtual;
    class function GetControlCaptionOffset(ABarItemControl: TdxBarItemControl): Integer; virtual;
    class function GetDefaultTextSize(ACanvas: TcxCanvas): Integer; virtual;
    class function GetPopupWindowBorderWidth: Integer; virtual;

    procedure GetImageParams(AItemControl: TdxBarItemControl;
      const ADrawRect: TRect; APaintType: TdxBarPaintType;
      AViewStructure: TdxBarItemControlViewStructure;
      AViewSize: TdxBarItemControlViewSize; ACenter, ASelected, ADowned, ADrawDowned: Boolean;
      var AGlyphEmpty: Boolean; out ACurrentGlyph: TBitmap; out ACurrentImages: TCustomImageList;
      out ACurrentImageIndex: Integer; out AImageBounds: TRect);
    function GetLargeImageBounds(AItemControl: TdxBarItemControl;
      const AImageSize: TSize; const ADrawRect: TRect; APaintType: TdxBarPaintType;
      AViewStructure: TdxBarItemControlViewStructure; AGlyphLayout: TdxBarGlyphLayout): TRect; virtual;
    class function GetSmallImageBounds(AItemControl: TdxBarItemControl;
      const AImageSize: TSize; const ADrawRect: TRect; APaintType: TdxBarPaintType;
      AViewStructure: TdxBarItemControlViewStructure;
      ACenter, AGlyphEmpty, AStretchGlyph, ADowned, ADrawDowned: Boolean): TRect;

    class procedure DrawBackground(ABarItemControl: TdxBarItemControl; DC: HDC;
      const R: TRect; ABrush: HBRUSH; AOpaque: Boolean); virtual;
    class procedure DrawBackgroundFrameRect(ABarItemControl: TdxBarItemControl;
      DC: HDC; R: TRect; ABrush: HBRUSH; AOpaque: Boolean); virtual;
    class procedure DrawDisabledShadowRect(ABarItemControl: TdxBarItemControl; DC: HDC;
      R: TRect); virtual;
    procedure DrawItemBackground(ABarItemControl: TdxBarItemControl;
      ACanvas: TcxCanvas; const ASourceRect: TRect; ABrush: HBRUSH);  virtual;
    procedure DrawGlyph(ABarItemControl: TdxBarItemControl; ADC: HDC;
      ADrawRect: TRect; const AFullBounds: TRect; APaintType: TdxBarPaintType;
      AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown, ACenter, AForceUseBkBrush, AIsSplit: Boolean); overload;
    procedure DrawGlyph(ABarItemControl: TdxBarItemControl; ADC: HDC;
      ADrawRect: TRect; const AFullBounds: TRect; out AImageBounds: TRect;
      APaintType: TdxBarPaintType; AViewStructure: TdxBarItemControlViewStructure;
      AViewSize: TdxBarItemControlViewSize; AGlyphEmpty, ASelected, ADowned,
      ADrawDowned, ADroppedDown, ACenter, AForceUseBkBrush, AGrayScale, AIsSplit: Boolean);  overload; virtual;
    procedure DrawGlyphAndBkgnd(ABarItemControl: TdxBarItemControl; ADC: HDC;
      const R, AGlyphRect: TRect; APaintType: TdxBarPaintType; AGlyph: TBitmap;
      AImages: TCustomImageList; AImageIndex: Integer; AGlyphEmpty, ASelected, ADowned,
      ADrawDowned, ADroppedDown, AForceUseBkBrush, AGrayScale, AIsSplit: Boolean); virtual;
    procedure DrawGlyphAndTextInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; const R: TRect);
    procedure DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect); virtual;
    procedure DrawItemMultilineText(const ADrawParams: TdxBarItemControlDrawParams;
      const AText: string; const ATextRect: TRect; AAlignment: UINT; AMaxLineCount: Integer);
    procedure DrawItemText(ABarItemControl: TdxBarItemControl; ADC: HDC;
      S: string; APaintRect: TRect; AAlignment: UINT; AEnabled, ASelected, ARotated,
      AClipped, AFlatText: Boolean; AFormat: UINT = DT_SINGLELINE); virtual;
    procedure DrawItemTextInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect);
    class procedure DrawLowered(DC: HDC; var R: TRect); virtual;
    class procedure FrameAndFillRect(ABarItemControl: TdxBarItemControl; DC: HDC;
      var R: TRect; Enabled, Selected, Pressed: Boolean); virtual;
    class function GetCaptionOffsets: TRect; virtual;
    class function GlyphBkgndBrush(ABarItemControl: TdxBarItemControl;
      APaintType: TdxBarPaintType; AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown,
      AForceUseBkBrush, AGrayScale: Boolean): HBRUSH; virtual;
    class function GlyphDownShift(ABarItemControl: TdxBarItemControl): Integer; virtual;
    class function GlyphDrawDownedShift(ABarItemControl: TdxBarItemControl; ADown: Boolean): Integer; virtual;
    class function IsFlatGlyphImage: Boolean; virtual;
    class function IsFlatItemText: Boolean; virtual;
    class function IsFlatItemTextForMenu: Boolean; virtual;
    function IsCustomSelectedTextColorExists(ABarItemControl: TdxBarItemControl): Boolean; virtual;
    class function IsGlyphImageBackgroundOpaque(ABarItemControl: TdxBarItemControl;
      ADown, ADrawDowned, ASelected, AGlyphEmpty: Boolean): Boolean; virtual;
    class function IsGlyphImageHasShadow: Boolean; virtual;
    class function IsGlyphImageTransparent(ABarItemControl: TdxBarItemControl): Boolean; virtual;
    class function IsItemTextSelectedInverted: Boolean; virtual;
    class function LoweredBorderSize(ABarItemControl: TdxBarItemControl): Integer; virtual;
    class function TextAreaOffset(ABarItemControl: TdxBarItemControl): Integer; virtual;
    // BarManager
    function BarFingersSize(ABar: TdxBar): Integer;
    function BeforeFingersSize: Integer; virtual;
    class function BorderSizeX: Integer; virtual;
    class function BorderSizeY: Integer; virtual;
    class function EmptyFingersSize: Integer; virtual;
    function FingersSize(ABarControl: TdxBarControl): Integer; virtual;
    function GripperSize(ABarControl: TdxBarControl): Integer; virtual;
    class function RealButtonArrowWidth(ABarManager: TdxBarManager): Integer; virtual;
    class function RealLargeButtonArrowWidth(ABarManager: TdxBarManager): Integer; virtual;
    class function SubMenuBeginGroupIndent: Integer; virtual;
    // DockControl
    procedure DockControlFillBackground(ADockControl: TdxDockControl;
      DC: HDC; ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor); virtual;
    class function IsNativeBackground: Boolean; virtual;
    // CustomBar
    class function BarChildrenHaveShadows(ABarControl: TCustomdxBarControl): Boolean; virtual;
    function BarHasShadow(ABarControl: TCustomdxBarControl): Boolean; virtual;
    function BarLinkedOwnerHasShadow(ABarControl: TCustomdxBarControl): Boolean; virtual;
    class function BarControlOwnerBrush(ABarManager: TdxBarManager): HBRUSH; virtual;
    class function BarDockedGetRowIndent: Integer; virtual;
    procedure BarDrawDockedBackground(ABarControl: TdxBarControl; DC: HDC;
     ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor); virtual;
    procedure BarDrawFloatingBackground(ABarControl: TCustomdxBarControl; DC: HDC;
      ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor); virtual;
    class procedure BarDrawOwnerLink(ABarControl: TCustomdxBarControl; DC: HDC); virtual;
    procedure BarFillParentBackground(ABarControl: TCustomdxBarControl; DC: HDC;
      const ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor);
    class function BarToolbarBrush(ABarControl: TCustomdxBarControl): HBRUSH; virtual;
    class function BarToolbarBrushEx(ABarControl: TdxBarControl): HBRUSH; virtual;
    class function BarToolbarDownedBrush(ABarControl: TCustomdxBarControl): HBRUSH; virtual;
    class function BarToolbarDownedSelBrush(ABarControl: TCustomdxBarControl): HBRUSH; virtual;
    class function BarToolbarSelBrush(ABarControl: TCustomdxBarControl): HBRUSH; virtual;
    function ComboBoxArrowWidth(ABarControl: TCustomdxBarControl; cX: Integer): Integer; virtual;
    class function EditTextSize(ABarControl: TCustomdxBarControl; cY: Integer): Integer; virtual;
    class procedure GetEditTextParams(out AOffsets: TRect; out AHeightCorrection: Integer);
    class procedure GetEditTextVerticalOffsets(out ATop, ABottom: Integer); virtual;
    class procedure SetWindowRgn(AHandle: THandle; const AWindowRect: TRect; ARedraw: Boolean = False); virtual;
    // Bar
    class function BarAllowHotTrack: Boolean; virtual;
    class function BarAllowQuickCustomizing: Boolean; virtual;
    function BarBeginGroupSideSize: Integer; virtual;
    function BarBeginGroupSize: Integer; virtual;
    procedure BarBorderPaintSizes(ABarControl: TdxBarControl; var R: TRect); virtual;
    class function BarBorderSize: Integer; virtual;
    procedure BarBorderSizes(ABar: TdxBar; AStyle: TdxBarDockingStyle; var R: TRect); virtual;
    class function BarCaptionAreaSize: Integer; virtual;
    procedure BarCaptionFillBackground(ABarControl: TdxBarControl; DC: HDC;
      R: TRect; AToolbarBrush: HBRUSH); virtual;
    class function BarCaptionSize: Integer; virtual;
    class function BarCaptionTransparent: Boolean; virtual;
    class function BarCloseButtonSize: TSize; virtual;
    procedure BarDrawBackground(ABarControl: TdxBarControl; ADC: HDC;
      const ADestRect, ASourceRect: TRect; ABrush: HBRUSH; AColor: TColor); virtual;
    procedure BarDrawBeginGroup(ABarControl: TCustomdxBarControl; DC: HDC;
      ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean); virtual;
    class procedure BarDrawCaptionElement(ABarControl: TdxBarControl; DC: HDC;
      R: TRect; AState: TdxBarMarkState); virtual;
    procedure BarDrawCloseButton(ABarControl: TdxBarControl; DC: HDC; R: TRect); virtual;
    procedure BarDrawDockedBarBorder(ABarControl: TdxBarControl; DC: HDC; R: TRect;
      AToolbarBrush: HBRUSH); virtual;
    procedure BarDrawFloatingBarBorder(ABarControl: TdxBarControl; DC: HDC;
      R, CR: TRect; AToolbarBrush: HBRUSH); virtual;
    procedure BarDrawFloatingBarCaption(ABarControl: TdxBarControl; DC: HDC;
      R, CR: TRect; AToolbarBrush: HBRUSH); virtual;
    procedure BarDrawMark(ABarControl: TdxBarControl; DC: HDC; MarkR: TRect); virtual;
    procedure BarDrawMarks(ABarControl: TdxBarControl; ACanvas: TcxCanvas;
      const AItemRect: TRect; AToolbarBrush: HBRUSH); virtual;
    procedure BarDrawMDIButton(ABarControl: TdxBarControl; AButton: TdxBarMDIButton;
      AState: Integer; DC: HDC; R: TRect); virtual;
    procedure BarDrawStatusBarGrip(ABarControl: TdxBarControl; DC: HDC;
      const R: TRect; AToolbarBrush: HBRUSH); virtual;
    procedure BarDrawStatusBarBorder(ABarControl: TdxBarControl; DC: HDC;
      R: TRect; AToolbarBrush: HBRUSH); virtual;
    class function BarHorSize: Integer; virtual;
    function BarMarkRect(ABarControl: TdxBarControl): TRect; virtual;
    function BarMarkItemRect(ABarControl: TdxBarControl): TRect; virtual;
    procedure BarMarkRectInvalidate(ABarControl: TdxBarControl); virtual;
    class function BarTopSize: Integer; virtual;
    class function BarBottomSize: Integer; virtual;
    class function BarUseSystemClose: Boolean; virtual;
    class function BarUseSystemNCBorder: Boolean; virtual;
    function MarkSizeX(ABarControl: TdxBarControl): Integer; virtual;
    procedure StatusBarFillBackground(ABarControl: TdxBarControl; DC: HDC;
      ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor); virtual;
    function StatusBarBorderOffsets: TRect; virtual;
    class function StatusBarTopBorderSize: Integer; virtual;
    function StatusBarGripSize(ABarManager: TdxBarManager): TSize; virtual;
    // QuickCustItem
    class function BarToolbarBrushEx2(ABarControl: TdxBarControl): HBRUSH; virtual;
    class procedure DrawQuickCustItemFrame(ABarItemControl: TdxBarItemControl;
      DC: HDC; var R, ARect: TRect; Selected: Boolean); virtual;
    class procedure DrawQuickCustItemFrameSelected(ABarItemControl: TdxBarItemControl;
      DC: HDC; WholeR, R: TRect; Selected: Boolean); virtual;
    class function IsQuickControlPopupOnRight: Boolean; virtual;

    // BarItemControl
      // Sizes
    class function GetTailAreaSize(const ADrawParams: TdxBarItemControlDrawParams): Integer; virtual;
    class function ItemControlGetIndents(const ADrawParams: TdxBarItemControlDrawParams;
      ADrawAreaType: TdxBarItemControlPart): TRect; virtual;

    // ButtonControl
      // Attributes
    function ButtonControlArrowBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH; virtual;
      // Conditions
    function IsButtonControlArrowBackgroundOpaque(const ADrawParams: TdxBarButtonLikeControlDrawParams): Boolean; virtual;
    function IsButtonControlArrowDrawSelected(const ADrawParams: TdxBarButtonLikeControlDrawParams): Boolean; virtual;
    function IsButtonControlArrowFlat: Boolean; virtual;
    function IsDropDownRepaintNeeded: Boolean; virtual;
      // Sizes
    function GetButtonBorderHeight: Integer; virtual;
    function GetButtonBorderWidth: Integer; virtual;
    function GetButtonHeight(AIconSize, ATextSize: Integer): Integer; virtual;
    function GetButtonWidth(AIconSize, ATextSize: Integer): Integer; virtual;
    function GetButtonSize(AIconSize, ATextSize: Integer): TSize; virtual;
    class function GetDefaultArrowSignSize: TSize; virtual;
    class procedure CorrectButtonControlDefaultHeight(var DefaultHeight: Integer); virtual;
    class procedure CorrectButtonControlDefaultWidth(var DefaultWidth: Integer); virtual;
    procedure OffsetCaptionBounds(ADowned, ADrawDowned: Boolean; var R: TRect); virtual;
    class procedure OffsetEllipsisBounds(APressed: Boolean; var R: TRect); virtual;
      // Draw
    procedure DrawButtonLikeControl(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect); virtual;
    procedure DrawButtonLikeControlCaption(const ADrawParams: TdxBarButtonLikeControlDrawParams; const ARect, AImageBounds: TRect); virtual;
    procedure DrawButtonControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      R1: TRect); virtual;
    procedure DrawButtonControlArrowBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      var R1: TRect; ABrush: HBRUSH); virtual;
    procedure DrawSplitControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect); virtual;
    procedure DrawAssociateControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect); virtual;

    // ComboControl
      // Attributes
    function ComboControlArrowColor(ADrawParams: TdxBarItemControlDrawParams): TColor; virtual;
    function ComboControlButtonBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH; virtual;
      // Sizes
    class function ComboControlArrowOffset: Integer; virtual;
    class function ComboControlButtonOffsets(APaintType: TdxBarPaintType): TRect; virtual;
      // Draw
    procedure ComboControlDrawArrowButton(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect; AInClientArea: Boolean); virtual;
    class procedure ComboControlDrawSimpleButton(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect; ABrush: HBRUSH); virtual;

    // DropDownListBox
    class function DropDownListBoxBorderSize: Integer; virtual;
    procedure DropDownListBoxDrawBorder(DC: HDC; AColor: TColor; ARect: TRect); virtual;
    // SubMenuControl
      // Conditions
    class function SubMenuControlHasBand: Boolean; virtual;
    class function SubMenuControlIsOffsetRecentGroupNeeded: Boolean; virtual;
      // Sizes
    class function SubMenuControlArrowsOffset: Integer; virtual;
    class function SubMenuControlArrowWidth(ATextSize: Integer): Integer; virtual;
    function SubMenuControlBeginGroupSize: Integer; virtual;
    class function SubMenuControlBorderSize: Integer; virtual;
    class function SubMenuControlNCBorderSize: Integer; virtual;
    class function SubMenuControlClientBorderSize: Integer; virtual;
    procedure SubMenuControlCalcDrawingConsts(ACanvas: TcxCanvas;
      ATextSize: Integer; out AMenuArrowWidth, AMarkSize: Integer); virtual;
    class function SubMenuControlContentRectOffset(ABarSubMenuControl: TdxBarSubMenuControl): TRect; virtual;
    class function SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; virtual;
    class function SubMenuControlGetBandSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; virtual;
    class function SubMenuControlGetControlContentIndent(ABarSubMenuControl: TdxBarSubMenuControl): Integer; virtual;
    class function SubMenuControlInternalBorderSize: Integer; virtual;
    class function SubMenuControlInternalBorderOffset: Integer; virtual;
    class function SubMenuControlMarkArrowSize(AMarkSize: Integer): Integer; virtual;
    class function SubMenuControlNormalItemHeight: Integer; virtual;
      // Positions
    class function SubMenuControlGetItemIconRect(const AItemRect: TRect; AIconAreaSize: Integer): TRect; virtual;
    class function SubMenuControlGetItemTextRect(const ADrawParams: TdxBarButtonLikeControlDrawParams; const AItemRect: TRect): TRect; virtual;
    class function SubMenuControlGetItemTextIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer; virtual;
    function SubMenuControlBeginGroupRect(
      ABarSubMenuControl: TdxBarSubMenuControl; AControl: TdxBarItemControl;
      const AItemRect: TRect): TRect; virtual;
    class procedure SubMenuControlOffsetDetachCaptionRect(ABarSubMenuControl: TdxBarSubMenuControl;
      var R: TRect); virtual;
      // Draw
    procedure SubMenuControlDrawScrollButton(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection); virtual;
    procedure SubMenuControlDrawBackground(ABarSubMenuControl: TdxBarSubMenuControl;
      ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor); virtual;
    procedure SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); virtual;
    procedure SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; const R: TRect; ABrush: HBRUSH); virtual;
    procedure SubMenuControlDrawDetachCaption(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); virtual;
    procedure SubMenuControlDrawBeginGroup(ABarSubMenuControl: TdxBarSubMenuControl;
      AControl: TdxBarItemControl; ACanvas: TcxCanvas; const ABeginGroupRect: TRect); virtual;
    class procedure SubMenuControlDrawItemFrame(ABarSubMenuControl: TdxBarSubMenuControl;
      AControl: TdxBarItemControl; DC: HDC; AItemRect: TRect; AIndex: Integer); virtual;
    procedure SubMenuControlDrawSeparator(ACanvas: TcxCanvas; const ARect: TRect); virtual;
    class procedure SubMenuControlPrepareBkBrush(ABarSubMenuControl: TdxBarSubMenuControl;
      var ABkBrush: HBRUSH); virtual;
    class function SubMenuControlTextSize(ACanvas: TcxCanvas): Integer; virtual;
    class function SubMenuControlToolbarItemsBrush(ABarSubMenuControl: TdxBarSubMenuControl): HBRUSH; virtual;
    // ApplicationMenu
    procedure ApplicationMenuDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const ARect: TRect); virtual;
    procedure ApplicationMenuDrawButton(const ADrawParams: TdxBarApplicationMenuButtonControlDrawParams; var R: TRect); virtual;
    procedure ApplicationMenuDrawContentArea(ABarSubMenuControl: TdxBarSubMenuControl;
      ACanvas: TcxCanvas; const AContentRect, AItemsArea: TRect); virtual;
    function ApplicationMenuGetFrameSizes: TRect; virtual;
    // SubMenuExtraControl
    procedure ExtraMenuControlDrawBackground(AExtraMenuControl: TCustomdxBarControl;
      ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor); virtual;
    procedure ExtraMenuControlDrawBeginGroup(AExtraMenuControl: TCustomdxBarControl;
      ACanvas: TcxCanvas; ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean); virtual;

    // Edit
    class procedure EditDrawInterior(ABarEditControl: TdxBarEditControl;
      ABarEdit: TdxBarEdit; ACanvas: TCanvas;  R: TRect; ItemLink: TdxBarItemLink); virtual;
    procedure EditGetRealLookAndFeel(ABarManager: TdxBarManager; ALookAndFeel: TcxLookAndFeel); virtual;
    function EditGetEnabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF; virtual;
    function EditGetDisabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF; virtual;
    function EditGetBkColor(const ADrawParams: TdxBarEditLikeControlDrawParams): COLORREF; virtual;
    function EditGetEnabledTextColor: COLORREF; virtual;
    function EditGetDisabledTextColor: COLORREF; virtual;
    function EditGetTextColor(ABarItemControl: TdxBarCustomEditControl): COLORREF; virtual;
    procedure EditGetColors(ABarItemControl: TdxBarCustomEditControl;
      var ATextColor, ABkColor: COLORREF); virtual;

    // EditButton
      // Conditions
    function EditButtonAllowOffsetContent: Boolean; virtual;
    function EditButtonAllowCompositeFrame: Boolean; virtual;
    class function EditButtonAllowHotTrack(const ADrawParams: TdxBarItemControlDrawParams): Boolean; virtual;
    function EditButtonIsCustomBorder: Boolean; virtual;
    function EditButtonIsCustomBackground(AState: Integer): Boolean; virtual;
      // Sizes
    procedure EditButtonCorrectDefaultWidth(var ADefaultWidth: Integer); virtual;
      // Draw
    procedure EditButtonDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams; AState: Integer;
      ARect: TRect; ABrush: HBrush); virtual;
    procedure EditButtonDrawBorder(const ADrawParams: TdxBarItemControlDrawParams;
      AState: Integer; var ADrawRect: TRect; out AContentRect: TRect); virtual;

    // CustomCombo
    class procedure CustomComboDrawItem(ABarCustomCombo: TdxBarCustomCombo;
      ACanvas: TCanvas; AIndex: Integer; ARect: TRect; AState: TOwnerDrawState;
      AInteriorIsDrawing: Boolean); virtual;
    // EditControl
    procedure DrawEditLikeControl(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect); virtual;
    class function EditControlBorderOffsets(APaintType: TdxBarPaintType): TRect; virtual;
    procedure EditControlDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams); virtual;
    procedure EditControlDrawBorder(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect); virtual;
    procedure EditControlDrawCaption(const ADrawParams: TdxBarEditLikeControlDrawParams; const ARect: TRect); virtual;
    procedure EditControlDrawSelectionFrame(const ADrawParams: TdxBarEditLikeControlDrawParams; const ARect: TRect); virtual;
    procedure EditControlDrawGlyph(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect); virtual;
    class function EditControlCaptionBackgroundIsOpaque(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; virtual;
    class function EditControlCaptionRightIndentIsOpaque(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; virtual;
    procedure EditControlDrawTextField(ABarEditControl: TdxBarEditControl;
      ACanvas: TcxCanvas; const ARect: TRect); virtual;
    function EditControlGetContentRect(APaintType: TdxBarPaintType; const ARect: TRect): TRect;
    class function EditControlShowIconDefault(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; virtual;
      // Select EditControl indents
    class function EditControlIndents(const ADrawParams: TdxBarEditLikeControlDrawParams;
      ADrawAreaType: TdxBarItemControlPart): TRect; virtual;
    class function EditControlCaptionLeftIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer; virtual;
    class function EditControlCaptionRelativeLeftIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer; virtual;
    class function EditControlCaptionAbsoluteLeftIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer; virtual;
    class function EditControlCaptionRightIndent: Integer; virtual;
    class function EditControlSubMenuGlyphIndents(const ADrawParams: TdxBarEditLikeControlDrawParams): TRect; virtual;

    class function EditControlGetRightCaptionIndentBrush(ABarEditControl: TdxBarCustomEditControl): HBRUSH; virtual;
    class function EditControlGlyphIsDrawSelected(ABarEditControl: TdxBarCustomEditControl): Boolean; virtual;
    class procedure EditControlUpdateWndText(ABarEditControl: TdxBarEditControl;
      AHandle: HWND; ANotEqual: Boolean); virtual;
    class function HasEditControlExternalFrame(APaintType: TdxBarPaintType;
      ASelected: Boolean): Boolean; virtual;

    // ColorCombo
      // Conditions
    function ColorComboHasCompleteFrame: Boolean; virtual;
    function IsCustomColorButtonVisible(const ADrawParams: TdxBarColorComboControlDrawParams): Boolean; virtual;
      // Sizes
    procedure ColorComboCorrectFrameRect(const ADrawParams: TdxBarColorComboControlDrawParams; var ARect: TRect); virtual;
    function GetCustomColorButtonIndents(APaintType: TdxBarPaintType): TRect; virtual;
      // Draw
    procedure ColorComboDrawCustomButton(const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect); virtual;
    procedure ColorComboDrawCustomButtonAdjacentZone(const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect); virtual;

    // SysPanel
    class procedure SysPanelCalcSize(AHandle: HWND; var ARect: TRect; var Corner: TdxCorner;
      Combo: TdxBarItem; AllowResizing: Boolean); virtual;
    class procedure SysPanelDraw(AHandle: HWND; AllowResizing, MouseAboveCloseButton,
      CloseButtonIsTracking: Boolean; var CloseButtonRect, GripRect: TRect; Corner: TdxCorner); virtual;
    class function SysPanelSize: Integer; virtual;
    // DateNavigator
    class function IsDateNavigatorFlat: Boolean; virtual;
    procedure DateNavigatorDrawButton(ABarItem: TdxBarItem;
      DC: HDC; R: TRect; const ACaption: string; APressed: Boolean); virtual;
    function DateNavigatorHeaderColor: TColor; virtual;

    // SpinEditControl
    function GetSpinEditArrowPos(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer): TPoint; virtual;
    procedure SpinEditCorrectFrameRect(const ADrawParams: TdxBarItemControlDrawParams; var ARect: TRect); virtual;
    function GetSpinEditArrowSize(AHeight: Integer): TSize; virtual;
    function GetSpinEditButtonBounds(const ADrawParams: TdxBarSpinEditDrawParams; const ARect: TRect; AButton: TdxBarSpinEditButton): TRect; virtual;
    function GetSpinEditButtonIndents(APaintType: TdxBarPaintType): TRect; virtual;
    function GetSpinEditButtonWidth(APaintType: TdxBarPaintType; const ARect: TRect): Integer; virtual;
    function GetSpinEditButtonState(const ADrawParams: TdxBarSpinEditDrawParams; AButtonIndex: Integer): TcxButtonState; virtual;
      // Draw
    procedure SpinEditControlDrawButton(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer); virtual;
    procedure SpinEditControlDrawButtonsAdjacentZone(const ADrawParams: TdxBarSpinEditDrawParams; const ARect: TRect); virtual;
    // ProgressControl
      //  Attributes
    class function ProgressControlBarBrushColor: TColorRef; virtual;
      // Conditions
    function CanUpdateBarPartly: Boolean; virtual;
      // Sizes
    function ProgressControlBarHeight(ABarItemControl: TdxBarItemControl): Integer; virtual;
    class function ProgressControlIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer; virtual;
      // Draw
    procedure ProgressControlDrawBar(const ADrawParams: TdxbarProgressControlDrawParams; BarR: TRect; ABarBrushColor: TColorRef); virtual;
    procedure ProgressControlDrawBackground(const ADrawParams: TdxBarItemControlDrawParams; var BarR: TRect); virtual;
    procedure ProgressControlDrawChunks(const ADrawParams: TdxBarItemControlDrawParams; BarR: TRect; ABarBrush: HBRUSH); virtual;
    procedure ProgressControlFillContent(const ADrawParams: TdxBarItemControlDrawParams; const R: TRect; ABarBrush: HBRUSH); virtual;
    procedure ProgressControlFillDiscreteContent(const ADrawParams: TdxBarItemControlDrawParams; const R: TRect; ABarBrush: HBRUSH); virtual;
    // ContainerControl
    class function ContainerControlSubMenuOffset: Integer; virtual;
    // InPlaceSubItemControl
      // Sizes
    class function InPlaceSubItemControlBrush: HBRUSH; virtual;
    class function InPlaceSubItemGetArrowWidth(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Integer; virtual;
    class function InPlaceSubItemGetTextIndent: Integer; virtual;
      // Conditions
    function InPlaceSubItemControlIsFlatItemText(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Boolean; virtual;
    function InPlaceSubItemControlIsArrowSelected(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Boolean; virtual;
      // Draw
    procedure InPlaceSubItemControlDrawArrow(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams;
      ADirection: TcxArrowDirection; ARect: TRect); virtual;
    procedure InPlaceSubItemControlDrawBackground(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams; ARect: TRect); virtual;
    procedure InPlaceSubItemControlDrawInMenu(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams; ARect: TRect); virtual;
    // StaticControl
    procedure DrawStaticBackground(const ADrawParams: TdxBarStaticLikeControlDrawParams; ARect: TRect); virtual;
    procedure DrawStaticBorder(const ADrawParams: TdxBarStaticLikeControlDrawParams; var ARect: TRect); virtual;
    procedure DrawStaticGlyphAndCaption(const ADrawParams: TdxBarStaticLikeControlDrawParams; const ARect: TRect); virtual;
    procedure DrawStaticLikeControl(const ADrawParams: TdxBarStaticLikeControlDrawParams; var ARect: TRect; const AIndentsRect: TRect); virtual;
    class function StaticBackgroundIsOpaque(const ADrawParams: TdxBarItemControlDrawParams): Boolean; virtual;
    function StaticControlGetBorderOffsets(AParent: TCustomdxBarControl; ABorderStyle: TdxBarStaticBorderStyle): TRect; virtual;
    // Separator
    class function SeparatorControlGetIndents(const ADrawParams: TdxBarSeparatorControlDrawParams;
      ADrawAreaType: TdxBarItemControlPart): TRect; virtual;
    function SubMenuGetSeparatorSize: Integer; virtual;
    procedure DrawSeparatorGlyphAndCaption(const ADrawParams: TdxBarSeparatorControlDrawParams; const ARect: TRect); virtual;
    procedure DrawSeparatorControl(const ADrawParams: TdxBarSeparatorControlDrawParams; const ARect: TRect); virtual;

    // ScreenTip
      // Attributes
    function ScreenTipGetDescriptionTextColor: TColor; virtual;
    function ScreenTipGetTitleTextColor: TColor; virtual;
      // Size
    function ScreenTipGetFooterLineSize: Integer; virtual;
      // Draw
    procedure ScreenTipDrawBackground(ACanvas: TcxCanvas; ARect: TRect); virtual;
    procedure ScreenTipDrawFooterLine(ACanvas: TcxCanvas; const ARect: TRect); virtual;
  end;

  TdxBarStandardPainter = class(TdxBarPainter)
  protected
    procedure DrawGlyphBorder(ABarItemControl: TdxBarItemControl; DC: HDC; ABrush: HBRUSH;
      NeedBorder: Boolean; R: TRect; PaintType: TdxBarPaintType; IsGlyphEmpty,
      Selected, Down, DrawDowned, ADroppedDown, IsSplit: Boolean); override;
    procedure DrawGlyphCheckMark(ABarItemControl: TdxBarItemControl; DC: HDC;
      X, Y, DoubleSize: Integer); override;
    class function IgnoreGlyphOpaque: Boolean; override;
    // Bar
    class function BarIsBarSmall(ABarControl: TdxBarControl; const R: TRect): Boolean; override;
    class procedure BarDrawMarkAtPos(ABarControl: TdxBarControl; DC: HDC;
      const ItemRect: TRect; Offset: Integer); override;
    procedure BarDrawMarkBackground(ABarControl: TdxBarControl; DC: HDC;
      ItemRect: TRect; AToolbarBrush: HBRUSH); override;
  public
    // Common
      // Sizes
    function GetBorderSize: Integer; override;
    class function GetCaptionOffsets: TRect; override;
    class function GlyphDownShift(ABarItemControl: TdxBarItemControl): Integer; override;
    class function GlyphDrawDownedShift(ABarItemControl: TdxBarItemControl; ADown: Boolean): Integer; override;
    class function LoweredBorderSize(ABarItemControl: TdxBarItemControl): Integer; override;
      // Draw
    class procedure DrawDisabledShadowRect(ABarItemControl: TdxBarItemControl; DC: HDC;
      R: TRect); override;
    procedure DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect); override;
    class procedure FrameAndFillRect(ABarItemControl: TdxBarItemControl; DC: HDC;
      var R: TRect; Enabled, Selected, Pressed: Boolean); override;
    class function GlyphBkgndBrush(ABarItemControl: TdxBarItemControl;
      APaintType: TdxBarPaintType; AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown,
      AForceUseBkBrush, AGrayScale: Boolean): HBRUSH; override;
    // BarManager
    function BeforeFingersSize: Integer; override;
    function FingersSize(ABarControl: TdxBarControl): Integer; override;
    class function SubMenuBeginGroupIndent: Integer; override;
    // Custom Bar
    class procedure GetEditTextVerticalOffsets(out ATop, ABottom: Integer); override;
    // Bar
    class function BarAllowHotTrack: Boolean; override;
    class function BarAllowQuickCustomizing: Boolean; override;
    procedure BarDrawCloseButton(ABarControl: TdxBarControl; DC: HDC; R: TRect); override;
    procedure BarDrawDockedBarBorder(ABarControl: TdxBarControl; DC: HDC; R: TRect;
      AToolbarBrush: HBRUSH); override;
    procedure BarDrawFloatingBarBorder(ABarControl: TdxBarControl; DC: HDC;
      R, CR: TRect; AToolbarBrush: HBRUSH); override;
    procedure BarDrawMDIButton(ABarControl: TdxBarControl; AButton: TdxBarMDIButton;
      AState: Integer; DC: HDC; R: TRect); override;
    class function BarHorSize: Integer; override;
    function BarMarkItemRect(ABarControl: TdxBarControl): TRect; override;
    class function BarTopSize: Integer; override;
    class function BarBottomSize: Integer; override;
    class function BarUseSystemClose: Boolean; override;
    class function BarUseSystemNCBorder: Boolean; override;
    // ButtonControl
    procedure DrawButtonControlArrowBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      var R1: TRect; ABrush: HBRUSH); override;

    // ComboControl
    class procedure ComboControlDrawSimpleButton(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect; ABrush: HBRUSH); override;

    // DropDownListBox
    procedure DropDownListBoxDrawBorder(DC: HDC; AColor: TColor; ARect: TRect); override;
    // SubMenuControl
    class procedure SubMenuControlDrawItemFrame(ABarSubMenuControl: TdxBarSubMenuControl;
      AControl: TdxBarItemControl; DC: HDC; AItemRect: TRect; AIndex: Integer); override;
    class function SubMenuControlIsOffsetRecentGroupNeeded: Boolean; override;
    class function SubMenuControlContentRectOffset(ABarSubMenuControl: TdxBarSubMenuControl): TRect; override;
    class function SubMenuControlClientBorderSize: Integer; override;
    // ProgressControl
      // Conditions
    function CanUpdateBarPartly: Boolean; override;
  end;

  TdxBarEnhancedPainter = class(TdxBarStandardPainter)
  protected
    // Bar
    class procedure BarDrawMarkAtPos(ABarControl: TdxBarControl; DC: HDC;
      const ItemRect: TRect; Offset: Integer); override;
    procedure BarDrawMarkBackground(ABarControl: TdxBarControl; DC: HDC;
      ItemRect: TRect; AToolbarBrush: HBRUSH); override;
  public
    // BarManager
    function BeforeFingersSize: Integer; override;
    function FingersSize(ABarControl: TdxBarControl): Integer; override;
    class function SubMenuBeginGroupIndent: Integer; override;
    // Bar
    class function BarAllowQuickCustomizing: Boolean; override;
    procedure BarDrawDockedBarBorder(ABarControl: TdxBarControl; DC: HDC; R: TRect;
      AToolbarBrush: HBRUSH); override;
  end;

  TdxBarFlatPainter = class(TdxBarPainter)
  protected
    // Common
    procedure DrawGlyphBorder(ABarItemControl: TdxBarItemControl; ADC: HDC; ABrush: HBRUSH;
      ANeedBorder: Boolean; R: TRect; APaintType: TdxBarPaintType; AGlyphEmpty,
      ASelected, ADowned, ADrawDowned, ADroppedDown, AIsSplit: Boolean); override;
    procedure DrawGlyphCheckMark(ABarItemControl: TdxBarItemControl; DC: HDC;
      X, Y, DoubleSize: Integer); override;
    class procedure DrawFrameRect(ABarItemControl: TdxBarItemControl; ADC: HDC;
      const ARect: TRect; ABrush: HBRUSH; APaintType: TdxBarPaintType; ASelected, ADowned: Boolean); virtual;
    class procedure FrameFlatSelRect(DC: HDC; const R: TRect); override;
    class function GetToolbarBrush(ABarItemControl: TdxBarItemControl): HBRUSH; virtual;
    // Bar
    class function BarCaptionBkColor(ABarControl: TdxBarControl; AMainFormActive: Boolean): COLORREF; override;
    class function BarMarkArrowColor(ABarControl: TdxBarControl; AState: TdxBarMarkState): COLORREF; override;
    procedure BarDrawMarkBackground(ABarControl: TdxBarControl; DC: HDC;
      ItemRect: TRect; AToolbarBrush: HBRUSH); override;
    class procedure BarOffsetFloatingBarCaption(ABarControl: TdxBarControl;
      var X: Integer; var R: TRect); override;
    class function GetDrawMarkElementColor(ABarControl: TdxBarControl): Integer; override;
    // SubMenuControl
    procedure SubMenuControlDrawNonRecentGroupSeparator(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection); override;
    procedure SubMenuControlDrawMarkSelection(ABarSubMenuControl: TdxBarSubMenuControl; ADC: HDC; const AMarkRect: TRect); override;
    // SpinEditControl
    procedure DrawSpinEditArrow(const ADrawParams: TdxBarSpinEditDrawParams; AArrowPos: TPoint; AButtonIndex: Integer); override;
  public
    // New
    procedure CalculateSpinEditParts(const ADrawParams: TdxBarSpinEditDrawParams;
      var AParts: array of TRect; const AItemRect: TRect); override;

    // Common
      // Sizes
    function GetBorderSize: Integer; override;
    class function GetControlCaptionOffset(ABarItemControl: TdxBarItemControl): Integer; override;
      // Draw
    procedure DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect); override;
    class procedure DrawLowered(DC: HDC; var R: TRect); override;
    procedure DrawStaticBorder(const ADrawParams: TdxBarStaticLikeControlDrawParams; var ARect: TRect); override;
    class procedure FrameAndFillRect(ABarItemControl: TdxBarItemControl; DC: HDC;
      var R: TRect; Enabled, Selected, Pressed: Boolean); override;
    class function GlyphBkgndBrush(ABarItemControl: TdxBarItemControl;
      APaintType: TdxBarPaintType; AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown,
      AForceUseBkBrush, AGrayScale: Boolean): HBRUSH; override;
    class function IsFlatGlyphImage: Boolean; override;
    class function IsFlatItemText: Boolean; override;
    class function IsGlyphImageBackgroundOpaque(ABarItemControl: TdxBarItemControl;
      ADown, ADrawDowned, ASelected, AGlyphEmpty: Boolean): Boolean; override;
    class function IsGlyphImageHasShadow: Boolean; override;
    class function LoweredBorderSize(ABarItemControl: TdxBarItemControl): Integer; override;
    class function StaticBorderBrush(ABarItemControl: TdxBarItemControl; ABorderStyle: TdxBarStaticBorderStyle): HBRUSH; virtual;
    class function TextAreaOffset(ABarItemControl: TdxBarItemControl): Integer; override;
    // BarManager
    function BeforeFingersSize: Integer; override;
    function FingersSize(ABarControl: TdxBarControl): Integer; override;
    class function RealButtonArrowWidth(ABarManager: TdxBarManager): Integer; override;
    class function RealLargeButtonArrowWidth(ABarManager: TdxBarManager): Integer; override;
    class function SubMenuBeginGroupIndent: Integer; override;
    // CustomBar
    class function BarChildrenHaveShadows(ABarControl: TCustomdxBarControl): Boolean; override;
    class procedure BarDrawBarControlOwner(ACustomBarControl: TCustomdxBarControl; DC: HDC;
      R: TRect; ABarControl: TCustomdxBarControl); virtual;
    class procedure BarDrawBarControlOwnerBorder(ACustomBarControl: TCustomdxBarControl;
      DC: HDC; R: TRect; ABarItemControl: TdxBarItemControl; ABarControl: TCustomdxBarControl); virtual;
    class procedure BarDrawBarControlOwnerFrame(ACustomBarControl: TCustomdxBarControl;
      DC: HDC; R: TRect); virtual;
    class procedure BarDrawBarControlOwnerLink(ACustomBarControl: TCustomdxBarControl;
      DC: HDC; R, ALinkR: TRect; ABarItemControl: TdxBarItemControl); virtual;
    class function BarToolbarBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarBrushEx(ABarControl: TdxBarControl): HBRUSH; override;
    class function BarToolbarDownedBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarDownedSelBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarSelBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    // Bar
    function BarBeginGroupSideSize: Integer; override;
    function BarBeginGroupSize: Integer; override;
    procedure BarDrawBeginGroup(ABarControl: TCustomdxBarControl; DC: HDC;
      ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean); override;
    procedure BarDrawCloseButton(ABarControl: TdxBarControl; DC: HDC; R: TRect); override;
    procedure BarDrawDockedBarBorder(ABarControl: TdxBarControl; DC: HDC; R: TRect;
      AToolbarBrush: HBRUSH); override;
    procedure BarDrawFloatingBarBorder(ABarControl: TdxBarControl; DC: HDC;
      R, CR: TRect; AToolbarBrush: HBRUSH); override;
    procedure BarDrawMark(ABarControl: TdxBarControl; DC: HDC; MarkR: TRect); override;
    procedure BarDrawMDIButton(ABarControl: TdxBarControl; AButton: TdxBarMDIButton;
      AState: Integer; DC: HDC; R: TRect); override;
    // QuickCustItem
    class function BarToolbarBrushEx2(ABarControl: TdxBarControl): HBRUSH; override;
    class procedure DrawQuickCustItemFrame(ABarItemControl: TdxBarItemControl;
      DC: HDC; var R, ARect: TRect; Selected: Boolean); override;
    class procedure DrawQuickCustItemFrameSelected(ABarItemControl: TdxBarItemControl;
      DC: HDC; WholeR, R: TRect; Selected: Boolean); override;
    class function IsQuickControlPopupOnRight: Boolean; override;
    // ButtonControl
      // Attributes
    function ButtonControlArrowBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH; override;
      // Sizes
    class procedure CorrectButtonControlDefaultHeight(var DefaultHeight: Integer); override;
    class procedure CorrectButtonControlDefaultWidth(var DefaultWidth: Integer); override;
      // Draw
    procedure DrawButtonControlArrowBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      var R1: TRect; ABrush: HBRUSH); override;

    // ComboControl
      // Attributes
    function ComboControlArrowColor(ADrawParams: TdxBarItemControlDrawParams): TColor; override;
    function ComboControlButtonBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH; override;
      // Draw
    class procedure ComboControlDrawSimpleButton(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect; ABrush: HBRUSH); override;

    // SubMenuControl
      // Sizes
    class function SubMenuControlArrowsOffset: Integer; override;
    function SubMenuControlBeginGroupRect(
      ABarSubMenuControl: TdxBarSubMenuControl; AControl: TdxBarItemControl;
      const AItemRect: TRect): TRect; override;
    function SubMenuControlBeginGroupSize: Integer; override;
    procedure SubMenuControlCalcDrawingConsts(ACanvas: TcxCanvas;
      ATextSize: Integer; out AMenuArrowWidth, AMarkSize: Integer); override;
    class function SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; override;
      // Positions
    class function SubMenuControlGetItemIconRect(const AItemRect: TRect; AIconAreaSize: Integer): TRect; override;
    class function SubMenuControlGetItemTextRect(const ADrawParams: TdxBarButtonLikeControlDrawParams; const AItemRect: TRect): TRect; override;
    class function SubMenuControlGetItemTextIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer; override;
      // Draw
    procedure SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); override;
    procedure SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; const R: TRect; ABrush: HBRUSH); override;
    procedure SubMenuControlDrawDetachCaption(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); override;
    procedure SubMenuControlDrawBeginGroup(ABarSubMenuControl: TdxBarSubMenuControl;
      AControl: TdxBarItemControl; ACanvas: TcxCanvas; const ABeginGroupRect: TRect); override;
    procedure SubMenuControlDrawSeparator(ACanvas: TcxCanvas; const ARect: TRect); override;
    class function SubMenuControlGetSeparatorColor: TColor; virtual;
    class function SubMenuControlMarkArrowSize(AMarkSize: Integer): Integer; override;
    class function SubMenuControlNormalItemHeight: Integer; override;
    class procedure SubMenuControlOffsetDetachCaptionRect(ABarSubMenuControl: TdxBarSubMenuControl;
      var R: TRect); override;
    class function SubMenuControlTextSize(ACanvas: TcxCanvas): Integer; override;
    class function SubMenuControlToolbarItemsBrush(ABarSubMenuControl: TdxBarSubMenuControl): HBRUSH; override;
    // CustomCombo
    class procedure CustomComboDrawItem(ABarCustomCombo: TdxBarCustomCombo;
      ACanvas: TCanvas; AIndex: Integer; ARect: TRect; AState: TOwnerDrawState;
      AInteriorIsDrawing: Boolean); override;
    // EditControl
    class function EditControlBorderOffsets(APaintType: TdxBarPaintType): TRect; override;
    procedure EditControlDrawBorder(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect); override;
    procedure EditControlDrawSelectionFrame(const ADrawParams: TdxBarEditLikeControlDrawParams; const ARect: TRect); override;
    class function EditControlCaptionRightIndentIsOpaque(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; override;
      // Select EditControl indents
    class function EditControlCaptionRelativeLeftIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer; override;
    class function EditControlCaptionAbsoluteLeftIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer; override;
    class function EditControlCaptionRightIndent: Integer; override;
    class function EditControlSubMenuGlyphIndents(const ADrawParams: TdxBarEditLikeControlDrawParams): TRect; override;

    class function EditControlGetRightCaptionIndentBrush(ABarEditControl: TdxBarCustomEditControl): HBRUSH; override;
    class function EditControlGlyphIsDrawSelected(ABarEditControl: TdxBarCustomEditControl): Boolean; override;
    class function HasEditControlExternalFrame(APaintType: TdxBarPaintType;
      ASelected: Boolean): Boolean; override;
    // ProgressControl
      // Conditions
    function CanUpdateBarPartly: Boolean; override;
    // SysPanel
    class procedure SysPanelDraw(AHandle: HWND; AllowResizing, MouseAboveCloseButton,
      CloseButtonIsTracking: Boolean; var CloseButtonRect, GripRect: TRect; Corner: TdxCorner); override;
    // DateNavigator
    class function IsDateNavigatorFlat: Boolean; override;
    procedure DateNavigatorDrawButton(ABarItem: TdxBarItem;
      DC: HDC; R: TRect; const ACaption: string; APressed: Boolean); override;
    // SpinEditControl
    procedure SpinEditControlDrawButton(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer); override;
    // ContainerControl
    class function ContainerControlSubMenuOffset: Integer; override;
    // InPlaceSubItemControl
    function InPlaceSubItemControlIsFlatItemText(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Boolean; override;
    function InPlaceSubItemControlIsArrowSelected(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Boolean; override;
  end;

  TdxBarOffice11Painter = class(TdxBarFlatPainter)
  protected
    // Common
    procedure DrawGlyphBorder(ABarItemControl: TdxBarItemControl; DC: HDC; ABrush: HBRUSH;
      NeedBorder: Boolean; R: TRect; PaintType: TdxBarPaintType; IsGlyphEmpty,
      Selected, Down, DrawDowned, ADroppedDown, IsSplit: Boolean); override;
    class procedure DrawItemArrow(DC: HDC; R: TRect; ArrowType: TcxArrowDirection;
      Enabled, Selected, Flat: Boolean; AColor: TColor = clDefault); override;
    procedure DrawLargeItemArrow(DC: HDC; R: TRect; ArrowType: TcxArrowDirection;
      Size: Integer; Selected, Enabled, Flat: Boolean; AColor: TColor = clDefault); override;
    class procedure DrawFrameRect(ABarItemControl: TdxBarItemControl; ADC: HDC;
      const ARect: TRect; ABrush: HBRUSH; APaintType: TdxBarPaintType; ASelected, ADowned: Boolean); override;
    class procedure FrameFlatSelRect(DC: HDC; const R: TRect); override;
    class function GetBarGradientRect(ABarControl: TCustomdxBarControl): TRect;
    class procedure GetDockColors(ADockControl: TdxDockControl; var AColor1, AColor2: TColor);
    class procedure GetMarkColors(ABarControl: TdxBarControl; var AMarkColor1, AMarkColor2, AColor6, AColor9: TColor);
    class procedure GetSelectedColors(ABarItemControl: TdxBarItemControl;
      ADown, ASelected: Boolean; var AColor1, AColor2: TColor);
    class function GetToolbarBrush(ABarItemControl: TdxBarItemControl): HBRUSH; override;

    function GetDefaultEnabledTextColor(ABarItemControl: TdxBarItemControl;
      ASelected, AFlat: Boolean): TColor; override;
    procedure GetDisabledTextColors(ABarItemControl: TdxBarItemControl;
      ASelected, AFlat: Boolean; var AColor1, AColor2: TColor); override;

    class function GetFaded(ABarControl: TCustomdxBarControl): Boolean; override;
    class function IgnoreNonRecentColor: Boolean; override;
    class function IsMenuGradient(ABarItemControl: TdxBarItemControl): Boolean;
    class function IsSimpleMark(ABarControl: TdxBarControl): Boolean;
    // Bar
    class function BarCaptionBkColor(ABarControl: TdxBarControl; AMainFormActive: Boolean): COLORREF; override;
    function BarCaptionColor(ABarControl: TdxBarControl): COLORREF; override;
    class function BarMarkArrowColor(ABarControl: TdxBarControl; AState: TdxBarMarkState): COLORREF; override;
    class procedure BarDrawFingerElements(ABarControl: TCustomdxBarControl; DC: HDC;
      ARect: TRect; AHorizontal: Boolean); virtual;
    procedure BarDrawMarkBackground(ABarControl: TdxBarControl; DC: HDC;
      ItemRect: TRect; AToolbarBrush: HBRUSH); override;
    procedure BarDrawMarkElements(ABarControl: TdxBarControl; DC: HDC;
      ItemRect: TRect); override;
    // SubMenuControl
      // Sizes
    function SubMenuControlMarkBorderSize: Integer;
    function SubMenuControlMarkContentRect(const ADrawRect: TRect): TRect;
      // Draw
    procedure SubMenuControlDrawMarkContent(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect; ASelected: Boolean); override;
  public
    // Common
    procedure DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect); override;
    class procedure FrameAndFillRect(ABarItemControl: TdxBarItemControl; DC: HDC;
      var R: TRect; Enabled, Selected, Pressed: Boolean); override;
    class function IsFlatGlyphImage: Boolean; override;
    class function IsGlyphImageHasShadow: Boolean; override;
    class function IsItemTextSelectedInverted: Boolean; override;
    class function StaticBorderBrush(ABarItemControl: TdxBarItemControl;
      ABorderStyle: TdxBarStaticBorderStyle): HBRUSH; override;
    // BarManager
    function BeforeFingersSize: Integer; override;
    class function BorderSizeX: Integer; override;
    class function BorderSizeY: Integer; override;
    class function EmptyFingersSize: Integer; override;
    // DockControl
    procedure DockControlFillBackground(ADockControl: TdxDockControl;
      DC: HDC; ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor); override;
    class function IsNativeBackground: Boolean; override;
    // CustomBar
    class function BarControlOwnerBrush(ABarManager: TdxBarManager): HBRUSH; override;
    class procedure BarDrawBarControlOwnerFrame(ACustomBarControl: TCustomdxBarControl;
      DC: HDC; R: TRect); override;
    class procedure BarDrawBarControlOwnerLink(ACustomBarControl: TCustomdxBarControl;
      DC: HDC; R, ALinkR: TRect; ABarItemControl: TdxBarItemControl); override;
    procedure BarDrawDockedBackground(ABarControl: TdxBarControl; DC: HDC;
      ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor); override;
    procedure BarDrawFloatingBackground(ABarControl: TCustomdxBarControl; DC: HDC;
      ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor); override;
    class procedure BarDrawOwnerLink(ABarControl: TCustomdxBarControl; DC: HDC); override;
    function BarHasShadow(ABarControl: TCustomdxBarControl): Boolean; override;
    class function BarToolbarBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarBrushEx(ABarControl: TdxBarControl): HBRUSH; override;
    class function BarToolbarDownedBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarDownedSelBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarSelBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    function ComboBoxArrowWidth(ABarControl: TCustomdxBarControl; cX: Integer): Integer; override;
    // Bar
    class function BarBeforeFingersIndent: Integer; virtual;
    procedure BarBorderPaintSizes(ABarControl: TdxBarControl; var R: TRect); override;
    procedure BarBorderSizes(ABar: TdxBar; AStyle: TdxBarDockingStyle; var R: TRect); override;
    procedure BarDrawBeginGroup(ABarControl: TCustomdxBarControl; DC: HDC;
      ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean); override;
    class procedure BarDrawCaptionElement(ABarControl: TdxBarControl; DC: HDC;
      R: TRect; AState: TdxBarMarkState); override;
    procedure BarDrawDockedBarBorder(ABarControl: TdxBarControl; DC: HDC; R: TRect;
      AToolbarBrush: HBRUSH); override;
    procedure BarDrawFloatingBarBorder(ABarControl: TdxBarControl; DC: HDC;
      R, CR: TRect; AToolbarBrush: HBRUSH); override;
    procedure BarDrawFloatingBarCaption(ABarControl: TdxBarControl; DC: HDC;
      R, CR: TRect; AToolbarBrush: HBRUSH); override;
    function BarMarkRect(ABarControl: TdxBarControl): TRect; override;
    procedure BarMarkRectInvalidate(ABarControl: TdxBarControl); override;

    // SubMenuControl
      // Attributes
    class function SubMenuControlGetSeparatorColor: TColor; override;
    class function SubMenuControlToolbarItemsBrush(ABarSubMenuControl: TdxBarSubMenuControl): HBRUSH; override;
      // Conditions
    class function SubMenuControlHasBand: Boolean; override;
    class function SubMenuControlIsSingleMenuBorder(ABarSubMenuControl: TdxBarSubMenuControl): Boolean;
      // Positions
    class procedure SubMenuControlOffsetDetachCaptionRect(ABarSubMenuControl: TdxBarSubMenuControl;
      var R: TRect); override;
      // Sizes
    procedure SubMenuControlCalcDrawingConsts(ACanvas: TcxCanvas;
      ATextSize: Integer; out AMenuArrowWidth, AMarkSize: Integer); override;
    class function SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; override;
      // Draw
    procedure SubMenuControlDrawBackground(ABarSubMenuControl: TdxBarSubMenuControl;
      ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor); override;
    procedure SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); override;
    procedure SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; const R: TRect; ABrush: HBRUSH); override;
    procedure SubMenuControlDrawDetachCaption(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); override;

    // DropDownListBox
    procedure DropDownListBoxDrawBorder(DC: HDC; AColor: TColor; ARect: TRect); override;
    // QuickCustItem
    class function BarToolbarBrushEx2(ABarControl: TdxBarControl): HBRUSH; override;
    class procedure DrawQuickCustItemFrameSelected(ABarItemControl: TdxBarItemControl;
      DC: HDC; WholeR, R: TRect; Selected: Boolean); override;

    // Button Control
    function ButtonControlArrowBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH; override;

    // EditButton
      // Conditions
    function EditButtonIsCustomBackground(AState: Integer): Boolean; override;
      // Draw
    procedure EditButtonDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams; AState: Integer;
      ARect: TRect; ABrush: HBrush); override;
    
    // EditControl
    class function EditControlBorderOffsets(APaintType: TdxBarPaintType): TRect; override;
    procedure EditControlDrawBorder(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect); override;
    class function EditControlCaptionBackgroundIsOpaque(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; override;
      // Select EditControl indents
    class function EditControlCaptionAbsoluteLeftIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer; override;
    class function EditControlSubMenuGlyphIndents(const ADrawParams: TdxBarEditLikeControlDrawParams): TRect; override;
    class function EditControlCaptionRightIndentIsOpaque(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; override;
    class function EditControlShowIconDefault(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; override;

    // ComboControl
      // Attributes
    function ComboControlArrowColor(ADrawParams: TdxBarItemControlDrawParams): TColor; override;
    function ComboControlButtonBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH; override;
      // Draw
    class procedure ComboControlDrawSimpleButton(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect; ABrush: HBRUSH); override;

    // ProgressControl
    class function ProgressControlIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer; override;
    // DateNavigator
    procedure DateNavigatorDrawButton(ABarItem: TdxBarItem;
      DC: HDC; R: TRect; const ACaption: string; APressed: Boolean); override;
    function DateNavigatorHeaderColor: TColor; override;
    // InPlaceSubItemControl
    class function InPlaceSubItemControlBrush: HBRUSH; override;
    // Edit
    function EditGetDisabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF; override;
    function EditGetDisabledTextColor: COLORREF; override;
    // Separator
    procedure DrawSeparatorGlyphAndCaption(const ADrawParams: TdxBarSeparatorControlDrawParams; const ARect: TRect); override;
  end;

  TdxBarXPPainter = class(TdxBarPainter)
  private
    procedure BarBeginGroupSizeInit;
    procedure BarCloseButtonSizeInit;
    procedure ButtonBorderHeightInit;
    procedure ComboBoxArrowWidthInit;
    procedure EditControlBorderOffsetsInit;
    procedure GripperSizeInit;
    procedure InitParams;
    procedure ProgressControlBarHeightInit;
    procedure StatusBarGripSizeInit;
    procedure SubMenuControlBeginGroupSizeInit;

    class function IsArrowButtonDowned(APaintStyle: TdxBarPaintType; AIsPressed: Boolean): Boolean;
  protected
    // Common
    procedure DrawGlyphBorder(ABarItemControl: TdxBarItemControl; DC: HDC; ABrush: HBRUSH;
      NeedBorder: Boolean; R: TRect; PaintType: TdxBarPaintType; IsGlyphEmpty,
      Selected, Down, DrawDowned, ADroppedDown, IsSplit: Boolean); override;
    procedure DrawGlyphCheckMark(ABarItemControl: TdxBarItemControl; DC: HDC;
      X, Y, DoubleSize: Integer); override;
    class function GetFaded(ABarControl: TCustomdxBarControl): Boolean; override;
    class function IsMenuItem(ABarItemControl: TdxBarItemControl): Boolean; override;
    // Bar
    class procedure BarDrawNativeGrip(ABarControl: TdxBarControl; DC: HDC; R: TRect;
      AToolbarBrush: HBRUSH);
    procedure BarDrawMarkBackground(ABarControl: TdxBarControl; DC: HDC;
      ItemRect: TRect; AToolbarBrush: HBRUSH); override;
    class procedure BarOffsetFloatingBarCaption(ABarControl: TdxBarControl;
      var X: Integer; var R: TRect); override;

    // ColorCombo
      // Sizes
    function GetDotSpaceAfter(ADotWidth: Integer): Integer; override;
      // Draw
    procedure DrawDot(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect); override;
  public
    constructor Create(AData: Integer); override;
    // Common
    procedure DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect); override;
    class function GlyphBkgndBrush(ABarItemControl: TdxBarItemControl;
      APaintType: TdxBarPaintType; AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown,
      AForceUseBkBrush, AGrayScale: Boolean): HBRUSH; override;
    class function GlyphDownShift(ABarItemControl: TdxBarItemControl): Integer; override;
    class function GlyphDrawDownedShift(ABarItemControl: TdxBarItemControl; ADown: Boolean): Integer; override;
    class function IsFlatGlyphImage: Boolean; override;
    // BarManager
    function BeforeFingersSize: Integer; override;
    function FingersSize(ABarControl: TdxBarControl): Integer; override;
    function GripperSize(ABarControl: TdxBarControl): Integer; override;
    class function RealButtonArrowWidth(ABarManager: TdxBarManager): Integer; override;
    class function RealLargeButtonArrowWidth(ABarManager: TdxBarManager): Integer; override;
    // DockControl
    procedure DockControlFillBackground(ADockControl: TdxDockControl;
      DC: HDC; ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor); override;
    class function IsNativeBackground: Boolean; override;
    // CustomBar
//    class function BarChildrenHaveShadows(ABarControl: TCustomdxBarControl): Boolean; override;
    class function BarToolbarBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarBrushEx(ABarControl: TdxBarControl): HBRUSH; override;
    class function BarToolbarDownedBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarDownedSelBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    class function BarToolbarSelBrush(ABarControl: TCustomdxBarControl): HBRUSH; override;
    function ComboBoxArrowWidth(ABarControl: TCustomdxBarControl; cX: Integer): Integer; override;
    // Bar
    function BarBeginGroupSideSize: Integer; override;
    function BarBeginGroupSize: Integer; override;
    class function BarBorderSize: Integer; override;
    procedure BarCaptionFillBackground(ABarControl: TdxBarControl; DC: HDC;
      R: TRect; AToolbarBrush: HBRUSH); override;
//    class function BarCaptionSize: Integer; override;
    class function BarCaptionTransparent: Boolean; override;
    class function BarCloseButtonSize: TSize; override;
    procedure BarDrawBeginGroup(ABarControl: TCustomdxBarControl; DC: HDC;
      ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean); override;
    procedure BarDrawCloseButton(ABarControl: TdxBarControl; DC: HDC; R: TRect); override;
    procedure BarDrawDockedBarBorder(ABarControl: TdxBarControl; DC: HDC; R: TRect;
      AToolbarBrush: HBRUSH); override;
    procedure BarDrawFloatingBarBorder(ABarControl: TdxBarControl; DC: HDC;
      R, CR: TRect; AToolbarBrush: HBRUSH); override;
    procedure BarDrawMDIButton(ABarControl: TdxBarControl; AButton: TdxBarMDIButton;
      AState: Integer; DC: HDC; R: TRect); override;
    class procedure StatusBarFillNativeBackground(ABarControl: TdxBarControl; DC: HDC;
      ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor);
    class function StatusBarNativeGripSize(ABarManager: TdxBarManager): TSize;

    // QuickCustItem
    class function IsQuickControlPopupOnRight: Boolean; override;

    // ButtonControl
      // Conditions
    function IsButtonControlArrowFlat: Boolean; override;
      // Sizes
    function GetButtonBorderHeight: Integer; override;
    function GetButtonBorderWidth: Integer; override;
    class procedure CorrectButtonControlDefaultHeight(var DefaultHeight: Integer); override;
      // Draw
    procedure DrawButtonControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      R1: TRect); override;
    procedure DrawButtonControlArrowBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      var R1: TRect; ABrush: HBRUSH); override;

    // EditControl
    class function EditControlBorderOffsets(APaintType: TdxBarPaintType): TRect; override;
    procedure EditControlDrawBorder(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect); override;
    class function EditControlCaptionRightIndentIsOpaque(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; override;
      // Select EditControl indents
    class function EditControlCaptionAbsoluteLeftIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer; override;
    class function EditControlCaptionRightIndent: Integer; override;
    class function EditControlSubMenuGlyphIndents(const ADrawParams: TdxBarEditLikeControlDrawParams): TRect; override;

    class function EditControlGetRightCaptionIndentBrush(ABarEditControl: TdxBarCustomEditControl): HBRUSH; override;
    // CustomCombo
    class procedure CustomComboDrawItem(ABarCustomCombo: TdxBarCustomCombo;
      ACanvas: TCanvas; AIndex: Integer; ARect: TRect; AState: TOwnerDrawState;
      AInteriorIsDrawing: Boolean); override;

    // ComboControl
      // Sizes
    class function ComboControlArrowOffset: Integer; override;
      // Draw
    procedure ComboControlDrawArrowButton(const ADrawParams: TdxBarEditLikeControlDrawParams;
      ARect: TRect; AInClientArea: Boolean); override;

    // SubMenuControl
      // Sizes
    class function SubMenuControlArrowsOffset: Integer; override;
    function SubMenuControlBeginGroupRect(
      ABarSubMenuControl: TdxBarSubMenuControl; AControl: TdxBarItemControl;
      const AItemRect: TRect): TRect; override;
    function SubMenuControlBeginGroupSize: Integer; override;
    class function SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; override;
      // Draw
    procedure SubMenuControlDrawBeginGroup(ABarSubMenuControl: TdxBarSubMenuControl;
      AControl: TdxBarItemControl; ACanvas: TcxCanvas; const ABeginGroupRect: TRect); override;
    procedure SubMenuControlDrawSeparator(ACanvas: TcxCanvas; const ARect: TRect); override;
    procedure SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); override;
    procedure SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; const R: TRect; ABrush: HBRUSH); override;
    class procedure SubMenuControlOffsetDetachCaptionRect(ABarSubMenuControl: TdxBarSubMenuControl;
      var R: TRect); override;
    class function SubMenuControlToolbarItemsBrush(ABarSubMenuControl: TdxBarSubMenuControl): HBRUSH; override;

    // ColorCombo
      // Sizes
    function GetCustomColorButtonIndents(APaintType: TdxBarPaintType): TRect; override;
      // Draw
    procedure ColorComboDrawCustomButton(const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect); override;
    procedure ColorComboDrawCustomButtonAdjacentZone(const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect); override;

    // DateNavigator
    class function IsDateNavigatorFlat: Boolean; override;
    class procedure DateNavigatorDrawNativeButton(ABarItem: TdxBarItem;
      DC: HDC; R: TRect; const ACaption: string; APressed: Boolean);
    procedure DateNavigatorDrawButton(ABarItem: TdxBarItem;
      DC: HDC; R: TRect; const ACaption: string; APressed: Boolean); override;
    // SysPanel
    class procedure SysPanelDraw(AHandle: HWND; AllowResizing, MouseAboveCloseButton,
      CloseButtonIsTracking: Boolean; var CloseButtonRect, GripRect: TRect; Corner: TdxCorner); override;
    class function SysPanelSize: Integer; override;
    // SpinEditControl
    procedure SpinEditControlDrawButton(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer); override;
    function GetSpinEditButtonIndents(APaintType: TdxBarPaintType): TRect; override;
    // ProgressControl
      // Attributes
    class function ProgressControlBarBrushColor: TColorRef; override;
      // Sizes
    function ProgressControlBarHeight(ABarItemControl: TdxBarItemControl): Integer; override;
      // Draw
    procedure ProgressControlDrawBackground(const ADrawParams: TdxBarItemControlDrawParams; var BarR: TRect); override;
    procedure ProgressControlDrawChunks(const ADrawParams: TdxBarItemControlDrawParams; BarR: TRect; ABarBrush: HBRUSH); override;
    // Edit
    function EditGetEnabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF; override;
    function EditGetDisabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF; override;
    function EditGetEnabledTextColor: COLORREF; override;
    function EditGetDisabledTextColor: COLORREF; override;
    // Separator
    function SubMenuGetSeparatorSize: Integer; override;
  end;

  TdxBarSkinnedPainter = class(TdxBarOffice11Painter, IdxFadingPainterHelper)
  private
    FSkinnedObject: TObject;

    function GetSkin: IdxSkin;

    function GetArrowRect(const ADrawParams: TdxBarButtonLikeControlDrawParams; const ARect: TRect): TRect;
    class function GetTextInsteadArrow(const ADrawParams: TdxBarItemControlDrawParams): string;

    class function GetMaxLineCount: Integer;
    procedure InternalDrawBeginGroup(DC: HDC; const ABeginGroupRect: TRect; AHorz: Boolean; AColor1, AColor2: TColor);
    procedure InternalDrawEditButton(const ADrawParams: TdxBarEditLikeControlDrawParams; APartIndex: Integer; ARect: TRect);
  protected
    procedure CorrectCaptionParams(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      var ATextBounds: TRect; const AImageBounds: TRect; out ATextAlignment: DWORD); override;
      
    // IdxFadingPainterHelper
    function BarMarkIsOpaque: Boolean;
    procedure DrawBarMarkState(ABarControl: TdxBarControl; DC: HDC; const R: TRect;
      AState: TdxBarMarkState);
    procedure DrawButtonBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams);

    // Common
    function AllowLargeIcons: Boolean; override;
    procedure BarDrawMarkElements(ABarControl: TdxBarControl; DC: HDC;
      ItemRect: TRect); override;
    procedure DrawToolbarContentPart(ABarControl: TdxBarControl; ACanvas: TcxCanvas); override;
    procedure DrawToolbarNonContentPart(ABarControl: TdxBarControl; DC: HDC); override;
    procedure DrawToolbarNonContentPartCaption(ABarControl: TdxBarControl; DC: HDC); virtual;
    class function GetControlTextIndents: TRect; override;
    class function GetControlCaptionRect(const ADrawParams: TdxBarItemControlDrawParams): TRect; override;

    function GetDefaultEnabledTextColor(ABarItemControl: TdxBarItemControl;
      ASelected, AFlat: Boolean): TColor; override;
    function GetEnabledTextColor(ABarItemControl: TdxBarItemControl;
      ASelected, AFlat: Boolean): TColor; override;
    procedure GetDisabledTextColors(ABarItemControl: TdxBarItemControl;
      ASelected, AFlat: Boolean; var AColor1, AColor2: TColor); override;

    function GetToolbarCaptionRect(const ARect: TRect): TRect; override;
    procedure InflateSizeForArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; var ASize: Integer); override;
    class function IsCompoundPainting: Boolean; override;

    class function GetButtonPartState(const ADrawParams: TdxBarButtonLikeControlDrawParams; AControlPart: Integer): Integer;
    class function GetEditPartState(const ADrawParams: TdxBarEditLikeControlDrawParams; AControlPart: Integer): Integer;
    class function GetSpinEditPartState(const ADrawParams: TdxBarSpinEditDrawParams;
      AControlPart: Integer): Integer;
    class function GetPartState(const ADrawParams: TdxBarItemControlDrawParams;
      AControlPart: Integer; AForbiddenParts: TdxByteSet): Integer; overload;
    class function GetPartState(const ADrawParams: TdxBarItemControlDrawParams;
      AControlPart: Integer): Integer; overload;

    function GetBarControlState(ABarControl: TdxBarControl): Integer;
    //Hints
    function CreateHintViewInfo(ABarManager: TdxBarManager; AHintText: string; const AShortCut: string;
      AScreenTip: TdxBarScreenTip): TdxBarCustomHintViewInfo; override;
    // ButtonLikeControl
    procedure ButtonLikeControlDoDrawCaption(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      const ATextBounds: TRect; ATextAlignment: DWORD; AFormat: DWORD = 0); override;
    procedure ButtonLikeControlDrawMenuArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      ADirection: TcxArrowDirection; ARect: TRect);
    // SpinEditControl
    procedure DrawSpinEditArrow(const ADrawParams: TdxBarSpinEditDrawParams;
      AArrowPos: TPoint; AButtonIndex: Integer); override;
    // SubMenuControl
    procedure SubMenuControlDrawMarkContent(ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; R: TRect; ASelected: Boolean); override;
    procedure SubMenuControlDrawMarkSelection(ABarSubMenuControl: TdxBarSubMenuControl; ADC: HDC; const AMarkRect: TRect); override;
    procedure SubMenuControlFillScrollArrow(ACanvas: TcxCanvas; ARect: TRect; AColor: TColor); override;
    function SubMenuControlGetScrollBandSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; override;
    class function SubMenuControlGetScrollArrowSize(ATextSize: Integer): Integer; override;
    class function SubMenuControlUseScrollButtons: Boolean; override;
  public
    constructor Create(AData: Integer); override;

    procedure CalculateButtonParts(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      var AParts: array of TRect; const AItemRect: TRect); override;
    procedure CalculateSpinEditParts(const ADrawParams: TdxBarSpinEditDrawParams;
      var AParts: array of TRect; const AItemRect: TRect); override;
    procedure DrawArrow(ADC: HDC; ARect: TRect; AArrowState: Integer);

    // Common
      // Sizes
    function GetBorderSize: Integer; override;
    function GetIconAreaSize(ABarControl: TCustomdxBarControl): Integer; override;
    class function GetDefaultTextSize(ACanvas: TcxCanvas): Integer; override;
    function GetLargeImageBounds(AItemControl: TdxBarItemControl;
      const AImageSize: TSize; const ADrawRect: TRect; APaintType: TdxBarPaintType;
      AViewStructure: TdxBarItemControlViewStructure; AGlyphLayout: TdxBarGlyphLayout): TRect; override;
    function GetSmallIconSize: Integer;
      // Draw
    procedure DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect); override;
    procedure DrawGlyphAndBkgnd(ABarItemControl: TdxBarItemControl; ADC: HDC;
      const R, AGlyphRect: TRect; APaintType: TdxBarPaintType; AGlyph: TBitmap;
      AImages: TCustomImageList; AImageIndex: Integer; AGlyphEmpty, ASelected, ADowned,
      ADrawDowned, ADroppedDown, AForceUseBkBrush, AGrayScale, AIsSplit: Boolean); override;
    function GetToolbarContentOffsets(ABar: TdxBar;
      ADockingStyle: TdxBarDockingStyle; AHasSizeGrip: Boolean): TRect; override;
    function GetToolbarsOffsetForAutoAlign: Integer; override;
    class function RealButtonArrowWidth(ABarManager: TdxBarManager): Integer; override;
    class function LoweredBorderSize(ABarItemControl: TdxBarItemControl): Integer; override;

    // CustomBar
    function BarLinkedOwnerHasShadow(ABarControl: TCustomdxBarControl): Boolean; override;
    procedure BarDrawBackground(ABarControl: TdxBarControl; ADC: HDC;
      const ADestRect, ASourceRect: TRect; ABrush: HBRUSH; AColor: TColor); override;
    procedure BarDrawDockedBackground(ABarControl: TdxBarControl; DC: HDC;
      ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor); override;
    function ComboBoxArrowWidth(ABarControl: TCustomdxBarControl; cX: Integer): Integer; override;
    class procedure SetWindowRgn(AHandle: THandle; const AWindowRect: TRect; ARedraw: Boolean = False); override;
    // Bar
    procedure BarDrawBeginGroup(ABarControl: TCustomdxBarControl; DC: HDC;
      ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean); override;
    // BarItemControl
      // Sizes
    class function GetTailAreaSize(const ADrawParams: TdxBarItemControlDrawParams): Integer; override;

    // ButtonControl
      // Sizes
    class function GetDefaultArrowSignSize: TSize; override;
    function GetButtonBorderHeight: Integer; override;
    function GetButtonBorderWidth: Integer; override;
    function GetButtonHeight(AIconSize, ATextSize: Integer): Integer; override;
    function GetButtonWidth(AIconSize, ATextSize: Integer): Integer; override;
    class procedure CorrectButtonControlDefaultHeight(var DefaultHeight: Integer); override;
      // Draw
    procedure DrawButtonLikeControl(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect); override;
    procedure DrawButtonControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams;
      R1: TRect); override;
    procedure DrawSplitControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect); override;
    procedure DrawAssociateControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect); override;

    // DropDownListBox
    procedure DropDownListBoxDrawBorder(DC: HDC; AColor: TColor; ARect: TRect); override;

    // SubMenuControl
      // Conditions
    class function SubMenuControlHasBand: Boolean; override;
      // Sizes
    class function SubMenuControlArrowWidth(ATextSize: Integer): Integer; override;
    function SubMenuControlBeginGroupSize: Integer; override;
    class function SubMenuControlNCBorderSize: Integer; override;
    class function SubMenuControlClientBorderSize: Integer; override;
    class function SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; override;
    class function SubMenuControlGetBandSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer; override;
    class function SubMenuControlNormalItemHeight: Integer; override;
    class function SubMenuControlTextIndent: Integer;
    class function SubMenuControlInternalBorderSize: Integer; override;
    class function SubMenuControlInternalBorderOffset: Integer; override;
    class function SubMenuControlTextSize(ACanvas: TcxCanvas): Integer; override;
      // Positions
    class function SubMenuControlGetItemIconRect(const AItemRect: TRect; AIconAreaSize: Integer): TRect; override;
    class function SubMenuControlGetItemTextIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer; override;
      // Draw
    procedure SubMenuControlDrawScrollBandBackground(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection); override;
    procedure SubMenuControlDrawScrollButton(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection); override;
    procedure SubMenuControlDrawBackground(ABarSubMenuControl: TdxBarSubMenuControl;
      ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor); override;
    procedure SubMenuControlDrawBeginGroup(ABarSubMenuControl: TdxBarSubMenuControl;
      AControl: TdxBarItemControl; ACanvas: TcxCanvas; const ABeginGroupRect: TRect); override;
    procedure SubMenuControlDrawSeparator(ACanvas: TcxCanvas; const ARect: TRect); override;
    procedure SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); override;
    procedure SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; const R: TRect; ABrush: HBRUSH); override;
    procedure SubMenuControlDrawDetachCaption(ABarSubMenuControl: TdxBarSubMenuControl;
      DC: HDC; R: TRect); override;
    procedure SubMenuControlDrawItemBackground(ABarSubMenuControl: TdxBarSubMenuControl;
      ACanvas: TcxCanvas; AItemRect: TRect);
      
    // ApplicationMenu
      // Sizes
    function ApplicationMenuGetFrameSizes: TRect; override;
      // Draw
    procedure ApplicationMenuDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const ARect: TRect); override;
    procedure ApplicationMenuDrawButton(const ADrawParams: TdxBarApplicationMenuButtonControlDrawParams; var R: TRect); override;
    procedure ApplicationMenuDrawContentArea(ABarSubMenuControl: TdxBarSubMenuControl;
      ACanvas: TcxCanvas; const AContentRect, AItemsArea: TRect); override;
      
    // ExtraMenuControl
    procedure ExtraMenuControlDrawBackground(AExtraMenuControl: TCustomdxBarControl;
      ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor); override;
    procedure ExtraMenuControlDrawBeginGroup(AExtraMenuControl: TCustomdxBarControl;
      ACanvas: TcxCanvas; ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean); override;
    procedure ExtraMenuControlDrawItemBackground(AExtraMenuControl: TCustomdxBarControl;
      ACanvas: TcxCanvas; AItemRect: TRect);
    // EditButton
      // Conditions
    function EditButtonAllowOffsetContent: Boolean; override;
    function EditButtonAllowCompositeFrame: Boolean; override;
    class function EditButtonAllowHotTrack(const ADrawParams: TdxBarItemControlDrawParams): Boolean; override;
    function EditButtonIsCustomBorder: Boolean; override;
    function EditButtonIsCustomBackground(AState: Integer): Boolean; override;
      // Sizes
    procedure EditButtonCorrectDefaultWidth(var ADefaultWidth: Integer); override;
      // Draw
    procedure EditButtonDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams; AState: Integer;
      ARect: TRect; ABrush: HBrush); override;
    procedure EditButtonDrawBorder(const ADrawParams: TdxBarItemControlDrawParams;
      AState: Integer; var ADrawRect: TRect; out AContentRect: TRect); override;

    // EditControl
    class function EditControlCaptionBackgroundIsOpaque(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; override;
    class function EditControlCaptionRightIndentIsOpaque(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; override;
    procedure EditControlDrawBorder(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect); override;
    procedure EditControlDrawSelectionFrame(const ADrawParams: TdxBarEditLikeControlDrawParams; const ARect: TRect); override;
    procedure EditControlDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams); override;
    procedure EditGetRealLookAndFeel(ABarManager: TdxBarManager; ALookAndFeel: TcxLookAndFeel); override;
    function EditGetBkColor(const ADrawParams: TdxBarEditLikeControlDrawParams): COLORREF; override;
    class function EditControlShowIconDefault(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean; override;

    // ComboControl
      // Sizes
    class function ComboControlArrowOffset: Integer; override;
    class function ComboControlButtonOffsets(APaintType: TdxBarPaintType): TRect; override;
      // Draw
    procedure ComboControlDrawArrowButton(const ADrawParams: TdxBarEditLikeControlDrawParams;
      ARect: TRect; AInClientArea: Boolean); override;

    // ColorCombo
      // Conditions
    function ColorComboHasCompleteFrame: Boolean; override;
      // Sizes
    function GetCustomColorButtonWidth(APaintType: TdxBarPaintType; const ARect: TRect): Integer; override;
    function GetCustomColorButtonIndents(APaintType: TdxBarPaintType): TRect; override;
      // Draw
    procedure ColorComboDrawCustomButton(const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect); override;
    procedure ColorComboDrawCustomButtonAdjacentZone(const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect); override;

    // DateNavigator
    function DateNavigatorHeaderColor: TColor; override;
    // InPlaceSubItemControl
      //Sizes
    class function InPlaceSubItemGetArrowWidth(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Integer; override;
      //Draw
    procedure InPlaceSubItemControlDrawArrow(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams;
      ADirection: TcxArrowDirection; ARect: TRect); override;
    procedure InPlaceSubItemControlDrawBackground(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams; ARect: TRect); override;
    // ProgressControl
      // Conditions
    function CanUpdateBarPartly: Boolean; override;
      // Draw
    procedure ProgressControlDrawBackground(const ADrawParams: TdxBarItemControlDrawParams; var R: TRect); override;
    procedure ProgressControlFillContent(const ADrawParams: TdxBarItemControlDrawParams; const R: TRect; ABarBrush: HBRUSH); override;
    procedure ProgressControlFillDiscreteContent(const ADrawParams: TdxBarItemControlDrawParams; const R: TRect; ABarBrush: HBRUSH); override;
    // SpinEditControl
    function GetSpinEditArrowPos(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer): TPoint; override;
    procedure SpinEditCorrectFrameRect(const ADrawParams: TdxBarItemControlDrawParams; var ARect: TRect); override;
    function GetSpinEditArrowSize(AHeight: Integer): TSize; override;
    function GetSpinEditButtonBounds(const ADrawParams: TdxBarSpinEditDrawParams; const ARect: TRect; AButton: TdxBarSpinEditButton): TRect; override;
    procedure SpinEditControlDrawButton(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer); override;
    procedure SpinEditControlDrawButtonsAdjacentZone(const ADrawParams: TdxBarSpinEditDrawParams; const ARect: TRect); override;
    procedure SpinEditControlDrawButtonsExternalFrame(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect);
    function GetSpinEditButtonIndents(APaintType: TdxBarPaintType): TRect; override;
    function GetSpinEditButtonWidth(APaintType: TdxBarPaintType; const ARect: TRect): Integer; override;
    // Static
    procedure DrawStaticBorder(const ADrawParams: TdxBarStaticLikeControlDrawParams; var ARect: TRect); override;
    class function StaticBackgroundIsOpaque(const ADrawParams: TdxBarItemControlDrawParams): Boolean; override;
    // Separator
    procedure DrawSeparatorGlyphAndCaption(const ADrawParams: TdxBarSeparatorControlDrawParams; const ARect: TRect); override;

    // ScreenTip
      // Draw
    procedure ScreenTipDrawBackground(ACanvas: TcxCanvas; ARect: TRect); override;
    procedure ScreenTipDrawFooterLine(ACanvas: TcxCanvas; const ARect: TRect); override;

    property Skin: IdxSkin read GetSkin;
    property SkinnedObject: TObject read FSkinnedObject;
  end;

  TRegItemRecord = class
  public
    FItemClass: TdxBarItemClass;
    FItemControlClass: TdxBarItemControlClass;
    FVisible: Boolean;
    constructor Create(AItemClass: TdxBarItemClass; AItemControlClass: TdxBarItemControlClass;
      AVisible: Boolean);
  end;

  TdxBarItemList = class(TList)
  private
    function GetItem(Index: Integer): TRegItemRecord;
    function GetItemClass(Index: Integer): TdxBarItemClass;
    function GetVisibleItemCount: Integer;
    function GetVisibleItemClass(Index: Integer): TdxBarItemClass;
  protected
    procedure Register(AItemClass: TdxBarItemClass;
      AItemControlClass: TdxBarItemControlClass; AVisible: Boolean);
    procedure Unregister(AItemClass: TdxBarItemClass); overload;
    procedure Unregister(Index: Integer); overload;
  public
    destructor Destroy; override;

    property Items[Index: Integer]: TRegItemRecord read GetItem; default;
    property ItemClass[Index: Integer]: TdxBarItemClass read GetItemClass;
    property VisibleItemCount: Integer read GetVisibleItemCount;
    property VisibleItemClass[Index: Integer]: TdxBarItemClass read GetVisibleItemClass;
  end;

  TdxBarManagerFormKind = (fkMain, fkMainOrMDIChild, fkAny);

  { TdxCustomQuickCustItemControl }

  TdxCustomQuickCustItemControl = class(TdxBarButtonControl)
  protected
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); override;
    function GetDefaultWidth: Integer; override;
    function IsDowned: Boolean; virtual; abstract;
  end;

  { TdxBarQuickCustItem and TdxBarQuickCustItemControl }

  TdxBarQuickCustItem = class(TdxBarButton)
  public
    procedure DoClick; override;
  end;

  TdxBarQuickCustItemControl = class(TdxCustomQuickCustItemControl)
  private
    function GetLinkedItemLink: TdxBarItemLink;
  protected
    procedure ControlUnclick(ByMouse: Boolean); override;
    function GetCaption: string; override;
    function GetGlyph: TBitmap; override;
    function GetImageIndex: Integer; override;
    function GetImageList(AViewSize: TdxBarItemControlViewSize): TCustomImageList; override;
    function GetLargeGlyph: TBitmap; override;
    function GetLargeImageIndex: Integer; override;
    function IsDowned: Boolean; override;
    function GetHint: string; override;
    function GetShortCut: TShortCut; override;
    function IsDestroyOnClick: Boolean; override;
    property LinkedItemLink: TdxBarItemLink read GetLinkedItemLink;
  end;

  { TdxBarQuickControl }

  TdxBarQuickControl = class(TdxBarControl)
  private
    FHidingTimer: TcxTimer;
    function GetParentBar: TdxBarControl;
    procedure QuickControlTimer(Sender: TObject);
    procedure SetParentBar(Value: TdxBarControl);
    procedure WMNCHitTest(var Message: TWMNCHitTest); message WM_NCHITTEST;
    procedure WMNCPaint(var Message: TMessage); message WM_NCPAINT;
    procedure WMRButtonDown(var Message: TWMRButtonDown); message WM_RBUTTONDOWN;
  protected
    function GetParentForm: TCustomForm; override;
    function GetSizeForPopup: TSize; override;
    function GetToolbarBrush: HBRUSH; override;
    function HasCaption: Boolean; override;
    function IsLinkedToOwner: Boolean; override;
    function IsPopup: Boolean; override;
    function LockHotTrackWhenPopup: Boolean; override;
    function NeedShowGlyphAndCheckForItem: Boolean; override;
    function GetOwnerControl: TWinControl; override;
    property ParentBar: TdxBarControl read GetParentBar write SetParentBar;
  public
    constructor CreateForPopup(AParentBarControl: TdxBarControl;
      ABar: TdxBar); override;
    destructor Destroy; override;
    function Kind: TdxBarKind; override;
    procedure Popup(const AOwnerRect: TRect); override;
    procedure StartHidingTimer;
  end;

  TdxBarKeyTipsShowingState = record
    ActiveContainer: IdxBarAccessibilityHelper;
    KeyTipsData: TdxObjectList;
    TypingString: string;
  end;

  { TdxBarNavigationController }

  TdxBarNavigationController = class
  private
    FHandleKey: Boolean;
    FKeyTipsShowingState: TdxBarKeyTipsShowingState;
    FKeyTipsWaitingRootObject: IdxBarAccessibilityHelper;
    FKeyTipsWaitingTimer: TcxTimer;
    FNavigationMode: Boolean;
    FSelectedObject: IdxBarAccessibilityHelper;
    FSelectedObjectParent: IdxBarAccessibilityHelper;
    procedure DestroyKeyTipsWaitingTimer;
    function GetActiveBarControl: TCustomdxBarControl;
    function GetKeyTipsHandlingMode: Boolean;
    function GetSelectedObject: IdxBarAccessibilityHelper;
    function GetSelectedObjectParent: IdxBarAccessibilityHelper;
    procedure HandleKeyTipKey(AKey: Word; AShift: TShiftState);
    function IsKeyTipsKey(AKey: Word; AShift: TShiftState;
      out AIsKeyAcceptable: Boolean; out AOnExecute: TNotifyEvent): Boolean; overload;
    function IsKeyTipsKey(AKey: Word; AShift: TShiftState;
      out AIsKeyAcceptable: Boolean): Boolean; overload;
    function IsNavigationControllerKey(AKey: Word): Boolean;
    procedure KeyTipsEscapeHandler;
    procedure KeyTipsWaitingTimerHandler(Sender: TObject);
    procedure StopKeyTipsHandlingMode;
  protected
    procedure ResetNavigationMode;
  public
    destructor Destroy; override;
    procedure BeginKeyTipsWaiting(ARootObject: IdxBarAccessibilityHelper);
    procedure ChangeSelectedObject(ASetFocus: Boolean;
      ANewSelectedObject: IdxBarAccessibilityHelper;
      APrevSelectedObject: IdxBarAccessibilityHelper = nil);
    procedure EndKeyTipsWaiting(AShowKeyTipWindows: Boolean);
    procedure HandleKey(AKey: Word; AShift: TShiftState;
      ASelectedObjectParent: IdxBarAccessibilityHelper = nil;
      ASelectedObject: IdxBarAccessibilityHelper = nil);
    function IsKeyTipsKey(AKey: Word; AShift: TShiftState): Boolean; overload;
    function IsKeyTipsWaiting: Boolean;
    function IsNavigationBarControl(ABarControl: TCustomdxBarControl): Boolean;
    function IsNavigationKey(AKey: Word): Boolean;
    function NeedsKey(AKey: Word; AShift: TShiftState): Boolean;
    procedure SelectDefaultObject(ARootObject: IdxBarAccessibilityHelper);
    procedure SetKeyTipsShowingState(
      AActiveKeyTipContainer: IdxBarAccessibilityHelper;
      const AKeyTipsTypingString: string);
    procedure StopKeyboardHandling;
    procedure UnassignObject(AObject: IdxBarAccessibilityHelper);
    procedure UnselectAssignedSelectedObject;
    property ActiveKeyTipContainer: IdxBarAccessibilityHelper
      read FKeyTipsShowingState.ActiveContainer; // TODO Remove this property
    property AssignedSelectedObject: IdxBarAccessibilityHelper read FSelectedObject;
    property AssignedSelectedObjectParent: IdxBarAccessibilityHelper
      read FSelectedObjectParent;
    property KeyTipsHandlingMode: Boolean read GetKeyTipsHandlingMode;
    property NavigationMode: Boolean read FNavigationMode;
    property SelectedObject: IdxBarAccessibilityHelper read GetSelectedObject
      write FSelectedObject;
    property SelectedObjectParent: IdxBarAccessibilityHelper
      read GetSelectedObjectParent write FSelectedObjectParent;
  end;

procedure BarAccessibilityHelperOwnerObjectDestroyed(
  var AIHelper: IdxBarAccessibilityHelper);
function GetAccessibilityHelper(AObject: TObject): IdxBarAccessibilityHelper;
function GetKeyTipContainerParent(
  AContainer: IdxBarAccessibilityHelper): IdxBarAccessibilityHelper;
function GetNextAccessibleObject(ASelectedObject: TdxBarAccessibilityHelper;
  AObjects: TList; ADirection: TcxAccessibilityNavigationDirection;
  ACycleHorizontally: Boolean): TdxBarAccessibilityHelper;
function GetRootAccessibleObject(AParentWnd: HWND): IdxBarAccessibilityHelper;

function BarDesignController: TdxBarDesignController;
function BarCanvas: TdxBarCanvas;
function BarNavigationController: TdxBarNavigationController;
function RegdxItemList: TdxBarItemList;
procedure dxBarRegisterItem(AItemClass: TdxBarItemClass;
  AItemControlClass: TdxBarItemControlClass; AVisible: Boolean);
procedure dxBarUnregisterItem(AItemClass: TdxBarItemClass);
procedure dxBarDesignerModified(ABarManager: TdxBarManager);
function dxBarCreateScreenTipViewInfo(ABarManager: TdxBarManager; AHintText: string; const AShortCut: string; AScreenTip: TdxBarScreenTip;
  APainter: TdxBarPainter): TdxBarCustomHintViewInfo;
function dxBarFlatPainter: TdxBarFlatPainter;

function ActiveBarControl: TCustomdxBarControl;
function BarGetMouseWheelReceiver: TdxBarMouseWheelEventReceiver;
function VisibleTodxBarVisible(Value: Boolean): TdxBarItemVisible;
function GetBarControlClass(AToolbar: TdxBar): TdxBarControlClass;
function GetBarManagerByComponent(AComponent: TComponent): TdxBarManager;
function GetBarManagerByForm(AForm: TCustomForm): TdxBarManager;
function GetBarManagerForComponent(AComponent: TComponent): TdxBarManager;
function GetParentBarForBar(Value: TCustomdxBarControl): TCustomdxBarControl;

function GetAccelPos(var AText: string; AModifyString: Boolean = False): Integer;
function GetWorkArea(const P: TPoint): TRect;
function GetTextOf(const S: string): string;
procedure DrawItemArrow(DC: HDC; R: TRect; ArrowType: TcxArrowDirection;
  Enabled, Selected, Flat: Boolean; AColor: TColor = clDefault); overload;
procedure DrawItemArrow(ADC: HDC; R: TRect; ADownArrow, AEnabled, ASelected, AFlat: Boolean; AColor: TColor = clDefault); overload;
procedure DrawLargeItemArrow(DC: HDC; R: TRect; ArrowType: TcxArrowDirection;
  Size: Integer; Selected, Enabled, Flat: Boolean; AColor: TColor = clDefault); overload;
procedure DrawLargeItemArrow(ADC: HDC; R: TRect; ADownArrow: Boolean;
  ASize: Integer; ASelected, AEnabled, AFlat: Boolean; AColor: TColor = clDefault); overload;
procedure FrameFlatSelRect(DC: HDC; const R: TRect);
procedure DrawVerticalGradient(Canvas: TCanvas; const ARect: TRect;
  FromR, ToR, FromG, ToG, FromB, ToB: Byte);
procedure TransparentDraw(DrawDC: HDC; const R: TRect; AGlyph: TBitmap; AEnabled: Boolean = True); overload;
procedure TransparentDraw(DrawDC: HDC; Brush: HBRUSH; const FullRect, R: TRect; AGlyph: TBitmap;
  AImages: TCustomImageList; AImageIndex: Integer; AImageListBkColor: TColor;
  AEnabled, AGrayScale, AFlat, ASelected, ADown, APressed, AShadow, AFaded: Boolean;
  ASmoothImage: Boolean = False; AUseLeftBottomPixelAsTransparent: Boolean = True); overload;
procedure TransparentDraw(ABarItemControl: TdxBarItemControl;
  DrawDC: HDC; Brush: HBRUSH; const FullRect, R: TRect; AGlyph: TBitmap;
  AImages: TCustomImageList; AImageIndex: Integer; AImageListBkColor: TColor;
  AEnabled, AGrayScale, AFlat, ASelected, ADown, APressed, AShadow, AFaded: Boolean;
  ASmoothImage: Boolean = False; AUseLeftBottomPixelAsTransparent: Boolean = True); overload;

function CloneFont(Source: HFONT): HFONT;
procedure FillRectByBitmap(DC: HDC; ADestR, ASourceR: TRect; ABitmap: TBitmap);
procedure RestoreClipRgn(DC: HDC; var AClipRgn: HRGN; var AClipRgnExists: Boolean);
procedure SaveClipRgn(DC: HDC; var AClipRgn: HRGN; var AClipRgnExists: Boolean);

procedure AfterDrawBackground(ADC: HDC; APrevWindowOrg: TPoint);
function BeforeDrawBackground(ASourceControl, ADestinationControl: TWinControl;
  ADC: HDC; var ARect: TRect; out APrevWindowOrg: TPoint): TPoint;

procedure ProcessMouseMessages;
procedure ProcessPaintMessages;

function LeftButtonPressed: Boolean;
function RightButtonPressed: Boolean;

function IsAncestorComponentDifferencesDetection(AComponent: TComponent): Boolean;
function IsApplicationActive: Boolean;
function IsFormActive(AForm: TCustomForm): Boolean;
function GetParentPopupWindow(AControl: TWinControl; ACheckParentBars: Boolean): TcxCustomPopupWindow;
procedure dxFreeAndNil(var AObject);
function dxKillTimer(AWindowHandle: HWND; var ATimerID: DWORD): Boolean;
function dxBarMessageBox(AText: string; AFlags: Integer): Integer;
procedure dxBarFrameRect(ADC: HDC; ARect: TRect; AColor: Integer);
procedure dxBarFocusRect(ADC: HDC; ARect: TRect);
procedure dxSetZOrder(AHandle: THandle; AWndAfter: DWORD = HWND_TOPMOST; AActivate: Boolean = False; AFlags: DWORD = 0);
function HasAsParent(Wnd: HWND; ParentWnd: HWND): Boolean;
function HasPopupWindowAbove(ABarControl: TCustomdxBarControl;
  AIgnoreSelectedControl: Boolean): Boolean;

function IsSelectableItem(AObject: TObject): Boolean; overload;
function IsSelectableItem(AObject: TObject;
  out ASelectableItem: IdxBarSelectableItem): Boolean; overload;
function GetSelectableItem(AObject: TObject): IdxBarSelectableItem;
procedure CleanSelectableItems(AItems: TdxObjectList);

function GetMaxViewLevel(AViewLevels: TdxBarItemViewLevels): TdxBarItemRealViewLevel;
function GetMinViewLevel(AViewLevels: TdxBarItemViewLevels): TdxBarItemRealViewLevel;
function GetNextViewLevel(AViewLevels: TdxBarItemViewLevels;
  AViewLevel: TdxBarItemRealViewLevel): TdxBarItemRealViewLevel;
function WidthToCurrentDpi(AValue: Integer; ANormalDpi: Integer = 96): Integer;
procedure BarDrawSizeGrip(DC: HDC; R: TRect);
procedure SetLayeredWndAttributes(AHandle: HWND; AAlphaBlendValue: Integer);

type
  TdxBarGetRootAccessibleObjectFunc = function(AParentWnd: HWND): IdxBarAccessibilityHelper;

var
  FOnRegisterBarManager: TcxNotifyProcedure;
  FOnUnregisterBarManager: TcxNotifyProcedure;
  dxBarHintKeeper: IdxBarHintKeeper;
  dxBarHintWindowClass: TdxBarHintWindowClass = TdxBarHintWindow;
  dxBarManagerList: TdxBarManagerList;
  PatternBrush: HBRUSH;
  dxBarMakeInactiveImagesDingy: Boolean = True;
  dxBarPlaySound: Boolean = True;
  FHintWindow: TdxBarHintWindow;
  dxBarGetRootAccessibleObject: TdxBarGetRootAccessibleObjectFunc;
  dxBarSkinPainterClass: TdxBarPainterClass = TdxBarStandardPainter;

const
  dxBarManagerTempCategoryIndex = -1000;
  dxBarCustomizingPopupPaintStyleGroupIndex = -1000;

  dxBarNonrecentlyUsedItemsColorDelta: Integer = 20;
  dxBarFlatToolbarsColorDelta: Integer = 20;

  dxBarWaitForSubMenuTime: Integer = 400;

  // TdxBarItemControl
  icpNone = -1;
  icpNonClient = 100;
  icpControl = 0;
  // TdxBarEditControlPart
  ecpEdit = 0;
  ecpIcon = 1;
  ecpText = 2;
  ecpHeaderParts = [ecpIcon, ecpText, icpNonClient];
  // TdxBarComboControlPart
  ccpDropButton = 3;
  // TdxBarColorComboControl
  clcpCustomColorButton = 4;
  // TdxBarButtonControlPart
  bcpButton = 0;
  bcpDropButton = 1;
  //TdxBarSpinEditControl
  secButtonUp = 3;
  secButtonDown = 4;
  //ScreenTips
  dxBarScreenTipFontColor: TColor = $4C4C4C;

implementation

{$R dxBar.res}

uses
  CommCtrl, MMSystem, Registry, Math,
  dxBarCustForm, dxBarPopupMenuEd, dxBarCustomCustomizationForm,
  dxBarStrs, dxBarCommon, dxUxTheme, dxThemeConsts, dxOffice11, dxBarNameEd,
  cxGeometry, dxBarSkinConsts, dxBarAccessibility, cxDWMApi, dxCore;

const
{$IFNDEF DELPHI6}
  WS_EX_LAYERED = $00080000;
  AC_SRC_ALPHA = $01;
  LWA_ALPHA = $00000002;
{$ENDIF}

  MAPVK_VK_TO_VSC    = 0;
  MAPVK_VSC_TO_VK    = 1;
  MAPVK_VK_TO_CHAR   = 2;
  MAPVK_VSC_TO_VK_EX = 3;

  dxBarButtonBorderWidth = 7;
  dxBarButtonBorderHeight = 6;

  dxBarEmptySubMenuControlContentWidth = 100;

  dxBarFingerSize = 3;
  dxBarHorSize = 4;
  dxBarTopSize = 2;
  dxBarBottomSize = 1;
  dxBarFlatBorderSize = 3;

  dxBarFloatToolbarMinWidth = 51;

  DefautGlyphSize = 16;
  InsertZone = 10;
  MarkSizeArrowY = 4;
  MarkSizeArrowX = 2 * MarkSizeArrowY - 1;
  MakeBeginGroupDragSize = 4;
  MinToolbarSize = 2 + 19 + 2;
  FloatToolbarMarkIndent = 1;
  MenuSeparatorSize = 2;

  HintOffset = 20;

  MinEditWidth = 20;
  EditSizingZoneSize = 7;

  MinDockSize = 3;
  DetachAreaDelta = 15;

  dxBarWaitForShowHintTime = 1000;
  dxBarWaitForHideHintTime = 10000;
  dxBarHiddedHintLifeTime = 400;
  dxBarScrollMenuTime = 80;
  dxBarSmoothScrollMenuTime = dxBarScrollMenuTime + 120;
  dxBarSlowExpandMenuTime = 4000;
  dxBarWaitForKeyTipsTime = 500;

  dxBarExtraPaneHeader = 'Recent Documents';
  dxBarExtraPaneWidthRatio = 2.5;

  MDIButtonStyles: array[TdxBarMDIButton] of Integer =
    (DFCS_CAPTIONMIN, DFCS_CAPTIONRESTORE, DFCS_CAPTIONCLOSE);

  ListItemSeparator = '-';

  DefaultViewParams: TcxViewParams = (
    Bitmap: nil;
    Color: clDefault;
    Font: nil;
    TextColor: clDefault
  );

type
  PBoolean = ^Boolean;
  TStringArray = array of string;

  TControlAccess = class(TControl);
  TCustomFormAccess = class(TCustomForm);
  TReaderAccess = class(TReader);
  TdxBarXPPainterParams = record
    BarBeginGroupSize: Integer;
    BarCloseButtonSize: TSize;
    ButtonBorderHeight: Integer;
    ComboBoxArrowWidth: Integer;
    EditControlBorderOffsets: TRect;
    GripperSize: Integer;
    ProgressControlBarHeight: Integer;
    SubMenuControlBeginGroupSize: Integer;
    StatusBarGripSize: TSize;
  end;

var
  FUnitIsFinalized: Boolean;
  FApplicationActive: Boolean = True;
  FApplicationDeactivation: Boolean;
  FMergingWith: TdxBar;
  FUser32DLL: HMODULE;
  FdxBarXPPainterParams: TdxBarXPPainterParams;

  UpdateLayeredWindow: function(Handle: THandle; hdcDest: HDC;
     pptDst: PPoint; _psize: PSize; hdcSrc: HDC; pptSrc: PPoint; crKey: COLORREF;
    pblend: PBLENDFUNCTION; dwFlags: DWORD): Boolean; stdcall;

  FBarCanvas: TdxBarCanvas;
  FBarControls: TList;
  FBarDesignController: TdxBarDesignController;
  FBarFlatPainter: TdxBarFlatPainter;
  FBarNavigationController: TdxBarNavigationController;
  FRegdxItemList: TdxBarItemList;

  FActiveBarControl: TCustomdxBarControl;

  FIsMDIButtonPressed, FIsMouseOverMDIButton: Boolean;
  FPressedMDIButton, FSelectedMDIButton: TdxBarMDIButton;

  ResettingToolbar: Boolean;

  ShowFullMenus: Boolean;

  BitsPerPixel: Integer;

{ blending }

type
  TAnimateWindowProc = function(hWnd: HWND; dwTime: DWORD; dwFlags: DWORD): BOOL; stdcall;
  TSetLayeredWindowAttributes = function (Hwnd: THandle; crKey: COLORREF; bAlpha: Byte; dwFlags: DWORD): Boolean; stdcall;

var
  AnimateWindowProc: TAnimateWindowProc = nil;
  SetLayeredWindowAttributes: TSetLayeredWindowAttributes = nil;

function GetBarManagerByHandle(AWnd: HWND): TdxBarManager; forward;

procedure BarAccessibilityHelperOwnerObjectDestroyed(
  var AIHelper: IdxBarAccessibilityHelper);
begin
  if AIHelper <> nil then
    AIHelper.OwnerObjectDestroyed;
  AIHelper := nil;
end;

function GetAccessibilityHelper(AObject: TObject): IdxBarAccessibilityHelper;
begin
  Supports(AObject, IdxBarAccessibilityHelper, Result);
end;

function GetKeyTipContainerParent(
  AContainer: IdxBarAccessibilityHelper): IdxBarAccessibilityHelper;
var
  AParentObject: TdxBarAccessibilityHelper;
begin
  Result := nil;
  AParentObject := AContainer.GetBarHelper;
  if AParentObject.ParentForKeyTip = nil then
    Exit;
  repeat
    AParentObject := AParentObject.ParentForKeyTip;
  until AParentObject.IsKeyTipContainer or (AParentObject.ParentForKeyTip = nil);
  Result := AParentObject;
end;

function GetNextAccessibleObject(ASelectedObject: TdxBarAccessibilityHelper;
  AObjects: TList; ADirection: TcxAccessibilityNavigationDirection;
  ACycleHorizontally: Boolean): TdxBarAccessibilityHelper;

  procedure CalcRectCenter(const R: TRect; out X, Y: Extended);
  begin
    X := R.Left + (R.Right - R.Left) / 2;
    Y := R.Top + (R.Bottom - R.Top) / 2;
  end;

  procedure CalcDistance(const R1, R2: TRect; out AAngle, ADistance: Extended);
  var
    AAngle1, AAngle2, X1, X2, Y1, Y2: Extended;
  begin
    CalcRectCenter(R1, X1, Y1);
    CalcRectCenter(R2, X2, Y2);

    AAngle1 := RadToDeg(ArcTan2(Y2 - Y1, X2 - X1));
    if AAngle1 < 0 then
      AAngle1 := AAngle1 + 360;
    case ADirection of
      andLeft:
        AAngle1 := AAngle1 - 180;
      andUp:
        AAngle1 := AAngle1 - 270;
      andDown:
        AAngle1 := AAngle1 - 90;
    end;
    if AAngle1 < 0 then
      AAngle2 := AAngle1 + 360
    else
      AAngle2 := AAngle1 - 360;
    if AAngle1 < 0 then
      AAngle1 := -AAngle1;
    if AAngle2 < 0 then
      AAngle2 := -AAngle2;
    AAngle := Min(AAngle1, AAngle2);

    case ADirection of
      andLeft:
        ADistance := R1.Left - R2.Right;
      andUp:
        ADistance := R1.Top - R2.Bottom;
      andRight:
        ADistance := R2.Left - R1.Right;
      andDown:
        ADistance := R2.Top - R1.Bottom;
    end;
  end;

var
  AAngle, ADistance, AMinAngle, AMinDistance: Extended;
  ANearestObject: TdxBarAccessibilityHelper;
  I: Integer;
  R, R1, R2: TRect;
begin
  if ADirection in [andPrev, andNext] then
  begin
    Result := nil; // TODO
    Exit;
  end;

  AMinAngle := 0;
  AMinDistance := 0;
  ANearestObject := nil;
  R1 := ASelectedObject.GetScreenBounds(cxAccessibleObjectSelfID);

  for I := 0 to AObjects.Count - 1 do
  begin
    R := TdxBarAccessibilityHelper(AObjects[I]).GetScreenBounds(cxAccessibleObjectSelfID);
    CalcDistance(R1, R, AAngle, ADistance);
    if (ADistance >= 0) and ((ANearestObject = nil) or (ADistance < AMinDistance) or (ADistance = AMinDistance) and (AAngle < AMinAngle)) then
    begin
      ANearestObject := TdxBarAccessibilityHelper(AObjects[I]);
      AMinAngle := AAngle;
      AMinDistance := ADistance;
    end;
  end;

  if (ANearestObject = nil) and (ADirection in [andLeft, andRight]) and ACycleHorizontally then
  begin
    R2 := R1;
    case ADirection of
      andLeft:
        begin
          OffsetRect(R2, -R2.Right, 0);
          OffsetRect(R2, MaxInt div 2, 0);
        end;
      andRight:
        begin
          OffsetRect(R2, -R2.Left, 0);
          OffsetRect(R2, -MaxInt div 2, 0);
        end;
    end;
    for I := 0 to AObjects.Count - 1 do
    begin
      R := TdxBarAccessibilityHelper(AObjects[I]).GetScreenBounds(cxAccessibleObjectSelfID);
      CalcDistance(R2, R, AAngle, ADistance);
      if (ADistance >= 0) and ((ANearestObject = nil) or (ADistance < AMinDistance) or (ADistance = AMinDistance) and (AAngle < AMinAngle)) then
      begin
        ANearestObject := TdxBarAccessibilityHelper(AObjects[I]);
        AMinAngle := AAngle;
        AMinDistance := ADistance;
      end;
    end;
  end;

  if ANearestObject <> nil then
    Result := ANearestObject
  else
    Result := nil;
end;

function GetRootAccessibleObject(AParentWnd: HWND): IdxBarAccessibilityHelper;
var
  ABarManager: TdxBarManager;
begin
  Result := nil;
  if Assigned(dxBarGetRootAccessibleObject) then
    Result := dxBarGetRootAccessibleObject(AParentWnd);
  if Result = nil then
  begin
    ABarManager := GetBarManagerByHandle(AParentWnd);
    if (ABarManager <> nil) and (ABarManager.MainMenuControl <> nil) then
      Result := ABarManager.MainMenuControl.IAccessibilityHelper;
  end;
end;

procedure HandleKeyTipsEscape(AActiveKeyTipContainer: IdxBarAccessibilityHelper);
begin
  AActiveKeyTipContainer.GetBarHelper.KeyTipsEscapeHandler;
end;

function GetLinksOwner(AObject: TObject): IdxBarLinksOwner;
begin
  Supports(AObject, IdxBarLinksOwner, Result);
end;

procedure dxSetZOrder(AHandle: THandle; AWndAfter: DWORD; AActivate: Boolean; AFlags: DWORD);
const
  AActivateMap: array[Boolean] of Byte = (SWP_NOACTIVATE, 0);
begin
  SetWindowPos(AHandle, AWndAfter, 0, 0, 0, 0, SWP_NOMOVE or SWP_NOSIZE or AActivateMap[AActivate] or AFlags);
end;

function GetChildWindowVCLParent(AWnd: HWND): TWinControl;
begin
  Result := nil;
  while (Result = nil) and (AWnd <> 0) and IsChildClassWindow(AWnd) do
  begin
    AWnd := GetParent(AWnd);
    Result := FindControl(AWnd);
  end;
end;

function IsFormActive(AForm: TCustomForm): Boolean;

  function IsWindowActive(AWindowHandle: HWND): Boolean;
  begin
    Result := AWindowHandle = GetActiveWindow;
  end;

  function IsMDIChildActive(AForm: TCustomForm): Boolean;
  begin
    Result := IsMDIChild(AForm) and IsWindowActive(Application.MainForm.Handle) and (Application.MainForm.ActiveMDIChild = AForm);
  end;

  function IsParentActive(AForm: TCustomForm): Boolean;
  begin
    Result := not IsMDIChild(AForm) and IsWindowActive(FindFirstNonChildParentWindow(AForm.Handle));
  end;

begin
  Result := (AForm <> nil) and AForm.HandleAllocated and 
    (IsWindowActive(AForm.Handle) or IsMDIChildActive(AForm) or IsParentActive(AForm));
end;

function IsAncestorComponentDifferencesDetection(AComponent: TComponent): Boolean;
begin
  Result := (AComponent.ComponentState * [csLoading, csReading, csAncestor] =
    [csLoading, csAncestor]);
end;

function IsTextCharForKeyTip(AKey: Word): Boolean;
var
  ARes: UINT;
begin
  ARes := MapVirtualKey(AKey, MAPVK_VK_TO_CHAR);
  Result := ((ARes and $FFFF0000) = 0) and (Char(ARes) <> ' ') and
    IsTextChar(Char(ARes));
end;

function IsParentFocused(AParent: THandle): Boolean;
begin
  Result := (AParent <> 0) and ((AParent = GetFocus) or IsChildClassWindow(AParent) and IsParentFocused(GetParent(AParent)));
end;

function IsControlVisible(AControl: TWinControl): Boolean;
begin
  Result := (AControl <> nil) and AControl.HandleAllocated and IsWindowVisible(AControl.Handle);
end;

function BarNavigationController: TdxBarNavigationController;
begin
  Result := FBarNavigationController;
end;

procedure SendCancelMode;
var
  AActiveControl: TWinControl;
begin
  AActiveControl := FindControl(GetActiveWindow);
  if AActiveControl is TCustomForm then
    TCustomForm(AActiveControl).SendCancelMode(nil);
end;

procedure SetActiveWindow(AWindowHandle: HWND);
begin
  Windows.SetActiveWindow(FindFirstNonChildParentWindow(AWindowHandle));
end;

// null reference routines
procedure RepaintItemControl(AItemControl: TdxBarItemControl); overload;
begin
  if AItemControl <> nil then
    AItemControl.Repaint;
end;

procedure RepaintItemControl(AItemLink: TdxBarItemLink); overload;
begin
  if AItemLink <> nil then
    RepaintItemControl(AItemLink.Control);
end;

function GetControlByLink(AItemLink: TdxBarItemLink): TdxBarItemControl;
begin
  if AItemLink <> nil then
    Result := AItemLink.Control
  else
    Result := nil;
end;

function GetLinkByControl(AItemControl: TdxBarItemControl): TdxBarItemLink;
begin
  if AItemControl <> nil then
    Result := AItemControl.ItemLink
  else
    Result := nil;
end;

function GetItemByControl(AItemControl: TdxBarItemControl): TdxBarItem;
begin
  if AItemControl <> nil then
    Result := AItemControl.Item
  else
    Result := nil;
end;

function GetItemByLink(AItemLink: TdxBarItemLink): TdxBarItem;
begin
  if AItemLink <> nil then
    Result := AItemLink.Item
  else
    Result := nil;
end;

function GetObjectByObjectLink(AObjectLink: TcxObjectLink): TObject;
begin
  if AObjectLink <> nil then
    Result := AObjectLink.Ref
  else
    Result := nil;
end;

function GetOwnedLinks(AObject: TObject): TdxBarItemLinks;
begin
  if GetLinksOwner(AObject) <> nil then
    Result := GetLinksOwner(AObject).GetItemLinks
  else
    Result := nil;
end;

function GetActiveForm: TCustomForm;
var
  AControl: TWinControl;
begin
  Result := nil;
  AControl := FindControl(GetActiveWindow);
  if (AControl is TCustomForm) and IsWindowEnabledEx(AControl.Handle) then
  begin
    Result := TCustomForm(AControl);
    if IsMDIForm(Result) and (TCustomFormAccess(Result).ActiveMDIChild <> nil) then
      Result := TCustomFormAccess(Result).ActiveMDIChild;
  end;
end;

function GetInstance(ASelectedItem: IdxBarSelectableItem): TPersistent;
begin
  if ASelectedItem <> nil then
    Result := ASelectedItem.GetInstance
  else
    Result := nil;
end;

function GetSubItemButtonByButtonCaption(ASubItem: TdxBarSubItem;
  const ACaption: string): TdxBarButton;
var
  I: Integer;
begin
  Result := nil;
  for I := 0 to ASubItem.ItemLinks.Count - 1 do
    if TdxBarButton(ASubItem.ItemLinks[I].Item).Caption = ACaption then
      Result := TdxBarButton(ASubItem.ItemLinks[I].Item);
end;

function IsMouseDownMessage(AMsg: Cardinal): Boolean;
begin
  Result :=
    (AMsg = WM_LBUTTONDOWN) or (AMsg = WM_LBUTTONDBLCLK) or
    (AMsg = WM_RBUTTONDOWN) or (AMsg = WM_RBUTTONDBLCLK) or
    (AMsg = WM_MBUTTONDOWN) or (AMsg = WM_MBUTTONDBLCLK) or
    (AMsg = WM_NCLBUTTONDOWN) or (AMsg = WM_NCLBUTTONDBLCLK) or
    (AMsg = WM_NCRBUTTONDOWN) or (AMsg = WM_NCRBUTTONDBLCLK) or
    (AMsg = WM_NCMBUTTONDOWN) or (AMsg = WM_NCMBUTTONDBLCLK);
end;

procedure KillBeep(AWnd: HWND);
begin
  KillMessages(AWnd, WM_CHAR, WM_CHAR);
end;

function GetBarControlClass(AToolbar: TdxBar): TdxBarControlClass;
begin
  if AToolbar.Control <> nil then
    Result := TdxBarControlClass(AToolbar.Control.ClassType)
  else
    Result := AToolbar.GetControlClass;
end;

function GetBarManagerByComponent(AComponent: TComponent): TdxBarManager;
var
  I: Integer;
begin
  Result := nil;

  if AComponent is TdxBarManager then
    Result := TdxBarManager(AComponent)
  else
  begin

{ B33023
    if AExtended and (AComponent is TCustomForm) and (TCustomForm(AComponent).Parent = nil) then
    begin
      if Assigned(cxControls.cxGetParentFormForDocking) then
        AComponent := cxControls.cxGetParentFormForDocking(TCustomForm(AComponent));
    end;
}

    if (AComponent <> nil) and (dxBarManagerList <> nil) then
      for I := 0 to dxBarManagerList.Count - 1 do
        if dxBarManagerList[I].Owner = AComponent then
        begin
          Result := dxBarManagerList[I];
          Break;
        end;
  end;
end;

function GetBarManagerByForm(AForm: TCustomForm): TdxBarManager;
begin
  Result := GetBarManagerByComponent(AForm);
end;

function GetWinControlOwner(AComponent: TComponent): TWinControl;
begin
  while (AComponent <> nil) and not (AComponent is TWinControl) do
    AComponent := AComponent.Owner;
  Result := TWinControl(AComponent)
end;

function GetBarManagerForComponent(AComponent: TComponent): TdxBarManager;
var
  AControl: TWinControl;
begin
  Result := nil;
  AControl := GetWinControlOwner(AComponent);
  if (AControl <> nil) and AControl.HandleAllocated then
    repeat
      Result := GetBarManagerByComponent(AControl);
      AControl := GetChildWindowVCLParent(AControl.Handle);
    until (Result <> nil) or (AControl = nil);
end;

function GetControlForm(AControl: TWinControl;
  AFormKind: TdxBarManagerFormKind): TCustomForm;

  function CheckForm(AForm: TCustomForm): Boolean;
  begin
    Result := (AForm <> nil) and ((AFormKind = fkAny) or
      (AFormKind = fkMainOrMDIChild) and IsMDIChild(AForm));
  end;

var
  AWnd: HWND;
  ACurrentForm: TCustomForm;
begin
  Result := nil;
  if not CanAllocateHandle(AControl) then
    Exit;
  AWnd := AControl.Handle;
  while AWnd <> 0 do
  begin
    if FindControl(AWnd) is TCustomForm then
    begin
      ACurrentForm := TCustomForm(FindControl(AWnd));
      Result := ACurrentForm;
    end
    else
      ACurrentForm := nil;
    if not IsChildClassWindow(AWnd) or CheckForm(ACurrentForm) then
      Break;
    AWnd := GetParent(AWnd);
  end;
end;

function GetComponentForm(AComponent: TComponent): TCustomForm;
var
  AControl: TWinControl;
begin
  AControl := GetWinControlOwner(AComponent);
  if AControl <> nil then
    Result := GetControlForm(AControl, fkAny)
  else
    Result := nil;
end;

function GetBarManagerForm(ABarManager: TdxBarManager;
  AFormKind: TdxBarManagerFormKind): TCustomForm;
begin
  Result := GetControlForm(ABarManager.Owner, AFormKind);
end;

function IsBarManagerOwner(ABarManager: TdxBarManager;
  AOwnerHandle: HWND): Boolean;
var
  AWnd: HWND;
begin
  Result := False;
  if ABarManager.Owner.HandleAllocated then
  begin
    AWnd := ABarManager.Owner.Handle;
    while (AWnd <> AOwnerHandle) and IsChildClassWindow(AWnd) do
      AWnd := GetParent(AWnd);
    Result := AWnd = AOwnerHandle;
  end;
end;

function GetWinControl(AControl: TControl): TWinControl;
begin
  if AControl is TWinControl then
    Result := TWinControl(AControl)
  else
    Result := AControl.Parent;
end;

function IsChildControl(AParentControl: TWinControl; AChildWnd: THandle): Boolean; overload;
begin
  Result := AParentControl.HandleAllocated and IsChildEx(AParentControl.Handle, AChildWnd);
end;

function IsChildControl(AParentControl: TWinControl; AChildControl: TControl): Boolean; overload;
var
  AParent: TWinControl;
  AChildWinControl: TWinControl;
begin
  AChildWinControl := GetWinControl(AChildControl);
  if AParentControl.HandleAllocated and AChildWinControl.HandleAllocated then
    Result := IsChildEx(AParentControl.Handle, AChildWinControl.Handle)
  else
  begin
    AParent := AChildWinControl;
    while (AParent <> nil) and (AParent <> AParentControl) do
      AParent := AParent.Parent;
    Result := AParent = AParentControl;
  end;
end;

function IsControlUnderBarManager(ABarManager: TdxBarManager;
  AControl: TControl): Boolean;
begin
  Result := IsChildControl(ABarManager.Owner, AControl);
end;

function GetParentPopupWindow(AControl: TWinControl; ACheckParentBars: Boolean): TcxCustomPopupWindow;

  function InternalGetParent(AWnd: HWND): HWND;
  var
    AControl: TWinControl;
  begin
    Result := 0;
    if IsChildClassWindow(AWnd) then
      Result := GetParent(AWnd)
    else
      if ACheckParentBars then
      begin
        AControl := FindControl(AWnd);
        if (AControl is TCustomdxBarControl) and (TCustomdxBarControl(AControl).ParentBar <> nil) then
          Result := TCustomdxBarControl(AControl).ParentBar.Handle;
      end;
  end;

var
  AParentWnd, AWnd: HWND;
begin
  Result := nil;
  if not AControl.HandleAllocated or (csDestroying in AControl.ComponentState) then
    Exit;

  AWnd := AControl.Handle;
  repeat
    AParentWnd := InternalGetParent(AWnd);
    if AParentWnd = 0 then
      Break;
    AWnd := AParentWnd;
  until False;
  if (AWnd <> AControl.Handle) and (FindControl(AWnd) is TcxCustomPopupWindow) then
    Result := TcxCustomPopupWindow(FindControl(AWnd));
end;
// Temp methods

function EnumToStringArray(ATypeInfo: PTypeInfo): TStringArray;
var
  ATypeData: PTypeData;
  AList: TStringList;
  I: Integer;
begin
  ATypeData := GetTypeData(ATypeInfo);
  AList := TStringList.Create;
  try
    for I := ATypeData.MinValue to ATypeData.MaxValue do
      AList.Add(GetEnumName(ATypeInfo, I));
//    AList.Sort;
    SetLength(Result, AList.Count);
    for I := 0 to High(Result) do
      Result[I] := AList[I];
  finally
    AList.Free;
  end;
end;

function SetToStringArray(ATypeInfo: PTypeInfo): TStringArray;
begin
  Result := EnumToStringArray(GetTypeData(ATypeInfo).CompType^);
end;

procedure SetLayeredWndAttributes(AHandle: HWND; AAlphaBlendValue: Integer);
var
  AStyle: Integer;
begin
  if Assigned(SetLayeredWindowAttributes) then
  begin
    AStyle := GetWindowLong(AHandle, GWL_EXSTYLE);
    if AAlphaBlendValue < 255 then
    begin
      if (AStyle and WS_EX_LAYERED) = 0 then
        SetWindowLong(AHandle, GWL_EXSTYLE, AStyle or WS_EX_LAYERED);
      SetLayeredWindowAttributes(AHandle, 0, AAlphaBlendValue, LWA_ALPHA);
    end
    else
      if (AStyle and WS_EX_LAYERED) <> 0 then
      begin
        SetWindowLong(AHandle, GWL_EXSTYLE, AStyle and not WS_EX_LAYERED);
        RedrawWindow(AHandle, nil, 0, RDW_ERASE or RDW_INVALIDATE or RDW_FRAME or RDW_ALLCHILDREN);
      end;
  end;
end;

procedure DeleteGDIObject(var AGDIObject);
begin
  if HGDIOBJ(AGDIObject) <> 0 then
  begin
    DeleteObject(HGDIOBJ(AGDIObject));
    HGDIOBJ(AGDIObject) := 0;
  end;
end;

procedure ReverseGDIObject(ADC: HDC; APrevGDIObject: HGDIOBJ);
begin
  DeleteObject(SelectObject(ADC, APrevGDIObject));
end;

procedure PolygonByColor(ADC: HDC; var APoints: array of TPoint; APenColor, ABrushColor: COLORREF);
var
  APrevBrush, APrevPen: HGDIOBJ;
begin
  APrevPen := SelectObject(ADC, CreatePen(PS_SOLID, 1, APenColor));
  APrevBrush := SelectObject(ADC, CreateSolidBrush(ABrushColor));
  Polygon(ADC, APoints, Length(APoints));
  ReverseGDIObject(ADC, APrevBrush);
  ReverseGDIObject(ADC, APrevPen);
end;

procedure RoundRectByColor(ADC: HDC; const R: TRect; AWidth, AHeight: Integer; APenColor, ABrushColor: TColor);
var
  APrevBrush, APrevPen: HGDIOBJ;
  ALogBrush: LOGBRUSH;
begin
  ZeroMemory(@ALogBrush, SizeOf(ALogBrush));
  if ABrushColor = clNone then
    ALogBrush.lbStyle := BS_NULL
  else
    ALogBrush.lbColor := ColorToRGB(ABrushColor);

  APrevBrush := SelectObject(ADC, CreateBrushIndirect(ALogBrush));
  APrevPen := SelectObject(ADC, CreatePen(PS_SOLID, 1, ColorToRGB(APenColor)));
  RoundRect(ADC, R.Left, R.Top, R.Right, R.Bottom, AWidth, AHeight);
  ReverseGDIObject(ADC, APrevBrush);
  ReverseGDIObject(ADC, APrevPen);
end;

procedure ExcludeFrameRegion(ACanvas: TcxCanvas; AFrameRect, AContentRect: TRect);
var
  ARegion: TcxRegion;
begin
  ARegion := TcxRegion.Create(AFrameRect);
  ARegion.Combine(TcxRegion.Create(AContentRect), roSubtract);
  ACanvas.SetClipRegion(ARegion, roSubtract);
end;

procedure DestroyWindowHandle(var AWindowHandle: HWND; ADestroyWindow: Boolean = True);
begin
  if AWindowHandle <> 0 then
  begin
    if ADestroyWindow then
      Windows.DestroyWindow(AWindowHandle);
    AWindowHandle := 0;
  end;
end;

function dxKillTimer(AWindowHandle: HWND; var ATimerID: DWORD): Boolean;
begin
  Result := (ATimerID <> 0) and KillTimer(AWindowHandle, ATimerID);
  if Result then
    ATimerID := 0;
end;

function IsAnotherApplicatonWindow(AWnd: HWND): Boolean;
var
  AProcessId: Cardinal;
begin
  GetWindowThreadProcessId(AWnd, @AProcessId);
  Result := (AWnd = 0) or (AProcessId <> GetCurrentProcessId);
end;

function IsPopupMenuShowed: Boolean;
var
  I, J: Integer;
begin
  Result := False;
  for I := 0 to dxBarManagerList.Count - 1 do
    if not dxBarManagerList[I].IsDestroying then
      for J := 0 to dxBarManagerList[I].FPopupMenus.Count - 1 do
        if TdxBarPopupMenu(dxBarManagerList[I].FPopupMenus[J]).FPopupMenuVisible then
        begin
          Result := True;
          Break;
        end;
end;

function GetSectionDelimiter(AStoringKind: TdxBarStoringKind): string;
begin
  case AStoringKind of
    skIni: Result := '.';
  else
    Result := '\';
  end;
end;

function GetShortCutFromMessageData(WParam: Integer; LParam: Integer): TShortCut;
const
  AltMask = $20000000;
begin
  Result := Byte(WParam);
  if Result <> 0 then
  begin
    if GetKeyState(VK_SHIFT) < 0 then Inc(Result, scShift);
    if GetKeyState(VK_CONTROL) < 0 then Inc(Result, scCtrl);
    if LParam and AltMask <> 0 then Inc(Result, scAlt);
  end;
end;

{ global methods }

function BarDesignController: TdxBarDesignController;
begin
  if (FBarDesignController = nil) and not FUnitIsFinalized then
    FBarDesignController := TdxBarDesignController.Create;
  Result := FBarDesignController;
end;

function BarCanvas: TdxBarCanvas;
begin
  if (FBarCanvas = nil) and not FUnitIsFinalized then
    FBarCanvas := TdxBarCanvas.Create;
  Result := FBarCanvas;
end;

function RegdxItemList: TdxBarItemList;
begin
  if (FRegdxItemList = nil) and not FUnitIsFinalized then
    FRegdxItemList := TdxBarItemList.Create;
  Result := FRegdxItemList;
end;

procedure dxBarRegisterItem(AItemClass: TdxBarItemClass;
  AItemControlClass: TdxBarItemControlClass; AVisible: Boolean);
begin
  RegdxItemList.Register(AItemClass, AItemControlClass, AVisible);
end;

procedure dxBarUnregisterItem(AItemClass: TdxBarItemClass);
begin
  RegdxItemList.Unregister(AItemClass);
end;

procedure AddBarControl(ABarControl: TCustomdxBarControl);
begin
  FBarControls.Add(ABarControl);
end;

procedure RemoveBarControl(ABarControl: TCustomdxBarControl);
begin
  FBarControls.Remove(ABarControl);
end;

function BarControlExists(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := (ABarControl <> nil) and (FBarControls.IndexOf(ABarControl) <> -1);
end;

procedure dxBarDesignerModified(ABarManager: TdxBarManager);
begin
  if ABarManager <> nil then ABarManager.DesignerModified;
end;

function dxBarCreateScreenTipViewInfo(ABarManager: TdxBarManager; AHintText: string; const AShortCut: string; AScreenTip: TdxBarScreenTip;
  APainter: TdxBarPainter): TdxBarCustomHintViewInfo;
begin
  if (AScreenTip <> nil) and AScreenTip.Collection.Repository.ShowDescription then
    Result := TdxBarScreenTipViewInfo.Create(AScreenTip, APainter, AHintText, AShortCut)
  else
  begin
    if (AScreenTip <> nil) and not AScreenTip.UseHintAsHeader and (AScreenTip.Header.Text <> '') then
      AHintText := AScreenTip.Header.Text;
    Result := TdxBarLikeHintScreenTipViewInfo.Create(ABarManager, APainter, AHintText, AShortCut, GetMouseCursorPos);
  end;
end;

function dxBarFlatPainter: TdxBarFlatPainter;
begin
  if FBarFlatPainter = nil then
    FBarFlatPainter := TdxBarFlatPainter.Create(0);
  Result := FBarFlatPainter;
end;

function dxBarCreateBitmap(AOnChangeProc: TNotifyEvent): TBitmap;
begin
  Result := TBitmap.Create;
  Result.OnChange := AOnChangeProc; 
end;

function ActiveBarControl: TCustomdxBarControl;
begin
  Result := FActiveBarControl;
end;

function ActiveBarManager: TdxBarManager;
begin
  if ActiveBarControl <> nil then
    Result := ActiveBarControl.BarManager
  else
    Result := nil;
end;

function IsActiveBarControlAccessible: Boolean;
begin
  Result := (ActiveBarControl <> nil) and ActiveBarControl.HandleAllocated and IsWindowEnabledEx(ActiveBarControl.Handle);
end;

function VisibleTodxBarVisible(Value: Boolean): TdxBarItemVisible;
begin
  if Value then
    Result := ivAlways
  else
    Result := ivNever;
end;

function GetBarManagerByHandle(AWnd: HWND): TdxBarManager;
begin
  Result := GetBarManagerByComponent(FindControl(AWnd));
end;

function GetParentBarOrSubMenuForBar(Value: TCustomdxBarControl): TCustomdxBarControl;
begin
  Result := Value;
  while (Result <> nil) and not Result.IsDestroying do
    if (Result.ParentBar = nil) or Result.IsInternal and not Result.ParentBar.IsInternal then
      Break
    else
      Result := Result.ParentBar;
end;

function GetParentBarForBar(Value: TCustomdxBarControl): TCustomdxBarControl;
begin
  Result := GetParentBarOrSubMenuForBar(Value);
  if Result is TdxBarSubMenuControl then Result := nil;
end;

function GetAccelPos(var AText: string; AModifyString: Boolean = False): Integer;
var
  I: Integer;
begin
  Result := 0;
  I := 1;
  while I < Length(AText) do
  begin
    if AText[I] = '&' then
    begin
      if AModifyString then
        Delete(AText, I, 1)
      else
        Inc(I);
      if AText[I] <> '&' then
        Result := I;
    end;
    Inc(I);
  end;
end;

function GetParentBarOrSubMenuForControl(Value: TdxBarItemControl): TCustomdxBarControl;
begin
  if Value = nil then
    Result := nil
  else
    Result := GetParentBarOrSubMenuForBar(Value.Parent);
end;

function GetParentBarForControl(Value: TdxBarItemControl): TCustomdxBarControl;
begin
  Result := GetParentBarOrSubMenuForControl(Value);
  if Result is TdxBarSubMenuControl then Result := nil;
end;

function FindVCLControl(Wnd: HWND): TWinControl;
begin
  repeat
    Result := FindControl(Wnd);
    Wnd := GetParent(Wnd);
  until (Result <> nil) or (Wnd = 0);
end;

function HasAsParent(Wnd: HWND; ParentWnd: HWND): Boolean;
begin
  Result := IsOwner(ParentWnd, Wnd);
end;

function HasPopupWindowAbove(ABarControl: TCustomdxBarControl;
  AIgnoreSelectedControl: Boolean): Boolean;

  function GetItemControlScreenBounds(AItemControl: TdxBarItemControl): TRect;
  begin
    Result := AItemControl.ViewInfo.Bounds;
    Result.TopLeft := AItemControl.Parent.ClientToScreen(Result.TopLeft);
    Result.BottomRight := AItemControl.Parent.ClientToScreen(Result.BottomRight);
  end;

var
  AActiveBarControl: TCustomdxBarControl;
begin
  AActiveBarControl := ActiveBarControl;
  if (AActiveBarControl = nil) and (BarDesignController.QuickControl <> nil) then
    AActiveBarControl := BarDesignController.QuickControl;
  Result := False;
  if AActiveBarControl = nil then
    Exit;
  Result := (AActiveBarControl.SelectedControl <> nil) and AActiveBarControl.SelectedControl.IsDroppedDown and
    (not AIgnoreSelectedControl or not PtInRect(GetItemControlScreenBounds(AActiveBarControl.SelectedControl), GetMouseCursorPos)) or
    (AActiveBarControl <> ABarControl) and (AActiveBarControl.ParentBar <> nil);
end;

function WindowFromPointEx(P: TPoint): HWND;

  function FindOne(Wnd: HWND; P: TPoint): HWND;
  begin
    Result := ChildWindowFromPointEx(Wnd, P, CWP_SKIPINVISIBLE);
    if Result = 0 then
      Result := Wnd
    else
      if Result <> Wnd then
      begin
        MapWindowPoints(Wnd, Result, P, 1);
        Result := FindOne(Result, P);
      end;
  end;

begin
  Result := WindowFromPoint(P);
  if Result <> 0 then
  begin
    ScreenToClient(Result, P);
    Result := FindOne(Result, P);
  end;
end;

function GetShortCutToHint(AShortCut: TShortCut): string;
begin
  Result := ShortCutToText(AShortCut);
  if Result <> '' then Result := ' (' + Result + ')';
end;

function GetTextOf(const S: string): string;
begin
  Result := RemoveAccelChars(S, False);
end;

procedure DrawItemArrow(DC: HDC; R: TRect; ArrowType: TcxArrowDirection;
  Enabled, Selected, Flat: Boolean; AColor: TColor = clDefault);
begin
  DrawItemArrow(DC, R, ArrowType = adDown, Enabled, Selected, Flat, AColor);
end;

procedure DrawItemArrow(ADC: HDC; R: TRect; ADownArrow, AEnabled, ASelected, AFlat: Boolean; AColor: TColor = clDefault);
var
  ASize: Integer;
begin
  if not ADownArrow then
    ASize := R.Bottom - R.Top - 6
  else  // adDown
    ASize := R.Right - R.Left - 8;
  ASize := Max((ASize - 1) div 2 + Byte(ASize mod 2 <> 0), 3);
  DrawLargeItemArrow(ADC, R, ADownArrow,  ASize, ASelected, AEnabled, AFlat, AColor);
end;

procedure DrawLargeItemArrow(DC: HDC; R: TRect; ArrowType: TcxArrowDirection;
  Size: Integer; Selected, Enabled, Flat: Boolean; AColor: TColor = clDefault);
begin
  DrawLargeItemArrow(DC, R, ArrowType = adDown, Size, Selected, Enabled, Flat, AColor);
end;

procedure DrawLargeItemArrow(ADC: HDC; R: TRect; ADownArrow: Boolean;
  ASize: Integer; ASelected, AEnabled, AFlat: Boolean; AColor: TColor = clDefault);

var
  X, Y: Integer;

  procedure DrawEnabled(AColor: COLORREF);
  var
    P: array[1..3] of TPoint;
  begin
    with R do
      if ADownArrow then
      begin
        X := (Left + Right - (2 * ASize - 1)) div 2;
        Y := (Top + Bottom - ASize) div 2;
        P[1] := Point(X, Y);
        P[2] := Point(X + 2 * ASize - 2, Y);
      end
      else
      begin
        X := (Left + Right - ASize) div 2;
        Y := (Top + Bottom - (2 * ASize - 1)) div 2;
        P[1] := Point(X, Y);
        P[2] := Point(X, Y + 2 * ASize - 2);
      end;
    P[3] := Point(X + ASize - 1, Y + ASize - 1);
    PolygonByColor(ADC, P, AColor, AColor);
  end;

  procedure DrawDisabled;
  var
    Pen: HPEN;
  begin
    Pen := SelectObject(ADC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNHIGHLIGHT)));
    if ADownArrow then
    begin
      MoveToEx(ADC, X + ASize, Y + ASize - 1, nil);
      LineTo(ADC, X + 2 * ASize - 1, Y);
      MoveToEx(ADC, X + ASize, Y + ASize, nil);
      LineTo(ADC, X + 2 * ASize, Y);
    end
    else
    begin
      MoveToEx(ADC, X + ASize - 1, Y + ASize, nil);
      LineTo(ADC, X, Y + 2 * ASize - 1);
      MoveToEx(ADC, X + ASize, Y + ASize, nil);
      LineTo(ADC, X, Y + 2 * ASize);
    end;
    ReverseGDIObject(ADC, Pen);
  end;

begin
  if AColor = clDefault then
    if AEnabled then
      if ASelected then
      begin
        if IsHighContrastWhite then
          AColor := clBtnFace // White
        else
          AColor := clHighLightText;
      end
      else
        AColor := clBtnText
    else
      AColor := clBtnShadow;
  DrawEnabled(ColorToRGB(AColor));
  if not AEnabled and not AFlat then DrawDisabled;
end;

procedure FrameFlatSelRect(DC: HDC; const R: TRect);
begin
  FrameRect(DC, R, GetSysColorBrush(COLOR_HIGHLIGHT));
end;

{ items global functions }

function GetWorkArea(const P: TPoint): TRect;
begin
  Result := GetDesktopWorkArea(P);
end;

procedure CheckEditWidth(var AWidth: Integer; AMinWidth: Integer);
begin
  if AWidth < AMinWidth then
    AWidth := AMinWidth;
end;

procedure RefreshDeviceConsts;
var
  DC: Integer;
begin
  DC := GetDC(0);
  try
    BitsPerPixel := GetDeviceCaps(DC, BITSPIXEL);
  finally
    ReleaseDC(0, DC);
  end;
end;

procedure CreatePatternBrush;
var
  Pattern: TBitmap;
  X, Y: Integer;
begin
  if FUnitIsFinalized then
    Exit;
  Pattern := TBitmap.Create;
  with Pattern, Canvas do
  begin
    Width := 8;
    Height := 8;
    Brush.Color := GetSysColor(COLOR_BTNHIGHLIGHT);
    FillRect(Rect(0, 0, Width, Height));
    for Y := 0 to 7 do
      for X := 0 to 7 do
        if (Y mod 2) = (X mod 2) then
          Pixels[X, Y] := GetSysColor(COLOR_BTNFACE);
  end;
  DeleteGDIObject(PatternBrush);
  PatternBrush := Windows.CreatePatternBrush(Pattern.Handle);
  Pattern.Free;
end;

procedure DrawVerticalGradient(Canvas: TCanvas; const ARect: TRect;
  FromR, ToR, FromG, ToG, FromB, ToB: Byte);
begin
  FillGradientRect(Canvas.Handle, ARect, RGB(FromR, FromG, FromB), RGB(ToR, ToG, ToB), False);
end;

procedure DrawDisablingHatch(ADC: HDC; const ARect: TRect);
begin
  cxDrawHatch(ADC, ARect, clBlack, clBtnFace, 2, 20, 170);
end;

procedure TransparentDraw(DrawDC: HDC; const R: TRect; AGlyph: TBitmap; AEnabled: Boolean = True);
const
  DrawModes: array [Boolean] of TcxImageDrawMode = (idmDisabled, idmNormal);
begin
  cxDrawImage(DrawDC, R, R, AGlyph, nil, -1, DrawModes[AEnabled]);
end;

procedure TransparentDraw(DrawDC: HDC; Brush: HBRUSH; const FullRect, R: TRect; AGlyph: TBitmap;
  AImages: TCustomImageList; AImageIndex: Integer; AImageListBkColor: TColor;
  AEnabled, AGrayScale, AFlat, ASelected, ADown, APressed, AShadow, AFaded: Boolean;
  ASmoothImage: Boolean = False; AUseLeftBottomPixelAsTransparent: Boolean = True);
begin
  TransparentDraw(nil, DrawDC, Brush, FullRect, R, AGlyph,
    AImages, AImageIndex, AImageListBkColor,
    AEnabled, AGrayScale, AFlat, ASelected, ADown, APressed, AShadow, AFaded,
    ASmoothImage, AUseLeftBottomPixelAsTransparent);
end;

procedure TransparentDraw(ABarItemControl: TdxBarItemControl;
  DrawDC: HDC; Brush: HBRUSH; const FullRect, R: TRect; AGlyph: TBitmap;
  AImages: TCustomImageList; AImageIndex: Integer; AImageListBkColor: TColor;
  AEnabled, AGrayScale, AFlat, ASelected, ADown, APressed, AShadow, AFaded: Boolean;
  ASmoothImage: Boolean = False; AUseLeftBottomPixelAsTransparent: Boolean = True);

  function GetDrawMode: TcxImageDrawMode;
  begin
    Result := idmNormal;
    if AEnabled or AFaded then
    begin
      if not AEnabled then
        Result := idmFaded
      else
        if AGrayScale then
          Result := idmGrayScale
        else
          if AFlat then
          begin
            if not ASelected and not ADown and dxBarMakeInactiveImagesDingy and (BitsPerPixel > 8) then
              Result := idmDingy
            else
              if AShadow and ASelected and not APressed {and not ADown} then
                Result := idmShadowed;
          end;
    end
    else
      Result := idmDisabled;
  end;

var
  ADrawMode: TcxImageDrawMode;
  APrevCustomDrawImageProc: TcxDrawImageProc;
begin
  if IsGlyphAssigned(AGlyph) then
    AImageListBkColor := clNone;

  APrevCustomDrawImageProc := CustomDrawImageProc;
  try
    ADrawMode := GetDrawMode;
    if (ABarItemControl <> nil) and ABarItemControl.BarManager.ImageOptions.CacheGlyphs and (ADrawMode <> idmShadowed) then
    begin
      if not ABarItemControl.FCachedImageOptions.IsCached(ADrawMode, AGlyph, AImages) then
        ABarItemControl.FCachedImageOptions.Cache(R, AGlyph, AImages, AImageIndex,
          ADrawMode, AImageListBkColor, ASmoothImage, AUseLeftBottomPixelAsTransparent);

      AGlyph := ABarItemControl.FCachedImageOptions.Glyph;
      ADrawMode := idmNormal;
      CustomDrawImageProc := nil;
    end;

    cxDrawImage(DrawDC, R, FullRect, AGlyph, AImages, AImageIndex, ADrawMode, ASmoothImage,
      Brush, AImageListBkColor, AUseLeftBottomPixelAsTransparent);
  finally
    CustomDrawImageProc := APrevCustomDrawImageProc;
  end;
end;

procedure ProcessMouseMessages;
var
  Msg: TMsg;
begin
  while PeekMessage(Msg, 0, WM_MOUSEFIRST, WM_MOUSELAST, PM_NOREMOVE) do
  begin
    case Integer(GetMessage(Msg, 0, WM_MOUSEFIRST, WM_MOUSELAST)) of
      -1: Break;
      0: begin
           PostQuitMessage(Msg.wParam);
           Break;
         end;
    end;
    DispatchMessage(Msg);
  end;
end;

procedure ProcessPaintMessages;
var
  Msg: TMsg;
begin
  while PeekMessage(Msg, 0, WM_PAINT, WM_PAINT, PM_NOREMOVE) do
  begin
    case Integer(GetMessage(Msg, 0, WM_PAINT, WM_PAINT)) of
      -1: Break;
      0: begin
           PostQuitMessage(Msg.wParam);
           Break;
         end;
    end;
    DispatchMessage(Msg);
  end;
end;

type
  TPlaySoundType = (psMenuPopup, psMenuCommand, psStopPlay);

procedure PlaySound(APlaySoundType: TPlaySoundType);
const
  PlaySounds: array[TPlaySoundType] of PChar = ('MenuPopup', 'MenuCommand', nil);
begin
  if dxBarPlaySound then
    MMSystem.PlaySound(PlaySounds[APlaySoundType], 0,
      SND_ALIAS or SND_ASYNC or SND_NODEFAULT {or SND_NOSTOP }or SND_NOWAIT);
end;

procedure InitMMSystem;
begin
  PlaySound(psStopPlay);
end;

function CreateToolbarCaptionFontHandle(AFont: TFont; AUseSystemFont: Boolean): HFont;
var
  ANonClientMetrics: TNonClientMetrics;
begin
  ANonClientMetrics.cbSize := SizeOf(ANonClientMetrics);
  SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, @ANonClientMetrics, 0);
  if not AUseSystemFont then
    with ANonClientMetrics.lfSmCaptionFont do
    begin
      lfHeight := Min(-11, lfHeight);
      StrPLCopy(lfFaceName, AFont.Name, LF_FACESIZE);
    end;
  Result := CreateFontIndirect(ANonClientMetrics.lfSmCaptionFont);
end;

procedure CreateEditFontHandle(AFont: TFont; var AEditFont: TFont; AScaled: Boolean);
var
  ASystemLogFont, ALogFont: TLogFont;
begin
  if AScaled then
  begin
    SystemParametersInfo(SPI_GETICONTITLELOGFONT, SizeOf(ASystemLogFont), @ASystemLogFont, 0);
    cxGetFontData(AFont.Handle, ALogFont);
    ALogFont.lfHeight := ASystemLogFont.lfHeight;
    with ALogFont do
      if lfHeight > -11 then lfHeight := -11;
    AEditFont.Handle := CreateFontIndirect(ALogFont);
  end
  else
    AEditFont.Handle := CloneFont(AFont.Handle);
end;

function CloneFont(Source: HFONT): HFONT;
var
  LogFont: TLogFont;
begin
  cxGetFontData(Source, LogFont);
  Result := CreateFontIndirect(LogFont);
end;

procedure RestoreClipRgn(DC: HDC; var AClipRgn: HRGN; var AClipRgnExists: Boolean);
begin
  if AClipRgnExists then
    SelectClipRgn(DC, AClipRgn)
  else
    SelectClipRgn(DC, 0);
  DeleteObject(AClipRgn);
end;

procedure SaveClipRgn(DC: HDC; var AClipRgn: HRGN; var AClipRgnExists: Boolean);
begin
  AClipRgn := CreateRectRgn(0, 0, 0, 0);
  AClipRgnExists := GetClipRgn(DC, AClipRgn) = 1;
end;

procedure AddClipRect(DC: HDC; const R: TRect);
var
  ARgn: HRGN;
begin
  with R do
    ARgn := CreateRectRgn(Left, Top, Right, Bottom);
  ExtSelectClipRgn(DC, ARgn, RGN_OR);
  DeleteObject(ARgn);
end;

procedure ExcludeRect(var MainRgn: HRGN; const R: TRect);
var
  TempRgn: HRGN;
begin
  TempRgn := CreateRectRgnIndirect(R);
  CombineRgn(MainRgn, MainRgn, TempRgn, RGN_DIFF);
  DeleteObject(TempRgn);
end;

function GetRealColor(AColor: COLORREF): COLORREF;
var
  DC: HDC;
begin
  DC := GetDC(0);
  Result := GetNearestColor(DC, AColor);
  ReleaseDC(0, DC);
end;

procedure FillBackgroundRect(DC: HDC; ADestR, ASourceR: TRect; ABrush: HBRUSH;
  AColor: TColor; ABitmap: TBitmap);
var
  ABrushExist: Boolean;
begin
  if (ABitmap <> nil) and not ABitmap.Empty then
    FillRectByBitmap(DC, ADestR, ASourceR, ABitmap)
  else
  begin
    ABrushExist := ABrush <> 0;
    if not ABrushExist then
      ABrush := CreateSolidBrush(ColorToRGB(AColor));
    FillRect(DC, ADestR, ABrush);
    if not ABrushExist then
      DeleteObject(ABrush);
  end;
end;

procedure FillRectByBitmap(DC: HDC; ADestR, ASourceR: TRect; ABitmap: TBitmap);
var
  W, H, RW, RH: Integer;
  I, J, XStart, XEnd, YStart, YEnd, X, Y: Integer;
  AClipRgn: HRGN;
  AClipRgnExists: Boolean;
begin
  W := ABitmap.Width;
  H := ABitmap.Height;
  RW := ASourceR.Right - ASourceR.Left;
  RH := ASourceR.Bottom - ASourceR.Top;
  if (W = 0) or (H = 0) or (RW = 0) or (RH = 0) then Exit;
  XStart := ASourceR.Left div W;
  XEnd := (ASourceR.Right - 1) div W;
  YStart := ASourceR.Top div H;
  YEnd := (ASourceR.Bottom - 1) div H;
  SaveClipRgn(DC, AClipRgn, AClipRgnExists);
  with ADestR do
    IntersectClipRect(DC, Left, Top, Right, Bottom);
  for J := YStart to YEnd do
    for I := XStart to XEnd do
    begin
      Y := J * H - (ASourceR.Top - ADestR.Top);
      X := I * W - (ASourceR.Left - ADestR.Left);
      BitBlt(DC, X, Y, W, H, ABitmap.Canvas.Handle, 0, 0, SRCCOPY);
    end;
  RestoreClipRgn(DC, AClipRgn, AClipRgnExists);
end;

procedure AfterDrawBackground(ADC: HDC; APrevWindowOrg: TPoint);
begin
  SetWindowOrgEx(ADC, APrevWindowOrg.X, APrevWindowOrg.Y, nil);
end;

function BeforeDrawBackground(ASourceControl, ADestinationControl: TWinControl;
  ADC: HDC; var ARect: TRect; out APrevWindowOrg: TPoint): TPoint;
begin
  Result := cxNullPoint;
  if (ASourceControl <> nil) and ASourceControl.HandleAllocated and
    (ADestinationControl <> nil) and ADestinationControl.HandleAllocated then
      MapWindowPoints(ASourceControl.Handle, ADestinationControl.Handle, Result, 1);
  OffsetWindowOrgEx(ADC, Result.X, Result.Y, APrevWindowOrg);
  ARect := cxRectOffset(ARect, Result);
end;

{ test of mouse keys pressing }

function IsMouseButtonPressed(AButton, ASwapButton: Integer): Boolean;
begin
  if GetSystemMetrics(SM_SWAPBUTTON) = 0 then
    Result := GetAsyncKeyState(AButton) < 0
  else
    Result := GetAsyncKeyState(ASwapButton) < 0;
end;

function LeftButtonPressed: Boolean;
begin
  Result := IsMouseButtonPressed(VK_LBUTTON, VK_RBUTTON);
end;

function RightButtonPressed: Boolean;
begin
  Result := IsMouseButtonPressed(VK_RBUTTON, VK_LBUTTON);
end;

function IsApplicationActive: Boolean;
begin
  Result := FApplicationActive and not FApplicationDeactivation and (GetActiveWindow <> 0);
end;

procedure dxFreeAndNil(var AObject);
begin
  TObject(AObject).Free;
  Pointer(AObject) := nil;
end;

procedure dxFreeAndNilObjectLink(var ALink: TcxObjectLink);
var
  ATempLink: TcxObjectLink;
begin
  if ALink <> nil then
  begin
    ATempLink := ALink;
    ALink := nil;
    cxRemoveObjectLink(ATempLink);
  end;
end;

function dxBarMessageBox(AText: string; AFlags: Integer): Integer;
begin
  Result := Application.MessageBox(PChar(AText), PChar(Application.Title), AFlags);
end;

procedure dxBarFrameRect(ADC: HDC; ARect: TRect; AColor: Integer);
begin
  FrameRect(ADC, ARect, GetSysColorBrush(AColor));
  InflateRect(ARect, -1, -1);
  FrameRect(ADC, ARect, GetSysColorBrush(AColor));
end;

procedure dxBarFocusRect(ADC: HDC; ARect: TRect);

  procedure InternalSetPixel(X, Y: Integer);
  begin
    if (X + Y) mod 2 = 0 then
      SetPixel(ADC, X, Y, ColorToRGB(clBtnText));
  end;

  procedure InternalDrawFocusRect;
  var
    I: Integer;
  begin
    for I := ARect.Left to ARect.Right - 1 do
    begin
      InternalSetPixel(I, ARect.Top);
      InternalSetPixel(I, ARect.Bottom - 1);
    end;
    for I := ARect.Top to ARect.Bottom - 1 do
    begin
      InternalSetPixel(ARect.Left, I);
      InternalSetPixel(ARect.Right - 1, I);
    end;
  end;

begin
  InternalDrawFocusRect;
  InflateRect(ARect, -1, -1);
  InternalDrawFocusRect;
end;

function IsSelectableItem(AObject: TObject): Boolean;
var
  ASelectableItem: IdxBarSelectableItem;
begin
  Result := IsSelectableItem(AObject, ASelectableItem);
end;

function IsSelectableItem(AObject: TObject;
  out ASelectableItem: IdxBarSelectableItem): Boolean;
var
  ATempSelectableItem: IdxBarSelectableItem;
begin
  Result := Supports(AObject, IdxBarSelectableItem, ATempSelectableItem);
  if Result then
    ASelectableItem := ATempSelectableItem;
end;

function GetSelectableItem(AObject: TObject): IdxBarSelectableItem;
begin
  if not IsSelectableItem(AObject, Result) then
    Result := nil;
end;

procedure CleanSelectableItems(AItems: TdxObjectList);
var
  I: Integer;
begin
  for I := AItems.Count - 1 downto 0 do
    if not IsSelectableItem(AItems[I]) then
      AItems.Delete(I);
end;

function GetMaxViewLevel(AViewLevels: TdxBarItemViewLevels): TdxBarItemRealViewLevel;
begin
  for Result := Low(TdxBarItemRealViewLevel) to High(TdxBarItemRealViewLevel) do
    if Result in AViewLevels then
      Break;
end;

function GetMinViewLevel(AViewLevels: TdxBarItemViewLevels): TdxBarItemRealViewLevel;
begin
  for Result := High(TdxBarItemRealViewLevel) downto Low(TdxBarItemRealViewLevel) do
    if Result in AViewLevels then
      Break;
end;

function GetNextViewLevel(AViewLevels: TdxBarItemViewLevels;
  AViewLevel: TdxBarItemRealViewLevel): TdxBarItemRealViewLevel;
begin
  for Result := Succ(AViewLevel) to High(TdxBarItemRealViewLevel) do
    if Result in AViewLevels then
      Break;
end;

function WidthToCurrentDpi(AValue: Integer; ANormalDpi: Integer = 96): Integer;
begin
  Result := Round(AValue * Screen.PixelsPerInch / ANormalDpi);
end;

procedure BarDrawSizeGrip(DC: HDC; R: TRect);
const
  ROP_DSPDxax = $00E20746;
var
  APrevBitmap, ATempBitmap, AMaskBitmap: HBITMAP;
  TempDC, MDC, MaskDC: HDC;
  W, H: Integer;
  APrevBkColor: COLORREF;
begin
  W := R.Right - R.Left;
  H := R.Bottom - R.Top;
  TempDC := CreateCompatibleDC(DC);
  ATempBitmap := SelectObject(TempDC, CreateCompatibleBitmap(DC, W, H));
  try
    BitBlt(TempDC, 0, 0, W, H, DC, R.Left, R.Top, SRCCOPY); // 1
    MDC := CreateCompatibleDC(DC);
    APrevBitmap := SelectObject(MDC, CreateCompatibleBitmap(DC, W, H));
    DrawFrameControl(MDC, Rect(0, 0, W, H), DFC_SCROLL, DFCS_SCROLLSIZEGRIP); // 2

    MaskDC := CreateCompatibleDC(DC);
    AMaskBitmap := SelectObject(MaskDC, CreateBitmap(W, H, 1, 1, nil));
    try
      APrevBkColor := SetBkColor(MDC, ColorToRGB(clBtnFace)); //!
      BitBlt(MaskDC, 0, 0, W, H, MDC, 0, 0, SRCCOPY);
      SetBkColor(MDC, APrevBkColor);

      BitBlt(TempDC, 0, 0, W, H, MaskDC, 0, 0, MERGEPAINT);
      BitBlt(MDC, 0, 0, W, H, MaskDC, 0, 0, SRCPAINT);
      BitBlt(TempDC, 0, 0, W, H, MDC, 0, 0, SRCAND);
    finally
      DeleteObject(SelectObject(MaskDC, AMaskBitmap));
      DeleteDC(MaskDC);
    end;

    DeleteObject(SelectObject(MDC, APrevBitmap));
    DeleteDC(MDC);

    BitBlt(DC, R.Left, R.Top, W, H, TempDC, 0, 0, SRCCOPY);
  finally
    DeleteObject(SelectObject(TempDC, ATempBitmap));
    DeleteDC(TempDC);
  end;
end;

{ XP routines }

function ThemeEditState(ABarEditControl: TdxBarWinControl(*TdxBarEditControl*)): Integer; // TODO ReadOnly
begin
  if not ABarEditControl.Enabled then
    Result := ETS_DISABLED
  else
//    if ABarEditControl.ReadOnly then
//      Result := ETS_READONLY
//    else
      Result := ETS_NORMAL;
end;

function ThemeEditColor(ATheme: TdxTheme; AEditState: Integer): COLORREF;
begin
  Result := GetSysColor(COLOR_WINDOW);
  if AEditState = ETS_DISABLED then
  begin
    if FAILED(GetThemeColor(ATheme, EP_EDITTEXT, AEditState, TMT_FILLCOLOR, Result)) then
      Result := GetSysColor(COLOR_WINDOW); 
  end;
end;

function ThemeEditTextColor(ATheme: TdxTheme; AEditState: Integer): COLORREF;
begin
  if FAILED(GetThemeColor(ATheme, EP_EDITTEXT, AEditState, TMT_TEXTCOLOR, Result)) then
  begin
    if AEditState = ETS_DISABLED then
      Result := GetSysColor(COLOR_GRAYTEXT)
    else
      Result := GetSysColor(COLOR_WINDOWTEXT);
  end;
end;

function ThemeToolbarColor: COLORREF;
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totToolbar);
  if FAILED(GetThemeColor(ATheme, 0, 0, TMT_FILLCOLOR, Result)) then
    Result := COLOR_BTNFACE;
end;

function ThemeCloseButtonSize: TSize;
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totWindow);
  GetThemePartSize(ATheme, 0, WP_SMALLCLOSEBUTTON, CBS_NORMAL, TS_TRUE, Result);
end;               

procedure ThemeDrawCloseButton(DC: HDC; var R: TRect; ASelected, APressed: Boolean;
  ACorner: TdxCorner);
const
  ButtonStates: array [TdxBarMarkState] of Integer = (CBS_NORMAL, CBS_HOT, CBS_PUSHED);
var
  ATheme: TdxTheme;
  AState, X: Integer;
  ASize: TSize;
begin
  ATheme := OpenTheme(totWindow);
  if APressed then
    AState := CBS_PUSHED
  else
    if ASelected then
      AState := CBS_HOT
    else
      AState := CBS_NORMAL;
  ASize := ThemeCloseButtonSize;
  if (R.Bottom - R.Top) > ASize.cy then
    X := ((R.Bottom - R.Top) - ASize.cy) div 2
  else
    X := 0;
  with R do
  begin
    if ACorner in [coTopRight, coBottomRight] then
    begin
      Inc(Left, X);
      Right := Left + ASize.cx;
    end
    else
    begin
      Dec(Right, X);
      Left := Right - ASize.cx;
    end;
    Inc(Top, X);
    Bottom := Top + ASize.cy;
  end;
  FillRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));
  DrawThemeBackground(ATheme, DC, WP_SMALLCLOSEBUTTON, AState, R);
end;

function ThemeSizeGripSize: TSize;
const
  Offset = 2; // !
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totScrollBar);
  GetThemePartSize(ATheme, 0, SBP_SIZEBOX, SZB_RIGHTALIGN, TS_TRUE, Result);
  Result.cx := Result.cx + Offset;
  Result.cy := Result.cy + Offset;
end;

procedure ThemeDrawSizeGrip(DC: HDC; var R: TRect; ACorner: TdxCorner);
const
  Offset = 2; // !
  Delta = 1;
var
  ATheme: TdxTheme;
  AMirrorX, AMirrorY: Boolean;
  R1: TRect;
  AScrollBarSize: TSize;
  APrevBitmap: HBITMAP;
  MDC: HDC;
  X, Y: Integer;
begin
  ATheme := OpenTheme(totScrollBar);
  AScrollBarSize := ThemeSizeGripSize;

  with R do
  begin
    if ACorner in [coTopRight, coBottomRight] then
      Left := Right - AScrollBarSize.cx - Delta
    else
      Right := Left + AScrollBarSize.cx + Delta;
    if ACorner in [coBottomLeft, coBottomRight] then
      Top := Bottom - AScrollBarSize.cy
    else
      Bottom := Top + AScrollBarSize.cy;
    AMirrorX := ACorner in [coTopLeft, coBottomLeft];
    AMirrorY := ACorner in [coTopLeft, coTopRight];
  end;

  FillRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));

  R1 := R;
  with R1 do
  begin
    if AMirrorX then
      Dec(Right, Offset)
    else
      Inc(Left, Offset);
    if AMirrorY then
      Dec(Bottom, Offset)
    else
      Inc(Top, Offset);
  end;

  X := R1.Left;
  Y := R1.Top;
  OffsetRect(R1, -R1.Left, -R1.Top);
  MDC := CreateCompatibleDC(DC);
  APrevBitmap := SelectObject(MDC, CreateCompatibleBitmap(DC, R1.Right, R1.Bottom));
  FillRect(MDC, R1, COLOR_BTNFACE + 1);
  DrawThemeBackground(ATheme, MDC, SBP_SIZEBOX, SZB_RIGHTALIGN, R1);
  with R1 do
    StretchBlt(DC, X, Y, Right, Bottom,
      MDC, Byte(AMirrorX) * (Right - 1), Byte(AMirrorY) * (Bottom - 1),
      (2 * Byte(not AMirrorX) - 1) * Right,
      (2 * Byte(not AMirrorY) - 1) * Bottom, SRCCOPY);
  DeleteObject(SelectObject(MDC, APrevBitmap));
  DeleteDC(MDC);
end;

{ TdxBarToolbarsPopup }

type
  TdxBarToolbarsPopup = class(TdxBarInternalSubMenuControl);

{ TdxBarDropDownListBox }

type
  TdxBarDropDownListBox = class(TCustomListBox)
  private
    FCombo: TdxBarCustomCombo;
    WaitForCapture: Boolean;
    function GetPainter: TdxBarPainter;
    procedure WMCaptureChanged(var Message: TMessage); message WM_CAPTURECHANGED;
    procedure WMEraseBkgnd(var Message: TWMEraseBkgnd); message WM_ERASEBKGND;
    procedure WMLButtonUp(var Message: TWMLButtonUp); message WM_LBUTTONUP;
    procedure WMNCCalcSize(var Message: TWMNCCalcSize); message WM_NCCALCSIZE;
    procedure WMNCPaint(var Message: TWMNCPaint); message WM_NCPAINT;
  protected
    procedure Click; override;
    procedure CreateParams(var Params: TCreateParams); override;
    procedure CreateWnd; override;
    procedure KeyDown(var Key: Word; Shift: TShiftState); override;
    procedure MouseMove(Shift: TShiftState; X, Y: Integer); override;
    property Painter: TdxBarPainter read GetPainter;
  public
    constructor Create(AOwner: TComponent); override;
    property OnDrawItem;
    property OnMeasureItem;
  end;

constructor TdxBarDropDownListBox.Create(AOwner: TComponent);
begin
  inherited;
  BorderStyle := bsNone;
  Style := lbOwnerDrawVariable;
  Visible := False;
end;

function TdxBarDropDownListBox.GetPainter: TdxBarPainter;
begin
  Result := TCustomdxBarControl(Parent).Painter;
end;

procedure TdxBarDropDownListBox.WMCaptureChanged(var Message: TMessage);
begin
  inherited;
  WaitForCapture := False;
end;

procedure TdxBarDropDownListBox.WMEraseBkgnd(var Message: TWMEraseBkgnd);
begin
  Message.Result := 1;
end;

procedure TdxBarDropDownListBox.WMLButtonUp(var Message: TWMLButtonUp);
var
  ACombo: TdxBarCustomCombo;
  AItemIndex: Integer;
  AItemLink, RealItemLink: TdxBarItemLink;
begin
  inherited;
  if WaitForCapture then
  begin
    ReleaseCapture;
    Exit;
  end;
  ACombo := FCombo;
  AItemIndex := ItemIndex;
  AItemLink := ACombo.CurItemLink;
  RealItemLink := AItemLink.RealItemLink;
  if RealItemLink <> nil then
  begin
    RealItemLink.BringToTopInRecentList(True);
    RealItemLink.BarManager.HideAll;
  end
  else
    AItemLink.BarManager.HideAll;
  if AItemIndex > -1 then ACombo.ItemIndex := AItemIndex;
end;

procedure TdxBarDropDownListBox.WMNCCalcSize(var Message: TWMNCCalcSize);
var
  ABorderSize: Integer;
begin
  inherited;
  ABorderSize := Painter.DropDownListBoxBorderSize;
  InflateRect(Message.CalcSize_Params.rgrc[0], -ABorderSize, -ABorderSize);
end;

procedure TdxBarDropDownListBox.WMNCPaint(var Message: TWMNCPaint);
var
  ARect: TRect;
  ADC: HDC;
begin
  inherited;
  ARect := cxGetWindowRect(Self);
  OffsetRect(ARect, -ARect.Left, -ARect.Top);
  ADC := GetWindowDC(Handle);
  BarCanvas.BeginPaint(ADC);
  try
    BarCanvas.ExcludeClipRect(cxRectInflate(ARect,
      -Painter.DropDownListBoxBorderSize, -Painter.DropDownListBoxBorderSize));
    Painter.DropDownListBoxDrawBorder(ADC, Color, ARect);
  finally
    BarCanvas.EndPaint;
  end;
  ReleaseDC(Handle, ADC);
end;

procedure TdxBarDropDownListBox.Click;
begin
  if ItemIndex > -1 then
    TdxBarComboControl(FCombo.CurItemLink.Control).LocalItemIndex := ItemIndex;
end;

procedure TdxBarDropDownListBox.CreateParams(var Params: TCreateParams);
begin
  inherited;
  with Params do
  begin
    ExStyle := WS_EX_TOOLWINDOW or WS_EX_TOPMOST;
    WindowClass.Style := WindowClass.Style or CS_SAVEBITS;
  end;
end;

procedure TdxBarDropDownListBox.CreateWnd;
begin
  inherited CreateWnd;
  Windows.SetParent(Handle, 0);
  CallWindowProc(DefWndProc, Handle, WM_SETFOCUS, 0, 0);
end;

procedure TdxBarDropDownListBox.KeyDown(var Key: Word; Shift: TShiftState);
begin
  if (ItemIndex = -1) and (Items.Count > 0) then ItemIndex := TopIndex;
  inherited;
end;

procedure TdxBarDropDownListBox.MouseMove(Shift: TShiftState; X, Y: Integer);
var
  I: Integer;
begin
  if (GetCapture = Handle) and WaitForCapture and PtInRect(ClientRect, Point(X, Y)) then
  begin
    WaitForCapture := False;
    CallWindowProc(DefWndProc, Handle, WM_LBUTTONDOWN, 0, MAKELPARAM(X, Y));
  end;
  inherited;
  I := ItemAtPos(Point(X, Y), True);
  if (0 <= I) and (I <= Items.Count - 1) then
    ItemIndex := I;
end;

procedure TdxCustomQuickCustItemControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
var
  AFullRect, R: TRect;
  ADC: HDC;
  ASelected: Boolean;
begin
  AFullRect := ARect;
  R := ARect;
  ASelected := IsSelected;
  ADC := Canvas.Handle;
  Painter.DrawQuickCustItemFrame(Self, ADC, R, ARect, ASelected);
  inherited;
  Painter.DrawGlyph(Self, ADC, R, cxEmptyRect, ptMenu, True, ASelected, IsDowned, False, False,
    True, False, False);
  Painter.DrawQuickCustItemFrameSelected(Self, ADC, AFullRect, R, ASelected);
end;

function TdxCustomQuickCustItemControl.GetDefaultWidth: Integer;
begin
  Result := inherited GetDefaultWidth;
  Inc(Result, GetDefaultHeight);
end;

procedure TdxBarQuickCustItem.DoClick;
var
  ItemLink: TdxBarItemLink;
begin
  inherited;
  ItemLink := TdxBarItemLink(ClickItemLink.Data);
  with ItemLink do
    Visible := not Visible;
end;

function TdxBarQuickCustItemControl.GetLinkedItemLink: TdxBarItemLink;
begin
  Result := TdxBarItemLink(FItemLink.Data);
end;

procedure TdxBarQuickCustItemControl.ControlUnclick(ByMouse: Boolean);
begin
  inherited;
  Repaint;
end;

function TdxBarQuickCustItemControl.GetCaption: string;
begin
  Result := LinkedItemLink.Caption;
end;

function TdxBarQuickCustItemControl.GetGlyph: TBitmap;
begin
  Result := LinkedItemLink.Glyph;
end;

function TdxBarQuickCustItemControl.GetImageIndex: Integer;
begin
  Result := LinkedItemLink.Item.ImageIndex;
end;

function TdxBarQuickCustItemControl.GetImageList(AViewSize: TdxBarItemControlViewSize): TCustomImageList;
begin
  Result := LinkedItemLink.Item.GetCurImages;
end;

function TdxBarQuickCustItemControl.GetLargeGlyph: TBitmap;
begin
  Result := LinkedItemLink.Item.LargeGlyph;
end;

function TdxBarQuickCustItemControl.GetLargeImageIndex: Integer;
begin
  Result := LinkedItemLink.Item.LargeImageIndex;
end;

function TdxBarQuickCustItemControl.IsDowned: Boolean;
begin
  Result := LinkedItemLink.Visible;
end;

function TdxBarQuickCustItemControl.GetHint: string;
begin
  Result := LinkedItemLink.Item.Hint;
end;

function TdxBarQuickCustItemControl.GetShortCut: TShortCut;
begin
  Result := LinkedItemLink.Item.ShortCut;
end;

function TdxBarQuickCustItemControl.IsDestroyOnClick: Boolean;
begin
  Result := False;
end;

{ TdxBarQuickCustExtButton and TdxBarQuickCustExtButtonControl }

type
  TdxBarQuickCustExtButton = class(TdxBarButton);

  TdxBarQuickCustExtButtonControl = class(TdxCustomQuickCustItemControl)
  protected
    function GetTextAreaOffset: Integer; override;
    function IsDowned: Boolean; override;
  end;

function TdxBarQuickCustExtButtonControl.GetTextAreaOffset: Integer;
begin
  Result := inherited GetTextAreaOffset + GetDefaultHeight;
end;

function TdxBarQuickCustExtButtonControl.IsDowned: Boolean;
begin
  Result := False;
end;

{ TdxBarQuickAccessItem and TdxBarQuickAccessSubControl }

type
  TdxBarQuickAccessItem = class(TdxBarSubItem)
  protected
    function CreateBarControl: TCustomdxBarControl; override;
  public
    constructor Create(AOwner: TComponent); override;
  end;

  TdxBarQuickAccessSubControl = class(TdxBarSubMenuControl)
  protected
    function NeedShowGlyphAndCheckForItem: Boolean; override;
  end;

constructor TdxBarQuickAccessItem.Create(AOwner: TComponent);
begin
  inherited;
  ItemLinks.Internal := True;
end;

function TdxBarQuickAccessItem.CreateBarControl: TCustomdxBarControl;
begin
  Result := TdxBarQuickAccessSubControl.Create(BarManager)
end;
  
function TdxBarQuickAccessSubControl.NeedShowGlyphAndCheckForItem: Boolean;
begin
  Result := True;
end;

constructor TdxBarQuickControl.CreateForPopup(AParentBarControl: TdxBarControl;
  ABar: TdxBar);
begin
  BarDesignController.ClearInternalItems;
  inherited CreateForPopup(AParentBarControl, ABar);
  OwnerBounds := ParentBar.MarkScreenRect;
  FHidingTimer := TcxTimer.Create(nil);
  FHidingTimer.Enabled := False;
  FHidingTimer.Interval := 200;
  FHidingTimer.OnTimer := QuickControlTimer;
end;

destructor TdxBarQuickControl.Destroy;
begin
  FreeAndNil(FHidingTimer);
  inherited Destroy;
end;

function TdxBarQuickControl.GetParentBar: TdxBarControl;
begin
  Result := TdxBarControl(inherited ParentBar);
end;

procedure TdxBarQuickControl.QuickControlTimer(Sender: TObject);
begin
  FHidingTimer.Enabled := False;

//#DG <BarManager.SelectedItem>
  if (BarManager.SelectedItem <> nil) and
    (GetParentBarForControl(BarManager.SelectedItem) <> Self) then
    try
      CloseUp;
    except
    end;
end;

procedure TdxBarQuickControl.SetParentBar(Value: TdxBarControl);
begin
  inherited ParentBar := Value;
end;

procedure TdxBarQuickControl.WMNCHitTest(var Message: TWMNCHitTest);
begin
  inherited;
  with Message do
    if Result <> HTCLIENT then Result := HTBORDER;
  FHitTest := HTCLIENT;
end;

procedure TdxBarQuickControl.WMNCPaint(var Message: TMessage);
var
  DC: HDC;
begin
  inherited;
  DC := GetWindowDC(Handle);
  Painter.BarDrawOwnerLink(Self, DC);
  ReleaseDC(Handle, DC);
end;

procedure TdxBarQuickControl.WMRButtonDown(var Message: TWMRButtonDown);
begin
  with TMessage(Message) do
    Result := DefWindowProc(Handle, Msg, wParam, lParam);
end;

function TdxBarQuickControl.GetParentForm: TCustomForm;
begin
  if ParentBar <> nil then
    Result := ParentBar.GetParentForm
  else
    Result := inherited GetParentForm;
end;

function TdxBarQuickControl.GetSizeForPopup: TSize;
begin
  with GetSizeForWidth(dsNone, 0) do
    Result := Size(X, Y);
  with Painter.GetToolbarContentOffsets(Bar, DockingStyle, False) do
  begin
    Inc(Result.cx, Left + Right);
    Inc(Result.cy, Top + Bottom);
  end;
end;

function TdxBarQuickControl.GetToolbarBrush: HBRUSH;
begin
  Result := Painter.BarToolbarBrushEx2(Self);
end;

function TdxBarQuickControl.HasCaption: Boolean;
begin
  Result := False;
end;

function TdxBarQuickControl.IsLinkedToOwner: Boolean;
begin
  Result := inherited IsLinkedToOwner(* or
    ((ParentBar <> nil) and (ParentBar.FQuickPopup = Self))*);
end;

function TdxBarQuickControl.IsPopup: Boolean;
begin
  Result := True;
end;

function TdxBarQuickControl.LockHotTrackWhenPopup: Boolean;
begin
  Result := False;
end;

function TdxBarQuickControl.NeedShowGlyphAndCheckForItem: Boolean;
begin
  Result := True;
end;

function TdxBarQuickControl.GetOwnerControl: TWinControl;
begin
  Result := ParentBar;
end;

function TdxBarQuickControl.Kind: TdxBarKind;
begin
  Result := bkBarQuickControl;
end;

procedure TdxBarQuickControl.Popup(const AOwnerRect: TRect);

  function GetDirection: TXDirection;
  begin
    if (ParentBar.DockingStyle = dsNone) and Painter.IsQuickControlPopupOnRight then
      Result := xdRight
    else
      Result := xdLeft;
  end;

begin
  PopupEx(AOwnerRect, GetDirection);
end;

procedure TdxBarQuickControl.StartHidingTimer;
begin
  FHidingTimer.Enabled := True;
end;

{ TdxBarManagerCategories }

type
  TdxBarCategoryData = class
  public
    ItemsVisible, LoadedItemsVisible: TdxBarItemVisible;
    Visible: Boolean;
  end;

  TdxBarManagerCategories = class(TStringList)
  private
    FMoving: Boolean;
    Owner: TdxBarManager;
    procedure ListChanged(Sender: TObject);
    procedure ChangeCategory(OldCategory, NewCategory: Integer);
    procedure ReadItemsVisibles(Reader: TReader);
    procedure ReadVisibles(Reader: TReader);
    procedure WriteItemsVisibles(Writer: TWriter);
    procedure WriteVisibles(Writer: TWriter);

    function IsIndexValid(AIndex: Integer): Boolean;
  protected
    procedure ClearObject(AIndex: Integer);
    procedure ClearObjects;
    procedure DefineProperties(Filer: TFiler); override;
  public
    constructor Create(AOwner: TdxBarManager);
    destructor Destroy; override;
    procedure Clear; override;
    procedure Delete(Index: Integer); override;
    procedure Insert(Index: Integer; const S: string); override;
    procedure Exchange(Index1, Index2: Integer); override;
    procedure Move(CurIndex, NewIndex: Integer); override;
  end;

constructor TdxBarManagerCategories.Create(AOwner: TdxBarManager);
begin
  inherited Create;
  Owner := AOwner;
  if not Owner.IsLoading then
    Add(cxGetResourceString(@dxSBAR_DEFAULTCATEGORYNAME));
  OnChange := ListChanged;
end;

destructor TdxBarManagerCategories.Destroy;
begin
  ClearObjects;
  inherited;
end;

procedure TdxBarManagerCategories.Clear;
begin
  ClearObjects;
  inherited;
end;

procedure TdxBarManagerCategories.ListChanged(Sender: TObject);
begin
  Owner.DesignerModified;
end;

procedure TdxBarManagerCategories.ChangeCategory(OldCategory, NewCategory: Integer);
var
  AList: TList;
  I: Integer;
begin
  if IsIndexValid(OldCategory) and (NewCategory > -1) then
  begin
    AList := TList.Create;
    try
      Owner.GetAllItemsByCategory(OldCategory, AList);
      for I := 0 to AList.Count - 1 do
        TdxBarItem(AList[I]).FCategory := NewCategory;
    finally
      AList.Free;
    end;
  end;
end;

procedure TdxBarManagerCategories.ReadItemsVisibles(Reader: TReader);
var
  I: Integer;
begin
  Reader.ReadListBegin;
  try
    BeginUpdate;
    try
      for I := 0 to Count - 1 do
      begin
        if Reader.EndOfList then Break;
        Owner.CategoryItemsVisible[I] := TdxBarItemVisible(Reader.ReadInteger);
      end;
    finally
      EndUpdate;
    end;
  finally
    Reader.ReadListEnd;
  end;  
end;

procedure TdxBarManagerCategories.ReadVisibles(Reader: TReader);
var
  I: Integer;
begin
  Reader.ReadListBegin;
  try
    BeginUpdate;
    try
      for I := 0 to Count - 1 do
      begin
        if Reader.EndOfList then Break;
        Owner.CategoryVisible[I] := Reader.ReadBoolean;
      end;
    finally
      EndUpdate;
    end;
  finally
    Reader.ReadListEnd;
  end;  
end;

procedure TdxBarManagerCategories.WriteItemsVisibles(Writer: TWriter);
var
  I: Integer;
begin
  Writer.WriteListBegin;
  try
    for I := 0 to Count - 1 do
      Writer.WriteInteger(Longint(Owner.CategoryItemsVisible[I]));
  finally
    Writer.WriteListEnd;
  end;
end;

procedure TdxBarManagerCategories.WriteVisibles(Writer: TWriter);
var
  I: Integer;
begin
  Writer.WriteListBegin;
  try
    for I := 0 to Count - 1 do
      Writer.WriteBoolean(Owner.CategoryVisible[I]);
  finally
    Writer.WriteListEnd;
  end;
end;

function TdxBarManagerCategories.IsIndexValid(AIndex: Integer): Boolean;
begin
  Result := (0 <= AIndex) and (AIndex < Count);
end;

procedure TdxBarManagerCategories.ClearObject(AIndex: Integer);
begin
  if Objects[AIndex] <> nil then
  begin
    Objects[AIndex].Free;
    Objects[AIndex] := nil;
  end;
end;

procedure TdxBarManagerCategories.ClearObjects;
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
    ClearObject(I);
end;

procedure TdxBarManagerCategories.DefineProperties(Filer: TFiler);
begin
  inherited;
  Filer.DefineProperty('ItemsVisibles', ReadItemsVisibles, WriteItemsVisibles, True);
  Filer.DefineProperty('Visibles', ReadVisibles, WriteVisibles, True);
end;

procedure TdxBarManagerCategories.Delete(Index: Integer);

  procedure DeleteCategoryItems;
  var
    AList: TObjectList;
  begin
    AList := TObjectList.Create;
    try
      Owner.GetAllItemsByCategory(Index, AList);
    finally
      AList.Free;
    end;
  end;

var
  I: Integer;
begin
  if FMoving then inherited
  else
  begin
    if IsIndexValid(Index) then
    begin
      DeleteCategoryItems;
      for I := Index + 1 to Count - 1 do
        ChangeCategory(I, I - 1);
      ClearObject(Index);
      inherited;
    end;
    if Count = 0 then
      Add(cxGetResourceString(@dxSBAR_DEFAULTCATEGORYNAME));
  end;    
end;

procedure TdxBarManagerCategories.Insert(Index: Integer; const S: string);
var
  I: Integer;
begin
  if not FMoving and IsIndexValid(Index) then
    for I := Count - 1 downto Index do
      ChangeCategory(I, I + 1);
  inherited Insert(Index, S);
end;

procedure TdxBarManagerCategories.Exchange(Index1, Index2: Integer);
var
  I: Integer;
  List1: TList;
  List2: TList;
begin
  if IsIndexValid(Index1) and IsIndexValid(Index2) then
  begin
    List1 := TList.Create;
    List2 := TList.Create;
    try
      Owner.GetAllItemsByCategory(Index1, List1);
      Owner.GetAllItemsByCategory(Index2, List2);
      for I := 0 to List1.Count - 1 do
        TdxBarItem(List1[I]).Category := Index2;
      for I := 0 to List2.Count - 1 do
        TdxBarItem(List2[I]).Category := Index1;
    finally
      List2.Free;
      List1.Free;
    end;
    inherited Exchange(Index1, Index2);
  end;
end;

procedure TdxBarManagerCategories.Move(CurIndex, NewIndex: Integer);
var
  List: TList;
  I: Integer;
begin
  if IsIndexValid(CurIndex) and IsIndexValid(NewIndex) and (CurIndex <> NewIndex) then
  begin
    List := TList.Create;
    try
      Owner.GetAllItemsByCategory(CurIndex, List);
      for I := 0 to List.Count - 1 do
        TdxBarItem(List[I]).FCategory := dxBarManagerTempCategoryIndex;
      if CurIndex < NewIndex then
        for I := CurIndex + 1 to NewIndex do
          ChangeCategory(I, I - 1)
      else
        for I := CurIndex - 1 downto NewIndex do
          ChangeCategory(I, I + 1);
      for I := 0 to List.Count - 1 do
        TdxBarItem(List[I]).FCategory := NewIndex;
    finally
      List.Free;
    end;
    FMoving := True;
    inherited Move(CurIndex, NewIndex);
    FMoving := False;
  end;
end;

{ TdxBarKeyTipData }

constructor TdxBarKeyTipData.Create(const AKeyTipInfo: TdxBarKeyTipInfo);
begin
  inherited Create;
  FKeyTipInfo := AKeyTipInfo;
end;

procedure TdxBarKeyTipData.HideKeyTipWindow(
  AKeyTipWindowsManager: IdxBarKeyTipWindowsManager);
begin
  if FKeyTipWindow <> nil then
  begin
    AKeyTipWindowsManager.Delete(FKeyTipWindow);
    FKeyTipWindow := nil;
  end;
end;

procedure TdxBarKeyTipData.ShowKeyTipWindow(
  AKeyTipWindowsManager: IdxBarKeyTipWindowsManager);
begin
  if FKeyTipWindow = nil then
    AKeyTipWindowsManager.Add(NormalizedKeyTip, BasePoint, HorzAlign, VertAlign,
      Enabled, FKeyTipWindow);
end;

function TdxBarKeyTipData.GetNormalizedKeyTip: string;
begin
  Result := AnsiUpperCase(KeyTip);
end;

{ TdxBarPersistent }

constructor TdxBarPersistent.Create(ABarManager: TdxBarManager);
begin
  inherited Create;
  FBarManager := ABarManager;
end;

function TdxBarPersistent.GetOwner: TPersistent;
begin
  Result := FBarManager;
end;

{$IFNDEF DELPHI6}
destructor TComponentList.Destroy;
begin
  Clear;
  inherited;
end;
{$ENDIF}

{ TdxBarControlEditor }

class procedure TdxBarControlEditor.InitCustomizationPopup(AItemLinks: TdxBarItemLinks);
var
  AItemLink: TdxBarItemLink;
begin
  AItemLink := BarDesignController.AddInternalItem(AItemLinks, PopupItemClass, GetPopupItemCaption);
  InitializePopupItem(AItemLink);
end;

class function TdxBarControlEditor.GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass;
begin
  Result := nil;
end;

class function TdxBarControlEditor.GetPopupItemCaption: string;
begin
  Result := '';
end;

class procedure TdxBarControlEditor.InitializePopupItem(AItemLink: TdxBarItemLink);
begin
// do nothing
end;

class function TdxBarControlEditor.PopupItemClass: TdxBarItemClass;
begin
  Result := nil;
end;

class procedure TdxBarControlEditor.AddItem(AClickedButton: TdxBarButton);
var
  AItemLink: TdxBarItemLink;
begin
  AItemLink := BarDesignController.AddItem(GetAddedItemClass(AClickedButton.Caption));
  InitializeAddedItem(AItemLink, AClickedButton.Caption);
//  BarDesignController.SelectItem(AItemLink);
//  AItemLink.BarControl.SetKeySelectedItem(AItemLink.Control);
  AItemLink.BarControl.SelectItemControl(AItemLink.Control, mbRight, []);
end;

class procedure TdxBarControlEditor.InitializeAddedItem(AItemLink: TdxBarItemLink; AAddedItemName: string);
begin
// do nothing
end;

class procedure TdxBarControlEditor.OnButtonClick(Sender: TObject);
begin
  AddItem(TdxBarButton(Sender));
end;

{ TdxAddSubItemEditor }

class function TdxAddSubItemEditor.GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass;
begin
  Result := TdxBarSubItem;
end;

class function TdxAddSubItemEditor.GetPopupItemCaption: string;
begin
  Result := dxSBAR_CP_ADDSUBITEM;
end;

class procedure TdxAddSubItemEditor.InitializePopupItem(AItemLink: TdxBarItemLink);
begin
  TdxBarButton(AItemLink.Item).OnClick := OnButtonClick;
  AItemLink.Item.Enabled := BarDesignController.CustomizingBarManager.CanAddComponents;
end;

class function TdxAddSubItemEditor.PopupItemClass: TdxBarItemClass;
begin
  Result := TdxBarButton;
end;

{ TdxAddButtonEditor }

class function TdxAddButtonEditor.GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass;
begin
  Result := TdxBarButton;
end;

class function TdxAddButtonEditor.GetPopupItemCaption: string;
begin
  Result := dxSBAR_CP_ADDBUTTON;
end;

{ TdxAddSeparatorEditor }

class function TdxAddSeparatorEditor.GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass;
begin
  Result := TdxBarSeparator;
end;

class function TdxAddSeparatorEditor.GetPopupItemCaption: string;
begin
  Result := dxSBAR_CP_ADDSEPARATOR;
end;

{ TdxItemsEditorEx }

class procedure TdxItemsEditorEx.InitSubItem(AItemLinks: TdxBarItemLinks);
var
  I: Integer;
begin
  for I := 0 to RegdxItemList.VisibleItemCount - 1 do
    BarDesignController.AddInternalItem(AItemLinks, TdxBarButton,
      RegdxItemList.VisibleItemClass[I].ClassName, OnButtonClick);
end;

class function TdxItemsEditorEx.GetAddedItemClass(const AAddedItemName: string): TdxBarItemClass;
begin
  Result := TdxBarItemClass(FindClass(AAddedItemName));
end;

class function TdxItemsEditorEx.GetPopupItemCaption: string;
begin
  Result := dxSBAR_CP_ADDDXITEM;
end;

class procedure TdxItemsEditorEx.InitializePopupItem(AItemLink: TdxBarItemLink);
var
  ASubItem: TdxBarSubItem;
begin
  ASubItem := TdxBarSubItem(AItemLink.Item);
  ASubItem.Enabled := BarDesignController.CustomizingBarManager.CanAddComponents;
  ASubItem.IsInternal := True;
  if ASubItem.Enabled then
  begin
    ASubItem.ItemLinks.BeginUpdate;
    try
      InitSubItem(ASubItem.ItemLinks);
    finally
      ASubItem.ItemLinks.EndUpdate;
    end;
  end;
end;

class function TdxItemsEditorEx.PopupItemClass: TdxBarItemClass;
begin
  Result := TdxBarSubItem;
end;

{ TCustomdxBarControlDesignHelper }

class procedure TCustomdxBarControlDesignHelper.FilterItemActions(var ASupportedActions: TdxBarCustomizationActions);
begin
  ASupportedActions := ASupportedActions - GetForbiddenActions;
end;

class procedure TCustomdxBarControlDesignHelper.GetEditors(AEditors: TList);
var
  I: Integer;
begin
  for I := 0 to BarDesignController.FRegisteredBarControlEditors.Count - 1 do
    AEditors.Add(BarDesignController.FRegisteredBarControlEditors[I])
end;

class function TCustomdxBarControlDesignHelper.GetForbiddenActions: TdxBarCustomizationActions;
begin
  Result := [caChangeButtonPaintStyle, caChangePosition, caChangeViewLevels, caChangeButtonGroup, caChangeRecentList, caChangeDistributed]
end;

{ TdxBarControlDesignHelper }

class function TdxBarControlDesignHelper.GetForbiddenActions: TdxBarCustomizationActions;
begin
  Result := inherited GetForbiddenActions - [caChangeButtonPaintStyle];
end;

{ TdxBarSubMenuControlDesignHelper }

class procedure TdxBarSubMenuControlDesignHelper.GetEditors(AEditors: TList);
begin
  inherited GetEditors(AEditors);
  AEditors.Add(TdxAddSeparatorEditor);
end;

class function TdxBarSubMenuControlDesignHelper.GetForbiddenActions: TdxBarCustomizationActions;
begin
  Result := inherited GetForbiddenActions - [caChangeRecentList];
end;

{ TdxBarDesignController }

constructor TdxBarDesignController.Create;
begin
  inherited Create;
  FRegisteredBarControlDesignHelpers := TcxRegisteredClassList.Create;
  FRegisteredBarControlEditors := TList.Create;
  FNotifyComponent := TcxFreeNotificator.Create(nil);
  FNotifyComponent.OnFreeNotification := FreeNotification;
  FInternalItems := TComponentList.Create;
end;

destructor TdxBarDesignController.Destroy;
begin
  FreeAndNil(FInternalItems);
  FreeAndNil(FNotifyComponent);
  FreeAndNil(FRegisteredBarControlEditors);
  FreeAndNil(FRegisteredBarControlDesignHelpers);
  inherited;
end;

procedure TdxBarDesignController.AddCustomizeItem(AItemLinks: TdxBarItemLinks;
  AItemClass: TdxBarItemClass; ABeginGroup: Boolean = True);
var
  AItemLink: TdxBarItemlink;
begin
  if AItemLinks.BarManager.CanCustomize then
  begin
    AItemLink := AddInternalItem(AItemLinks, AItemClass,
      cxGetResourceString(@dxSBAR_CUSTOMIZE), CustomizeItemClick);
    AItemLink.BeginGroup := ABeginGroup;
    AItemLink.Item.Enabled := dxBarCustomizingForm = nil;
  end;
end;

function TdxBarDesignController.AddInternalItem(AItemLinks: TdxBarItemLinks;
  AItemClass: TdxBarItemClass; ACaption: string; AOnClick: TNotifyEvent = nil;
  ATag: Integer = 0; ABeginGroup: Boolean = False): TdxBarItemLink;
var
  AItem: TdxBarItem;
begin
  Result := AItemLinks.AddItem(AItemClass, nil);
  AItem := Result.Item;
  AddInternalItem(AItem);

  AItem.Caption := ACaption;
  AItem.OnClick := AOnClick;
  AItem.Tag := ATag;
  Result.BeginGroup := ABeginGroup;
end;

procedure TdxBarDesignController.AddInternalItem(AItem: TdxBarItem; AList: TList = nil);
begin
  if AList = nil then
    AList := FInternalItems;

  AList.Add(AItem);
  RemoveItemFromBarManagerList(AItem);
end;

procedure TdxBarDesignController.ClearInternalItems;
begin
  FInternalItems.Clear;
end;

procedure TdxBarDesignController.RemoveItemFromBarManagerList(AItem: TdxBarItem);
begin
  AItem.BarManager.ItemList.Remove(AItem);
end;

function TdxBarDesignController.AddItem(ABarItemClass: TdxBarItemClass): TdxBarItemLink;
var
  ACategoryIndex, AItemIndex: Integer;
  AItem: TdxBarItem;
begin
  CustomizingBarManager.ItemList.BeginUpdate;
  try
    FCustomizingItemLinks.BeginUpdate;
    try
      Result := FCustomizingItemLinks.AddItem(ABarItemClass, {GetBarManagerForm(FCustomizingBarManager, fkAny).Designer.GetRoot} FCustomizingBarManager.Owner);

      AItem := Result.Item;
      ACategoryIndex := FCustomizingBarManager.Categories.IndexOf(dxSBAR_DEFAULTCATEGORYNAME);
      if ACategoryIndex = -1 then
        ACategoryIndex := 0;
      AItem.Category := ACategoryIndex;
      AItem.Name := FCustomizingBarManager.GetUniqueItemName(ABarItemClass);
      AItem.Caption := ABarItemClass.GetNewCaption;
      AItemIndex := FCustomizingItemLinks.IndexOf(CustomizingItemLink); //#DG ! FCustomizingItemLinks.Index
      if AItemIndex <> -1 then
        Result.Index := AItemIndex + 1;
    finally
      FCustomizingItemLinks.EndUpdate;
    end;
  finally
    CustomizingBarManager.ItemList.EndUpdate;
  end;
end;

procedure TdxBarDesignController.SelectItemLink(AItemLink: TdxBarItemLink);
begin
  if (CustomizingBarControl <> nil) and
     not IsRectEmpty(CustomizingBarControl.GetItemRect(AItemLink.Control)) then
  begin
    CustomizingBarControl.BarGetFocus(AItemLink.Control);
    SelectItem(AItemLink); //#DG new
  end;
end;

procedure TdxBarDesignController.DesignerModified;
begin
  FCustomizingBarManager.DesignerModified;
end;

function TdxBarDesignController.IsCustomizedByPopup: Boolean;
begin
  Result := FCustomizationPopup <> nil;
end;

procedure TdxBarDesignController.RegisterBarControlDesignHelper(
  ABarControlClass: TCustomdxBarControlClass;
  AHelperClass: TCustomdxBarControlDesignHelperClass);
begin
  FRegisteredBarControlDesignHelpers.Register(ABarControlClass, AHelperClass);
end;

procedure TdxBarDesignController.RegisterBarControlEditor(AEditor: TdxBarControlEditorClass);
begin
  FRegisteredBarControlEditors.Add(AEditor);
end;

procedure TdxBarDesignController.UnregisterBarControlDesignHelper(
  ABarControlClass: TCustomdxBarControlClass;
  AHelperClass: TCustomdxBarControlDesignHelperClass);
begin
  FRegisteredBarControlDesignHelpers.Unregister(ABarControlClass, AHelperClass);
end;

procedure TdxBarDesignController.UnregisterBarControlEditor(
  AEditor: TdxBarControlEditorClass);
begin
  FRegisteredBarControlEditors.Remove(AEditor);
end;

procedure TdxBarDesignController.DropSelection(ASelectableItem: IdxBarSelectableItem);
begin
  if IsItemLastSelected(ASelectableItem) then
    FLastSelectedItem := nil;
end;

function TdxBarDesignController.IsItemCustomized(ASelectableItem: IdxBarSelectableItem): Boolean;
begin
  Result := IsCustomizedByPopup and (ASelectableItem.GetInstance = FCustomizingItemLink);
end;

function TdxBarDesignController.IsItemLastSelected(ASelectableItem: IdxBarSelectableItem): Boolean;
begin
  Result := (ASelectableItem <> nil) and (ASelectableItem = LastSelectedItem);
end;

function TdxBarDesignController.IsItemLinkCustomized: Boolean;
begin
  Result := IsCustomizedByPopup and (FCustomizingItemLink <> nil);
end;

function TdxBarDesignController.IsItemSingleSelected(ASelectableItem: IdxBarSelectableItem): Boolean;
begin
  Result := (ASelectableItem <> nil) and IsSelectionSingle(ASelectableItem.GetBarManager);
end;

function TdxBarDesignController.IsSelectionComplex(ABarManager: TdxBarManager): Boolean;
var
  ASelection: TdxObjectList;
  I: Integer;
begin
  Result := False;
  ASelection := TdxObjectList.Create;
  try
    ABarManager.GetSelection(ASelection);
    CleanSelectableItems(ASelection);
    for I := 0 to ASelection.Count - 1 do
      Result := Result or GetSelectableItem(ASelection[I]).IsComplex;
  finally
    ASelection.Free;
  end;
end;

function TdxBarDesignController.IsSelectionSingle(ABarManager: TdxBarManager): Boolean;
var
  ASelection: TdxObjectList;
begin
  ASelection := TdxObjectList.Create;
  try
    ABarManager.GetSelection(ASelection);
    CleanSelectableItems(ASelection);
    Result := ASelection.Count = 1;
  finally
    ASelection.Free;
  end;
end;

function TdxBarDesignController.NeedDefaultSelection(ASelectableItem: IdxBarSelectableItem): Boolean;
begin
//  Result := IsItemCustomized(ASelectableItem) or IsItemSingleSelected(ASelectableItem) and not IsSelectionComplex(ASelectableItem.GetBarManager);
  Result := not ASelectableItem.GetBarManager.Designing and IsItemLastSelected(ASelectableItem) or
    IsSelectionSingle(ASelectableItem.GetBarManager) and
    (not IsSelectionComplex(ASelectableItem.GetBarManager) or IsItemCustomized(ASelectableItem));
end;

procedure TdxBarDesignController.SelectItem(ASelectableItem: IdxBarSelectableItem;
  ASelectionOperation: TdxBarSelectionOperation = soExclusive);
begin
  if ASelectableItem <> nil then
    ASelectableItem.SelectComponent(ASelectionOperation);
  case ASelectionOperation of
    soAdd, soExclusive: LastSelectedItem := ASelectableItem;
    soExclude: SynchronizeLastSelectedItem;
  end;
end;

procedure TdxBarDesignController.SelectObject(AObject: TPersistent;
  ASelectionOperation: TdxBarSelectionOperation);
begin
  if GetSelectableItem(AObject) <> nil then
    SelectItem(GetSelectableItem(AObject), ASelectionOperation)
  else
    CustomizingBarManager.SelectComponent(AObject, ASelectionOperation);
end;

procedure TdxBarDesignController.SynchronizeLastSelectedItem;
begin
  if (LastSelectedItem <> nil) and
    (not LastSelectedItem.IsComponentSelected or not IsApplicationActive)then
    LastSelectedItem := nil;
end;

function TdxBarDesignController.DeleteSelectedObjects(ADestruction, AIsKeyboardAction: Boolean): Boolean;

  function IsComplexItemSelected(ASelection: TdxObjectList): Boolean;
  var
    I: Integer;
  begin
    Result := False;
    for I := 0 to ASelection.Count - 1 do
      Result := Result or (ASelection[I] is TdxBarItem) and (TdxBarItem(ASelection[I]).LinkCount > 1);
  end;

  function GetNextSelectedObject(ASelection: TdxObjectList): TPersistent;

    function CanSelect(AObject: TObject): Boolean;
    begin
      Result := (ASelection.IndexOf(AObject) = -1) and IsObjectUnbound(AObject, ASelection);
    end;

  var
    ASelectableItem, ANextSelectableItem: IdxBarSelectableItem;
  begin
    Result := nil;
    ASelectableItem := GetSelectableItem(ASelection.Last);
    ANextSelectableItem := ASelectableItem.GetNextSelectableItem;
    while (Result = nil) and (ANextSelectableItem <> nil) and (ANextSelectableItem.GetInstance <> ASelectableItem.GetInstance) do
    begin
      if CanSelect(ANextSelectableItem.GetInstance) then
        Result := ANextSelectableItem.GetInstance;
      ANextSelectableItem := ANextSelectableItem.GetNextSelectableItem;
    end;
    if (Result = nil) and CanSelect(ASelectableItem.GetSelectableParent) then
      Result := ASelectableItem.GetSelectableParent;
  end;

var
  ASelection: TdxObjectList;
  ASelectableItem: IdxBarSelectableItem;
  ANextSelectedObject: TPersistent;
  I: Integer;
begin
  Result := False;

  FindCustomizingBarManager;
  if CanCustomize(CustomizingBarManager, AIsKeyboardAction) then
  begin
    if CustomizingBarManager.Designing then
    begin
      ASelection := TdxObjectList.Create;
      try
        GetSelection(ASelection);
        RemoveIrrelevantObjectsForDelete(ASelection, ADestruction);
        if ASelection.Count > 0 then
        begin
          Result := True;
          if ADestruction or not IsComplexItemSelected(ASelection) or
            (dxBarMessageBox(dxSBAR_WANTTODELETECOMPLEXITEM, MB_YESNO) = IDYES) then
          begin
            CustomizingBarManager.BeginUpdate;
            try
              ANextSelectedObject := GetNextSelectedObject(ASelection);
              for I := ASelection.Count - 1 downto 0 do
              begin
                ASelectableItem := GetSelectableItem(ASelection[I]);
                ASelectableItem.DeleteSelection(ASelectableItem, ADestruction);
              end;
              if ANextSelectedObject <> nil then
                SelectObject(ANextSelectedObject);
            finally
              CustomizingBarManager.EndUpdate;
            end;
            DesignerModified;
          end;
        end;
      finally
        ASelection.Free;
      end;
    end
    else
      CustomizingBarManager.LastSelectedLinkAtDesign.Free;
  end;
end;

procedure TdxBarDesignController.DeleteCustomizingItem;
begin
  if FCustomizingItemLink = nil then Exit;
  FCustomizingItemLink.Item.Free;
  FCustomizingItemLink := nil;
end;

procedure TdxBarDesignController.DeleteCustomizingItemLink;
begin
  FreeAndNil(FCustomizingItemLink);
end;

function TdxBarDesignController.SelectParentComponent: Boolean;
var
  ASelectedObjects: TdxObjectList;
  ASelectableItem: IdxBarSelectableItem;
begin
  FindCustomizingBarManager;
  if CanCustomize(CustomizingBarManager, True) then
  begin
    ASelectedObjects := TdxObjectList.Create;
    try
      CustomizingBarManager.GetActiveSelection(ASelectedObjects);
      Result := IsSelectableItem(ASelectedObjects.Last, ASelectableItem) and
        ASelectableItem.SelectParentComponent;
    finally
      ASelectedObjects.Free;
    end;
  end
  else
    Result := False;
end;

procedure TdxBarDesignController.ShowCustomCustomizePopup(ABarManager: TdxBarManager;
  AInitPopupProc: TInitPopupProc; APainter: TdxBarPainter;
  ACustomizingBarControl: TCustomdxBarControl = nil; ACustomizingItemLink: TdxBarItemLink = nil);

  procedure DeactivateCustomizingItem;
  begin
//    if (FCustomizingBarControl <> nil) and FCustomizingBarControl.IsFocused then
//      FCustomizingBarControl.SetMouseSelectedItem(GetControlByLink(FCustomizingItemLink));
    if (FCustomizingBarControl <> nil) and (FCustomizingBarControl.SelectedControl <> nil) then
      FCustomizingBarControl.SelectedControl.ControlInactivate(False);
  end;

begin
  ClearInternalItems;

  FCustomizingBarControl := ACustomizingBarControl;
  FCustomizingItemLink := ACustomizingItemLink;
  FCustomizingBarManager := ABarmanager;

  FCustomizationPopup := TdxBarCustomizingPopup.Create(FCustomizingBarManager);
  if ACustomizingBarControl <> nil then
    FCustomizationPopup.FParentWnd := ACustomizingBarControl.Handle;
  FCustomizationPopup.FPainter := APainter;
  FCustomizationPopup.OnCloseUp := CustomizationPopupCloseUp;
  FCustomizationPopup.OnDestroy := CustomizationPopupDestroy;
  AInitPopupProc(FCustomizationPopup.ItemLinks);
  if FCustomizationPopup.ItemLinks.Count > 0 then
  begin
    DeactivateCustomizingItem;
    FCustomizationPopup.DoShowCustomizingPopup;

    FCustomizationPopup.Left := GetMouseCursorPos.X;
    FCustomizationPopup.Top := GetMouseCursorPos.Y;
    FCustomizationPopup.Show;
  end
  else
  begin
    FCustomizingBarControl := nil;
    FreeAndNil(FCustomizationPopup);
  end;
end;

procedure TdxBarDesignController.ShowCustomizePopup(ABarControl: TCustomdxBarControl;
  ACustomizingItemLink: TdxBarItemLink);
begin
  FCustomizingItemLinks := ABarControl.ItemLinks;
  ShowCustomCustomizePopup(ABarControl.Barmanager, InitCustomizationPopup, ABarControl.Painter, ABarControl, ACustomizingItemLink);
end;

procedure TdxBarDesignController.SetCustomizePopupTopMosts(AShow: Boolean);
var
  APrevBarControl, ABarControl: TCustomdxBarControl;
begin
  if AShow then
  begin
    dxSetZOrder(FCustomizationPopup.Handle);
    APrevBarControl := FCustomizationPopup;
    if CustomizingItemLink.Control <> nil then
    begin
      ABarControl := CustomizingBarControl;
      repeat
        dxSetZOrder(ABarControl.Handle, APrevBarControl.Handle);
        APrevBarControl := ABarControl;
        ABarControl := ABarControl.ParentBar;
      until ABarControl = nil;
    end;
  end
  else
  begin
    if CustomizingItemLink.Control <> nil then
    begin
      ABarControl := CustomizingBarControl;
      while ABarControl.ParentBar <> nil do
        ABarControl := ABarControl.ParentBar;
      repeat
        dxSetZOrder(ABarControl.Handle, HWND_NOTOPMOST);
        ABarControl := ABarControl.ChildBar;
      until ABarControl = nil;
    end;
    dxSetZOrder(FCustomizationPopup.Handle, HWND_NOTOPMOST);
  end;
end;

procedure TdxBarDesignController.InitToolBarPopup(AItemLinks: TdxBarItemLinks);
var
  I: Integer;
  ABars: TdxBars;
  ABar: TdxBar;
  AItem: TdxBarButton;
  AItemLink: TdxBarItemLink;
begin
  ClearOwnedItems(AItemLinks);
  ABars := AItemLinks.BarManager.Bars;
  for I := 0 to ABars.Count - 1 do
  begin
    ABar := ABars[I];
    if ABar.CanClose and not ABar.Hidden and (ABar.MergeData.MergedWith = nil) then
    begin
      AItemLink := AddInternalItem(AItemLinks, TdxBarButton, ABar.Caption, ToolbarsPopupClick);
      AItem := TdxBarButton(AItemLink.Item);
      AItem.Tag := Integer(ABar);
      AItem.ButtonStyle := bsChecked;
      AItem.Down := ABars[I].Visible;
    end;
  end;
  AddCustomizeItem(AItemLinks, TdxBarButton);
end;

procedure TdxBarDesignController.ShowToolbarsPopup(ABarManager: TdxBarManager; APainter: TdxBarPainter);
var
  AToolbarsPopup: TdxBarToolbarsPopup;
begin
  ClearInternalItems;

  FCustomizingBarManager := ABarManager;
  AToolbarsPopup := TdxBarToolbarsPopup.Create(ABarManager);
  AToolbarsPopup.FPainter := APainter;
  InitToolBarPopup(AToolbarsPopup.ItemLinks);
  ABarManager.DoShowToolbarsPopup(AToolbarsPopup.ItemLinks);
  if AToolbarsPopup.FItemLinks.Count = 0 then
    AToolbarsPopup.Free
  else
  begin
    ABarManager.HideAll;
    AToolbarsPopup.Left := GetMouseCursorPos.X;
    AToolbarsPopup.Top := GetMouseCursorPos.Y;
    AToolbarsPopup.FShowAnimation := True;
    AToolbarsPopup.Show;
  end;
end;

procedure TdxBarDesignController.ShowQuickControl(ABarControl: TdxBarControl; AOwnerRect: TRect);
begin
  FCustomizingBarManager := ABarControl.Barmanager;

  FQuickControl := ABarControl.GetQuickControlClass.CreateForPopup(ABarControl, ABarControl.Bar);
  FQuickControl.FPainter := ABarControl.Painter;
  FQuickControl.OnDestroy := QuickControlDestroy;
  ABarControl.InitQuickControl(FQuickControl.ItemLinks);
  FQuickControl.Popup(AOwnerRect);
  PlaySound(psMenuPopup);
end;

function TdxBarDesignController.CanDeleteSelectedObjects: Boolean;
var
  ASelection: TdxObjectList;
begin
  ASelection := TdxObjectList.Create;
  try
    GetSelection(ASelection);
    RemoveIrrelevantObjectsForDelete(ASelection);
    Result := ASelection.Count > 0;
  finally
    ASelection.Free;
  end;
end;

procedure TdxBarDesignController.GetSelection(ASelection: TdxObjectList);
begin
  CustomizingBarManager.GetSelection(ASelection);
  CleanSelectableItems(ASelection);
end;

function TdxBarDesignController.IsObjectUnbound(AObject: TObject; AMasterObjects: TdxObjectList): Boolean;
var
  I: Integer;
  AInternalMasterObjects: TdxObjectList;
  ASelectableItem: IdxBarSelectableItem;
begin
  Result := True;
  if IsSelectableItem(AObject, ASelectableItem) then
  begin
    AInternalMasterObjects := TdxObjectList.Create;
    try
      ASelectableItem.GetMasterObjects(AInternalMasterObjects);
      for I := 0 to AInternalMasterObjects.Count - 1 do
        Result := (AMasterObjects.IndexOf(AInternalMasterObjects[I]) = -1) and IsObjectUnbound(AInternalMasterObjects[I], AMasterObjects);
    finally
      AInternalMasterObjects.Free;
    end;
  end;
end;

procedure TdxBarDesignController.RemoveIrrelevantObjectsForDelete(ASelection: TdxObjectList; ADestruction: Boolean = False);
var
  I: Integer;
begin
  for I := ASelection.Count - 1 downto 0 do
    if not GetSelectableItem(ASelection[I]).CanDelete(ADestruction) or
         ADestruction and not IsObjectUnbound(ASelection[I], ASelection) then
      ASelection.Delete(I);
end;

procedure TdxBarDesignController.ClearOwnedItems(AItemLinks: TdxBarItemLinks);
begin
  while AItemLinks.Count > 0 do
    AItemLinks.Items[0].Item.Free;
end;

procedure TdxBarDesignController.CustomizeItemClick(Sender: TObject);
begin
  TdxBarItem(Sender).BarManager.Customizing(True);
end;

procedure TdxBarDesignController.TextItemChange(Sender: TObject);
begin
  if TdxBarEdit(Sender).Text = '' then
  begin
    if FCustomizationPopup <> nil then
      FCustomizationPopup.Hide;
    dxBarMessageBox(cxGetResourceString(@dxSBAR_COMMANDNAMECANNOTBEBLANK), MB_ICONSTOP);
  end
  else
    if FCustomizingBarManager.Designing then
    begin
      CustomizingItemLink.Item.Caption := TdxBarEdit(Sender).Text;
      SynchronizeAction(caChangeCaption);
      DesignerModified;
    end
    else
      CustomizingItemLink.UserCaption := TdxBarEdit(Sender).Text;
end;

procedure TdxBarDesignController.CustomizationPopupCloseUp(Sender: TObject);
begin
{ #DG problems when customize empty subcontrol
  if (FCustomizingItemLink <> nil) and
    not FCustomizingBarManager.FIsCustomizing and
    (FCustomizingBarControl <> nil) and
    (FCustomizingBarControl.SelectedItem = FCustomizingItemLink.Control) then
  begin
    FCustomizingBarManager.FSelectedItem := nil;
    FCustomizingBarControl.SelectedItem := nil;
  end;
}
  FCustomizingBarControl := nil;
end;

procedure TdxBarDesignController.CustomizationPopupDestroy(Sender: TObject);
begin
  FCustomizationPopup := nil;
end;

procedure TdxBarDesignController.CustomizationPopupItemClick(Sender: TObject);

  procedure ChangeButtonGroup(AButtonGroupAction: TdxChangeButtonGroupAction);

    const
      AGroupPosition: array[TdxChangeButtonGroupAction] of TdxBarButtonGroupPosition = (bgpNone, bgpStart, bgpMember, bgpMember, bgpNone);

    procedure MakeButtonGroup;
    var
      I: Integer;
      ALink: TdxBarItemLink;
    begin
      FCustomizingItemLinks.BeginUpdate;
      try
        ALink := CustomizingItemLink;
        for I := FCustomizingItemLinks.Count - 1 downto 0 do
          if FCustomizingItemLinks[I].IsComponentSelected then
          begin
            ALink := FCustomizingItemLinks[I];
            ALink.ButtonGroup := AGroupPosition[AButtonGroupAction];
          end;
        if AButtonGroupAction = bgaGroup then
          ALink.ButtonGroup := bgpStart;
      finally
        FCustomizingItemLinks.EndUpdate;
      end;
    end;

  begin
    if AButtonGroupAction in [bgaNone..bgaMember] then
    begin
      CustomizingItemLink.ButtonGroup := AGroupPosition[AButtonGroupAction];
      SynchronizeAction(caChangeButtonGroup);
    end
    else
      MakeButtonGroup;
  end;

  procedure ChangeViewLevel(AViewLevelAction: TdxChangeViewLevelAction);
  var
    AViewLevel: TdxBarItemRealViewLevel;
  begin
    case AViewLevelAction of
      vlaChangeLargeIconWithText..vlaChangeControl:
        begin
          AViewLevel := TdxBarItemViewLevel(AViewLevelAction);
          if AViewLevel in CustomizingItemLink.ViewLevels then
            CustomizingItemLink.ViewLevels := CustomizingItemLink.ViewLevels - [AViewLevel]
          else
            CustomizingItemLink.ViewLevels := CustomizingItemLink.ViewLevels + [AViewLevel];
        end;
      vlaSetAll:
        CustomizingItemLink.ViewLevels := [ivlLargeIconWithText..ivlControlOnly];
      vlaSetLargeIconWithTextOnly:
        CustomizingItemLink.ViewLevels := [ivlLargeIconWithText];
      vlaSetSmallIconWithTextOnly:
        CustomizingItemLink.ViewLevels := [ivlSmallIconWithText];
      vlaSetSmallIconOnly:
        CustomizingItemLink.ViewLevels := [ivlSmallIcon];
      vlaControlOnly:
        CustomizingItemLink.ViewLevels := [ivlControlOnly];
    end;
  end;

var
  ADetailAction: WORD;
  ABasicAction: TdxBarCustomizationAction;
  ABarButton: TdxBarButton;
begin
  ABarButton := TdxBarButton(Sender);
  ABasicAction := TdxBarCustomizationAction(HiWord(ABarButton.Tag));
  ADetailAction := LoWord(ABarButton.Tag);
  case ABasicAction of
    caDelete:
      DeleteSelectedObjects(False, False);
    caDeleteItem:
      DeleteSelectedObjects(True, False);
    caDeleteLink:
      DeleteCustomizingItemLink;

    // multiple operations
    caReset:
      CustomizingItemLink.UserDefine := [];
    caChangeButtonPaintStyle:
      CustomizingItemLink.UserPaintStyle := TdxBarPaintStyle(ADetailAction);
    caChangePosition:
      CustomizingItemLink.Position := TdxBarItemPosition(ADetailAction);
    caChangeViewLevels:
      begin
        ChangeViewLevel(TdxChangeViewLevelAction(ADetailAction));
        UpdateViewLevelsSubItemButtonStates(ABarButton.Links[0].Owner);
      end;
    caChangeButtonGroup:
      ChangeButtonGroup(TdxChangeButtonGroupAction(ADetailAction));
    caChangeBeginGroup:
      CustomizingItemLink.BeginGroup := not CustomizingItemLink.BeginGroup;
    caChangeVisible:
      CustomizingItemLink.Visible := not CustomizingItemLink.Visible;
    caChangeRecentList:
      CustomizingItemLink.MostRecentlyUsed := not CustomizingItemLink.MostRecentlyUsed;
    caChangeDistributed:
      CustomizingItemLink.Distributed := not CustomizingItemLink.Distributed;
  end;
  if not (ABasicAction in [caDelete, caDeleteItem, caDeleteLink, caChangeButtonGroup]) then
    SynchronizeAction(ABasicAction);
end;

procedure TdxBarDesignController.InitCustomizationPopup(AItemLinks: TdxBarItemLinks);

  function AddCustomizationButton(AItemLinks: TdxBarItemLinks;
    const ACaption: string; ABasicAction: TdxBarCustomizationAction;
    ABeginGroup: Boolean = False;
    AButtonStyle: TdxBarButtonStyle = bsDefault;
    AIsDown: Boolean = False;
    AEnabled: Boolean = True;
    AGroupIndex: Integer = 0; ADetailAction: Word = 0): TdxBarButton;
  var
    AItemLink: TdxBarItemLink;
    AItem: TdxBarButton;
  begin
    AItemLink := AddInternalItem(AItemLinks, TdxBarButton, ACaption, CustomizationPopupItemClick);
    AItemLink.BeginGroup := ABeginGroup;
    AItem := TdxBarButton(AItemLink.Item);
    AItem.Tag := MakeLong(ADetailAction, Word(ABasicAction));
    AItem.ButtonStyle := AButtonStyle;
    AItem.Down := AIsDown;
    AItem.Enabled := AEnabled;
    AItem.GroupIndex := AGroupIndex;
    Result := AItem;
  end;

  procedure AddCustomizationEdit(AItemLinks: TdxBarItemLinks; const ACaption: string);
  var
    AItemLink: TdxBarItemLink;
  begin
    AItemLink := AddInternalItem(AItemLinks, TdxBarEdit, ACaption);
    AItemLink.BeginGroup := True;
    TdxBarEdit(AItemLink.Item).Text := CustomizingItemLink.Caption;
    TdxBarEdit(AItemLink.Item).FOnChange := TextItemChange;
  end;

  function AddCustomizationSubItem(AItemLinks: TdxBarItemLinks;
    const ACaption: string; AActionType: TdxBarCustomizationAction;
    ABeginGroup: Boolean = False; AEnabled: Boolean = True): TdxBarSubItem;
  var
    AItemLink: TdxBarItemLink;
  begin
    AItemLink := AddInternalItem(AItemLinks, TdxBarSubItem, ACaption);
    Result := TdxBarSubItem(AItemLink.Item);
    AItemLink.BeginGroup := ABeginGroup;
    Result.Enabled := AEnabled;
    Result.IsInternal := True;
  end;

  function GetBarControlDesignHelperClass: TCustomdxBarControlDesignHelperClass;
  begin
    Result := TCustomdxBarControlDesignHelperClass(
      FRegisteredBarControlDesignHelpers.FindClass(CustomizingBarControl.ClassType));
  end;

  function GetSupportedActions: TdxBarCustomizationActions;
  var
    ASelection: TdxObjectList;
    I: Integer;
    ASelectableItem: IdxBarSelectableItem;
  begin
    Result := FLastSelectedItem.GetSupportedActions;
    if CustomizingBarManager.Designing then
    begin
      ASelection := TdxObjectList.Create;
      try
        GetSelection(ASelection);
        for I := 0 to ASelection.Count - 1 do
        begin
          ASelectableItem := GetSelectableItem(ASelection[I]);
          Result := Result * ASelectableItem.GetSupportedActions;
        end;
      finally
        ASelection.Free;
      end;
    end;
  end;

  procedure AddViewLevelMenu;

    function GetButtonStyle(AViewLevelAction: TdxChangeViewLevelAction): TdxBarButtonStyle;
    begin
      if AViewLevelAction in [vlaChangeLargeIconWithText..vlaChangeControl] then
        Result := bsChecked
      else
        Result := bsDefault;
    end;

    function GetButtonCaption(AViewLevelAction: TdxChangeViewLevelAction; AViewLevelNames: TStringArray): string;
    begin
      case AViewLevelAction of
        vlaChangeLargeIconWithText..vlaChangeControl: Result := AViewLevelNames[Ord(AViewLevelAction)];
        vlaSetAll: Result := cxGetResourceString(@dxSBAR_CP_ALLVIEWLEVELS);
      else
        Result := AViewLevelNames[Ord(AViewLevelAction) - Ord(vlaSetLargeIconWithTextOnly)] + cxGetResourceString(@dxSBAR_CP_SINGLEVIEWLEVELITEMSUFFIX);
      end;
    end;

  var
    AViewLevelAction: TdxChangeViewLevelAction;
    AViewLevelNames: TStringArray;
    AOwnerLinks: TdxBarItemLinks;
  begin
    AViewLevelNames := SetToStringArray(TypeInfo(TdxBarItemViewLevels));
    AOwnerLinks := AddCustomizationSubItem(AItemLinks, cxGetResourceString(@dxSBAR_CP_VIEWLEVELSMENU), caChangeViewLevels).ItemLinks;
    for AViewLevelAction := Low(TdxChangeViewLevelAction) to High(TdxChangeViewLevelAction) do
      AddCustomizationButton(AOwnerLinks, GetButtonCaption(AViewLevelAction, AViewLevelNames),
        caChangeViewLevels, AViewLevelAction in [vlaSetAll, vlaSetLargeIconWithTextOnly], GetButtonStyle(AViewLevelAction),
        False, True, 0, Word(AViewLevelAction)).CloseSubMenuOnClick := False;

    UpdateViewLevelsSubItemButtonStates(AOwnerLinks);
  end;

  procedure AddButtonPaintStyleMenu;
  const
    APaintStyleCaptions: array [TdxBarPaintStyle] of TcxResourceStringID =
      (@dxSBAR_CP_DEFAULTSTYLE, @dxSBAR_CP_TEXTONLYALWAYS, @dxSBAR_CP_TEXTONLYINMENUS, @dxSBAR_CP_IMAGEANDTEXT);
  var
    APaintStyle: TdxBarPaintStyle;
    AOwnerLinks: TdxBarItemLinks;
  begin
    { unusually
    if CustomizingBarManager.Designing then
      AOwnerLinks := AddCustomizationSubItem(AItemLinks, cxGetResourceString(@dxSBAR_CP_BUTTONPAINTSTYLEMENU),
        caChangeButtonPaintStyle, True).ItemLinks
    else
    }
      AOwnerLinks := AItemLinks;
    for APaintStyle := Low(TdxBarPaintStyle) to High(TdxBarPaintStyle) do
      AddCustomizationButton(AOwnerLinks, cxGetResourceString(APaintStyleCaptions[APaintStyle]),
        caChangeButtonPaintStyle, APaintStyle = Low(TdxBarPaintStyle), bsChecked,
        CustomizingItemLink.PaintStyle = APaintStyle,
        CustomizingItemLink.CanChangePaintStyle, dxBarCustomizingPopupPaintStyleGroupIndex, Word(APaintStyle));
  end;

  procedure AddPositionMenu;
  var
    APosition: TdxBarItemPosition;
    APositionNames: TStringArray;
    AOwnerLinks: TdxBarItemLinks;
  begin
    APositionNames := EnumToStringArray(TypeInfo(TdxBarItemPosition));
    AOwnerLinks := AddCustomizationSubItem(AItemLinks, cxGetResourceString(@dxSBAR_CP_POSITIONMENU), caChangePosition, True).ItemLinks;
    for APosition := Low(TdxBarItemPosition) to High(TdxBarItemPosition) do
      AddCustomizationButton(AOwnerLinks, APositionNames[Ord(APosition)],
        caChangePosition, False, bsChecked,
        CustomizingItemLink.Position = APosition, True, 0, Word(APosition));
  end;

  procedure AddButtonGroupMenu;

    function IsDowned(AButtonGroupAction: TdxChangeButtonGroupAction): Boolean;
    begin
      Result := (AButtonGroupAction in [bgaNone..bgaMember]) and (CustomizingItemLink.ButtonGroup = TdxBarButtonGroupPosition(AButtonGroupAction));
    end;

    function GetByttonStyle(AButtonGroupAction: TdxChangeButtonGroupAction): TdxBarButtonStyle;
    begin
      if AButtonGroupAction in [bgaNone..bgaMember] then
        Result := bsChecked
      else
        Result := bsDefault;
    end;

    function GetButtonCaption(AButtonGroupAction: TdxChangeButtonGroupAction; AButtonGroupNames: TStringArray): string;
    begin
      case AButtonGroupAction of
        bgaGroup: Result := cxGetResourceString(@dxSBAR_CP_BUTTONGROUP);
        bgaUngroup: Result := cxGetResourceString(@dxSBAR_CP_BUTTONUNGROUP);
      else
        Result := AButtonGroupNames[Ord(AButtonGroupAction)];
      end;
    end;

  var
    AButtonGroupAction: TdxChangeButtonGroupAction;
    AButtonGroupNames: TStringArray;
    AOwnerLinks: TdxBarItemLinks;
  begin
    AButtonGroupNames := EnumToStringArray(TypeInfo(TdxBarButtonGroupPosition));
    AOwnerLinks := AddCustomizationSubItem(AItemLinks, cxGetResourceString(@dxSBAR_CP_BUTTONGROUPMENU), caChangeButtonGroup).ItemLinks;
    for AButtonGroupAction := Low(TdxChangeButtonGroupAction) to High(TdxChangeButtonGroupAction) do
      AddCustomizationButton(AOwnerLinks, GetButtonCaption(AButtonGroupAction, AButtonGroupNames),
        caChangeButtonGroup, AButtonGroupAction = bgaGroup, GetByttonStyle(AButtonGroupAction),
        IsDowned(AButtonGroupAction), True, 0, Word(AButtonGroupAction));
  end;

const
  AChangeCaptionName: array [Boolean] of TcxResourceStringID = (@dxSBAR_CP_NAME, @dxSBAR_CP_CAPTION);
  ADeleteLinkName: array [Boolean] of TcxResourceStringID = (@dxSBAR_CP_DELETE, @dxSBAR_CP_DELETELINK);
var
  ABarControlEditors: TList;
  I: Integer;
  AAction: TdxBarCustomizationAction;
  ASupportedActions: TdxBarCustomizationActions;
begin
  AItemLinks.BeginUpdate;
  try
    FCustomizingBarManager.ItemList.BeginUpdate;
    try
      if FCustomizingBarManager.Designing and IsSelectionSingle(FCustomizingBarManager) then
      begin
        ABarControlEditors := TList.Create;
        try
          GetBarControlDesignHelperClass.GetEditors(ABarControlEditors);
          for I := 0 to ABarControlEditors.Count - 1 do
            TdxBarControlEditorClass(ABarControlEditors[I]).InitCustomizationPopup(AItemLinks);
        finally
          FreeAndNil(ABarControlEditors);
        end;
      end;

    ASupportedActions := GetSupportedActions;
    GetBarControlDesignHelperClass.FilterItemActions(ASupportedActions);
    for AAction := Low(TdxBarCustomizationAction) to High(TdxBarCustomizationAction) do
      if AAction in ASupportedActions then
        case AAction of
          caReset:
            AddCustomizationButton(AItemLinks, cxGetResourceString(@dxSBAR_CP_RESET), AAction, True);
          caDelete:
            AddCustomizationButton(AItemLinks, cxGetResourceString(@dxSBAR_CP_DELETE), AAction, True,
              bsDefault, False, CanDeleteSelectedObjects).ShortCut := VK_DELETE;
          caDeleteItem:
            AddCustomizationButton(AItemLinks, cxGetResourceString(@dxSBAR_CP_DELETEITEM), AAction, False,
              bsDefault, False, CustomizingItemLink.Item.CanDelete(True)).ShortCut := ShortCut(VK_DELETE, [ssCtrl]);
          caDeleteLink:
            AddCustomizationButton(AItemLinks, cxGetResourceString(ADeleteLinkName[FCustomizingBarManager.Designing]), AAction, False, bsDefault, False);
          caChangeCaption:
            AddCustomizationEdit(AItemLinks, cxGetResourceString(AChangeCaptionName[FCustomizingBarManager.Designing]));
          caChangeButtonPaintStyle:
            AddButtonPaintStyleMenu;
          caChangePosition:
            AddPositionMenu;
          caChangeViewLevels:
            AddViewLevelMenu;
          caChangeButtonGroup:
            AddButtonGroupMenu;
          caChangeDistributed:
            AddCustomizationButton(AItemLinks, cxGetResourceString(@dxSBAR_CP_DISTRIBUTED), AAction, False,
              bsChecked, CustomizingItemLink.Distributed);
          caChangeBeginGroup:
            AddCustomizationButton(AItemLinks, cxGetResourceString(@dxSBAR_CP_BEGINAGROUP), AAction, True,
              bsChecked, CustomizingItemLink.BeginGroup, CustomizingItemLink.Index > 0);
          caChangeVisible:
            AddCustomizationButton(AItemLinks, cxGetResourceString(@dxSBAR_CP_VISIBLE), AAction, not (caChangeBeginGroup in ASupportedActions),
              bsChecked, CustomizingItemLink.Visible);
          caChangeRecentList:
            AddCustomizationButton(AItemLinks, cxGetResourceString(@dxSBAR_CP_MOSTRECENTLYUSED), AAction, False,
              bsChecked, CustomizingItemLink.MostRecentlyUsed);
        end;
    finally
      FCustomizingBarManager.ItemList.CancelUpdate;
    end;
  finally
    AItemLinks.EndUpdate;
  end;
end;

procedure TdxBarDesignController.SynchronizeAction(ABasicAction: TdxBarCustomizationAction);
var
  I: Integer;
  ASelection: TdxObjectList;
begin
  ASelection := TdxObjectList.Create;
  try
    GetSelection(ASelection);
    for I := 0 to ASelection.Count - 1 do
      GetSelectableItem(ASelection[I]).ExecuteCustomizationAction(ABasicAction);
  finally
    ASelection.Free;
  end;
end;

procedure TdxBarDesignController.UpdateViewLevelsSubItemButtonStates(AItemLinks: TdxBarItemLinks);
var
  I: Integer;
  AButton: TdxBarButton;
begin
  for I := 0 to AItemLinks.Count - 1 do
  begin
    AButton := TdxBarButton(AItemLinks[I].Item);
    if TdxChangeViewLevelAction(LoWord(AButton.Tag)) in [vlaChangeLargeIconWithText..vlaChangeControl] then
      AButton.Down := TdxBarItemViewLevel(LoWord(AButton.Tag)) in CustomizingItemLink.ViewLevels;
  end;
end;

procedure TdxBarDesignController.ToolbarsPopupClick(Sender: TObject);
var
  ABar: TdxBar;
begin
  ABar := TdxBar(TComponent(Sender).Tag);
  ABar.Visible := not ABar.Visible;
end;

procedure TdxBarDesignController.QuickControlDestroy(Sender: TObject);
begin
  FQuickControl := nil;
end;

procedure TdxBarDesignController.FindCustomizingBarManager;
var
  I: Integer;
  ASelection: TdxObjectList;
begin
  if LastSelectedItem <> nil then
    FCustomizingBarManager := LastSelectedItem.GetBarManager
  else
  begin
    ASelection := TdxObjectList.Create;
    try
      FCustomizingBarManager := nil;
      for I := 0 to dxBarManagerList.Count - 1 do
      begin
        dxBarManagerList[I].GetActiveSelection(ASelection);
        CleanSelectableItems(ASelection);
        if ASelection.Count > 0 then
        begin
          FCustomizingBarManager := dxBarManagerList[I];
          Break;
        end;
      end;
    finally
      ASelection.Free;
    end;
  end;
end;

function TdxBarDesignController.CanCustomize(ABarManager: TdxBarManager; AIsKeyboardAction: Boolean): Boolean;
begin
  Result := (ABarManager <> nil) and
    (not AIsKeyboardAction or
      (ABarManager.Owner.HandleAllocated) and (IsParentFocused(ABarManager.Owner.Handle)));
end;

procedure TdxBarDesignController.SetLastSelectedItem(Value: IdxBarSelectableItem);

  procedure UpdateItem(ASelectedItem: IdxBarSelectableItem; AOperation: TOperation);
  var
    AInstance: TPersistent;
  begin
    if ASelectedItem <> nil then
    begin
      ASelectedItem.Invalidate; //#DG for RunTime only
      AInstance := ASelectedItem.GetInstance;
      if AInstance is TComponent then
        case AOperation of
          opInsert: FNotifyComponent.FreeNotification(TComponent(AInstance));
          opRemove: FNotifyComponent.RemoveFreeNotification(TComponent(AInstance));
        end;
    end;
  end;

var
  APrevSelectedItem: IdxBarSelectableItem;
begin
  if FLastSelectedItem <> Value then
  begin
    APrevSelectedItem := FLastSelectedItem;
    FLastSelectedItem := Value;
    UpdateItem(APrevSelectedItem, opRemove);
    UpdateItem(FLastSelectedItem, opInsert);
  end;
end;

procedure TdxBarDesignController.FreeNotification(AComponent: TComponent);
begin
  DropSelection(GetSelectableItem(AComponent));
end;

{ TdxBarCanvas }

constructor TdxBarCanvas.Create;
begin
  inherited Create(TCanvas.Create);
end;

destructor TdxBarCanvas.Destroy;
begin
  Canvas.Free;
  inherited;
end;

procedure TdxBarCanvas.BeginPaint(ADC: THandle);
begin
  SetLength(FSavedDCs, FCounter + 1);

  if HandleValid then
  begin
    SaveState;
    FSavedDCs[FCounter].PrevDC := Handle;
  end
  else
    FSavedDCs[FCounter].PrevDC := 0;

  FSavedDCs[FCounter].PrevCanvas := nil;
  FSavedDCs[FCounter].NewDC := ADC;
  FSavedDCs[FCounter].NewDCIndex := Windows.SaveDC(ADC);
  SynchronizeObjects(ADC);
  Canvas.Handle := ADC;
  Inc(FCounter);
end;

procedure TdxBarCanvas.BeginPaint(ACanvas: TCanvas);
begin
  SetLength(FSavedDCs, FCounter + 1);
  FSavedDCs[FCounter].PrevCanvas := Canvas;
  Canvas := ACanvas;
  SaveClipRegion;
  SaveState;
  Inc(FCounter);
end;

procedure TdxBarCanvas.EndPaint;
begin
  if FCounter > 0 then
  begin
    Dec(FCounter);
    if FSavedDCs[FCounter].PrevCanvas <> nil then
    begin
      RestoreState;
      RestoreClipRegion;
      Canvas := FSavedDCs[FCounter].PrevCanvas;
    end
    else
    begin
      Canvas.Handle := FSavedDCs[FCounter].PrevDC;
      Windows.RestoreDC(FSavedDCs[FCounter].NewDC, FSavedDCs[FCounter].NewDCIndex);
      if HandleValid then
        RestoreState;
    end;
    SetLength(FSavedDCs, FCounter);
  end;
end;

function TdxBarCanvas.HandleValid;
begin
  Result := {$IFDEF DELPHI6}Canvas.HandleAllocated{$ELSE}FCounter > 0{$ENDIF};
end;

{ TdxBarComponent }

constructor TdxBarComponent.Create(AOwner: TComponent);
begin
  inherited;
  FChangeNotifies := TObjectList.Create(False);
end;

destructor TdxBarComponent.Destroy;
begin
  FreeAndNil(FChangeNotifies);
  inherited;
end;

procedure TdxBarComponent.AddChangeNotify(AComponentList: TdxBarComponentList);
begin
  FChangeNotifies.Add(AComponentList);
end;

procedure TdxBarComponent.RemoveChangeNotify(AComponentList: TdxBarComponentList);
begin
  FChangeNotifies.Remove(AComponentList);
end;

procedure TdxBarComponent.Changed(AllItems: Boolean = False);
var
  I: Integer;
begin
  if not (csDestroying in ComponentState) then
    for I := 0 to FChangeNotifies.Count - 1 do
      if AllItems then
        TdxBarComponentList(FChangeNotifies[I]).Update(nil)
      else
        TdxBarComponentList(FChangeNotifies[I]).Update(Self);
end;

procedure TdxBarComponent.GetMasterObjects(AList: TdxObjectList);
begin
  AList.Add(Owner);
end;

function TdxBarComponent.GetNextSelectableItem: IdxBarSelectableItem;
begin
  Result := nil;
end;

function TdxBarComponent.GetSelectableParent: TPersistent;
begin
  Result := Owner;
end;

function TdxBarComponent.CanDelete(ADestruction: Boolean = False): Boolean;
begin
  Result := BarManager.CanDeleteComponent(Self);
end;

procedure TdxBarComponent.DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean);
begin
  if CanDelete(ADestruction) then
  begin
    AReference := nil;
    Free;
  end;
end;

procedure TdxBarComponent.ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction);
begin
// do nothing
end;

function TdxBarComponent.GetBarManager: TdxBarManager;
begin
  Result := FBarManager;
end;

function TdxBarComponent.GetSelectionStatus: TdxBarSelectionStatus;
begin
  Result := BarManager.GetSelectionStatus(Self);
end;

function TdxBarComponent.GetSupportedActions: TdxBarCustomizationActions;
begin
  Result := [caDelete];
end;

procedure TdxBarComponent.Invalidate;
begin
// do nothing
end;

function TdxBarComponent.IsComplex: Boolean;
begin
  Result := False;
end;

function TdxBarComponent.IsComponentSelected: Boolean;
begin
  Result := BarManager.IsComponentSelected(Self);
end;

procedure TdxBarComponent.SelectComponent(ASelectionOperation: TdxBarSelectionOperation = soExclusive);
begin
  BarManager.SelectComponent(Self, ASelectionOperation);
end;

function TdxBarComponent.SelectParentComponent: Boolean;
begin
  Result := False;
end;

procedure TdxBarComponent.SelectionChanged;
begin
// do nothing
end;

function TdxBarComponent.GetPersistentInstance: TPersistent;
begin
  Result := Self;
end;

function TdxBarComponent.GetComponentInstance: TComponent;
begin
  Result := Self;
end;

{ TdxObjectList }

constructor TdxObjectList.Create;
begin
  inherited Create(False);
end;

procedure TdxObjectList.Add(AObject: TObject);
begin
  if (AObject <> nil) and (IndexOf(AObject) = -1) then
    inherited Add(AObject);
end;

procedure TdxObjectList.AddList(AObjects: TList);
begin
  AddFromList(AObjects, Self);
end;

procedure TdxObjectList.CopyFrom(ASource: TList);
begin
  CopyList(ASource, Self);
end;

procedure TdxObjectList.CopyTo(ADestination: TList);
begin
  CopyList(Self, ADestination);
end;

procedure TdxObjectList.XorList(ASourceA, ASourceB: TList);
begin
  Clear;
  AddFromList(ASourceA, ASourceB);
  AddFromList(ASourceB, ASourceA);
end;

function TdxObjectList.First: TObject;
begin
  Result := GetItem(0);
end;

function TdxObjectList.Last: TObject;
begin
  Result := GetItem(Count - 1);
end;

procedure TdxObjectList.CopyList(ASource, ADestination: TList);
var
  I: Integer;
begin
  ADestination.Clear;
  ADestination.Capacity := ASource.Capacity;
  for I := 0 to ASource.Count - 1 do
    if ADestination is TdxObjectList then
      TdxObjectList(ADestination).Add(ASource[I])
    else
      ADestination.Add(ASource[I]);
end;

function TdxObjectList.GetItem(AIndex: Integer): TObject;
begin
  if (AIndex >= 0) and (AIndex < Count) then
    Result := inherited GetItem(AIndex)
  else
    Result := nil;
end;

procedure TdxObjectList.AddFromList(ASource, AExcludedList: TList);
var
  I: Integer;
begin
  for I := 0 to ASource.Count - 1 do
    if AExcludedList.IndexOf(ASource[I]) = -1 then
      Add(ASource[I]);
end;

{ TdxBarComponentList }

procedure TdxBarComponentList.DoNotify(AItem: TComponent; AAction: TListNotification);
begin
  case AAction of
    lnExtracted, lnDeleted:
      if not (csDestroying in TdxBarComponent(AItem).ComponentState) then
        TdxBarComponent(AItem).RemoveChangeNotify(Self);
    lnAdded:
      TdxBarComponent(AItem).AddChangeNotify(Self);
  end;
  inherited;
end;

function TdxBarComponentList.GetItemClass: TClass;
begin
  Result := TdxBarComponent;
end;

{ TdxBarGroup }

constructor TdxBarGroup.Create(AOwner: TComponent);
begin
  inherited;
  FEnabled := True;
  FItems := TdxBarComponentList.Create;
  FVisible := ivAlways;
end;

destructor TdxBarGroup.Destroy;
begin
  FreeAndNil(FItems);
  inherited;
end;

function TdxBarGroup.GetCount: Integer;
begin
//  Result := FItems.Count;
  Result := InternalGetCount;
end;

function TdxBarGroup.GetIndex: Integer;
begin
  Result := FBarManager.FGroups.IndexOf(Self);
end;

function TdxBarGroup.GetItem(Index: Integer): TComponent;
begin
  Result := TComponent(FItems[Index]);
end;

function TdxBarGroup.InternalGetCount: Integer;
begin
  if IsAncestorComponentDifferencesDetection(Self) then
    Result := FItemsNames.Count
  else
    Result := FItems.Count;
end;

function TdxBarGroup.InternalGetItemName(Index: Integer): string;
begin
  if IsAncestorComponentDifferencesDetection(Self) then
    Result := FItemsNames[Index]
  else
    Result := Items[Index].Name;
end;

procedure TdxBarGroup.SetIndex(Value: Integer);
begin
  if Index <> Value then
    FBarManager.GroupList.Move(Index, Value);
end;

procedure TdxBarGroup.ReadItems(Reader: TReader);
var
  AItem: TComponent;
begin
  if csLoading in ComponentState then
  begin
    if FItemsNames = nil then
      FItemsNames := TStringList.Create
    else
      FItemsNames.Clear;
    Reader.ReadListBegin;
    try
      while not Reader.EndOfList do
        FItemsNames.Add(Reader.ReadString);
    finally
      Reader.ReadListEnd;
    end;
  end
  else
  begin
    ItemList.Clear;
    Reader.ReadListBegin;
    try
      while not Reader.EndOfList do
      begin
        AItem := BarManager.Owner.FindComponent(Reader.ReadString);
        if AItem <> nil then
          Add(TdxBarComponent(AItem));
      end;
    finally
      Reader.ReadListEnd;
    end;
  end;
end;

procedure TdxBarGroup.WriteItems(Writer: TWriter);
var
  I: Integer;
begin
  Writer.WriteListBegin;
  try
    for I := 0 to InternalGetCount - 1 do
      Writer.WriteString(InternalGetItemName(I));
  finally
    Writer.WriteListEnd;
  end;
end;

procedure TdxBarGroup.DefineProperties(Filer: TFiler);

  function NeedWriteItems: Boolean;

    function IsGroupsEqual(AGroup1, AGroup2: TdxBarGroup): Boolean;
    var
      I: Integer;
    begin
      Result := AGroup1.InternalGetCount = AGroup2.InternalGetCount;
      if Result then
        for I := 0 to AGroup1.InternalGetCount - 1 do
          Result := Result and (AGroup1.InternalGetItemName(I) = AGroup2.InternalGetItemName(I))
    end;

  begin
    Result := (Filer.Ancestor = nil) or not IsGroupsEqual(Self, TdxBarGroup(Filer.Ancestor));
  end;

begin
  inherited;
  Filer.DefineProperty('Items', ReadItems, WriteItems, NeedWriteItems);
end;

function TdxBarGroup.GetEnabled: Boolean;
begin
  Result := FEnabled;
end;

procedure TdxBarGroup.Loaded;
var
  I: Integer;
  AItem: TComponent;
begin
  inherited;
  if FItemsNames = nil then Exit;
  try
    for I := 0 to FItemsNames.Count - 1 do
    begin
      AItem := FBarManager.Owner.FindComponent(FItemsNames[I]);//#DG
      if AItem <> nil then Add(TdxBarComponent(AItem));
    end;
  finally
    FreeAndNil(FItemsNames);
  end;
end;

procedure TdxBarGroup.SetName(const NewName: TComponentName);
begin
  inherited;
  Changed;
end;

procedure TdxBarGroup.SetEnabled(Value: Boolean);
var
  ALock: Boolean;
  I: Integer;
begin
  //if FEnabled <> Value then
  begin
    FEnabled := Value;
    ALock := (BarDesignController.QuickControl = nil) and ([csLoading, csDestroying] * ComponentState = []);
    if ALock then
      FBarManager.BeginUpdate;
    try
      for I := 0 to Count - 1 do
        TdxBarComponent(Items[I]).Enabled := Value;
    finally
      if ALock then
        FBarManager.EndUpdate;
    end;
  end;
end;

procedure TdxBarGroup.SetVisible(Value: TdxBarItemVisible);
var
  I: Integer;
begin
  //if FVisible <> Value then
  begin
    FVisible := Value;
    if [csLoading, csDestroying] * ComponentState = [] then
      FBarManager.BeginUpdate;
    try
      for I := 0 to Count - 1 do
        TdxBarComponent(Items[I]).Visible := Value;
    finally
      if [csLoading, csDestroying] * ComponentState = [] then
        FBarManager.EndUpdate;
    end;
  end;
end;

function TdxBarGroup.GetParentComponent: TComponent;
begin
  Result := FBarManager;
end;

function TdxBarGroup.HasParent: Boolean;
begin
  Result := FBarManager <> nil;
end;

procedure TdxBarGroup.SetParentComponent(AParent: TComponent);
begin
  inherited;
  if AParent is TdxBarManager then
    TdxBarManager(AParent).AddGroup(Self);
end;

procedure TdxBarGroup.Add(AItem: TdxBarComponent);

  function IsRecursive(AItem: TComponent): Boolean;
  var
    I: Integer;
  begin
    Result := False;
    if AItem is TdxBarGroup then
    begin
      Result := AItem = Self;
      if not Result then
        with TdxBarGroup(AItem) do
          for I := 0 to Count - 1 do
          begin
            Result := IsRecursive(Items[I]);
            if Result then Break;
          end;
    end;      
  end;

begin
  if not (AItem is TdxBarComponent) or (IndexOf(AItem) <> -1) then Exit;
  if IsRecursive(AItem) then
    raise EdxException.Create(cxGetResourceString(@dxSBAR_RECURSIVEGROUPS));
  FItems.Add(AItem);
end;

procedure TdxBarGroup.Delete(Index: Integer);
begin
  FItems.Delete(Index);
end;

function TdxBarGroup.IndexOf(AItem: TdxBarComponent): Integer;
begin
  Result := FItems.IndexOf(AItem);
end;

procedure TdxBarGroup.Move(FromIndex, ToIndex: Integer);
begin
  FItems.Move(FromIndex, ToIndex);
end;

procedure TdxBarGroup.Remove(AItem: TdxBarComponent);
begin
  FItems.Remove(AItem);
end;

{ TdxBarPopupMenuLink }

function TdxBarPopupMenuLink.GetBarManager: TdxBarManager;
begin
  Result := TdxBarPopupMenuLinks(Collection).BarManager;
end;

function TdxBarPopupMenuLink.GetWinControl: TWinControl;
begin
  if Control is TWinControl then
    Result := TWinControl(Control)
  else
    Result := nil;
end;

procedure TdxBarPopupMenuLink.SetControl(Value: TControl);
begin
  if (Value <> nil) and not IsControlUnderBarManager(BarManager, Value) then
    Value := nil;
  if FControl <> Value then
  begin
    if FControl <> nil then
      FControl.WindowProc := FPrevWndProc;
    FControl := Value;
    if FControl <> nil then
    begin
      FControl.FreeNotification(BarManager);
      FPrevWndProc := FControl.WindowProc;
      FControl.WindowProc := NewWndProc;
    end;
  end;
end;

procedure TdxBarPopupMenuLink.SetPopupMenu(Value: TdxBarPopupMenu);
begin
  if FPopupMenu <> Value then
  begin
    FPopupMenu := Value;
    if Value <> nil then Value.FreeNotification(BarManager);
  end;
end;

procedure TdxBarPopupMenuLink.ContextPopup(Sender: TObject; MousePos: TPoint; var Handled: Boolean);
var
  AControlAtPos: TControl;
begin
  if Assigned(FPrevOnContextPopup) then
    FPrevOnContextPopup(Sender, MousePos, Handled);
  if Control is TWinControl then
    AControlAtPos := TWinControl(Control).ControlAtPos(MousePos, True, True)
  else
    AControlAtPos := nil;
  if not Handled and (ProcessChildren or (AControlAtPos = nil)) then
    Handled := DoAction(MousePos);
end;

function TdxBarPopupMenuLink.DoAction(AClientPopupPoint: TPoint): Boolean;
var
  AClickedByMouse: Boolean;
begin
  AClickedByMouse := not cxPointIsEqual(cxInvalidPoint, AClientPopupPoint);
  Result := FPopupMenu <> nil;
  if Assigned(FOnAction) then
    FOnAction(Self, AClientPopupPoint.X, AClientPopupPoint.Y, AClickedByMouse, Result);
  if Result and (FPopupMenu <> nil) then
  begin
    with Control.ClientToScreen(AClientPopupPoint) do
      FPopupMenu.Popup(X, Y);
  end;
end;

function TdxBarPopupMenuLink.IsShortCut(AShortCut: TShortCut): Boolean;
var
  X, Y: Integer;
begin
  Result := FPopupMenu <> nil;
  if Assigned(FOnAction) then
  begin
    X := -1;
    Y := -1;
    FOnAction(Self, X, Y, False, Result);
  end;
  if Result then
    Result := (FPopupMenu <> nil) and FPopupMenu.ItemLinks.IsShortCut(AShortCut);
end;

procedure TdxBarPopupMenuLink.NewWndProc(var Message: TMessage);

  function IsContextMenuProcessed: Boolean;
  var
    AOnContextPopup: TContextPopupEvent;
  begin
    AOnContextPopup := ContextPopup;
    Result := EqualMethods(TMethod(TControlAccess(Control).OnContextPopup), TMethod(AOnContextPopup));
  end;

begin
  if (Message.Msg = WM_CONTEXTMENU) and not(csDesigning in Control.ComponentState) then
  begin
    if not IsContextMenuProcessed then
    begin
      FPrevOnContextPopup := TControlAccess(Control).OnContextPopup;
      TControlAccess(Control).OnContextPopup := ContextPopup;
      try
        FPrevWndProc(Message);
      finally
        TControlAccess(Control).OnContextPopup := FPrevOnContextPopup;
      end;
    end;
  end
  else
    FPrevWndProc(Message);
end;

constructor TdxBarPopupMenuLink.Create(Collection: TCollection);
begin
  inherited;
  FProcessChildren := True;
end;

destructor TdxBarPopupMenuLink.Destroy;
begin
  Control := nil;
  inherited;
end;

procedure TdxBarPopupMenuLink.Assign(Source: TPersistent);

  function FindLinkComponent(AComponent: TComponent): TComponent;
  begin
    if AComponent <> nil then
      Result := BarManager.Owner.FindComponent(AComponent.Name)
    else
      Result := nil;
  end;

begin
  if Source is TdxBarPopupMenuLink then
  begin
    Control := FindLinkComponent(TdxBarPopupMenuLink(Source).Control) as TWinControl;
    PopupMenu := FindLinkComponent(TdxBarPopupMenuLink(Source).PopupMenu) as TdxBarPopupMenu;
    ProcessChildren := TdxBarPopupMenuLink(Source).ProcessChildren;
  end
  else inherited Assign(Source);
end;

function TdxBarPopupMenuLink.DoAction(Wnd: HWND; const P: TPoint): Boolean;
begin
  Result := DoAction(Control.ScreenToClient(P));
end;

{ TdxBarPopupMenuLinks }

constructor TdxBarPopupMenuLinks.Create(ABarManager: TdxBarManager);
begin
  inherited Create(TdxBarPopupMenuLink);
  FBarManager := ABarManager;
end;

function TdxBarPopupMenuLinks.GetItem(Index: Integer): TdxBarPopupMenuLink;
begin
  Result := TdxBarPopupMenuLink(inherited GetItem(Index));
end;

procedure TdxBarPopupMenuLinks.SetItem(Index: Integer; Value: TdxBarPopupMenuLink);
begin
  inherited SetItem(Index, Value);
end;
                                
function TdxBarPopupMenuLinks.GetOwner: TPersistent;
begin
  Result := FBarManager;
end;

function TdxBarPopupMenuLinks.IsShortCut(AControl: TWinControl;
  AShortCut: TShortCut): Boolean;
var
  AItem: TdxBarPopupMenuLink;
  AParentBarManager: TdxBarManager;
  I: Integer;
begin
  Result := False;

  for I := 0 to Count - 1 do
  begin
    if Items[I].Control = AControl then
      Result := Items[I].IsShortCut(AShortCut);
    if Result then
      Break;
  end;

  if not Result then
    for I := 0 to Count - 1 do
    begin
      AItem := Items[I];
      if AItem.ProcessChildren and (AItem.WinControl <> nil) and
        IsChildControl(AItem.WinControl, AControl) then
          Result := AItem.IsShortCut(AShortCut);
      if Result then
        Break;
    end;

  if not Result then
  begin
    AParentBarManager := BarManager.ParentBarManager;
    if AParentBarManager <> nil then
      Result := AParentBarManager.PopupMenuLinks.IsShortCut(AControl, AShortCut);
  end;
end;

function TdxBarPopupMenuLinks.Add: TdxBarPopupMenuLink;
begin
  Result := TdxBarPopupMenuLink(inherited Add);
end;

function TdxBarPopupMenuLinks.DoAction(AControl: TWinControl; Wnd: HWND;
  const P: TPoint): Boolean;
var
  AItem: TdxBarPopupMenuLink;
  AParentBarManager: TdxBarManager;
  I: Integer;
begin
  Result := False;
  if BarManager.Designing then
    Exit;

  for I := 0 to Count - 1 do
  begin
    if Items[I].Control = AControl then
      Result := Items[I].DoAction(Wnd, P);
    if Result then
      Break;
  end;

  if not Result then
    for I := 0 to Count - 1 do
    begin
      AItem := Items[I];
      if AItem.ProcessChildren and (AItem.WinControl <> nil) and
        IsChildControl(AItem.WinControl, Wnd) then
          Result := Items[I].DoAction(Wnd, P);
      if Result then
        Break;
    end;

  if not Result then
  begin
    AParentBarManager := BarManager.ParentBarManager;
    if AParentBarManager <> nil then
      Result := AParentBarManager.PopupMenuLinks.DoAction(AControl, Wnd, P);
  end;
end;

{ TdxBarBackgrounds }

constructor TdxBarBackgrounds.Create(ABarManager: TdxBarManager);
begin
  inherited;
  FBarBackgroundBitmap := dxBarCreateBitmap(BitmapChanged);
  FSubMenuBackgroundBitmap := TBitmap.Create;
end;

destructor TdxBarBackgrounds.Destroy;
begin
  FreeAndNil(FSubMenuBackgroundBitmap);
  FreeAndNil(FBarBackgroundBitmap);
  inherited Destroy;
end;

procedure TdxBarBackgrounds.Assign(Source: TPersistent);
begin
  if Source is TdxBarBackgrounds then
  begin
    Bar := TdxBarBackgrounds(Source).Bar;
    SubMenu := TdxBarBackgrounds(Source).SubMenu;
  end
  else
    inherited Assign(Source);
end;

procedure TdxBarBackgrounds.Changed;
begin
  BarManager.InternalStyleChanged; // TODO: ???
end;

procedure TdxBarBackgrounds.BitmapChanged(Sender: TObject);
begin
  Changed;
end;

procedure TdxBarBackgrounds.SetBarBackgroundBitmap(Value: TBitmap);
var
  AChanged: Boolean;
begin
  AChanged := not ((Value = nil) and FBarBackgroundBitmap.Empty);
  FBarBackgroundBitmap.Assign(Value);
  if AChanged then
    Changed;
end;

procedure TdxBarBackgrounds.SetSubMenuBackgroundBitmap(Value: TBitmap);
begin
  FSubMenuBackgroundBitmap.Assign(Value);
end;

{ TdxBarManager }

var
  KeyboardHookHandle: HHOOK;
  MouseHookHandle: HHOOK;
  WndProcHookHandle: HHOOK;
  EatKey, WaitForMenu, DontCallNextKeybHook: Boolean;
  EatingKey: WPARAM;
  InMouseHook: Boolean;
  AClassName: array[0..256] of Char;

  FDockTimerID: UINT;
  FDockBarManager: TdxBarManager;

  FHintWindowShowing: Boolean;
  FHintTimerID, FHiddenHintTimerID: UINT;
  FCustomHint: string;
  FLiveHiddenHint: Boolean;

procedure KillHintTimer;
begin
  dxKillTimer(0, FHintTimerID);
end;

procedure KillHiddenHintTimer;
begin
  if dxKillTimer(0, FHiddenHintTimerID) then
    FLiveHiddenHint := False;
end;

function dxBarKeyboardHook(Code: Integer; wParam: WParam; lParam: LParam): LRESULT; stdcall;

  function AnyKeyPressed: Boolean;
  var
    KS: TKeyboardState;
    I: Integer;
  begin
    GetKeyboardState(KS);
    for I := Low(KS) to High(KS) do
    begin
      Result := KS[I] and 128 <> 0;
      if Result then Break;
    end;
  end;

  function ShiftState: TShiftState;
  begin
    Result := [];
    if GetKeyState(VK_SHIFT) < 0 then Result := Result + [ssShift];
    if GetKeyState(VK_CONTROL) < 0 then Result := Result + [ssCtrl];
    if GetKeyState(VK_MENU) < 0 then Result := Result + [ssAlt];
  end;

  function KeyPressed: Boolean;
  begin
    Result := (lParam shr 31) and 1 = 0;
  end;

  procedure EatKeyIfPressed;
  begin
    if KeyPressed then
    begin
      EatKey := True;
      EatingKey := wParam;
    end;
  end;

  procedure HandleKey(ABarManager: TdxBarManager; var AHookResult: LRESULT);
  var
    AIsUniqueItem: Boolean;
    AItemLink: TdxBarItemLink;
    AShift: TShiftState;
  begin
    if ABarManager.HandleShortCut(GetShortCutFromMessageData(wParam, lParam)) then
      AHookResult := 1
    else
      if GetKeyState(VK_MENU) < 0 then
      begin
        AShift := ShiftState - [ssAlt];
        AItemLink := ABarManager.GetItemLinkWithAccel(wParam, AShift);
        if (AItemLink <> nil) and AItemLink.Item.Enabled then
          with AItemLink do
          begin
            AIsUniqueItem := Owner.FindItemWithAccel(wParam, AShift, AItemLink) = AItemLink;
            if not Control.IsDestroyOnClick or not AIsUniqueItem then
              TdxBarControl(BarControl).BarGetFocus(Control);
            if AIsUniqueItem then
            begin
              if Control is TdxBarSubItemControl then
                BarControl.IsDowned := True;
              Control.Click(False);
            end;
            AHookResult := 1;
          end;
      end;
  end;

  function ActiveBarFocused(ABarManager: TdxBarManager): boolean;
  var
    ACurIndex: Integer;
  begin
    ACurIndex := dxBarManagerList.IndexOf(ABarManager);
    repeat
      Result := ABarManager.BarControlFocused;
      ABarManager := dxBarManagerList.NextActive(ABarManager, True);
    until Result or (dxBarManagerList.IndexOf(ABarManager) = ACurIndex);
  end;

  function GetBarManager(AFindRootAccessibleObject: Boolean;
    out AIRootAccessibilityHelper: IdxBarAccessibilityHelper): TdxBarManager;

    function FindBarManagerAmongParents(AWnd: HWND): TdxBarManager;
    begin
      Result := nil;
      repeat
        if AFindRootAccessibleObject then
        begin
          AIRootAccessibilityHelper := GetRootAccessibleObject(AWnd);
          if AIRootAccessibilityHelper <> nil then
            Result := AIRootAccessibilityHelper.GetBarManager;
        end
        else
          Result := GetBarManagerByHandle(AWnd);
        if not IsChildClassWindow(AWnd) then
          Break;
        AWnd := GetParent(AWnd);
      until Result <> nil;
    end;

  var
    AControl: TWinControl;
    I: Integer;
  begin
    Result := nil;
    if GetFocus <> 0 then
      Result := FindBarManagerAmongParents(GetFocus);

    if (Result = nil) and (GetActiveForm <> nil) then
    begin
      Result := FindBarManagerAmongParents(GetActiveForm.Handle);
      if (Result = nil) and (Application.MainForm <> nil) and
        IsWindowEnabledEx(Application.MainForm.Handle) then
      begin
        Result := FindBarManagerAmongParents(Application.MainForm.Handle);
        if (Result <> nil) and not Result.AllowCallFromAnotherForm then
            Result := nil;
      end;
    end;

    if (Result = nil) and not AFindRootAccessibleObject then
    begin
      AControl := FindControl(GetActiveWindow);
      if (AControl <> nil) and not IsWindowEnabledEx(AControl.Handle) then
        AControl := nil;
      if (AControl is TCustomForm) and (TCustomForm(AControl).Parent = nil) then
      begin
        if Assigned(cxControls.cxGetParentFormForDocking) then                    
          AControl := cxControls.cxGetParentFormForDocking(TCustomForm(AControl));
      end;
      if AControl is TCustomForm then
        for I := 0 to dxBarManagerList.Count - 1 do
          if dxBarManagerList[I].GetMainForm = AControl then
          begin
            Result := dxBarManagerList[I];
            Break;
          end;
    end;

    if (Result <> nil) and (Result.IsCustomizing or ActiveBarFocused(Result)) then
      Result := nil;
  end;

  function MenuActivateIfNeeded(var AHookResult: LRESULT): Boolean;
  var
    AKeyTipWindowsManager: IdxBarKeyTipWindowsManager;
    AIRootAccessibilityHelper: IdxBarAccessibilityHelper;
    ABarManager: TdxBarManager;
  begin
    Result := False;
    ABarManager := GetBarManager((wParam = VK_F10) or (wParam = VK_MENU),
      AIRootAccessibilityHelper);
    if ABarManager <> nil then
    begin
      if not KeyPressed then // release key
      begin
        if (wParam = VK_MENU) and WaitForMenu or
          ABarManager.UseF10ForMenu and (wParam = VK_F10) and (ShiftState = []) then
        begin
          WaitForMenu := False;
          BarNavigationController.SelectDefaultObject(AIRootAccessibilityHelper);
          AHookResult := 1;
          Result := True;
          if AIRootAccessibilityHelper.AreKeyTipsSupported(AKeyTipWindowsManager) then
            BarNavigationController.EndKeyTipsWaiting(True);
        end
        else
          BarNavigationController.EndKeyTipsWaiting(False);
      end
      else // press key
        if (((wParam = VK_MENU) and not (ssCtrl in ShiftState)) or
          (ABarManager.UseF10ForMenu and (wParam = VK_F10) and (ShiftState = []))) and
          not (EatKey and (wParam = EatingKey)) then
        begin
          ABarManager.HideHint;
          WaitForMenu := True;
          if AIRootAccessibilityHelper.AreKeyTipsSupported(AKeyTipWindowsManager) then
            BarNavigationController.BeginKeyTipsWaiting(AIRootAccessibilityHelper);
        end
        else
        begin
          BarNavigationController.EndKeyTipsWaiting(False);
          HandleKey(ABarManager, AHookResult);
          Result := True;
        end;
    end;
  end;

  function HandleByActiveBarControlIfNeeded(var AHookResult: LRESULT): Boolean;
  const
    KeyMessages: array[Boolean] of Integer = (WM_KEYUP, WM_KEYDOWN);
  begin
    Result := False;
    if EatKey and (wParam = EatingKey) and not KeyPressed then  // release eating key
    begin
      EatKey := False;
      AHookResult := 1;
      Result := True;
      Exit;
    end;
    if dsKeyAlreadyProcessed in BarDesignController.FDesignStates then
      Exit;
    if BarNavigationController.NeedsKey(wParam, ShiftState) then
    begin
      EatKeyIfPressed;
      if KeyPressed then
        BarNavigationController.HandleKey(wParam, ShiftState);
//      if (BarNavigationController.SelectedObjectParent <> nil) or not KeyPressed then
//        EatKey := False;
      AHookResult := 1;
      Result := True;
    end
    else
    begin
      if IsTextCharForKeyTip(wParam) and (BarNavigationController.IsKeyTipsWaiting or BarNavigationController.KeyTipsHandlingMode) then
        BarNavigationController.StopKeyboardHandling;
      if IsActiveBarControlAccessible and not ActiveBarControl.IsCustomizing then
      begin
        if not (ActiveBarControl.SelectedControl is TdxBarWinControl and
          TdxBarWinControl(ActiveBarControl.SelectedControl).Focused) then
        begin
          EatKeyIfPressed;
          SendMessage(ActiveBarControl.Handle, KeyMessages[KeyPressed], wParam, lParam);
          if (ActiveBarControl <> nil) or (GetKeyState(wParam) >= 0) then
            EatKey := False;
          AHookResult := 1;
          Result := True;
        end
      end
      else
        case wParam of
          VK_DELETE:
            if KeyPressed and BarDesignController.DeleteSelectedObjects(ssCtrl in ShiftState, True) then
            begin
              AHookResult := 1;
              Result := True;
            end;
          //#DG <BarManager.SelectedItem>
            {
            if ActiveBarControl.BarManager.SelectedItem <> nil then
            begin
              if not (ssCtrl in ShiftState) then
                ActiveBarControl.BarManager.SelectedItem.ItemLink.Free
              else
                if ActiveBarControl.BarManager.Designing and
                  ActiveBarControl.BarManager.CanDeleteComponent(ActiveBarControl.BarManager.SelectedItem.Item) then
                    ActiveBarControl.BarManager.SelectedItem.Item.Free;
              AHookResult := 1;
              Result := True;
            end;
                    }

          VK_ESCAPE:
            if (ActiveBarControl <> nil) and (GetCapture = ActiveBarControl.Handle) then
            begin
              ReleaseCapture;
              AHookResult := 1;
              Result := True;
              Exit;
            end
            else
              if KeyPressed and BarDesignController.SelectParentComponent then
              begin
                AHookResult := 1;
                Result := True;
              end;
          VK_MENU:
            if (ActiveBarControl = nil) and (BarDesignController.FQuickControl <> nil) then
            begin
              EatKeyIfPressed;
              BarDesignController.FQuickControl.HideAll;
              if (GetKeyState(wParam) >= 0) then
                EatKey := False;
              AHookResult := 1;
              Result := True;
            end;
        end;
    end;
  end;

var
  Res: LRESULT;
begin
  Result := 0;
  try
    if Code = HC_NOREMOVE then Exit;
    if FIsMDIButtonPressed then
    begin
      Result := 1;
      Exit;
    end;

    if wParam = VK_PROCESSKEY then Exit;  // for Korean windows
    if Code < 0 then Exit;
    if HandleByActiveBarControlIfNeeded(Result) then
      Exit;
    if GetCapture = 0 then
    begin
      if MenuActivateIfNeeded(Result) then
        Exit;
    end;
  finally
    if DontCallNextKeybHook then Result := 0
    else
    begin
      Res := CallNextHookEx(KeyboardHookHandle, Code, wParam, lParam);
      if Result = 0 then Result := Res;
    end;
  end;
end;

function BarGetMouseWheelReceiver: TdxBarMouseWheelEventReceiver;
begin
  if ActiveBarControl <> nil then
    if ActiveBarControl.SelectedControl is TdxBarWinControl and
      TdxBarWinControl(ActiveBarControl.SelectedControl).Focused then
        Result := mwrFocusedItemControl
    else
      if ActiveBarControl.NeedsMouseWheel then
        Result := mwrActiveBarControl
      else
        Result := mwrNone
  else
    Result := mwrWindow;
end;

function ProcessMessage(AWindow: HWND; out AIsMessageForMeaningParent: Boolean): Boolean;
var
  AControl: TCustomdxBarControl;
begin
  Result := not ActiveBarControl.IsWindowEnabled and not ActiveBarManager.IsCustomizing;
//    Result := not IsWindowEnabled(AMHS.hwnd) and not ActiveBarControl.BarManager.IsCustomizing and not ActiveBarControl.IsWindowEnabled;
  AControl := ActiveBarControl;
  while (AControl <> nil) and not Result do
  begin
    Result := AControl.IsChildWindow(AWindow);
    if not Result then
    begin
      Result := AControl.IsMeaningParent(AWindow);
      AIsMessageForMeaningParent := Result;
    end
    else
      AIsMessageForMeaningParent := False;
    AControl := AControl.GetEquivalentParentBar;
  end;
end;

function dxBarMouseHook(Code: Integer; wParam: WParam; lParam: LParam): LRESULT; stdcall;

var
  AMHS: PMouseHookStruct;

  function ActiveControl: TdxBarItemControl;
  begin
    Result := nil;
    if FindControl(AMHS.hwnd) is TCustomdxBarControl then
      Result := TCustomdxBarControl(FindControl(AMHS.hwnd)).SelectedControl;

    if (Result = nil) and (GetCapture > 0) and (ActiveBarControl <> nil) then
      if WindowFromPointEx(AMHS.pt) = ActiveBarControl.Handle then
        Result := ActiveBarControl.SelectedControl
      else
      begin
        Result := ActiveBarControl.SelectedControl;
        if (Result <> nil) and
          (not (Result.ItemLink.Item is TCustomdxBarCombo) or
           not TCustomdxBarCombo(Result.ItemLink.Item).DroppedDown) then
          Result := nil;
      end;
  end;

  function NeedProccessThisEvent(AWnd: HWND): Boolean;
  var
    I: Integer;
  begin
    Result := FindControl(AWnd) <> nil;
    if IsWin95 and not Result then
      for I := 0 to Screen.FormCount - 1 do
        if Screen.Forms[I].Handle = AWnd then
        begin
          Result := True;
          Break;
        end;
  end;

  procedure CheckHookParams;

    function IsMouseOverCustomizingControl(AParentHandle, AControlHandle: HWND; const AMousePos: TPoint): Boolean;
    var
      AChildHandle: HWND;
      AClientPos: TPoint;
    begin
      AClientPos := AMousePos;
      ScreenToClient(AParentHandle, AClientPos);
      AChildHandle := ChildWindowFromPointEx(AParentHandle, AClientPos, CWP_SKIPINVISIBLE);
      Result := AChildHandle = AControlHandle;
      if not Result and (AChildHandle <> 0) and (AChildHandle <> AParentHandle) then
        Result := IsMouseOverCustomizingControl(AChildHandle, AControlHandle, AMousePos);
    end;

  var
    ACustomizingControl: TWinControl;
  begin
    //## Check whole procedure
    if dxBarCustomizingForm <> nil then
    begin
      ACustomizingControl := dxBarCustomizingForm.BarManager.Owner;
      if (ACustomizingControl <> nil) and IsChildClassWindow(ACustomizingControl.Handle) then
      begin
        if IsMouseOverCustomizingControl(AMHS.hwnd, ACustomizingControl.Handle, AMHS.pt) then
        begin
          if (WM_MOUSEMOVE <= wParam) and (wParam <= WM_MBUTTONDBLCLK) then
            wParam := wParam - WM_MOUSEMOVE + WM_NCMOUSEMOVE;
          AMHS.hwnd := ACustomizingControl.Handle;
          AMHS.wHitTestCode := UINT(HTERROR);
        end;
      end;
    end;
  end;

  function BarsWantMouse: Boolean;

    function AllowCustomize(ABarManager: TdxBarManager): Boolean;
    begin
      Result := (dxBarCustomizingForm <> nil) and
        {#DG when adding new toolbar - BarControl must ignore mouse}
        (dxBarCustomizingForm.Active or IsChildEx(GetActiveWindow, ABarManager.Owner.Handle));
    end;

  var
    ABarManager: TdxBarManager;
    I: Integer;
  begin
    Result := False;
    if NeedProccessThisEvent(AMHS.hwnd) and (SmallInt(AMHS.wHitTestCode) = HTERROR) then
    begin
      ABarManager := dxBarManagerList.CustomizingBarManager;
      if (ABarManager <> nil) and AllowCustomize(ABarManager) then
        for I := 0 to ABarManager.Bars.Count - 1 do
          if (ABarManager.Bars[I].Control <> nil) and ABarManager.Bars[I].Control.WantMouse then
          begin
            Result := True;
            AMHS.hwnd := ABarManager.Bars[I].Control.Handle;
            AMHS.wHitTestCode := SendMessage(AMHS.hwnd, WM_NCHITTEST, 0, MakeLParam(AMHS.pt.X, AMHS.pt.Y));
            SendMessage(AMHS.hwnd, WM_SETCURSOR, AMHS.hwnd, MakeLParam(AMHS.wHitTestCode, wParam));
            Break;
          end;
    end;
  end;

  function HideAllIfNeeded(var AHookResult: LRESULT): Boolean;
  var
    AIsMessageForMeaningParent: Boolean;
  begin
    Result := False;
    if not InMouseHook and (Code >= 0) and (ActiveBarControl <> nil) then
    begin
      InMouseHook := True;
      if ((wParam = WM_RBUTTONUP) or (wParam = WM_NCRBUTTONUP) or
        (wParam = WM_MBUTTONUP) or (wParam = WM_NCMBUTTONUP)) and
        (ActiveControl = nil) and not ProcessMessage(AMHS.hwnd, AIsMessageForMeaningParent) then
      begin
        InMouseHook := False;
        AHookResult := 1;
        Result := True;
        Exit;
      end;
      if not ActiveBarManager.Dragging then
        repeat
          if ({((wParam = WM_LBUTTONUP) or (wParam = WM_NCLBUTTONUP)) and (ActiveControl = nil) and
              (AnimatingSubMenu = nil) and not ActiveBarControl.IsCustomizing and
              ((ActiveBarControl is TdxBarControl) or (ActiveBarControl.ParentBar <> nil)) or}
            IsMouseDownMessage(wParam)) then
          begin
            if not ProcessMessage(AMHS.hwnd, AIsMessageForMeaningParent) then
            begin
              ActiveBarControl.HideAll;
              if not IsWindowVisible(AMHS.hwnd) then
              begin
                AHookResult := 1;
                Result := True;
              end;
            end
            else
            begin
              if AIsMessageForMeaningParent then
                ActiveBarControl.ProcessMouseDownMessageForMeaningParent(
                  AMHS.hwnd, wParam, AMHS.pt);
              Break;
            end
          end
          else
            Break;
        until ActiveBarControl = nil;
      InMouseHook := False;
{      if not IsWindowVisible(AMHS.hwnd) and
        (ActiveBarControl <> nil) and ActiveBarControl.IsWindowEnabled then
      begin
        AHookResult := 1;
        Result := True;
      end;     }
    end;
  end;

  procedure CheckNavigationController;
  begin
    if ((BarNavigationController.AssignedSelectedObject <> nil) or
      BarNavigationController.IsKeyTipsWaiting or
      BarNavigationController.KeyTipsHandlingMode) and
      IsMouseDownMessage(wParam) then
        BarNavigationController.StopKeyboardHandling;
  end;

  procedure CheckBarMarkState;

    function IsChildWindowEx(AParentWnd, AWnd: HWND): Boolean;
    begin
      repeat
        Result := AWnd = AParentWnd;
        if Result or not IsChildClassWindow(AWnd) then
          Break;
        AWnd := GetParent(AWnd);
      until AWnd = 0;
    end;

  var
//    P: TPoint;
//    ABarControl: TCustomdxBarControl;
    AQuickControl: TdxBarControl;
  begin
    if (BarDesignController.QuickControl <> nil) and
      not BarDesignController.QuickControl.IsActive and
        (BarDesignController.QuickControl <> BarDesignController.CustomizingBarControl) and
//      ((WM_MOUSEFIRST < wParam) and (wParam <= WM_MOUSELAST) or
//       (WM_NCMOUSEMOVE < wParam) and (wParam <= WM_NCMBUTTONDBLCLK)) then
      IsMouseDownMessage(wParam) then
    begin
      AQuickControl := BarDesignController.QuickControl;
      if not IsChildWindowEx(AQuickControl.Handle, AMHS.hwnd) and
        (not AQuickControl.ParentBar.MouseOnMark or (wParam = WM_RBUTTONDOWN)) then
          AQuickControl.CloseUp;
{
      if FindControl(AMHS.hwnd) is TCustomdxBarControl then
      begin
        ABarControl := TCustomdxBarControl(FindControl(AMHS.hwnd));
        P := AMHS.pt;
        ScreenToClient(AMHS.hwnd, P)
      end
      else
        ABarControl := nil;

      if (ABarControl = nil) or (ABarControl <> QuickCustBar) and
        ((ABarControl <> QuickCustBar.ParentBar) or
         not PtInRect(TdxBarControl(ABarControl).MarkRect, P) or
         (wParam = WM_RBUTTONDOWN)) then
        QuickCustBar.ParentBar.MarkState := msNone;
}
    end;
  end;

  procedure ProcessManually(var AHookResult: LRESULT);
  var
    P: TPoint;
    AKeys: Longint;
  begin
    P := AMHS.pt;
    if (WM_NCMOUSEMOVE <= wParam) and (wParam <= WM_NCMBUTTONDBLCLK) then
    begin
      wParam := wParam - WM_NCMOUSEMOVE + WM_MOUSEMOVE;
      ScreenToClient(AMHS.hwnd, P);
    end;
    if wParam <> WM_MOUSEMOVE then
      SetForegroundWindow(dxBarCustomizingForm.Handle);
    AKeys :=
      Byte(GetAsyncKeyState(VK_CONTROL) < 0) * MK_CONTROL +
      Byte(LeftButtonPressed) * MK_LBUTTON +
      Byte(GetAsyncKeyState(VK_MBUTTON) < 0) * MK_MBUTTON +
      Byte(RightButtonPressed) * MK_RBUTTON +
      Byte(GetAsyncKeyState(VK_SHIFT) < 0) * MK_SHIFT;
    SendMessage(AMHS.hwnd, wParam, AKeys, MakeLParam(P.X, P.Y));
    AHookResult := 1;
  end;

  procedure TrackMouseMoving;
  var
    APoint: TPoint;
    AWnd: HWND;
    AMessage: TMessage;
    AControl: TWinControl;
  begin
    if wParam = WM_MOUSEMOVE then
    begin
      AWnd := AMHS.hwnd;
      repeat
        AControl := FindControl(AWnd);
        if AControl is TCustomdxBarControl then
        begin
          if AWnd <> AMHS.hwnd then
          begin
            APoint := AMHS.pt;
            MapWindowPoint(0, AWnd, APoint);
            AMessage.Msg := WM_MOUSEMOVE;
            AMessage.WParam := 0;
            AMessage.LParam := MakeLParam(APoint.X, APoint.Y);
            (AControl as TCustomdxBarControl).WMMouseMove(TWMMouse(AMessage));
          end;
          Break;
        end;
        AWnd := GetParent(AWnd);
      until AWnd = 0;
    end;
  end;

var
  AManualProcessing: Boolean;
  Res: HRESULT;
begin
  Result := 0;
  try
    if (Code = HC_ACTION) and IsMouseDownMessage(wParam) then
      BarNavigationController.ResetNavigationMode;

    if (Code >= 0) and (wParam = WM_MOUSEWHEEL) and (BarGetMouseWheelReceiver = mwrNone) then
    begin
      Result := 1;
      Exit;
    end;

    AMHS := PMouseHookStruct(lParam);
    if (AMHS.hwnd = GetCapture) and (wParam <> WM_RBUTTONUP) then // TTreeView has capture while WM_RBUTTONUP
      Exit;

    CheckHookParams;
    AManualProcessing := BarsWantMouse;
    if HideAllIfNeeded(Result) then
      Exit;
    CheckBarMarkState;
    CheckNavigationController;

    if AManualProcessing then
      ProcessManually(Result);

    TrackMouseMoving;
  finally
    Res := CallNextHookEx(MouseHookHandle, Code, wParam, lParam);
    if Result = 0 then Result := Res;
  end;
end;

// win95 bug fix
var
  FIsGetingBarManagerdxBarWndProcHook: Boolean;

function dxBarWndProcHook(Code: Integer; wParam: WParam; lParam: LParam): LRESULT; stdcall;

  function GetWindowParentForm(AWnd: HWND): TCustomForm;
  begin
    while not (FindControl(AWnd) is TCustomForm) and (GetParent(AWnd) <> 0) do
      AWnd := GetParent(AWnd);
    if FindControl(AWnd) is TCustomForm then
      Result := TCustomForm(FindControl(AWnd))
    else
      Result := nil;
  end;

  function GetBarManager(AWnd: HWND): TdxBarManager;
  begin
    FIsGetingBarManagerdxBarWndProcHook := True;
    try
      Result := GetBarManagerByHandle(AWnd);
    finally
      FIsGetingBarManagerdxBarWndProcHook := False;
    end;
  end;

  procedure ActivateMDIChildFormToolbars(AActivate: Boolean; AActiveWindow: HWND);
  var
    ABarManagerMainForm: TCustomForm;
    AControl: TWinControl;
    I: Integer;
  begin
    AControl := FindControl(AActiveWindow);
    if AControl is TCustomdxBarControl then
    begin
      ABarManagerMainForm := GetBarManagerForm(TCustomdxBarControl(AControl).BarManager, fkMainOrMDIChild);
      if IsMDIChild(ABarManagerMainForm) then
        Exit;
    end;
    ABarManagerMainForm := Application.MainForm.ActiveMDIChild;
    if ABarManagerMainForm <> nil then
      for I := 0 to dxBarManagerList.Count - 1 do
        if GetBarManagerForm(dxBarManagerList[I], fkMainOrMDIChild) = ABarManagerMainForm then
          dxBarManagerList[I].ShowToolbars(AActivate, False, AActiveWindow);
  end;

  procedure CallOwnerWndProc(Msg: Cardinal; wParam, lParam: Integer; AHandle: HWND);
  var
    ABarManager: TdxBarManager;
//#DG    AControl: TWinControl;
    AParentForm: TCustomForm;
    AWnd: HWND;
  begin
    if (Msg = WM_ACTIVATE) and ((AHandle = GetParent(lParam)) or (HWND(lParam) = GetParent(AHandle))) and
      not IsAnotherApplicatonWindow(AHandle) and not IsAnotherApplicatonWindow(lParam) then
        Exit;
    AWnd := AHandle;
    if (Msg = WM_HELP) and (ActiveBarControl <> nil) then
    begin
      AParentForm := GetWindowParentForm(AWnd);
      if (AParentForm = nil) or not IsBarManagerOwner(ActiveBarManager, AParentForm.Handle) then
        AWnd := GetBarManagerForm(ActiveBarManager, fkAny).Handle;
    end;
    ABarManager := GetBarManager(AWnd); //##
    if (ABarManager = nil) and (Msg = WM_ACTIVATE) then
    begin
//#DG      AControl := FindControl(AHandle);
//#DG      if not (AControl is TCustomdxBarControl) and IsWindowVisible(GetParent(AHandle)) then
      if IsWindowVisible(GetParent(AHandle)) then //#DG
        ABarManager := GetBarManager(GetParent(AHandle)); //##
    end;
    if ABarManager <> nil then
      ABarManager.OwnerWndProc(AWnd, Msg, wParam, lParam);
    TdxBarManager.SendFormBroadcastMessage(AWnd, Msg, wParam, lParam);
  end;

  procedure CallMainFormClientWndProc(AWnd: HWND; Msg: Cardinal; wParam, lParam: Integer);
  var
    ABarManager: TdxBarManager;
  begin
    if (AWnd <> 0) and (Application.MainForm <> nil) and Application.MainForm.HandleAllocated then
    begin
      GetClassName(AWnd, AClassName, 256);
      if AnsiStrIComp(AClassName, 'MDICLIENT') = 0 then
      begin
        ABarManager := GetBarManager(Application.MainForm.Handle);
        if ABarManager <> nil then
          ABarManager.MainFormClientWndProc(Msg, wParam, lParam);
      end;
    end;
  end;

var
  AMsg: PCWPStruct;
begin
  AMsg := PCWPStruct(lParam);

  case AMsg.message of
    WM_ACTIVATE:
      if (LOWORD(AMsg.wParam) = WA_INACTIVE) and IsAnotherApplicatonWindow(AMsg.lParam) then
        FApplicationDeactivation := True;
    WM_ACTIVATEAPP:
      begin
        FApplicationDeactivation := False;
        FApplicationActive := Bool(AMsg.wParam);
        BarDesignController.SynchronizeLastSelectedItem; //#DG new
      end;
  end;

  if not FIsGetingBarManagerdxBarWndProcHook then
  begin
    CallOwnerWndProc(AMsg.message, AMsg.wParam, AMsg.lParam, AMsg.hwnd);
    if IsMDIForm(Application.MainForm) and
      Application.MainForm.HandleAllocated and (AMsg.hwnd = Application.MainForm.Handle) and
      not IsPopupMenuShowed then
        case AMsg.message of
          WM_ACTIVATE:
            ActivateMDIChildFormToolbars(LOWORD(AMsg.wParam) <> WA_INACTIVE, AMsg.lParam);
          WM_WINDOWPOSCHANGED:
            if dxBarCustomizingForm <> nil then
              dxBarCustomizingForm.UpdateVisibility(PWindowPos(AMsg.lParam)^);
        end;
  end;

  Result := CallNextHookEx(WndProcHookHandle, Code, wParam, lParam);

  case AMsg.message of
    WM_CHILDACTIVATE, WM_DESTROY, WM_MDIACTIVATE:
      CallMainFormClientWndProc(GetParent(AMsg.hwnd), AMsg.message, AMsg.wParam, AMsg.lParam);
  end;
end;

var
  FPrevInitProc: TProcedure;

procedure dxBarInitProc;
begin
  if Assigned(FPrevInitProc) then
    FPrevInitProc;
  InitMMSystem;
end;

procedure RegisterdxBarManager(ABarManager: TdxBarManager);
begin
  if dxBarManagerList.IndexOf(ABarManager) < 0 then
  begin
    if dxBarManagerList.Count = 0 then
    begin
      SetHook(KeyboardHookHandle, WH_KEYBOARD, dxBarKeyboardHook);
      SetHook(MouseHookHandle, WH_MOUSE, dxBarMouseHook);
      SetHook(WndProcHookHandle, WH_CALLWNDPROC, dxBarWndProcHook);
    end;
    dxBarManagerList.Add(ABarManager);
    if Assigned(FOnRegisterBarManager) then
      FOnRegisterBarManager(ABarManager);
  end;
  if not ABarManager.Designing and (FHintWindow = nil) then
    FHintWindow := dxBarHintWindowClass.Create(nil);
end;

procedure FinalizationBars;
begin
  ReleaseHook(WndProcHookHandle);
  ReleaseHook(MouseHookHandle);
  ReleaseHook(KeyboardHookHandle);
  FreeAndNil(FHintWindow);
end;

procedure UnregisterdxBarManager(ABarManager: TdxBarManager);
begin
  if dxBarManagerList <> nil then
  begin
    dxBarManagerList.Extract(ABarManager);
    if dxBarManagerList.Count = 0 then
      FinalizationBars;
  end;

  if Assigned(FOnUnregisterBarManager) then
    FOnUnregisterBarManager(ABarManager);
end;

{ TCustomdxBarControlViewInfo }

constructor TCustomdxBarControlViewInfo.Create(ABarControl: TCustomdxBarControl);
begin
  inherited Create;
  FBarControl := ABarControl;
  FItemControlViewInfos := TList.Create
end;

destructor TCustomdxBarControlViewInfo.Destroy;
begin
  FreeAndNil(FItemControlViewInfos);
  inherited Destroy;
end;

procedure TCustomdxBarControlViewInfo.Calculate;
begin
  Clear;
end;

function TCustomdxBarControlViewInfo.GetItemControlIndex(
  AItemControl: TdxBarItemControl): Integer;
begin
  Result := FItemControlViewInfos.IndexOf(AItemControl.ViewInfo);
end;

function TCustomdxBarControlViewInfo.IsAssociatedWithSeparator(
  AItemControl: TdxBarItemControl; out ASeparatorIndex: Integer): Boolean;
var
  I: Integer;
begin
  Result := False;
  for I := 0 to High(FSeparatorsData) do
    if FSeparatorsData[I].AssociatedItemControl = AItemControl then
    begin
      Result := True;
      ASeparatorIndex := I;
      Break;
    end;
end;

function TCustomdxBarControlViewInfo.IsItemControlVisible(
  AItemControl: TdxBarItemControl): Boolean;
begin
  Result := FItemControlViewInfos.IndexOf(AItemControl.ViewInfo) <> -1;
end;

procedure TCustomdxBarControlViewInfo.AddItemControlViewInfo(
  AViewInfo: TdxBarItemControlViewInfo);
begin
  FItemControlViewInfos.Add(AViewInfo);
end;

procedure TCustomdxBarControlViewInfo.AddSeparatorInfo(const ARect: TRect;
  AKind: TdxBarItemSeparatorKind; AAssociatedItemControl: TdxBarItemControl);
var
  AIndex: Integer;
begin
  AIndex := Length(FSeparatorsData);
  SetLength(FSeparatorsData, AIndex + 1);
  with FSeparatorsData[AIndex] do
  begin
    AssociatedItemControl := AAssociatedItemControl;
    Bounds := ARect;
    Kind := AKind;
  end;
end;

procedure TCustomdxBarControlViewInfo.Clear;
begin
  FItemControlViewInfos.Clear;
  RemoveSeparatorInfos;
end;

procedure TCustomdxBarControlViewInfo.RemoveItemControlViewInfo(
  AViewInfo: TdxBarItemControlViewInfo);
begin
  FItemControlViewInfos.Remove(AViewInfo);
end;

procedure TCustomdxBarControlViewInfo.RemoveSeparatorInfos;
begin
  SetLength(FSeparatorsData, 0);
end;

function TCustomdxBarControlViewInfo.GetItemControlCount: Integer;
begin
  Result := FItemControlViewInfos.Count;
end;

function TCustomdxBarControlViewInfo.GetItemControlViewInfo(
  AIndex: Integer): TdxBarItemControlViewInfo;
begin
  Result := TdxBarItemControlViewInfo(FItemControlViewInfos[AIndex]);
end;

function TCustomdxBarControlViewInfo.GetSeparatorCount: Integer;
begin
  Result := Length(FSeparatorsData);
end;

function TCustomdxBarControlViewInfo.GetSeparatorInfo(
  AIndex: Integer): TdxBarItemSeparatorInfo;
begin
  with FSeparatorsData[AIndex] do
  begin
    Result.Bounds := Bounds;
    Result.Kind := Kind;
  end;
end;

procedure TCustomdxBarControlViewInfo.SetSeparatorInfo(AIndex: Integer;
  const Value: TdxBarItemSeparatorInfo);
begin
  with FSeparatorsData[AIndex] do
  begin
    Bounds := Value.Bounds;
    Kind := Value.Kind;
  end;
end;

{ TdxBarDragInfo }

constructor TdxBarDragInfo.Create(ABarManager: TdxBarmanager);
begin
  inherited Create;
  FBarManager := ABarManager;
end;

destructor TdxBarDragInfo.Destroy;
begin
  cxRemoveObjectLink(FDragOverBarControlLink);
  cxRemoveObjectLink(FDragLineBarControlLink);
  inherited;
end;

procedure TdxBarDragInfo.BeginDrag(AItem: TdxBarItem; AItemLink: TdxBarItemLink);
begin
  FDraggingItem := AItem;
  FDraggingItemLink := AItemLink;
  if FDraggingItemLink <> nil then
    FDragDownPoint := FDraggingItemLink.ScreenToClient(GetMouseCursorPos);
  FDefaultCursor := Screen.Cursor;
  FCaptureWnd := FBarManager.GetWindowForMouseCapturing;
  SetCapture(FCaptureWnd);
  ProcessMouseMessages;
end;

procedure TdxBarDragInfo.DragDrop;
begin
  case DraggingState of
    dsNoDrop: DeleteDraggingItemLink;
    dsNoDrag: {do nothing};
    dsBeginGroup: ChangeBeginGroup;
    dsCategory: MoveItemToAnotherCategory;
    dsCopy, dsDrag:
      begin
        FDraggingState := dsNoDrag;
        CreateNewItemLink;
      end;
  end;
end;

procedure TdxBarDragInfo.EndDrag;
begin
  if GetCapture = FCaptureWnd then
    ReleaseCapture;
  DraggingState := dsNoDrag;

  DestroyWindow(FDraggingItemLinkParentHandle);

  RepaintItemControl(DraggingControl);
  FDraggingItem := nil;
  FDraggingItemLink := nil;
  DragOverBarControl := nil;
  DragLineBarControl := nil;
end;

procedure TdxBarDragInfo.HandleDragging;
var
  AWnd: HWND;
  AMsg: TMsg;
  P: TPoint;
  AControl: TWinControl;
  ACategoryItemIndex: Integer;
  AAccept: Boolean;
begin
  Include(BarDesignController.FDesignStates, dsKeyAlreadyProcessed);
  try
    while GetCapture = FCaptureWnd do
    begin
      case Integer(GetMessage(AMsg, 0, 0, 0)) of
        -1: Break;
        0: begin
            PostQuitMessage(AMsg.wParam);
            Break;
          end;
      end;
      case AMsg.message of
        WM_KEYDOWN:
          case AMsg.wParam of
            VK_ESCAPE: Break;
            VK_CONTROL:
              if HasTarget then
                DraggingState := dsCopy;
          end;
        WM_KEYUP:
          case AMsg.wParam of
            VK_CONTROL:
              if HasTarget then
                DraggingState := dsDrag;
          end;
        WM_MOUSEMOVE:
          begin
            P := GetMouseCursorPos;

            AWnd := WindowFromPointEx(P);
            AControl := FindControl(AWnd);

            if CategoriesList <> nil then
              if AControl = CategoriesList then
              begin
                P := CategoriesList.ScreenToClient(P);
                ACategoryItemIndex := CategoriesList.ItemAtPos(P, True);
                if (0 <= ACategoryItemIndex) and (ACategoryItemIndex <= CategoriesList.Items.Count - 1) then
                begin
                  CategoriesList.ItemIndex := ACategoryItemIndex;
                  DraggingState := dsCategory;
                end
                else
                begin
                  CategoriesList.ItemIndex := FDraggingItem.Category;
                  DraggingState := dsNoDrop;
                end;
                Continue;
              end
              else
              begin
                CategoriesList.ItemIndex := FDraggingItem.Category;
              end;

            BeginUpdate;
            try
              if (dxBarSubMenuEditor <> nil) and (dxBarSubMenuEditor.Handle = AWnd) then
                dxBarSubMenuEditor.Perform(CM_ACTIVATE, 0, 0);

              CalcDragOverItemParameters(P);

              AAccept := True;
              if DragOverBarControl <> nil then
                DragOverBarControl.DragOver(P.X, P.Y, AAccept);

              if AAccept and HasTarget then
              begin
                if IsDragCopy then
                  DraggingState := dsCopy
                else
                begin
                  if (DragOverItemControl <> nil) and (FDraggingItemLink <> nil) and
                       ((DragOverItemLink = FDraggingItemLink) or NoNeedDragLine) then
                    DraggingState := dsBeginGroup
                  else
                    DraggingState := dsDrag
                end;
              end
              else
                DraggingState := dsNoDrop;
            finally
              EndUpdate;
            end;
          end;
        WM_LBUTTONUP:
          begin
            DragDrop;
            Break;
          end;
      else
        TranslateMessage(AMsg);
        DispatchMessage(AMsg);
      end;
    end;
  finally
    Exclude(BarDesignController.FDesignStates, dsKeyAlreadyProcessed);
  end;
end;

procedure TdxBarDragInfo.BeginUpdate;
begin
  Inc(FLockCount);
end;

procedure TdxBarDragInfo.EndUpdate;
begin
  if FLockCount > 0 then
  begin
    Dec(FLockCount);
    DragInfoChanged;
  end;
end;

procedure TdxBarDragInfo.CalcDragOverItemParameters(var ACursorPos: TPoint);

  function GetDragOverBarControl(AControl: TWinControl): TCustomdxBarControl;
  var
    I: Integer;
    ABarControl: TdxBarControl;
  begin
    Result := nil;
    if AControl is TCustomdxBarControl then
    begin
      if TCustomdxBarControl(AControl).BarManager = FBarManager then
        Result := TCustomdxBarControl(AControl)
    end
    else
      for I := 0 to FBarManager.Bars.Count - 1 do
      begin
        ABarControl := FBarManager.Bars[I].Control;
        if (ABarControl <> nil) and ABarControl.WantMouse then
        begin
          Result := ABarControl;
          Break;
        end;
      end;

    if (Result <> nil) and not Result.CanCustomizing then
      Result := nil;
  end;

var
  AItemLink: TdxBarItemLink;
  AIsBeginGroup, AIsFirstPart, AIsVerticalDirection: Boolean;
begin
  AIsFirstPart := False;
  AIsBeginGroup := False;
  AIsVerticalDirection := False;
  AItemLink := nil;
  DragOverBarControl := GetDragOverBarControl(FindControl(WindowFromPointEx(ACursorPos)));
  if DragOverBarControl <> nil then
  begin
    ACursorPos := DragOverBarControl.ScreenToClient(ACursorPos);
    DragOverBarControl.CalcDragOverParameters(ACursorPos, AItemLink,
      AIsBeginGroup, AIsFirstPart, AIsVerticalDirection);
  end;
  DragOverItemLink := AItemLink;
  DragOverBeginGroup := AIsBeginGroup;
  DragOverFirstPart := AIsFirstPart;
  DragOverVerticalDirection := AIsVerticalDirection;
end;

function TdxBarDragInfo.CategoriesList: TListBox;
begin
  if (dxBarCustomizingForm <> nil) and (FDraggingItemLink = nil) and FBarManager.Designing then
    Result := dxBarCustomizingForm.CategoriesList
  else
    Result := nil;
end;

procedure TdxBarDragInfo.DragInfoChanged;
var
  ACursor: TCursor;
begin
  if FLockCount = 0 then
  begin
    case DraggingState of
      dsNoDrop:
        begin
          ACursor := crdxBarDragNoDrop;
          DrawDraggingLine(False);
          FDragOverItemLink := nil;
        end;
      dsDrag:
        begin
          DrawDraggingLine(False);
          ACursor := crdxBarDrag;
          if not NoNeedDragLine then
            DrawDraggingLine(True);
        end;
      dsCopy:
        begin
          DrawDraggingLine(False);
          ACursor := crdxBarDragCopy;
          DrawDraggingLine(True);
        end;
      dsCategory: ACursor := crdxBarDrag;
      dsBeginGroup:
        begin
          DrawDraggingLine(False);
          ACursor := crdxBarDrag;
        end;
    else {dsNoDrag}
      begin
        ACursor := FDefaultCursor;
        DrawDraggingLine(False);
      end;
    end;
    SetCursor(Screen.Cursors[ACursor]);
    FModified := False;
  end
  else
    FModified := True;
end;

procedure TdxBarDragInfo.DrawDraggingLine(AVisible: Boolean);

  procedure CalculateDragLineParameters;
  var
    ADragLineItemLink: TdxBarItemLink;
    AIsLastControl: Boolean;
    AParentLinks: TdxBarItemLinks;
  begin
    FDragLineVerticalDirection := DragOverVerticalDirection;

    if DragOverItemLink <> nil then
    begin
      ADragLineItemLink := DragOverItemLink;
      FDragLineFirstPart := DragOverFirstPart;
      AParentLinks := FDragOverItemLink.Owner;
      if FDragOverBeginGroup then
      begin
        if FDragLineFirstPart then
          ADragLineItemLink := AParentLinks.Prev(ADragLineItemLink, True);
        FDragLineFirstPart := not FDragLineFirstPart;
      end
      else
        if not FDragLineFirstPart then
        begin
          AIsLastControl := ADragLineItemLink.Control.FLastInRow or AParentLinks.Next(ADragLineItemLink, True).BeginGroup;
          if not AIsLastControl then
          begin
            ADragLineItemLink := AParentLinks.Next(ADragLineItemLink, True);
            FDragLineFirstPart := True;
          end;
        end;
      FDragLineRect := ADragLineItemLink.ItemRect;
    end
    else
    begin
      FDragLineFirstPart := True;
      FDragLineRect := DragLineBarControl.ClientRect;
    end;
  end;

begin
  if (FDragLineVisible <> AVisible) then
  begin
  (*
  {TODO CHECK IT}
      if not ADragLineVisible then
        FDragOverItemControl.Parent.Update;
    *)
    if AVisible then
    begin
      if DragOverBarControl <> nil then
      begin
        DragLineBarControl := DragOverBarControl;
        CalculateDragLineParameters;
        InternalDrawDraggingLine;
        FDragLineVisible := AVisible;
      end;
    end
    else
    begin
      if DragLineBarControl <> nil then
        InternalDrawDraggingLine;

      DragLineBarControl := nil;
      FDragLineVisible := AVisible;
    end;
  end;
end;

function TdxBarDragInfo.HasTarget: Boolean;
begin
  Result := (DragOverItemControl <> nil) or
    (DragOverBarControl <> nil) and (DragOverBarItemLinks.VisibleItemCount = 0);
end;

function TdxBarDragInfo.IsDragCopy: Boolean;
begin
  Result := (GetAsyncKeyState(VK_CONTROL) < 0) or (FDraggingItemLink = nil);
end;

function TdxBarDragInfo.NoNeedDragLine: Boolean;
begin
//#DG to drop on empty toolbar  Result := (FDragOverItemLink = nil) or
  Result := not HasTarget or //#DG to drop on empty toolbar
   ((DraggingItemLink <> nil) and
     ((DragOverItemLink = DraggingItemLink) and (not DragOverBeginGroup or not FDragOverFirstPart) or

       (FDraggingItemLink.VisibleIndex > 0) and
       (DragOverItemLink = FDraggingItemLink.Owner.Prev(FDraggingItemLink, True)) and
       (not FDraggingItemLink.BeginGroup and not FDragOverBeginGroup and not FDragOverFirstPart) or

       (FDraggingItemLink.VisibleIndex < (FDraggingItemLink.Owner.VisibleItemCount - 1)) and
       ((DragOverItemLink = FDraggingItemLink.Owner.Next(FDraggingItemLink, True)) and
         ((FDragOverBeginGroup or not DragOverItemLink.BeginGroup) and FDragOverFirstPart))));
end;

procedure TdxBarDragInfo.ChangeBeginGroup;
var
  ACursorPos: TPoint;
  ABeginGroup: Boolean;
  ACursorOffset: Integer;
begin
  ACursorPos := FDraggingItemLink.ScreenToClient(GetMouseCursorPos);
  if DragOverBarControl.IsVerticalDirection then
    ACursorOffset := ACursorPos.Y - FDragDownPoint.Y
  else
    ACursorOffset := ACursorPos.X - FDragDownPoint.X;
  ABeginGroup := ACursorOffset > 0;
  if Abs(ACursorOffset) >= MakeBeginGroupDragSize then
    if FDraggingItemLink.BeginGroup <> ABeginGroup then
    begin
      FDraggingItemLink.BarControl.SelectedLink := DraggingItemLink;
      FBarManager.InternalSetSelectedItem(DraggingControl);
      FDraggingItemLink.BeginGroup := ABeginGroup;
    end
    else
      FDraggingItemLink.BarControl.SetKeySelectedItem(DraggingControl);
end;

procedure TdxBarDragInfo.CreateNewItemLink;
var
  ASetBeginGroup{, ANeedRepaintBar}: Boolean;
  AItemLink: TdxBarItemLink;
begin
  FBarManager.LockDesignerModified(True);
  FBarManager.BeginUpdate; //#DG without this - AV, when dropped on empty subcontrol
  FBarManager.ItemList.BeginUpdate;
  DragOverBarItemLinks.BeginUpdate; //#DG
  try
    AItemLink := DragOverBarItemLinks.Add;
    begin
      AItemLink.InternalBringToTopInRecentList(True);

      if FDraggingItemLink <> nil then
      begin
        if not IsDragCopy then
          FDraggingItemLink.FIsMarkedForDeletion := True;
        try
          AItemLink.Assign(FDraggingItemLink);
        finally
          FDraggingItemLink.FIsMarkedForDeletion := False;
        end;
        AItemLink.FBeginGroup := False;
      end
      else
        AItemLink.Item := FDraggingItem;

      if DragOverItemLink <> nil then
      begin
        ASetBeginGroup := FDragOverBeginGroup and not FDragOverFirstPart or
          not FDragOverBeginGroup and FDragOverFirstPart and DragOverItemLink.BeginGroup;
        AItemLink.Index := DragOverItemLink.Index +
          Byte(not FDragOverBeginGroup and not FDragOverFirstPart);
        if ASetBeginGroup then
        begin
          AItemLink.BeginGroup := True;
          DragOverItemLink.BeginGroup := False;
        end;
      end;

      AItemLink.CreateControl;
      FBarManager.InternalSetSelectedItem(AItemLink.Control);
      DragOverBarControl.SelectedLink := AItemLink;

      //temp
      if not IsDragCopy then
        DeleteDraggingItemLink;

      { WHY ???
      if (FDraggingItemLink <> nil) and not IsDragCopy then
      begin
        ANeedRepaintBar := FDraggingItemLink.Owner <> DragOverBarItemLinks;
        DeleteDraggingItemlink;
      end
      else
        ANeedRepaintBar := True;

      if ANeedRepaintBar then
        DragOverBarControl.RepaintBar;
        }

      // activate barcontrol which contains new itemlink
      if (ActiveBarControl <> nil) and (DragOverBarControl is TdxBarControl) and
        (ActiveBarControl <> DragOverBarControl) then
      begin
        ActiveBarControl.HideAll;
        TdxBarControl(DragOverBarControl).BarGetFocus(AItemLink.Control);
      end;
      BarDesignController.SelectItem(AItemLink, soAdd);
    end
  finally
    DragOverBarItemLinks.EndUpdate;
    FBarManager.ItemList.CancelUpdate;
    FBarManager.EndUpdate;
    FBarManager.LockDesignerModified(False);
  end;
end;

procedure TdxBarDragInfo.DeleteDraggingItemLink;
begin
  if FDraggingItemLink <> nil then
    FDraggingItemLink.MoveBeginGroupItemIfNeeded;
  dxFreeAndNil(FDraggingItemLink);
  FBarManager.DesignerModified;
end;

procedure TdxBarDragInfo.InternalDrawDraggingLine;
const
  LineSize = 6;
  Pairs: array[0..5] of DWORD = (2, 2, 2, 2, 2, 2);

  procedure PolyPolyLine(ADC: HDC; const Points: array of TPoint);
  begin
    Windows.PolyPolyLine(ADC, Points, Pairs, 6);
  end;

var
  ADC: HDC;
  AOrigin: Integer;
begin
  ADC := DragLineBarControl.Canvas.Handle;
  SetROP2(ADC, R2_NOT);
  try
    with FDragLineRect do
      if FDragLineVerticalDirection then
      begin
        if FDragLineFirstPart then
          AOrigin := Top
        else
          AOrigin := Bottom - LineSize;
        PolyPolyLine(ADC,
          [Point(Left, AOrigin), Point(Left, AOrigin + LineSize),
           Point(Left + 1, AOrigin + 1), Point(Left + 1, AOrigin + LineSize - 1),

           Point(Left + 2, AOrigin + 2), Point(Right - 2, AOrigin + 2),
           Point(Left + 2, AOrigin + 3), Point(Right - 2, AOrigin + 3),

           Point(Right - 2, AOrigin + 1), Point(Right - 2, AOrigin + LineSize - 1),
           Point(Right - 1, AOrigin), Point(Right - 1, AOrigin + LineSize)]);
      end
      else
      begin
        if FDragLineFirstPart then
          AOrigin := Left
        else
          AOrigin := Right - LineSize;
        PolyPolyLine(ADC,
          [Point(AOrigin, Top), Point(AOrigin + LineSize, Top),
           Point(AOrigin + 1, Top + 1), Point(AOrigin + LineSize - 1, Top + 1),

           Point(AOrigin + 2, Top + 2), Point(AOrigin + 2, Bottom - 2),
           Point(AOrigin + 3, Top + 2), Point(AOrigin + 3, Bottom - 2),

           Point(AOrigin + 1, Bottom - 2), Point(AOrigin + LineSize - 1, Bottom - 2),
           Point(AOrigin, Bottom - 1), Point(AOrigin + LineSize, Bottom - 1)]);
      end;
  finally
    SetROP2(ADC, R2_COPYPEN);
  end;
end;

procedure TdxBarDragInfo.MoveItemToAnotherCategory;
begin
  if (CategoriesList <> nil) and (FDraggingItem.Category <> CategoriesList.ItemIndex) then
    FDraggingItem.Category := CategoriesList.ItemIndex;
end;

function TdxBarDragInfo.GetDraggingControl: TdxBarItemControl;
begin
  Result := GetControlByLink(FDraggingItemLink);
end;

function TdxBarDragInfo.GetDragLineBarControl: TCustomdxBarControl;
begin
  Result := TCustomdxBarControl(GetObjectByObjectLink(FDragLineBarControlLink));
end;

function TdxBarDragInfo.GetDragOverBarControl: TCustomdxBarControl;
begin
  Result := TCustomdxBarControl(GetObjectByObjectLink(FDragOverBarControlLink));
end;

function TdxBarDragInfo.GetDragOverBarItemLinks: TdxBarItemLinks;
begin
  if DragOverBarControl <> nil then
    Result := DragOverBarControl.ItemLinks
  else
    Result := nil;
end;

function TdxBarDragInfo.GetDragOverItemControl: TdxBarItemControl;
begin
  Result := GetControlByLink(FDragOverItemLink);
end;

procedure TdxBarDragInfo.SetDraggingState(Value: TdxBarDraggingState);
begin
  if FDraggingState <> Value then
  begin
    FDraggingState := Value;
    DragInfoChanged;
  end;
end;

procedure TdxBarDragInfo.SetDragLineBarControl(Value: TCustomdxBarControl);
begin
  cxRemoveObjectLink(FDragLineBarControlLink);
  FDragLineBarControlLink := cxAddObjectLink(Value);
end;

procedure TdxBarDragInfo.SetDragOverBarControl(Value: TCustomdxBarControl);
begin
  cxRemoveObjectLink(FDragOverBarControlLink);
  FDragOverBarControlLink := cxAddObjectLink(Value);
end;

procedure TdxBarDragInfo.SetDragOverBeginGroup(Value: Boolean);
begin
  if FDragOverBeginGroup <> Value then
  begin
    FDragOverBeginGroup := Value;
    DragInfoChanged;
  end;
end;

procedure TdxBarDragInfo.SetDragOverFirstPart(Value: Boolean);
begin
  if FDragOverFirstPart <> Value then
  begin
    FDragOverFirstPart := Value;
    DragInfoChanged;
  end;
end;

procedure TdxBarDragInfo.SetDragOverVerticalDirection(Value: Boolean);
begin
  if FDragOverVerticalDirection <> Value then
  begin
    FDragOverVerticalDirection := Value;
    DragInfoChanged;
  end;
end;

procedure TdxBarDragInfo.SetDragOverItemLink(Value: TdxBarItemLink);
begin
  if FDragOverItemLink <> Value then
  begin
    FDragOverItemLink := Value;

    if FDragOverItemLink <> nil then
    begin
      DrawDraggingLine(False);
      if (DragOverItemControl is TdxBarSubItemControl) or
        (DragOverBarControl.SelectedControl is TdxBarSubItemControl) then
        DragOverBarControl.SetMouseSelectedItem(DragOverItemControl)
      else
      begin  // for better painting
        FBarManager.SelectedItem := DragOverItemControl;
        DragOverBarControl.SelectedLink := DragOverItemLink;
      end;
      ProcessPaintMessages;
    end;

    DragInfoChanged;
  end;
end;

{ TdxBarImageOptions }

constructor TdxBarImageOptions.Create;
begin
  inherited;
  FNotifyComponent := TcxFreeNotificator.Create(nil);
  FNotifyComponent.OnFreeNotification := FreeNotification;

  FImagesChangeLink := TChangeLink.Create;
  FLargeImagesChangeLink := TChangeLink.Create;
  FHotImagesChangeLink := TChangeLink.Create;
  FDisabledImagesChangeLink := TChangeLink.Create;
  FDisabledLargeImagesChangeLink := TChangeLink.Create;

  FCacheGlyphs := True;
  FUseLeftBottomPixelAsTransparent := True;
  FStretchGlyphs := True;
  FImageListBkColor := clFuchsia;
  CalcGlyphSize;
end;

destructor TdxBarImageOptions.Destroy;
begin
  FreeAndNil(FDisabledImagesChangeLink);
  FreeAndNil(FDisabledLargeImagesChangeLink);
  FreeAndNil(FHotImagesChangeLink);
  FreeAndNil(FLargeImagesChangeLink);
  FreeAndNil(FImagesChangeLink);

  FreeAndNil(FNotifyComponent);
  inherited;
end;

procedure TdxBarImageOptions.Assign(Source: TPersistent);
begin
  if Source is TdxBarImageOptions then
  begin
    DisabledImages := TdxBarImageOptions(Source).DisabledImages;
    DisabledLargeImages := TdxBarImageOptions(Source).DisabledLargeImages;
    HotImages := TdxBarImageOptions(Source).HotImages;
    ImageListBkColor := TdxBarImageOptions(Source).ImageListBkColor;
    Images := TdxBarImageOptions(Source).Images;
    LargeImages := TdxBarImageOptions(Source).LargeImages;
    LargeIcons := TdxBarImageOptions(Source).LargeIcons;
    MakeDisabledImagesFaded := TdxBarImageOptions(Source).MakeDisabledImagesFaded;
    SmoothGlyphs := TdxBarImageOptions(Source).SmoothGlyphs;
    StretchGlyphs := TdxBarImageOptions(Source).StretchGlyphs;
    UseLargeImagesForLargeIcons := TdxBarImageOptions(Source).UseLargeImagesForLargeIcons;
    UseLeftBottomPixelAsTransparent := TdxBarImageOptions(Source).UseLeftBottomPixelAsTransparent;
  end
  else
    inherited Assign(Source);
end;

function TdxBarImageOptions.GetIsLoading: Boolean;

  function InternalIsLoading(AImages: TCustomImageList): Boolean;
  begin
    Result := (AImages <> nil) and (csLoading in AImages.ComponentState);
  end;

begin
  Result := InternalIsLoading(FImages) or InternalIsLoading(FDisabledImages) or
    InternalIsLoading(FDisabledLargeImages) or InternalIsLoading(FHotImages) or
    InternalIsLoading(FLargeImages);
end;

procedure TdxBarImageOptions.SetImageList(var ANewValue, AOldValue: TCustomImageList; const AChangeLink: TChangeLink);
begin
  cxSetImageList(ANewValue, AOldValue, AChangeLink, FNotifyComponent);
end;

procedure TdxBarImageOptions.SetHotImages(Value: TCustomImageList);
begin
  SetImageList(Value, FHotImages, FHotImagesChangeLink);
end;

procedure TdxBarImageOptions.SetImageListBkColor(Value: TColor);
begin
  if FImageListBkColor <> Value then
  begin
    FImageListBkColor := Value;
    CallNotify(FOnImageOptionsChange, Self);
  end;
end;

procedure TdxBarImageOptions.SetImages(Value: TCustomImageList);
begin
  SetImageList(Value, FImages, FImagesChangeLink);
end;

procedure TdxBarImageOptions.SetDisabledImages(Value: TCustomImageList);
begin
  SetImageList(Value, FDisabledImages, FDisabledImagesChangeLink);
end;

procedure TdxBarImageOptions.SetDisabledLargeImages(Value: TCustomImageList);
begin
  SetImageList(Value, FDisabledLargeImages, FDisabledLargeImagesChangeLink);
end;

procedure TdxBarImageOptions.SetLargeIcons(Value: Boolean);
begin
  if FLargeIcons <> Value then
  begin
    FLargeIcons := Value;
    CallNotify(FOnLargeIconsChange, Self);
  end;
end;

procedure TdxBarImageOptions.SetLargeImages(Value: TCustomImageList);
begin
  if FLargeImages <> Value then
  begin
    SetImageList(Value, FLargeImages, FLargeImagesChangeLink);
    if LargeIcons and UseLargeImagesForLargeIcons then
      CallNotify(FOnLargeIconsChange, Self);
  end;
end;

procedure TdxBarImageOptions.SetMakeDisabledImagesFaded(Value: Boolean);
begin
  if FMakeDisabledImagesFaded <> Value then
  begin
    FMakeDisabledImagesFaded := Value;
    CallNotify(FOnImageOptionsChange, Self);
  end;
end;

procedure TdxBarImageOptions.SetUseLargeImagesForLargeIcons(Value: Boolean);
begin
  if FUseLargeImagesForLargeIcons <> Value then
  begin
    FUseLargeImagesForLargeIcons := Value;
    CallNotify(FOnImageOptionsChange, Self);
  end;
end;

procedure TdxBarImageOptions.SetUseLeftBottomPixelAsTransparent(Value: Boolean);
begin
  if FUseLeftBottomPixelAsTransparent <> Value then
  begin
    FUseLeftBottomPixelAsTransparent := Value;
    CallNotify(FOnImageOptionsChange, Self);
  end;
end;

procedure TdxBarImageOptions.CalcGlyphSize;
begin
  if LargeIcons then
  begin
    if IsLargeImagesForLargeIcons then
      FGlyphSize := LargeImages.Width
    else
      FGlyphSize := DefautGlyphSize * 2;
  end
  else
    FGlyphSize := DefautGlyphSize; // * (1 + Byte(FLargeIcons));
end;

function TdxBarImageOptions.IsLargeImagesForLargeIcons: Boolean;
begin
  Result := UseLargeImagesForLargeIcons and (LargeImages <> nil);
end;

procedure TdxBarImageOptions.FreeNotification(AComponent: TComponent);
begin
  if AComponent = DisabledLargeImages then DisabledLargeImages := nil;
  if AComponent = DisabledImages then DisabledImages := nil;
  if AComponent = HotImages then HotImages := nil;
  if AComponent = Images then Images := nil;
  if AComponent = LargeImages then LargeImages := nil;
end;

{ TdxBarManager }

constructor TdxBarManager.Create(AOwner: TComponent);
begin
  Include(FInternalState, bisCreating);
  if (AOwner = nil) and (Application.MainForm <> nil) then
    AOwner := Application.MainForm;
  if not (AOwner is TWinControl) then
    raise EdxException.Create(cxGetResourceString(@dxSBAR_BARMANAGERBADOWNER));
  if GetBarManagerByComponent(AOwner) <> nil then
    raise EdxException.Create(cxGetResourceString(@dxSBAR_BARMANAGERMORETHANONE));
  Exclude(FInternalState, bisCreating);

  inherited Create(AOwner);

  RegisterdxBarManager(Self);
  FBackgrounds := TdxBarBackgrounds.Create(Self);
  FLookAndFeel := TcxLookAndFeel.Create(Self);
  FLookAndFeel.OnChanged := LFChanged;
  Style := bmsEnhanced;
  FAllowReset := True;
  FAutoDockColor := True;

  FInternalItems := TComponentList.Create;
  FItems := TdxBarComponentList.Create; //#DG list

  FCategories := TdxBarManagerCategories.Create(Self);
  FDockControls := TList.Create;
  FPopupMenus := TComponentList.Create(False);
  FBars := TdxBars.Create(Self);

  FReadIniFileHandlers := TcxEventHandlerCollection.Create;
  FWriteIniFileHandlers := TcxEventHandlerCollection.Create;
  FMDIStateChangedHandlers := TcxEventHandlerCollection.Create;
  FSystemFontChangedHandlers := TcxEventHandlerCollection.Create;

  FCanCustomize := True;
  FDockColor := clBtnFace;
  FBarCaptionFont := TFont.Create;
  FEditFont := TFont.Create;
  FFont := TFont.Create;
  FFont.OnChange := FontChanged;

  FGroups := TdxBarComponentList.Create; //#DG list

  FHelpButtonGlyph := dxBarCreateBitmap(HelpButtonGlyphChanged);
  FHideFloatingBarsWhenInactive := True;

  FThemeChangedNotificator := TdxThemeChangedNotificator.Create;
  FThemeChangedNotificator.OnThemeChanged := ThemeChanged;
  FButtonArrowWidth := dxBarDefaultButtonArrowWidth;
  FLargeButtonArrowWidth := dxBarDefaultLargeButtonArrowWidth;
  FMenusShowRecentItemsFirst := True;
  FMostRecentItemsPercents := 95;
  CalcMostRecentlyUsedUseCount;
  FPopupMenuLinks := TdxBarPopupMenuLinks.Create(Self);
  FScaled := True;
  FShowFullMenusAfterDelay := True;
  FShowHint := True;
  FShowHintForDisabledItems := True;

  FUseF10ForMenu := True;
  UseSystemFont := True;
  FWaitForDockingTime := 21;
  CreateToolbarsBrushes;

  FDragInfo := TdxBarDragInfo.Create(Self);

  FImageOptions := TdxBarImageOptions.Create(Self);
  FImageOptions.FImagesChangeLink.OnChange := ImageListChange;
  FImageOptions.FLargeImagesChangeLink.OnChange := LargeImageListChange;
  FImageOptions.FHotImagesChangeLink.OnChange := HotImageListChange;
  FImageOptions.FDisabledImagesChangeLink.OnChange := DisabledImageListChange;
  FImageOptions.FDisabledLargeImagesChangeLink.OnChange := DisabledLargeImageListChange;
  FImageOptions.FOnImageOptionsChange := ImageOptionsChange;
  FImageOptions.FOnLargeIconsChange := LargeIconsChange;
  if not (csDesigning in ComponentState) then
    FSavedState := TMemIniFile.Create('');
end;

destructor TdxBarManager.Destroy;
begin
  if not (bisCreating in FInternalState) then
  begin
    UnregisterdxBarManager(Self);

    FHintObject := nil;
    FreeAndNil(FSavedState);
    FreeAndNil(FImageOptions);
    FreeAndNil(FDragInfo);
    FreeAndNil(FLookAndFeel);

    FreeAndNil(FThemeChangedNotificator);

    if FHintTimerID <> 0 then
    begin
      KillHintTimer;
      HideHint;
    end;
    KillHiddenHintTimer;
    Customizing(False);

    DestroyToolbarsBrushes;
    FPopupMenus.OwnsObjects := True;
    FreeAndNil(FPopupMenus);
    FreeAndNil(FHelpButtonGlyph);
    FGroups.OwnsObjects := True;
    FreeAndNil(FGroups);
    FreeAndNil(FFont);
    FreeAndNil(FEditFont);
    FreeAndNil(FBarCaptionFont);
    dxFreeAndNil(FBars);

    FreeAndNil(FMDIStateChangedHandlers);
    FreeAndNil(FSystemFontChangedHandlers);
    FreeAndNil(FReadIniFileHandlers);
    FreeAndNil(FWriteIniFileHandlers);

    FreeAndNil(FDockControls);
    DestroyItems;
//#DG    UnregisterdxBarManager(Self);
    FreeAndNil(FCategories);
    DestroyBarRestoringList;
    FreeAndNil(FPopupMenuLinks);
    FreeAndNil(FBackgrounds);
    FreeAndNil(FDefaultPainter);
  end;
  inherited Destroy;
end;

procedure TdxBarManager.ActivateHint(AShow: Boolean; const CustomHint: string; AHintObject: TObject = nil);
begin
  if not IsCustomizing and ShowHint then
  begin
    if AShow and FHintWindow.IsScreenTipWindow then
      DoActivateHint(False, '', nil);
    DoActivateHint(AShow, CustomHint, AHintObject);
  end;
end;

procedure TdxBarManager.HideHint;
begin
  ActivateHint(False, '');
end;

procedure TdxBarManager.BeginUpdate;
begin
  Inc(FLockUpdateCount);
  if FLockUpdateCount = 1 then
    DoLockUpdate(True, False);
end;

procedure TdxBarManager.EndUpdate(ACheckBarsChanges: Boolean = True);
begin
  Dec(FLockUpdateCount);
  if (FLockUpdateCount = 0) and not IsDestroying then
    DoLockUpdate(False, ACheckBarsChanges);
end;

procedure TdxBarManager.InternalSetSelectedItem(Value: TdxBarItemControl);
begin
  FSelectedItem := Value;
end;

function TdxBarManager.GetBarControlFocused: Boolean;
begin
  Result := FFocusedBarControl <> nil;
end;

function TdxBarManager.GetBarsLoading: Boolean;
begin
  Result := bisBarsLoading in FInternalState;
end;

function TdxBarManager.GetCanModifyDesigner: Boolean;
begin
  Result := FLockDesignerModifiedCount = 0;
end;

function TdxBarManager.GetCategoryItemsVisible(AIndex: Integer): TdxBarItemVisible;
begin
  if (0 <= AIndex) and (AIndex < FCategories.Count) then
    with FCategories do
      if Objects[AIndex] = nil then
        Result := ivAlways
      else
        Result := TdxBarCategoryData(Objects[AIndex]).ItemsVisible
  else Result := ivNever;
end;

function TdxBarManager.GetCategoryVisible(AIndex: Integer): Boolean;
begin
  if (0 <= AIndex) and (AIndex < FCategories.Count) then
    with FCategories do
      Result := (Objects[AIndex] = nil) or TdxBarCategoryData(Objects[AIndex]).Visible
  else Result := False;
end;

function TdxBarManager.GetDesigning: Boolean;
begin
  Result := csDesigning in ComponentState;
end;

function TdxBarManager.GetDockColor: TColor;
begin
  if FAutoDockColor then
    Result := TControlAccess(Owner).Color
  else
    Result := FDockColor;
end;

function TdxBarManager.GetDockControl(Index: Integer): TdxDockControl;
begin
  Result := FDockControls[Index];
end;

function TdxBarManager.GetDockControlCount: Integer;
begin
  Result := FDockControls.Count;
end;

function TdxBarManager.GetDragging: Boolean;
begin
  Result := DragInfo.DraggingState <> dsNoDrag;
end;

function TdxBarManager.GetDraggingItem: TdxBarItem;
begin
  Result := DragInfo.DraggingItem;
end;

function TdxBarManager.GetDraggingItemLink: TdxBarItemLink;
begin
  Result := DragInfo.DraggingItemLink;
end;

function TdxBarManager.GetFlat: Boolean;
begin
  Result := FStyle = bmsFlat;
end;

function TdxBarManager.GetFlatToolbarsBorderColor: COLORREF;

  function GetDarkValue(Value: Byte): Byte;
  begin
    Result := MulDiv(Value, 8, 10);
  end;

begin
  Result := GetSysColor(COLOR_BTNSHADOW);
  Result := RGB(
    GetDarkValue(GetRValue(Result)),
    GetDarkValue(GetGValue(Result)),
    GetDarkValue(GetBValue(Result)));
  Result := GetRealColor(Result);
end;

function TdxBarManager.GetFlatToolbarsColor: COLORREF;

  function GetLightValue(Value: Byte): Byte;
  begin
    Result := Value + MulDiv(255 - Value, 16, 100);
  end;

begin
  Result := GetSysColor(COLOR_BTNFACE);
  Result := RGB(
    GetLightValue(GetRValue(Result)),
    GetLightValue(GetGValue(Result)),
    GetLightValue(GetBValue(Result)));
  Result := GetRealColor(Result);
end;

function TdxBarManager.GetFlatToolbarsDownedColor: COLORREF;
begin
  Result := GetRealColor(GetLightColor(11, 9, 73));
end;

function TdxBarManager.GetFlatToolbarsDownedSelColor: COLORREF;
begin
  Result := GetRealColor(GetLightColor(14, 44, 40));
end;

function TdxBarManager.GetFlatToolbarsSelColor: COLORREF;
begin
  Result := GetRealColor(GetLightColor(-2, 30, 72));
end;

function TdxBarManager.GetGroup(Index: Integer): TdxBarGroup;
begin
  Result := TdxBarGroup(FGroups[Index]);
end;

function TdxBarManager.GetGroupCount: Integer;
begin
  Result := FGroups.Count;
end;

function TdxBarManager.GetInternalDockControl(
  ADockingStyle: TdxBarDockedDockingStyle): TdxDockControl;
begin
  Result := DockControls[Integer(ADockingStyle) - 1];
end;

function TdxBarManager.GetIsCustomizing: Boolean;
begin
  Result := FIsCustomizing or Designing;
end;

function TdxBarManager.GetIsDestroying: Boolean;
begin
  Result := csDestroying in ComponentState;
end;

function TdxBarManager.GetIsHandleCreating: Boolean;
begin
  Result := bisHandleCreating in FInternalState;
end;

function TdxBarManager.GetIsInitializing: Boolean;
begin
  Result := IsLoading or (bisAfterLoading in FInternalState);
end;

function TdxBarManager.GetItemCount: Integer;
begin
  Result := FItems.Count;
end;

function TdxBarManager.GetItem(Index: Integer): TdxBarItem;
begin
  if (0 <= Index) and (Index < FItems.Count) then
    Result := TdxBarItem(FItems[Index])
  else
    Result := nil;
end;

function TdxBarManager.GetLastSelectedLinkAtDesign: TdxBarItemLink;
var
  ASelectedItem: TPersistent;
begin
{
#DG remove from BarControl
  if BarManager.Dragging then
    Result := BarManager.DraggingItemLink
  else
    if (SelectedItem = BarManager.SelectedItem) and (SelectedItem <> nil) then
      Result := BarManager.SelectedItem.ItemLink
    else
      Result := nil
}
  ASelectedItem := GetInstance(BarDesignController.LastSelectedItem);
  if not(ASelectedItem is TdxBarItemLink) or (TdxBarItemLink(ASelectedItem).BarManager <> Self) then
    ASelectedItem := nil;

  Result := TdxBarItemLink(ASelectedItem);
end;

function TdxBarManager.GetRestoringListBar(Index: Integer): TdxBar;
begin
  Result := TdxBar(FBarRestoringList[Index]);
end;

function TdxBarManager.GetRestoringListBarCount: Integer;
begin
  if BarRestoringListExists then
    Result := FBarRestoringList.Count
  else
    Result := 0;
end;

function TdxBarManager.GetTabOrder: Integer;
begin
  Result := dxBarManagerList.IndexOf(Self);
end;

procedure TdxBarManager.IniFileCollectionCallMethods(ACollection: TcxEventHandlerCollection;
  AIniFile: TCustomIniFile; AStoringKind: TdxBarStoringKind; ASection: string);
var
  AIniFileEventData: TdxBarIniFileEventData;
begin
  AIniFileEventData.IniFile := AIniFile;
  AIniFileEventData.StoringKind := AStoringKind;
  AIniFileEventData.BaseSection := ASection;
  AIniFileEventData.Delimiter := GetSectionDelimiter(AStoringKind);
  ACollection.CallEvents(Self, AIniFileEventData);
end;

function TdxBarManager.InternalGetPainterClass: TdxBarPainterClass;
begin
  Result := TdxBarPainterClass(DefaultPainter.ClassType);
end;

procedure TdxBarManager.SetAutoAlignBars(Value: Boolean);
begin
  if FAutoAlignBars <> Value then
  begin
    FAutoAlignBars := Value;
    DoLockUpdate(False, False);
  end;
end;

procedure TdxBarManager.SetAutoDockColor(Value: Boolean);
var
  I: Integer;
begin
  if FAutoDockColor <> Value then
  begin
    FAutoDockColor := Value;
    for I := 0 to DockControlCount - 1 do
      DockControls[I].ColorChanged;
  end;
end;

procedure TdxBarManager.SetAutoHideEmptyBars(Value: Boolean);
var
  I: Integer;
begin
  if FAutoHideEmptyBars <> Value then
  begin
    FAutoHideEmptyBars := Value;
    if not Value then
      for I := 0 to FBars.Count - 1 do
        Bars[I].FInternallyHidden := False;
  end;
end;

procedure TdxBarManager.SetBackgrounds(Value: TdxBarBackgrounds);
begin
  FBackgrounds.Assign(Value);
end;

procedure TdxBarManager.SetButtonArrowWidth(Value: Integer);
begin
  if FButtonArrowWidth <> Value then
  begin
    if Value < 2 then Exit;
    FButtonArrowWidth := Value;
    Bars.Repaint;
  end;
end;

procedure TdxBarManager.SetCategories(Value: TStrings);
begin
  Categories.Assign(Value);
end;

procedure TdxBarManager.SetCategoryItemsVisible(AIndex: Integer; Value: TdxBarItemVisible);
var
  ACategoryData: TdxBarCategoryData;
  AEmptyBars, AList: TList;
  APrevValue: TdxBarItemVisible;
  I: Integer;
begin
  if (AIndex < 0) or (AIndex >= FCategories.Count) then
    Exit;

  APrevValue := CategoryItemsVisible[AIndex];
  with FCategories do
  begin
    ACategoryData := TdxBarCategoryData(Objects[AIndex]);
    if ACategoryData = nil then
    begin
      Objects[AIndex] := TdxBarCategoryData.Create;
      ACategoryData := TdxBarCategoryData(Objects[AIndex]);
      ACategoryData.ItemsVisible := ivAlways;
      ACategoryData.Visible := True;
    end;
    if Self.IsLoading then
    begin
      ACategoryData.LoadedItemsVisible := Value;
      Exit;
    end;
    ACategoryData.ItemsVisible := Value;

    if not Designing then
    begin
      AEmptyBars := nil;
      if AutoHideEmptyBars then
      begin
        AEmptyBars := TList.Create;
        for I := 0 to FBars.Count - 1 do
          if FBars[I].ItemLinks.AvailableItemCount = 0 then AEmptyBars.Add(FBars[I]);
      end;
      Self.BeginUpdate;

      AList := TList.Create;
      try
        GetAllItemsByCategory(AIndex, AList);
        if Value = ivAlways then
        begin
          for I := AList.Count - 1 downto 0 do
            if TdxBarItem(AList[I]).Visible = APrevValue then
              TdxBarItem(AList[I]).Visible := Value;
        end
        else
          for I := 0 to AList.Count - 1 do
            if TdxBarItem(AList[I]).Visible = APrevValue then
              TdxBarItem(AList[I]).Visible := Value;
      finally
        AList.Free;

        if AutoHideEmptyBars then
          for I := 0 to Bars.Count - 1 do
            if (Value = ivNever) and (Bars[I].ItemLinks.AvailableItemCount = 0) and (AEmptyBars.IndexOf(Bars[I]) = -1) or
              (Value = ivAlways) and (Bars[I].ItemLinks.AvailableItemCount > 0) and Bars[I].FInternallyHidden then
            begin
              Bars[I].Visible := Value = ivAlways;
              Bars[I].FInternallyHidden := Value = ivNever;
            end;
        FreeAndNil(AEmptyBars);
        Self.EndUpdate;
      end;
    end;
  end;
  if Value <> APrevValue then
    DesignerModified;
end;

procedure TdxBarManager.SetCategoryVisible(AIndex: Integer; Value: Boolean);
begin
  if (0 <= AIndex) and (AIndex < FCategories.Count) and
    (CategoryVisible[AIndex] <> Value) then
  begin
    with FCategories do
    begin
      if Objects[AIndex] = nil then
      begin
        Objects[AIndex] := TdxBarCategoryData.Create;
        TdxBarCategoryData(Objects[AIndex]).ItemsVisible := ivAlways;
      end;
      TdxBarCategoryData(Objects[AIndex]).Visible := Value;
    end;
    DesignerModified;
  end;
end;

function TdxBarManager.GetMainForm: TCustomForm;
begin
  Result := GetBarManagerForm(Self, fkMain);
end;

function TdxBarManager.GetMainMenuControl: TdxBarControl;
begin
  if MainMenuBar <> nil then
    Result := FMainMenuBar.Control
  else
    Result := nil;
end;

function TdxBarManager.GetMasterForm: TCustomForm;
begin
  Result := GetBarManagerForm(Self, fkMainOrMDIChild);
end;

function TdxBarManager.GetNotDocking: TdxBarDockingStyles;
begin
  Result := FNotDocking;
end;

function TdxBarManager.GetParentBarManager: TdxBarManager;
begin
  Result := nil;
  if Owner.HandleAllocated then
    Result := GetBarManagerForComponent(GetChildWindowVCLParent(Owner.Handle));
end;

function TdxBarManager.GetParentedOwner: TWinControl;
begin
  Result := TWinControl(inherited Owner);
end;

function TdxBarManager.GetParentForm: TCustomForm;
begin
  Result := GetBarManagerForm(Self, fkAny);
end;

procedure TdxBarManager.SetDockColor(Value: TColor);
var
  I: Integer;
begin
  if FDockColor <> Value then
  begin
    FDockColor := Value;
    FAutoDockColor := False;
    for I := 0 to DockControlCount - 1 do
      DockControls[I].ColorChanged;
  end;
end;

procedure TdxBarManager.SetFlatCloseButton(Value: Boolean);
begin
  if FFlatCloseButton <> Value then
  begin
    FFlatCloseButton := Value;
    if MainMenuControl <> nil then
    begin
    //#DG <BarManager.SelectedItem>
      if (SelectedItem <> nil) and (SelectedItem.Parent = MainMenuControl) then
        SelectedItem := nil;
      MainMenuControl.RepaintBar;
    end;
  end;
end;

procedure TdxBarManager.SetFont(Value: TFont);
begin
  Font.Assign(Value);
end;

procedure TdxBarManager.SetHelpButtonGlyph(Value: TBitmap);
begin
  FHelpButtonGlyph.Assign(Value);
end;

procedure TdxBarManager.SetHideFloatingBarsWhenInactive(Value: Boolean);
begin
  if FHideFloatingBarsWhenInactive <> Value then
  begin
    FHideFloatingBarsWhenInactive := Value;
    ShowToolbars(FMainFormActive or not FHideFloatingBarsWhenInactive, False, 0);
  end;
end;

procedure TdxBarManager.SetDraggingItem(Value: TdxBarItem);
begin
  DragInfo.DraggingItem := Value;
end;

procedure TdxBarManager.SetDraggingItemLink(Value: TdxBarItemLink);
begin
  DragInfo.DraggingItemLink := Value;
end;

function TdxBarManager.GetIsLoading: Boolean;
begin
  Result := csLoading in ComponentState;
end;

function TdxBarManager.GetIsRecreating: Boolean;
begin
{$IFDEF DELPHI10}
  Result := csRecreating in Owner.ControlState;
{$ELSE}
  Result := False;
{$ENDIF}
end;

function TdxBarManager.GetIsStateSaving: Boolean;
begin
  Result := bisStateSaving in FInternalState;
end;

procedure TdxBarManager.SetLargeButtonArrowWidth(Value: Integer);
var
  I: Integer;
begin
  if FLargeButtonArrowWidth <> Value then
  begin
    if Value < 2 then Exit;
    FLargeButtonArrowWidth := Value;
    for I := 0 to Bars.Count - 1 do
      with Bars[I] do
        if Control <> nil then Control.RepaintBar;
  end;
end;

procedure TdxBarManager.SetLockUpdate(Value: Boolean);
begin
  if Value <> FLockUpdate then
  begin
    FLockUpdate := Value;
    if FLockUpdate then
      BeginUpdate
    else
      EndUpdate(False);
  end;
end;

procedure TdxBarManager.SetLookAndFeel(Value: TcxLookAndFeel);
begin
  FLookAndFeel.Assign(Value);
end;

procedure TdxBarManager.SetMenuAnimations(Value: TdxBarMenuAnimations);
begin
  if FMenuAnimations <> Value then
  begin
    FMenuAnimations := Value;
    DesignerModified;
    UpdateBarManagerOptions;
  end;
end;

procedure TdxBarManager.SetMenusShowRecentItemsFirst(Value: Boolean);
begin
  if FMenusShowRecentItemsFirst <> Value then
  begin
    FMenusShowRecentItemsFirst := Value;
    DesignerModified;
    UpdateBarManagerOptions;
  end;
end;

procedure TdxBarManager.SetMostRecentItemsPercents(Value: Byte);
begin
  if Value > 100 then Value := 100;
  FMostRecentItemsPercents := Value;
  CalcMostRecentlyUsedUseCount;
end;

procedure TdxBarManager.SetNotDocking(Value: TdxBarDockingStyles);
begin
  if FNotDocking <> Value then
  begin
    FNotDocking := Value;
    InternalStyleChanged; // TODO: ???
  end;
end;

procedure TdxBarManager.SetPopupMenuLinks(Value: TdxBarPopupMenuLinks);
begin
  FPopupMenuLinks.Assign(Value);
end;

procedure TdxBarManager.SetRegistryPath(Value: string);
begin
  FRegistryPath := Value;
  CorrectRegistryPath(FRegistryPath);
end;

procedure TdxBarManager.SetScaled(Value: Boolean);
begin
  if FScaled <> Value then
  begin
    FScaled := Value;
    if Value and not FUseSystemFont then AssignFont;
  end;
end;

procedure TdxBarManager.SetSelectedItem(Value: TdxBarItemControl);
//#DG var
//#DG   OldSelectedItem: TdxBarItemControl;
begin
  if FSelectedItem <> Value then
  begin
    if IsCustomizing and (FSelectedItem <> nil) and
      ((Value = nil) or
       (GetParentBarForControl(Value) <> GetParentBarForControl(FSelectedItem))) then
      if GetParentBarForControl(FSelectedItem) <> nil then
        GetParentBarForControl(FSelectedItem).SetMouseSelectedItem(nil)
      else
        if (dxBarSubMenuEditor <> nil) and (GetParentBarOrSubMenuForControl(FSelectedItem) =
          dxBarSubMenuEditor.ItemLinks.BarControl) then
            dxBarSubMenuEditor.ItemLinks.DestroyBarControl;
//#DG    OldSelectedItem := FSelectedItem;
    InternalSetSelectedItem(Value);
{#DG may be un necessary ?
    if (OldSelectedItem <> nil) and (OldSelectedItem.Parent <> nil) and not Dragging then
      OldSelectedItem.Repaint;
}
{#DG
    if Designing and (FSelectedItem <> nil) and not Dragging then
      SelectComponent(FSelectedItem.ItemLink.Item);
}
(* #DG LastSelectedObject idea
    if (Value = nil) and IsCustomizing and not Designing then
      SelectedLink := nil;
*)
  end;
end;

procedure TdxBarManager.SetShowCloseButton(Value: Boolean);
begin
  if FShowCloseButton <> Value then
  begin
    FShowCloseButton := Value;
    if MainMenuControl <> nil then
    begin
    //#DG <BarManager.SelectedItem>
      if (SelectedItem <> nil) and (SelectedItem.Parent = MainMenuControl) then
        SelectedItem := nil;
      MainMenuControl.RepaintBar;
    end;
  end;
end;

procedure TdxBarManager.SetShowFullMenusAfterDelay(Value: Boolean);
begin
  if FShowFullMenusAfterDelay <> Value then
  begin
    FShowFullMenusAfterDelay := Value;
    DesignerModified;
    UpdateBarManagerOptions;
  end;
end;

procedure TdxBarManager.SetShowHelpButton(Value: Boolean);
begin
  if FShowHelpButton <> Value then
  begin
    FShowHelpButton := Value;
    UpdateHelpButton;
  end;
end;

procedure TdxBarManager.SetShowHint(Value: Boolean);
begin
  if FShowHint <> Value then
  begin
    FShowHint := Value;
    DesignerModified;
    UpdateBarManagerOptions;
  end;
end;

procedure TdxBarManager.SetShowShortCutInHint(Value: Boolean);
begin
  if FShowShortCutInHint <> Value then
  begin
    FShowShortCutInHint := Value;
    DesignerModified;
    UpdateBarManagerOptions;
  end;
end;

procedure TdxBarManager.SetStyle(Value: TdxBarManagerStyle);
begin
  if FStyle <> Value then
  begin
    FStyle := Value;
    InternalStyleChanged;
  end;
end;

procedure TdxBarManager.SetSunkenBorder(Value: Boolean);
var
  I: Integer;
begin
  if FSunkenBorder <> Value then
  begin
    FSunkenBorder := Value;
    for I := 0 to DockControlCount - 1 do
      DockControls[I].NCChanged;
  end;
end;

procedure TdxBarManager.SetTabOrder(Value: Integer);
begin
  if Value < 0 then Value := 0;
  if Value >= dxBarManagerList.Count then Value := dxBarManagerList.Count - 1;
  dxBarManagerList.Move(dxBarManagerList.IndexOf(Self), Value);
end;

procedure TdxBarManager.SetUseSystemFont(Value: Boolean);
begin
  if FUseSystemFont <> Value then
  begin
    FUseSystemFont := Value;
    if FUseSystemFont then
      OwnerWndProc(0, WM_SETTINGCHANGE, SPI_SETNONCLIENTMETRICS, 0);
  end;
end;

procedure TdxBarManager.SetWaitForDockingTime(Value: Integer);
begin
  if Value >= 0 then FWaitForDockingTime := Value;
end;

function TdxBarManager.GetDisabledImages: TCustomImageList;
begin
  Result := FImageOptions.DisabledImages;
end;

function TdxBarManager.GetDisabledLargeImages: TCustomImageList;
begin
  Result := FImageOptions.DisabledLargeImages;
end;

function TdxBarManager.GetGlyphSize: Integer;
begin
  Result := FImageOptions.FGlyphSize;
end;

function TdxBarManager.GetHotImages: TCustomImageList;
begin
  Result := FImageOptions.HotImages;
end;

function TdxBarManager.GetImageListBkColor: TColor;
begin
  Result := FImageOptions.FImageListBkColor;
end;

function TdxBarManager.GetImages: TCustomImageList;
begin
  Result := FImageOptions.Images;
end;

function TdxBarManager.GetLargeImages: TCustomImageList;
begin
  Result := FImageOptions.LargeImages;
end;

function TdxBarManager.GetLargeIcons: Boolean;
begin
  Result := FImageOptions.LargeIcons;
end;

function TdxBarManager.GetMainMenuBar: TdxBar;
begin
  Result := FMainMenuBar;
  if (Result <> nil) and (Result.Control <> nil) and not Result.Control.IsMainMenu then
    Result := nil;
end;

function TdxBarManager.GetMakeDisabledImagesFaded: Boolean;
begin
  Result := FImageOptions.MakeDisabledImagesFaded;
end;

function TdxBarManager.GetStretchGlyphs: Boolean;
begin
  Result := FImageOptions.StretchGlyphs;
end;

function TdxBarManager.GetUseLargeImagesForLargeIcons: Boolean;
begin
  Result := FImageOptions.UseLargeImagesForLargeIcons;
end;

procedure TdxBarManager.SetDisabledImages(Value: TCustomImageList);
begin
  FImageOptions.DisabledImages := Value;
end;

procedure TdxBarManager.SetDisabledLargeImages(Value: TCustomImageList);
begin
  FImageOptions.DisabledLargeImages := Value;
end;

procedure TdxBarManager.SetGlyphSize(Value: Integer);
begin
  FImageOptions.FGlyphSize := Value;
end;

procedure TdxBarManager.SetHotImages(Value: TCustomImageList);
begin
  FImageOptions.HotImages := Value;
end;

procedure TdxBarManager.SetImageListBkColor(Value: TColor);
begin
  FImageOptions.ImageListBkColor := Value;
end;

procedure TdxBarManager.SetImages(Value: TCustomImageList);
begin
  FImageOptions.Images := Value;
end;

procedure TdxBarManager.SetLargeIcons(Value: Boolean);
begin
  FImageOptions.LargeIcons := Value;
end;

procedure TdxBarManager.SetLargeImages(Value: TCustomImageList);
begin
  FImageOptions.LargeImages := Value;
end;

procedure TdxBarManager.SetMakeDisabledImagesFaded(Value: Boolean);
begin
  FImageOptions.MakeDisabledImagesFaded := Value;
end;

procedure TdxBarManager.SetStretchGlyphs(Value: Boolean);
begin
  FImageOptions.StretchGlyphs := Value;
end;

procedure TdxBarManager.SetUseLargeImagesForLargeIcons(Value: Boolean);
begin
  FImageOptions.UseLargeImagesForLargeIcons := Value;
end;

procedure TdxBarManager.DisabledImageListChange(Sender: TObject);
begin
  CustomImagesChanged(DisabledImagesChanged);
end;

procedure TdxBarManager.DisabledLargeImageListChange(Sender: TObject);
begin
  CustomImagesChanged(DisabledLargeImagesChanged);
end;

procedure TdxBarManager.HotImageListChange(Sender: TObject);
begin
  CustomImagesChanged(HotImagesChanged);
end;

procedure TdxBarManager.ImageListChange(Sender: TObject);
begin
  CustomImagesChanged(ImagesChanged);
end;

procedure TdxBarManager.ImageOptionsChange(Sender: TObject);
begin
  Bars.Repaint;
end;

procedure TdxBarManager.LargeIconsChange;
begin
  FImageOptions.CalcGlyphSize;
  DesignerModified;
  UpdateBarManagerOptions;
  Bars.Repaint;
end;

procedure TdxBarManager.LargeImageListChange(Sender: TObject);
begin
  CustomImagesChanged(LargeImagesChanged);
end;

function TdxBarManager.BarByNewName(const AName: string): TdxBar;
var
  I: Integer;
begin
  for I := 0 to FBars.Count - 1 do
  begin
    Result := FBars[I];
    if Result.Name = AName then Exit;
  end;
  Result := nil;
end;

procedure TdxBarManager.FontChanged(Sender: TObject);

  procedure ProcessBars;
  var
    I: Integer;
  begin
    for I := 0 to Bars.Count - 1 do
      with Bars[I] do
      begin
        FInternalFontChange := True;
        try
          if UseOwnFont then
            FontChanged(nil)
          else
            Font := Self.Font;
        finally
          FInternalFontChange := False;
        end;
      end;
  end;

  procedure ProcessPopupMenus;
  var
    I: Integer;
  begin
    for I := 0 to FPopupMenus.Count - 1 do
      with TdxBarPopupMenu(FPopupMenus[I]) do
      begin
        FInternalFontChange := True;
        try
          if UseOwnFont then
            FontChanged(nil)
          else
            Font := Self.Font;
        finally
          FInternalFontChange := False;
        end;
      end;
  end;

  procedure ProcessSystemFontListeners;
  begin
    FSystemFontChangedHandlers.CallEvents(Self, []);
  end;

begin
  if not FInternalFontChange then
    FUseSystemFont := False;
  if FScaled then
  begin
    Font.OnChange := nil;
    try
      AssignFont;
    finally
      Font.OnChange := FontChanged;
    end;
  end;
  CreateEditFontHandle(Font, FEditFont, FScaled);
  FBarCaptionFont.Handle := CreateToolbarCaptionFontHandle(Font, UseSystemFont);
  ProcessSystemFontListeners;
  ProcessBars;
  ProcessPopupMenus;
end;

{ TSystemMenuSubItem }

type
  TSystemMenuSubItem = class(TCustomdxBarSubItem)
  private
    FMDIChildHandle: HWND;
    function GetIconHandle: HICON;
    procedure ButtonClick(Sender: TObject);
  protected
    procedure BuildMenu;
    procedure DirectClick; override;
  public
    property IconHandle: HICON read GetIconHandle;
    property MDIChildHandle: HWND read FMDIChildHandle write FMDIChildHandle;
  end;

function TSystemMenuSubItem.GetIconHandle: HICON;
begin
  Result := SendMessage(FMDIChildHandle, WM_GETICON, ICON_SMALL, 0);
  if Result = 0 then
    Result := SendMessage(FMDIChildHandle, WM_GETICON, ICON_BIG, 0);
  Result :=
    CopyImage(Result, IMAGE_ICON, 16, 16, LR_COPYFROMRESOURCE);
end;

procedure TSystemMenuSubItem.ButtonClick(Sender: TObject);
begin
  with TdxBarItem(Sender) do
    SendMessage(MDIChildHandle, WM_SYSCOMMAND, Tag, 0);
end;

procedure TSystemMenuSubItem.BuildMenu;
const
  SLength = 1024;

  procedure BuildSubMenu(SubItem: TCustomdxBarSubItem; Menu: HWND);
  const
    BitmapNames: array[HBMMENU_POPUP_CLOSE..HBMMENU_POPUP_MINIMIZE] of string =
      ('DXBARCLOSE', 'DXBARRESTORE', 'DXBARMAXIMIZE', 'DXBARMINIMIZE');
  var
    ABeginGroup: Boolean;
    AItemText: array[0..SLength - 1] of Char;
    I, P: Integer;
    MI: TMenuItemInfo;
    AShortCutText: string;
    AItem: TdxBarItem;
  begin
    ABeginGroup := False;
    for I := 0 to GetMenuItemCount(Menu) - 1 do
    begin
      with MI do
      begin
        if not IsWin95 then
          cbSize := SizeOf(MI)
        else
        begin
          cbSize := 44;
          MI.hbmpItem := 0;
        end;
        fMask := MIIM_CHECKMARKS or MIIM_ID or MIIM_STATE or MIIM_SUBMENU or MIIM_TYPE;
        dwTypeData := AItemText;
        cch := SLength;
      end;
      GetMenuItemInfo(Menu, I, True, MI);

      if MI.fType and MFT_SEPARATOR <> 0 then
      begin
        ABeginGroup := True;
        Continue;
      end;

      if MI.fType and MFT_BITMAP <> 0 then
        GetMenuString(Menu, I, AItemText, SLength, MF_BYPOSITION)
      else
        if MI.cch = 0 then
          AItemText := '';
      P := Pos(#9, AItemText);
      if P = 0 then
        AShortCutText := ''
      else
      begin
        AShortCutText := Copy(AItemText, P + 1, Length(AItemText) - P);
        StrLCopy(AItemText, AItemText, P - 1);
      end;

      if MI.hSubMenu = 0 then
      begin
        AItem := TdxBarButton.Create(Owner);
        if MI.fState and MFS_CHECKED <> 0 then
          with TdxBarButton(AItem) do
          begin
            ButtonStyle := bsChecked;
            Down := True;
          end;
        with AItem do
        begin
          Tag := MI.wID;
          OnClick := ButtonClick;
        end;
      end
      else
      begin
        AItem := TdxBarSubItem.Create(Owner);
        BuildSubMenu(TCustomdxBarSubItem(AItem), MI.hSubMenu);
      end;
      BarDesignController.AddInternalItem(AItem);
      with AItem do
      begin
        Caption := AItemText;
        Enabled := MI.fState and (MFS_DISABLED or MFS_GRAYED) = 0;
        if MI.hbmpItem in [HBMMENU_POPUP_CLOSE..HBMMENU_POPUP_MINIMIZE] then
          Glyph.Handle := LoadBitmap(HInstance, PChar(BitmapNames[MI.hbmpItem]))
        else
        begin
          if MI.fState and MFS_CHECKED <> 0 then
            if MI.hbmpChecked <> 0 then
              Glyph.Handle := CopyImage(MI.hbmpChecked, IMAGE_BITMAP, 0, 0, 0)
            else
          else
            if MI.hbmpUnchecked <> 0 then
              Glyph.Handle := CopyImage(MI.hbmpUnchecked, IMAGE_BITMAP, 0, 0, 0);
          if (Glyph.Handle = 0) and (MI.fType and MFT_BITMAP <> 0) then
            Glyph.Handle := CopyImage(HBITMAP(MI.dwTypeData), IMAGE_BITMAP, 0, 0, 0);
        end;  
        ShortCut := TextToShortCut(AShortCutText);
      end;

      with SubItem.ItemLinks.Add do
      begin
        BeginGroup := ABeginGroup;
        Item := AItem;
      end;
      ABeginGroup := False;
    end;
  end;

begin
  BarDesignController.ClearInternalItems;
  BuildSubMenu(Self, GetSystemMenu(FMDIChildHandle, False));
end;

procedure TSystemMenuSubItem.DirectClick;
begin
  BuildMenu;
  inherited;
end;

{ TSystemMenuSubItemControl }

type
  TSystemMenuSubItemControl = class(TdxBarSubItemControl)
  private
    function GetItem: TSystemMenuSubItem;
  protected
    function CanCustomize: Boolean; override;
    function CanSelect: Boolean; override;
    procedure DblClick; override;
    procedure DoPaint(ARect: TRect; PaintType: TdxBarPaintType); override;
    function HasShadow: Boolean; override;
    function GetDefaultHeight: Integer; override;
    function GetDefaultWidth: Integer; override;
    function IsExpandable: Boolean; override;
    function WantsDblClick: Boolean; override;
  public
    property Item: TSystemMenuSubItem read GetItem;
  end;

function TSystemMenuSubItemControl.GetItem: TSystemMenuSubItem;
begin
  Result := TSystemMenuSubItem(ItemLink.Item);
end;

function TSystemMenuSubItemControl.CanCustomize: Boolean;
begin
  Result := False;
end;

function TSystemMenuSubItemControl.CanSelect: Boolean;
begin
  Result := not BarManager.IsCustomizing;
end;

procedure TSystemMenuSubItemControl.DblClick;
begin
  inherited;
  Parent.HideAll;
  with Item do
    SendMessage(FMDIChildHandle, WM_SYSCOMMAND,
      GetMenuDefaultItem(GetSystemMenu(FMDIChildHandle, False), 0, 0), 0);
end;

procedure TSystemMenuSubItemControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
var
  Icon: HIcon;
begin
  Icon := Item.IconHandle;
  with ARect do
  begin
    Parent.FillBackground(Canvas.Handle, ARect, Parent.BkBrush, clNone, True);
    DrawIconEx(Canvas.Handle, Left, Top, Icon,
      Right - Left, Bottom - Top, 0, 0{Parent.BkBrush}, DI_NORMAL);
  end;
  DestroyIcon(Icon);
end;

function TSystemMenuSubItemControl.HasShadow: Boolean;
begin
  Result := False;
end;

function TSystemMenuSubItemControl.GetdefaultHeight: Integer;
begin
  Result := GetSystemMetrics(SM_CYSMICON);
end;

function TSystemMenuSubItemControl.GetDefaultWidth: Integer;
begin
  Result := GetSystemMetrics(SM_CXSMICON);
end;

function TSystemMenuSubItemControl.IsExpandable: Boolean;
begin
  Result := False;
end;

function TSystemMenuSubItemControl.WantsDblClick: Boolean;
begin
  Result := True;
end;

{ continuation }

function TdxBarManager.ActiveMDIChild: HWND;
begin
  if (Application.MainForm <> nil) and (Application.MainForm.ClientHandle <> 0) then
    Result := SendMessage(Application.MainForm.ClientHandle, WM_MDIGETACTIVE, 0, 0)
  else
    Result := 0;
end;

procedure TdxBarManager.CreateMDIChildSystemMenu(AWnd: HWND);
var
  ASystemMenuSubItem: TSystemMenuSubItem;
begin
  if GetSystemMenu(AWnd, False) = 0 then Exit;
  ASystemMenuSubItem := TSystemMenuSubItem.Create(Owner);//#DG
  BarDesignController.AddInternalItem(ASystemMenuSubItem, FInternalItems);
  ASystemMenuSubItem.MDIChildHandle := AWnd;
  with MainMenuBar.ItemLinks.Add do
  begin
    Item := ASystemMenuSubItem;
    Index := 0;
  end;
end;

procedure TdxBarManager.DestroyMDIChildSystemMenu;
begin
  FInternalItems.Clear;
end;

function TdxBarManager.IsMDIChildSystemMenuExist: Boolean;
begin
  Result := FInternalItems.Count <> 0; // TODO
end;

procedure TdxBarManager.MDIStateChanged(AChange: TdxBarMDIStateChange; AWnd: HWND);
type
  TMergeOperation = (moNone, moMerge, moUnmerge);

  procedure UpdateSystemMenu;
  begin
    if MainMenuBar <> nil then
      if (AChange <> scChildDeactivated) and IsMDIMaximized then
        CreateMDIChildSystemMenu(AWnd)
      else
        if ((AChange = scChildDeactivated) or (AChange = scMaximizedChanged) and not IsMDIMaximized) and
          IsMDIChildSystemMenuExist then
          DestroyMDIChildSystemMenu;
  end;

  function GetMergeOperation: TMergeOperation;
  begin
    Result := moNone;
    if not ((AChange = scMaximizedChanged) and FAlwaysMerge) then
      if (AChange <> scChildDeactivated) and (FAlwaysMerge or IsMDIMaximized) then
        Result := moMerge
      else
        if (AChange = scChildDeactivated) or (AChange = scMaximizedChanged) and not IsMDIMaximized then
          Result := moUnmerge;
  end;

  procedure DoMenuMerging;
  var
    ABar: TdxBar;
    ABarManager: TdxBarManager;
    AMergedBarList: TList;
    I: Integer;
  begin
    ABarManager := GetBarManagerByHandle(AWnd);
    if (MainMenuBar = nil) or (ABarManager = nil) or (ABarManager.MainMenuBar = nil) then
      Exit;

    case GetMergeOperation of
      moMerge:
        if Assigned(FOnMenuMerge) then
        begin
          FOnMenuMerge(Self, ABarManager, True);
          if ABarManager.MainMenuBar.MergeData.MergedWith = nil then
          begin
            ABarManager.MainMenuBar.MergeData.MergedWith := MainMenuBar;
            MainMenuBar.MergeData.MergedBarList.Add(ABarManager.MainMenuBar);
            ABarManager.MainMenuBar.MergeData.VisibleBeforeMerging := ABarManager.MainMenuBar.Visible;
          end;
          ABarManager.MainMenuBar.SetVisibility(False);
        end
        else
          MainMenuBar.Merge(ABarManager.MainMenuBar);
      moUnmerge:
        begin
          AMergedBarList := TList.Create;
          try
            MainMenuBar.MergeData.SaveMergedBarList(AMergedBarList);
            MainMenuBar.InternalUnmergeFromBar(nil, False);
            if Assigned(FOnMenuMerge) then
              FOnMenuMerge(Self, ABarManager, False);
            for I := 0 to AMergedBarList.Count - 1 do
            begin
              ABar := TdxBar(AMergedBarList[I]);
              ABar.SetVisibility(ABar.MergeData.VisibleBeforeMerging);
            end;
          finally
            AMergedBarList.Free;
          end;
        end;
    end;
  end;

  procedure DoMerging;
  var
    ABarManager: TdxBarManager;
  begin
    if Assigned(FOnMerge) then
    begin
      ABarManager := GetBarManagerByHandle(AWnd);
      if (ABarManager <> nil) and (GetMergeOperation <> moNone) then
        FOnMerge(Self, ABarManager, GetMergeOperation = moMerge);
    end;
  end;

var
  AEventData: TdxBarMDIStateChangeEventData;
begin
  UpdateSystemMenu;
  DoMenuMerging;
  DoMerging;
  AEventData.Change := AChange;
  AEventData.Wnd := AWnd;
  FMDIStateChangedHandlers.CallEvents(Self, AEventData);
end;

procedure TdxBarManager.CheckToolbarsVisibility;
var
  WorkArea, R: TRect;
  I: Integer;
begin
  WorkArea := GetWorkArea(Point(Owner.Left + Owner.Width div 2, Owner.Top + Owner.Height div 2));//#DG
  for I := 0 to FBars.Count - 1 do
    with FBars[I] do
      if DockingStyle = dsNone then
      begin
        if Control = nil then
          R := Bounds(FloatLeft, FloatTop,
            BarNCSizeX(dsNone) + FloatClientWidth, BarNCSizeY(dsNone) + FloatClientHeight)
        else
          R := Control.BoundsRect;
        with WorkArea do
        begin
          if R.Bottom > Bottom then OffsetRect(R, 0, Bottom - R.Bottom);
          if R.Top < Top then OffsetRect(R, 0, Top - R.Top);
          if R.Right > Right then OffsetRect(R, Right - R.Right, 0);
          if R.Left < Left then OffsetRect(R, Left - R.Left, 0);
        end;
        if Control = nil then
        begin
          LockDesignerModified(True);
          try
            FloatLeft := R.Left;
            FloatTop := R.Top;
          finally
            LockDesignerModified(False);
          end;
        end
        else
          Control.BoundsRect := R;
      end;
end;                

class function TdxBarManager.IsFormBroadcastMessage(AMsg: UINT): Boolean;
begin
  Result := (AMsg = WM_ACTIVATE) or (AMsg = WM_ACTIVATEAPP) or
    (AMsg = WM_CHILDACTIVATE) or (AMsg = WM_MDIACTIVATE) or
    (AMsg = WM_SETTINGCHANGE) or (AMsg = WM_SYSCOLORCHANGE) or
    (AMsg = WM_SYSCOMMAND) or (AMsg = WM_WINDOWPOSCHANGED) or
    (AMsg = WM_WINDOWPOSCHANGING);
end;

function TdxBarManager.IsOwnerMDIChild(ARecursive: Boolean): Boolean;
begin
  if ARecursive then
    Result := IsMDIChild(GetBarManagerForm(Self, fkMainOrMDIChild))
  else
    Result := (Owner is TCustomForm) and IsMDIChild(TCustomForm(Owner));
end;

procedure TdxBarManager.MainFormClientWndProc(Msg: UINT; wParam: WPARAM; lParam: LPARAM);
var
  APrevIsMDIMaximized: Boolean;
begin
  APrevIsMDIMaximized := IsMDIMaximized;
  FIsMDIMaximized := (ActiveMDIChild <> 0) and IsZoomed(ActiveMDIChild);

  BeginUpdate;
  try
    if ActiveMDIChild <> FPrevActiveMDIChild then
    begin
      MDIStateChanged(scChildDeactivated, FPrevActiveMDIChild);
      MDIStateChanged(scChildActivated, ActiveMDIChild);
    end
    else
      if IsMDIMaximized <> APrevIsMDIMaximized then
        MDIStateChanged(scMaximizedChanged, ActiveMDIChild);
  finally
    EndUpdate;
  end;

  FPrevActiveMDIChild := ActiveMDIChild;
end;

procedure TdxBarManager.OwnerWndProc(AWnd: HWND; AMsg: UINT; wParam: WPARAM;
  lParam: LPARAM);

  procedure HandleFormBroadcastMessage;
  var
    ABar: TdxBar;
    I: Integer;
  begin
    case AMsg of
      WM_ACTIVATE:
        DoActivate(LOWORD(wParam), HiWord(wParam), AWnd, lParam);
      WM_ACTIVATEAPP:
        DoActivateApp(Bool(wParam), lParam);
      WM_CHILDACTIVATE:
        ActivateFloatToolbars(True, False, 0);
      WM_MDIACTIVATE:
        ActivateFloatToolbars(HWND(lParam) = AWnd, False, 0);
      WM_SETTINGCHANGE:
        case wParam of
          SPI_SETNONCLIENTMETRICS: AssignFont;
          SPI_SETWORKAREA: CheckToolbarsVisibility;
        end;
      WM_SYSCOLORCHANGE:
        begin
          RefreshDeviceConsts;
          CreatePatternBrush;
          RecreateToolbarsBrushes;
          RefreshFloatingBarsShadows;
        end;
      WM_SYSCOMMAND:
        begin
          if (wParam = SC_CLOSE) and Designing and (ActiveBarControl <> nil) and
            (ActiveBarManager = Self) then
              ActiveBarControl.HideAll;
          if (wParam = SC_MINIMIZE) or (wParam = SC_MAXIMIZE) or
            (wParam = SC_RESTORE) or (wParam = SC_CLOSE) then
          begin
            for I := 0 to Bars.Count - 1 do
            begin
              ABar := Bars[I];
              if ABar.Visible and (ABar.Control <> nil) and (ABar.DockingStyle = dsNone) then
                if (wParam = SC_MINIMIZE) or (wParam = SC_CLOSE) then
                  ShowWindow(ABar.Control.Handle, SW_HIDE)
                else
                begin
                  ShowWindow(ABar.Control.Handle, SW_SHOWNOACTIVATE);
                  UpdateWindow(ABar.Control.Handle);
                end;
            end;
            //if IsWindowVisible(MainForm.Handle) then ProcessPaintMessages;
          end;
        end;
      WM_WINDOWPOSCHANGING:
          if PWindowPos(lParam).flags and SWP_HIDEWINDOW <> 0 then
            ActivateFloatToolbars(False, True, 0);
      WM_WINDOWPOSCHANGED:
        begin
          if FIsCustomizing and (dxBarCustomizingForm <> nil) then
          begin
            dxBarCustomizingForm.UpdateVisibility(PWindowPos(lParam)^);
            if dxBarSubMenuEditor <> nil then
              if PWindowPos(lParam).flags and SWP_SHOWWINDOW <> 0 then
                ShowWindow(dxBarSubMenuEditor.Handle, SW_SHOWNA)
              else
                if PWindowPos(lParam).flags and SWP_HIDEWINDOW <> 0 then
                  ShowWindow(dxBarSubMenuEditor.Handle, SW_HIDE);
          end;

          if not IsOwnerMDIChild(True) and (PWindowPos(lParam).flags and SWP_SHOWWINDOW <> 0) then
            ActivateFloatToolbars(True, True, 0);
        end;
    end;
  end;

  procedure HandleOwnerMessage;
  var
    AContextID: Integer;
    AControl: TWinControl;
    AItem: TdxBarItemControl;
    P: TPoint;
  begin
    case AMsg of
      WM_CANCELMODE:
        DoModalActivate;
      WM_CREATE:
        DoCreate;
      WM_DISPLAYCHANGE:
        CheckToolbarsVisibility;
      WM_HELP:
        if not Designing and (PHelpInfo(lParam).iContextType = HELPINFO_WINDOW) then
          with PHelpInfo(lParam)^ do
          begin
            AItem := nil;
            if ActiveBarControl <> nil then
            begin
              AControl := ActiveBarControl;
              AItem := TCustomdxBarControl(AControl).SelectedControl;
              if (AItem = nil) or (AItem.Item.HelpContext = 0) then
              begin
                while TCustomdxBarControl(AControl).ParentBar <> nil do
                begin
                  AItem := TdxBarSubMenuControl(AControl).FSubItem;
                  AControl := TCustomdxBarControl(AControl).ParentBar;
                  if (AItem = nil) or (AItem.Item.HelpContext <> 0) then Break;
                end;
                if (AItem = nil) or (AItem.Item.HelpContext = 0) then
                begin
                  HideAll;
                  AContextID := AControl.HelpContext;
                  if AContextID <> 0 then
                    if biHelp in TCustomFormAccess(GetBarManagerForm(Self, fkAny)).BorderIcons then
                      Application.HelpCommand(HELP_CONTEXTPOPUP, AContextID)
                    else
                      Application.HelpContext(AContextID);
                  Exit;
                end;
              end;
            end
            else
            begin
              AControl := FindControl(hItemHandle);
              if AControl is TCustomdxBarControl then
              begin
                P := MousePos;
                ScreenToClient(AControl.Handle, P);
                AItem := TCustomdxBarControl(AControl).ItemAtPos(P);
              end;
            end;
            if AItem <> nil then
            begin
              with AItem.ItemBounds do P := Point((Left + Right) div 2, Bottom);
              ClientToScreen(AControl.Handle, P);
              AContextID := AItem.Item.HelpContext;
              HideAll;
              if AContextID = 0 then Exit;
              if biHelp in TCustomFormAccess(GetBarManagerForm(Self, fkAny)).BorderIcons then
              begin
                Application.HelpCommand(HELP_SETPOPUP_POS, Longint(PointToSmallPoint(P)));
                Application.HelpCommand(HELP_CONTEXTPOPUP, AContextID);
              end
              else
                Application.HelpContext(AContextID);
            end;
          end;
    end;
  end;

begin
  if (csDestroying in Owner.ComponentState) or (Owner = dxBarCustomizingForm) then
  begin
    if (AMsg = WM_DESTROY) and not Designing then
    begin
      if StoreInRegistry then
        SaveToRegistry(RegistryPath);
      if StoreInIniFile then
        SaveToIniFile(IniFileName);
    end;
    Exit;
  end;

  if Bars = nil then
    Exit;

  if IsFormBroadcastMessage(AMsg) then
    HandleFormBroadcastMessage
  else
    HandleOwnerMessage;
  {WM_NCACTIVATE:   - does not allow submenu.edit.setfocus
    if TCustomFormAccess(MainForm).FormStyle = fsMDIChild then
      ActivateToolbars(Boolean(wParam), False, 0);}
end;

class procedure TdxBarManager.SendFormBroadcastMessage(
  AOwnerHandle: HWND; AMsg: UINT; wParam: WPARAM; lParam: LPARAM);
var
  ABarManager: TdxBarManager;
  I: Integer;
begin
  if IsFormBroadcastMessage(AMsg) then
    for I := 0 to dxBarManagerList.Count - 1 do
    begin
      ABarManager := dxBarManagerList[I];
      if ABarManager.Owner.HandleAllocated and (ABarManager.Owner.Handle <> AOwnerHandle) and
        IsBarManagerOwner(ABarManager, AOwnerHandle) and (ABarManager.GetMainForm <> nil) then
          ABarManager.OwnerWndProc(AOwnerHandle, AMsg, wParam, lParam);
    end;
end;

var
  HintTimerABarManager: TdxBarManager;

procedure ShowHintTimerProc(Wnd: HWnd; Msg, TimerID, SysTime: Longint); stdcall;
begin
  if (HintTimerABarManager <> nil) and
    not HintTimerABarManager.IsDestroying then
    with HintTimerABarManager do
    begin
      KillHintTimer;
      DisplayHint;
    end;
end;

procedure HideHintTimerProc(Wnd: HWnd; Msg, TimerID, SysTime: Longint); stdcall;
begin
  if (HintTimerABarManager <> nil) and
    not HintTimerABarManager.IsDestroying then
    with HintTimerABarManager do
    begin
      KillHintTimer;
      HideHint;
    end;
end;

procedure KillHiddenHintTimerProc(Wnd: HWnd; Msg, TimerID, SysTime: Longint); stdcall;
begin
  KillHiddenHintTimer;
end;

procedure TdxBarManager.DisplayHint;

  function ActivateHintWindow(const AHintText: string; AShortCut: string = ''): Boolean;
  begin
    Result := FHintWindow.ActivateHint(Self, AHintText, AShortCut);
    if Result then
    begin
      FHintWindowShowing := True;
      HintTimerABarManager := Self;
      FHintTimerID := SetTimer(0, 0, FHintWindow.HideHintTime, @HideHintTimerProc);
    end;
  end;

var
  AHintKeeper: IdxBarHintKeeper;
  ANeedDeactivate: Boolean;
  AHintText, AShortCut: string;
begin
  ANeedDeactivate := True;
  if FCustomHint <> '' then
    ANeedDeactivate := not ActivateHintWindow(FCustomHint)
  else
    if Supports(FHintObject, IdxBarHintKeeper, AHintKeeper) then
      if AHintKeeper.DoHint(ANeedDeactivate, AHintText, AShortCut) then
      begin
        if AHintKeeper.GetEnabled or ShowHintForDisabledItems then
        begin
          if not ShowShortCutInHint and not Application.HintShortCuts then
            AShortCut := '';
          ANeedDeactivate := not ActivateHintWindow(AHintText, AShortCut);
        end
        else
          ANeedDeactivate := True;
      end;
  if ANeedDeactivate then
    HideHint;
end;

var
  FHintTimerPrevShow: Boolean; //***

procedure TdxBarManager.DoActivateHint(AShow: Boolean; const CustomHint: string; AHintObject: TObject);
var
  PrevShow: Boolean;
begin
  if not AShow and not FHintTimerPrevShow{***} then Exit;
  FHintTimerPrevShow := AShow; //***
  FCustomHint := CustomHint;
  FHintWindowShowing := False;
  PrevShow := AShow;
//#DG <BarManager.SelectedItem>
  AShow := AShow and
    ((SelectedItem <> nil) and not SelectedItem.Parent.IsActive or (FCustomHint <> '') or (AHintObject <> nil));
  KillHintTimer;
  FHintObject := AHintObject;
  if AShow then
  begin
    if not IsHintActive and not FLiveHiddenHint then
    begin
      HintTimerABarManager := Self;
      FHintTimerID := SetTimer(0, 0, FHintWindow.ShowHintTime, @ShowHintTimerProc);
    end
    else
      DisplayHint;
  end
  else
  begin
    if IsHintActive then
    begin
      ShowWindow(FHintWindow.Handle, SW_HIDE);
      if PrevShow then
      begin
        KillHiddenHintTimer;
        FLiveHiddenHint := True;
        FHiddenHintTimerID := SetTimer(0, 0, dxBarHiddedHintLifeTime, @KillHiddenHintTimerProc);
      end;
    end;
  end;
end;

function TdxBarManager.IsHintActive: Boolean;
begin
  Result := IsControlVisible(FHintWindow);
end;

procedure TdxBarManager.DestroyItems;
begin
  FreeAndNil(FInternalItems);
  FItems.OwnsObjects := True;
  FreeAndNil(FItems);
end;

procedure TdxBarManager.HelpButtonGlyphChanged(Sender: TObject);
begin
  UpdateHelpButton;
end;

procedure TdxBarManager.CalcMostRecentlyUsedUseCount;
var
  I: Integer;
begin
  if FMostRecentItemsPercents = 100 then FMostRecentlyUsedUseCount := 0
  else
    for I := 1 to MaxInt do
      if I * (100 - FMostRecentItemsPercents) div 100 > 0 then
      begin
        FMostRecentlyUsedUseCount := I;
        Break;
      end;
end;

function TdxBarManager.ShowRecentItemsFirst: Boolean;
begin
  Result := CanShowRecentItems and MenusShowRecentItemsFirst;
end;

procedure TdxBarManager.AddDockControl(ADockControl: TdxDockControl);
begin
  FDockControls.Add(ADockControl);
  FreeNotification(ADockControl);
end;

procedure TdxBarManager.RemoveDockControl(ADockControl: TdxDockControl);
var
  I: Integer;
begin
  if FBars <> nil then
    for I := 0 to FBars.Count - 1 do
      with FBars[I] do
      begin
        if DockControl = ADockControl then DockControl := nil;
        if DockedDockControl = ADockControl then DockedDockControl := nil;
        if RealDockControl = ADockControl then Visible := False;
      end;
  if FDockControls <> nil then FDockControls.Remove(ADockControl);
  if ADockControl.Main and (FBars <> nil) then
    FBars.FDockControls[ADockControl.FDockingStyle] := nil;
  ADockControl.ParentColor := True;
end;

procedure TdxBarManager.AddGroup(AGroup: TdxBarGroup);
begin
  FGroups.Add(AGroup);
  AGroup.FBarManager := Self;
end;

{#DG
procedure TdxBarManager.RemoveGroup(AGroup: TdxBarGroup);
begin
  FGroups.Remove(AGroup);
end;
}

function TdxBarManager.CorrectRegistryPath(var APath: string): Boolean;
begin
  Result := APath <> '';
  if Result then
  begin
    if APath[1] <> '\' then
      APath := '\' + APath;
    if APath[Length(APath)] <> '\' then
      APath := APath + '\';
  end;
end;

function TdxBarManager.GetSavedBarIndex(const ABarCaption: string): Integer;
var
  ABarCount, I: Integer;
begin
  Result := -1;
  ABarCount := SavedState.ReadInteger(
    GetBarManagerSection(GetBaseIniSection, skIni), 'BarCount', 0);
  for I := 0 to ABarCount - 1 do
    if SavedState.ReadString(TdxBar.GetIniSection(GetBaseIniSection, I), 'Caption', '') = ABarCaption then
    begin
      Result := I;
      Break;
    end;
end;

function TdxBarManager.IsDockColorStored: Boolean;
begin
  Result := not FAutoDockColor;
end;

procedure TdxBarManager.LoadLinkItemNames;
var
  I: Integer;
begin
  for I := 0 to ItemCount - 1 do
    if Items[I].GetItemLinks <> nil then
      Items[I].GetItemLinks.LoadItemNames;
  for I := 0 to Bars.Count - 1 do
    Bars[I].ItemLinks.LoadItemNames;
end;

procedure TdxBarManager.ReadBars(AReader: TReader);
var
  AItem: TdxBar;
  I: Integer;
begin
  AReader.ReadValue;
  I := 0;
  while not AReader.EndOfList do
  begin
    if AReader.NextValue in [vaInt8, vaInt16, vaInt32] then
      AReader.ReadInteger;
    if I < Bars.Count then
      AItem := Bars[I]
    else
      AItem := Bars.Add;
    Inc(I);
    AItem.FIsNameLocked := True;
    try
      AReader.ReadListBegin;
      while not AReader.EndOfList do
        TReaderAccess(AReader).ReadProperty(AItem);
      AReader.ReadListEnd;
    finally
      AItem.FIsNameLocked := False;
    end;
  end;
  AReader.ReadListEnd;
end;

procedure TdxBarManager.ReadDockControlHeights(Reader: TReader);
begin
  with Reader, FBars do
  begin
    ReadListBegin;
    try
      FDockControls[dsLeft].Width := ReadInteger;
      FDockControls[dsRight].Width := ReadInteger;
      FDockControls[dsTop].Height := ReadInteger;
      FDockControls[dsBottom].Height := ReadInteger;
    finally
      ReadListEnd;
    end;
  end;
end;

procedure TdxBarManager.WriteDockControlHeights(Writer: TWriter);
begin
  with Writer, FBars do
  begin
    WriteListBegin;
    try
      WriteInteger(FDockControls[dsLeft].Width);
      WriteInteger(FDockControls[dsRight].Width);
      WriteInteger(FDockControls[dsTop].Height);
      WriteInteger(FDockControls[dsBottom].Height);
    finally
      WriteListEnd;
    end;
  end;
end;

procedure TdxBarManager.CreateFlatToolbarsBrushes;
begin
  DestroyFlatToolbarsBrushes;
  FFlatToolbarsBorderBrush := CreateSolidBrush(FlatToolbarsBorderColor);
  FFlatToolbarsBrush := CreateSolidBrush(FlatToolbarsColor);
  FFlatToolbarsDownedBrush := CreateSolidBrush(FlatToolbarsDownedColor);
  FFlatToolbarsDownedSelBrush := CreateSolidBrush(FlatToolbarsDownedSelColor);
  FFlatToolbarsSelBrush := CreateSolidBrush(FlatToolbarsSelColor);
end;

procedure TdxBarManager.DestroyFlatToolbarsBrushes;
begin
  DeleteGDIObject(FFlatToolbarsSelBrush);
  DeleteGDIObject(FFlatToolbarsDownedSelBrush);
  DeleteGDIObject(FFlatToolbarsDownedBrush);
  DeleteGDIObject(FFlatToolbarsBrush);
  DeleteGDIObject(FFlatToolbarsBorderBrush);
end;

procedure TdxBarManager.CreateThemeToolbarsBrushes;
begin
  DestroyThemeToolbarsBrushes;
  if FThemeAvailable then
  begin
    FThemeToolbarsBrush := CreateSolidBrush(ThemeToolbarColor);
//  FThemeToolbarsDownedBrush := CreateSolidBrush();
//  FThemeToolbarsDownedSelBrush := CreateSolidBrush();
//  FThemeToolbarsSelBrush := CreateSolidBrush();
  end;
end;

procedure TdxBarManager.DestroyThemeToolbarsBrushes;
begin
//  if FThemeToolbarsSelBrush <> 0 then DeleteObject(FThemeToolbarsSelBrush);
//  if FThemeToolbarsDownedSelBrush <> 0 then DeleteObject(FThemeToolbarsDownedSelBrush);
//  if FThemeToolbarsDownedBrush <> 0 then DeleteObject(FThemeToolbarsDownedBrush);
  DeleteGDIObject(FThemeToolbarsBrush);
end;

procedure TdxBarManager.DestroyToolbarsBrushes;
begin
  DestroyThemeToolbarsBrushes;
  DestroyFlatToolbarsBrushes;
  ReleaseOffice11Colors;
end;

procedure TdxBarManager.CreateToolbarsBrushes;
begin
  CreateFlatToolbarsBrushes;
  CreateThemeToolbarsBrushes;
  CreateOffice11Colors;
  ResetBackgrounds;
end;

procedure TdxBarManager.RecreateToolbarsBrushes;
begin
  CreateFlatToolbarsBrushes;
  CreateThemeToolbarsBrushes;
  RefreshOffice11Colors;
  ResetBackgrounds;
end;

procedure TdxBarManager.RefreshFloatingBarsShadows;
var
  I: Integer;
begin
  for I := 0 to Bars.Count - 1 do
    if (Bars[I].DockingStyle = dsNone) and (Bars[I].Control <> nil) then
      Bars[I].Control.RefreshShadow;
end;

procedure TdxBarManager.ResetBackgrounds;
var
  I: Integer;
begin
  for I := 0 to DockControlCount - 1 do
  begin
//    DockControls[I].ResetBackground;
    DockControls[I].BarManagerChanged;
    DockControls[I].UpdateDoubleBuffered;
    DockControls[I].Invalidate;
  end;
  for I := 0 to Bars.Count - 1 do
    if Bars[I].Control <> nil then
    begin
      Bars[I].Control.ResetBackground;
      Bars[I].Control.UpdateDoubleBuffered;
      Bars[I].Control.FullInvalidate;
    end;  
end;

procedure TdxBarManager.InitPainter;
begin
  FThemeAvailable := AreVisualStylesAvailable([totToolBar, totComboBox, totEdit,
    totWindow, totScrollBar, totRebar, totStatus, totSpin, totProgress]);
  FreeAndNil(FDefaultPainter);
  FDefaultPainter := GetPainterClass.Create(Integer(LookAndFeel.SkinPainter));
end;

procedure TdxBarManager.InternalStyleChanged;
var
  I: Integer;
begin
  FChangingStyle := True;
  try
    InitPainter;
    if Bars <> nil then
    begin
      for I := 0 to Bars.Count - 1 do
        if Bars[I].Control <> nil then
          Bars[I].Control.BarManagerStyleChanged;
      HostBarManagerStyleChanged;
      ResetBackgrounds;
    end;
  finally
    FChangingStyle := False;
  end;
end;

procedure TdxBarManager.ThemeChanged;
begin
  InternalStyleChanged;
end;

procedure TdxBarManager.LFChanged(Sender: TcxLookAndFeel; AChangedValues: TcxLookAndFeelValues);
begin
  if not IsDestroying then
    InternalStyleChanged;
end;

procedure TdxBarManager.DoActivate(AState, AMinimized: WORD; AHandle, AWndPrevious: HWND);
var
  AControl: TWinControl;
  AMainForm: TCustomForm;
  ANeedActivate: Boolean;
begin
  Include(FInternalState, bisFormActivating);
  try
    AMainForm := GetBarManagerForm(Self, fkMainOrMDIChild);
    if IsMDIChild(AMainForm) and (Application.MainForm.ActiveMDIChild <> AMainForm) then
      Exit;
    AMainForm := GetMainForm;
    AControl := FindControl(AWndPrevious);

    if (AState = WA_INACTIVE) and (AControl is TCustomdxBarControl) and
      (TCustomdxBarControl(AControl).BarManager.GetMainForm = AMainForm) then
        Exit;
    if {(AState = WA_INACTIVE) and }(ActiveBarControl <> nil) and
      (ActiveBarControl.SelectedControl <> nil) and
      ActiveBarControl.SelectedControl.IsChildWindow(AWndPrevious) then
        Exit;

    ANeedActivate := MainFormActive and not (IsWindowEnabledEx(AMainForm.Handle) or Designing) or
      (AState <> WA_INACTIVE) or (AMainForm.Handle = AWndPrevious);
    ActivateFloatToolbars(ANeedActivate, False, AWndPrevious);

    if not (bisToolbarsVisibleChanging in FInternalState) and (AState <> WA_INACTIVE) and //ANeedActivate and
      (dxBarCustomizingForm <> nil) and FIsCustomizing and not IsWindowEnabledEx(AMainForm.Handle)
      and not IsChildEx(dxBarCustomizingForm.Handle, AHandle) then
        SendMessage(dxBarCustomizingForm.Handle, WM_ACTIVATE, MakeWParam(AState, AMinimized), AMainForm.Handle);

    if (AState = WA_INACTIVE) and (AMainForm.Handle <> AWndPrevious) and (FMouseTrackingBarControl <> nil) then
      FMouseTrackingBarControl.MouseLeave;
  finally
    Exclude(FInternalState, bisFormActivating);
  end;
end;

procedure TdxBarManager.DoActivateApp(AActivate: Boolean; AThreadID: DWORD);
begin
  if bisModalActivating in FInternalState then
    Exit;
  if not AActivate then
  begin
    if MainFormActive and not IsWindowEnabledEx(GetMainForm.Handle) then
      Include(FInternalState, bisWasActive);
    ActivateFloatToolbars(False, False, 0);
    if (ActiveBarControl <> nil) and (ActiveBarControl.BarManager = Self) then
      ActiveBarControl.HideAll; //SC-Q93427
    //#DG <BarManager.SelectedItem>
    if SelectedItem <> nil then
      SendMessage(SelectedItem.Parent.Handle, WM_MOUSELEAVE, 0, 0);
//#DG    SelectedItem := nil;
  end
  else {TODO}
    if bisWasActive in FInternalState then
    begin
      ActivateFloatToolbars(True, False, 0);
      Exclude(FInternalState, bisWasActive);
    end;
end;

procedure TdxBarManager.DoCreate;
var
  I: Integer;
begin
  if BarRestoringListExists then
  begin
    Include(FInternalState, bisHandleCreating);
    try
      for I := 0 to DockControlCount - 1 do
        if CanAllocateHandle(DockControls[I]) then // for BarDockControl
          DockControls[I].HandleNeeded;
      ShowBarsFromRestoringList(nil);
    finally
      if RestoringListBarCount = 0 then // for BarDockControl
        DestroyBarRestoringList;
      Exclude(FInternalState, bisHandleCreating);
    end;
  end;
end;

procedure TdxBarManager.DoModalActivate;
begin
  if BarNavigationController.IsKeyTipsWaiting then
    BarNavigationController.EndKeyTipsWaiting(False);
  Include(FInternalState, bisModalActivating);
  try
    if not IsInternalWindowsDisabling and
      (ActiveBarControl <> nil) and (ActiveBarControl.BarManager = Self){SC-S90738} and ActiveBarControl.HideOnClick then
      ActiveBarControl.HideAll;
  finally
    Exclude(FInternalState, bisModalActivating);
  end;
end;

procedure TdxBarManager.DoLockUpdate(ALock: Boolean;
  ACheckBarsChanges: Boolean);

  function IsBarHasChanges(ABar: TdxBar): Boolean;
  begin
    Result := (ABar.DockingStyle = dsNone) or ACheckBarsChanges and ABar.FChanged;
  end;

var
  ABar: TdxBar;
  ADockControl: TdxDockControl;
  I, J: Integer;
begin
  try
    for I := 0 to DockControlCount - 1 do
      if DockControls[I].Visible and DockControls[I].HandleAllocated then
        SendMessage(DockControls[I].Handle, WM_SETREDRAW, WPARAM(not ALock), 0);

    if not ALock then
    begin
      if FChangedSubMenuControl <> nil then
      begin
        FChangedSubMenuControl.RepaintBar;
        FChangedSubMenuControl := nil;
      end;

      for I := 0 to Bars.Count - 1 do
      begin
        ABar := Bars[I];
        if (ABar.Control <> nil) and IsBarHasChanges(ABar) then
          ABar.Control.RecreateControls;
      end;

      for I := 0 to Bars.Count - 1 do
      begin
        ABar := Bars[I];
        if (ABar.Control <> nil) and IsBarHasChanges(ABar) then
          ABar.Control.RepaintBarEx(False)
      end;

      for I := 0 to DockControlCount - 1 do
      begin
        ADockControl := DockControls[I];
        for J := ADockControl.RowCount - 1 downto 0 do
          if TdxDockRow(ADockControl.RowList[J]).FBars.Count = 0 then
          begin
            TdxDockRow(ADockControl.RowList[J]).Free;
            ADockControl.RowList.Delete(J);
          end;
        if ADockControl.Visible and ADockControl.HandleAllocated then
        begin
          ADockControl.UpdateDock;
          SendMessage(ADockControl.Handle, WM_NCPAINT, 0, 0);
        end;
      end;

      for I := 0 to Bars.Count - 1 do
      begin
        ABar := Bars[I];
        if (ABar.Control <> nil) and not IsBarHasChanges(ABar) then
        begin
          ABar.Control.FrameChanged;
          ABar.Control.Repaint;
        end;
      end;      
    end;
  finally
    for I := 0 to Bars.Count - 1 do
      Bars[I].FChanged := False;
  end;
end;

function TdxBarManager.GetItemLinkWithAccel(AKey: Word;
  AShift: TShiftState): TdxBarItemLink;

  function GlobalFindItemWithAccel(ABarManager: TdxBarManager): TdxBarItemLink;
  var
    ABar: TdxBar;
    I: Integer;
  begin
    if ABarManager.MainMenuControl <> nil then
      Result := ABarManager.MainMenuBar.ItemLinks.FindItemWithAccel(AKey, AShift, nil)
    else
      Result := nil;
    if Result = nil then
      for I := 0 to ABarManager.Bars.Count - 1 do
      begin
        ABar := ABarManager.Bars[I];
        if ABar.Visible and (ABar <> ABarManager.MainMenuBar) then
        begin
          Result := ABar.ItemLinks.FindItemWithAccel(AKey, AShift, nil);
          if Result <> nil then Break;
        end;
      end;
  end;

var
  ATempBarManager: TdxBarManager;
  AWnd: HWND;
begin
  Result := nil;
  AWnd := Owner.Handle;
  repeat
    ATempBarManager := GetBarManagerByHandle(AWnd);
    if ATempBarManager <> nil then
      Result := GlobalFindItemWithAccel(ATempBarManager);
    if not IsChildClassWindow(AWnd) then
      Break;
    AWnd := GetParent(AWnd);
  until Result <> nil;

  if Result = nil then
  begin
    ATempBarManager := Self;
    repeat
      ATempBarManager := dxBarManagerList.NextActive(ATempBarManager, True);
      if ATempBarManager = Self then
        Break;
      Result := GlobalFindItemWithAccel(ATempBarManager);
    until Result <> nil;
  end;
end;

function TdxBarManager.HandleShortCut(AShortCut: TShortCut): Boolean;

  function IsBarManagerShortCut(ABarManager: TdxBarManager;
    AShortCut: TShortCut): Boolean;
  var
    ABar: TdxBar;
    I: Integer;
  begin
    Result := (ABarManager.MainMenuBar <> nil) and
      (ABarManager.MainMenuBar.IsShortCut(AShortCut));
    if not Result then
      for I := 0 to ABarManager.Bars.Count - 1 do
      begin
        ABar := ABarManager.Bars[I];
        if (ABar <> ABarManager.MainMenuBar) and
          (ABar.Visible and (ABar.Control <> nil) and ABar.Control.CanProcessShortCut or
           (GetBarIndexInRestoringList(ABar) <> -1)) then
        begin
          Result := ABar.IsShortCut(AShortCut);
          if Result then Break;
        end;
      end;
    if not Result then
      for I := 0 to ABarManager.FPopupMenus.Count - 1 do
      begin
        Result := TdxBarCustomPopupMenu(ABarManager.FPopupMenus[I]).IsShortCut(AShortCut);
        if Result then Break;
      end;
  end;

var
  AControl: TWinControl;
  ATempBarManager: TdxBarManager;
  AWnd: HWND;
begin
  AControl := FindVCLControl(GetFocus);
  ATempBarManager := GetBarManagerForComponent(AControl);
  Result := (ATempBarManager <> nil) and ATempBarManager.PopupMenuLinks.IsShortCut(AControl, AShortCut);
  if not Result then
  begin
    AWnd := Owner.Handle;
    repeat
      ATempBarManager := GetBarManagerByHandle(AWnd);
      Result := (ATempBarManager <> nil) and
        IsBarManagerShortCut(ATempBarManager, AShortCut);
      if not IsChildClassWindow(AWnd) then
        Break;
      AWnd := GetParent(AWnd);
    until Result;
  end;
  if not Result then
  begin
    ATempBarManager := Self;
    repeat
      ATempBarManager := dxBarManagerList.NextActive(ATempBarManager, True);
      if ATempBarManager = Self then
        Break;
      Result := IsBarManagerShortCut(ATempBarManager, AShortCut);
    until Result;
  end;
end;

function TdxBarManager.CanDeleteComponent(AComponent: TComponent): Boolean;
begin
  Result := (FdxBarDesignHelper = nil) or
    FdxBarDesignHelper.CanDeleteComponent(AComponent);
end;

procedure TdxBarManager.GetSelection(AList: TList);
begin
  if FdxBarDesignHelper <> nil then
    FdxBarDesignHelper.GetSelection(AList);
end;

function TdxBarManager.GetSelectionStatus(AComponent: TPersistent): TdxBarSelectionStatus;
begin
  if FdxBarDesignHelper <> nil then
    Result := FdxBarDesignHelper.GetSelectionStatus(AComponent)
  else
    Result := ssUnselected;
end;

function TdxBarManager.IsComponentSelected(AComponent: TPersistent): Boolean;
begin
  Result := (GetSelectionStatus(AComponent) = ssActiveSelected);
end;

procedure TdxBarManager.SelectComponent(AComponent: TPersistent; ASelectionOperation: TdxBarSelectionOperation = soExclusive);
begin
  if FdxBarDesignHelper <> nil then
    FdxBarDesignHelper.SelectComponent(AComponent, ASelectionOperation);
end;

procedure TdxBarManager.SetSelection(AList: TList);
begin
  if FdxBarDesignHelper <> nil then
    FdxBarDesignHelper.SetSelection(AList);
end;

procedure TdxBarManager.ShowDefaultEventHandler(AItem: TdxBarItem);
begin
  if FdxBarDesignHelper <> nil then
    FdxBarDesignHelper.ShowDefaultEventHandler(AItem);
end;

function TdxBarManager.UniqueName(const BaseName: string): string;
begin
  if FdxBarDesignHelper <> nil then
    Result := FdxBarDesignHelper.UniqueName(BaseName)
end;

procedure TdxBarManager.CreateBarRestoringList;
begin
  if not BarRestoringListExists then
    FBarRestoringList := TList.Create;
end;

procedure TdxBarManager.DestroyBarRestoringList;
begin
  FreeAndNil(FBarRestoringList);
end;

function TdxBarManager.BarRestoringListExists: Boolean;
begin
  Result := FBarRestoringList <> nil;
end;

procedure TdxBarManager.AddBarToRestoringList(ABar: TdxBar);
begin
  if BarRestoringListExists and (FBarRestoringList.IndexOf(ABar) = -1) then
    FBarRestoringList.Add(ABar);
end;

procedure TdxBarManager.RemoveBarFromRestoringList(ABar: TdxBar);
begin
  if BarRestoringListExists then
    FBarRestoringList.Remove(ABar);
end;

procedure TdxBarManager.ShowBarsFromRestoringList(ADockControl: TdxBarDockControl);

  function CanShowBar(ABar: TdxBar): Boolean;
  begin
    if ADockControl = nil then
      Result := (ABar.RealDockControl = nil) or ABar.RealDockControl.HandleAllocated
    else
      Result := (ABar.DockControl = ADockControl) and (ABar.DockingStyle <> dsNone);
  end;

var
  I: Integer;
begin
  for I := RestoringListBarCount - 1 downto 0 do
    if CanShowBar(RestoringListBars[I]) then
      RestoringListBars[I].Visible := True;
end;

function TdxBarManager.GetBarIndexInRestoringList(ABar: TdxBar): Integer;
begin
  if BarRestoringListExists then
    Result := FBarRestoringList.IndexOf(ABar)
  else
    Result := -1;
end;

procedure TdxBarManager.AssignFont;
var
  NonClientMetrics: TNonClientMetrics;
begin
  NonClientMetrics.cbSize := SizeOf(NonClientMetrics);
  SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, @NonClientMetrics, 0);
  if FUseSystemFont then
  begin
    FInternalFontChange := True;
    try
      Font.Handle := CreateFontIndirect(NonClientMetrics.lfMenuFont);
    finally
      FInternalFontChange := False;
    end;
  end
  else
    if FScaled then
      Font.Height := NonClientMetrics.lfMenuFont.lfHeight;
end;

function TdxBarManager.CanReset: Boolean;
begin
  Result := (FReadStateCount > 0) and FAllowReset;
end;

procedure TdxBarManager.DefineProperties(Filer: TFiler);
begin
  inherited;
  Filer.DefineProperty('Bars', ReadBars, nil, False);
  Filer.DefineProperty('DockControlHeights', ReadDockControlHeights, WriteDockControlHeights, True);
end;

procedure TdxBarManager.DesignerModified;
begin
  if not (IsInitializing or IsDestroying) then
    if not CanModifyDesigner then
      FDesignerModifiedInvoked := True
    else
    begin
      FModified := True;
      if Designing and not (csUpdating in ComponentState) and not IsRecreating and
        ([bisBarsLoading, bisHandleCreating] * FInternalState = []) and not FImageOptions.IsLoading then
          BarDesignController.DesignerModified(ParentForm);
    end;
end;

procedure TdxBarManager.DoBarAfterReset(ABar: TdxBar);
begin
  if Assigned(FOnBarAfterReset) then FOnBarAfterReset(Self, ABar);
end;

procedure TdxBarManager.DoBarBeforeReset(ABar: TdxBar);
begin
  if Assigned(FOnBarBeforeReset) then FOnBarBeforeReset(Self, ABar);
end;

procedure TdxBarManager.DoBarClose(ABar: TdxBar);
begin
  if Assigned(FOnBarClose) then FOnBarClose(Self, ABar);
end;

procedure TdxBarManager.DoBarDockingStyleChanged(ABar: TdxBar);
begin
  if not BarsLoading then
  begin
    if Assigned(FOnBarDockingStyleChange) then
      FOnBarDockingStyleChange(Self, ABar);
//#DG    DesignerModified;
    ABar.Changed(True);
  end;
end;

procedure TdxBarManager.DoClickItem(AItem: TdxBarItem);
begin
  if Assigned(FOnClickItem) then FOnClickItem(Self, AItem);
end;

procedure TdxBarManager.DoCloseButtonClick;
begin
  CallNotify(FOnCloseButtonClick, Self);
end;

function TdxBarManager.DoDocking(ABar: TdxBar; AStyle: TdxBarDockingStyle;
  ADockControl: TdxDockControl): Boolean;
begin
  Result :=
    not (AStyle in ABar.NotDocking) and
    (((ADockControl = nil) or ADockControl.Main) and not (AStyle in NotDocking) or
     (ADockControl <> nil) and not ADockControl.Main and ADockControl.CanDocking(ABar));
  if Assigned(FOnDocking) then FOnDocking(ABar, AStyle, ADockControl, Result);
end;

procedure TdxBarManager.DoItemLinkChange(AItemLink: TdxBarItemLink);
begin
  if Assigned(OnItemLinkChange) and not IsLoading then
    OnItemLinkChange(Self, AItemLink);
end;

procedure TdxBarManager.DoHelpButtonClick;
begin
  CallNotify(FOnHelpButtonClick, Self);
end;

procedure TdxBarManager.DoMergeItemLink(
  ADstItemLinks, ASrcItemLinks: TdxBarItemLinks; ASrcItemLink: TdxBarItemLink;
  var AMergeKind: TdxBarItemMergeKind; var AMergeIndex: Integer);
begin
  if Assigned(FOnMergeItemLink) then
    FOnMergeItemLink(Self, ADstItemLinks, ASrcItemLinks, ASrcItemLink,
      AMergeKind, AMergeIndex);
end;

procedure TdxBarManager.DoShowCustomizingPopup(PopupItemLinks: TdxBarItemLinks);
begin
  if Assigned(FOnShowCustomizingPopup) then FOnShowCustomizingPopup(Self, PopupItemLinks);
end;

procedure TdxBarManager.DoShowToolbarsPopup(PopupItemLinks: TdxBarItemLinks);
begin
  if Assigned(FOnShowToolbarsPopup) then FOnShowToolbarsPopup(Self, PopupItemLinks);
end;

procedure TdxBarManager.DragAndDrop(AItem: TdxBarItem; AItemLink: TdxBarItemLink);
begin
  DragInfo.BeginDrag(AItem, AItemLink);
  try
    DragInfo.HandleDragging;
  finally
    DragInfo.EndDrag;
  end;
end;

function TdxBarManager.FindDockControl(APath: string): TdxBarDockControl;
var
  ARootName: string;
  ARoot: TComponent;
begin
  ARootName := Copy(APath, 1, Pos('.', APath) - 1);
  if ARootName <> '' then
  begin
    ARoot := FindGlobalComponent(ARootName);
    Delete(APath, 1, Length(ARootName) + 1);
  end
  else
    ARoot := Owner;//#DG
  Result := FindNestedComponent(ARoot, APath) as TdxBarDockControl;
end;

function TdxBarManager.GetCategoryRealIndex(AIndex: Integer): Integer;
var
  I: Integer;
begin
  if Designing then Result := AIndex
  else
  begin
    Result := -1;
    for I := 0 to FCategories.Count - 1 do
      if CategoryVisible[I] then
      begin
        Inc(Result);
        if Result = AIndex then
        begin
          Result := I;
          Exit;
        end;
      end;
    Result := -1;
  end;
end;

procedure TdxBarManager.GetChildren(Proc: TGetChildProc; Root: TComponent);
var
  I: Integer;
begin
  for I := 0 to Bars.Count - 1 do
    if Bars[I].Owner = Root then Proc(Bars[I]);
  for I := 0 to ItemCount - 1 do
    if (Items[I].Owner = Root) and (Items[I].Category > -1) then Proc(Items[I]);
  for I := 0 to GroupCount - 1 do
    if Groups[I].Owner = Root then Proc(Groups[I]);
end;

function TdxBarManager.GetChildOwner: TComponent;
begin
  Result := Owner;
end;

function TdxBarManager.GetPainterClass: TdxBarPainterClass;
begin
  case GetRealPaintStyle of
    rpsEnhanced:
      Result := TdxBarEnhancedPainter;
    rpsFlat:
      Result := TdxBarFlatPainter;
    rpsXP:
      Result := TdxBarXPPainter;
    rpsOffice11:
      Result := TdxBarOffice11Painter;
    rpsSkin:
      Result := dxBarSkinPainterClass;
  else{rpsStandard}
    Result := TdxBarStandardPainter;
  end;
end;

procedure TdxBarManager.GetRealLookAndFeel(ALookAndFeel: TcxLookAndFeel);
begin
  ALookAndFeel.Reset;
  ALookAndFeel.SkinName := '';
  case GetRealPaintStyle of
    rpsXP:
      ALookAndFeel.SetStyle(lfsNative);
    rpsStandard, rpsEnhanced:
      ALookAndFeel.SetStyle(lfsFlat);
    rpsFlat:
      ALookAndFeel.SetStyle(lfsUltraFlat);
    rpsOffice11:
      ALookAndFeel.SetStyle(lfsOffice11);
  else{rpsSkin}
    ALookAndFeel.Assign(LookAndFeel);
  end;
end;

function TdxBarManager.GetRealPaintStyle: TdxBarRealPaintStyle;
const
  BarManagerStyle2RealPaintStyle: array [bmsStandard..bmsOffice11] of TdxBarRealPaintStyle =
    (rpsStandard, rpsEnhanced, rpsFlat, rpsXP, rpsOffice11);
  LookAndFeelKind2RealPaintStyle: array [TcxLookAndFeelKind] of TdxBarRealPaintStyle =
    (rpsEnhanced, rpsStandard, rpsFlat, rpsOffice11);
begin
  case Style of
    bmsUseLookAndFeel:
      if LookAndFeel.NativeStyle and FThemeAvailable then
        Result := rpsXP
      else
        if LookAndFeel.SkinPainter <> nil then
          Result := rpsSkin
        else
          Result := LookAndFeelKind2RealPaintStyle[LookAndFeel.Kind];
    bmsXP:
      if not FThemeAvailable then
        Result := rpsEnhanced
      else
        Result := rpsXP;
  else
    Result := BarManagerStyle2RealPaintStyle[Style];
  end;
end;

function TdxBarManager.GetWindowForMouseCapturing: HWND;
begin
  if FIsCustomizing and (dxBarCustomizingForm <> nil) then
    Result := dxBarCustomizingForm.Handle
  else
    if IsWindowVisible(Application.Handle) then
      Result := Application.Handle
    else
      Result := Owner.Handle;//#DG
end;

procedure TdxBarManager.SetChildOrder(Child: TComponent; Order: Integer);
begin
  inherited;
  if Child is TdxBarItem then
    TdxBarItem(Child).Index := Order - Bars.Count;
  if Child is TdxBarGroup then
    TdxBarGroup(Child).Index := Order - Bars.Count - ItemCount;
end;

procedure TdxBarManager.CustomImagesChanged(AChangeProc: TdxBarItemChangeProc);
var
  I: Integer;
begin
  if not IsLoading and not IsDestroying then
  begin
    BeginUpdate;
    try
      for I := 0 to ItemCount - 1 do
        AChangeProc(Items[I]);
    finally
      EndUpdate;
    end;
  end;
end;

procedure TdxBarManager.DisabledImagesChanged(AItem: TdxBarItem);
begin
  if AItem.ImageIndex > -1 then AItem.GlyphChanged;
end;

procedure TdxBarManager.DisabledLargeImagesChanged(AItem: TdxBarItem);
begin
  if AItem.UseLargeImages then AItem.LargeGlyphChanged;
end;

procedure TdxBarManager.HotImagesChanged(AItem: TdxBarItem);
begin
  if AItem.UseHotImages then AItem.HotGlyphChanged;
end;

procedure TdxBarManager.ImagesChanged(AItem: TdxBarItem);
begin
  if AItem.ImageIndex > -1 then AItem.GlyphChanged;
end;

function TdxBarManager.IsLargeImagesForLargeIcons: Boolean;
begin
  Result := FImageOptions.IsLargeImagesForLargeIcons;
end;

procedure TdxBarManager.LargeImagesChanged(AItem: TdxBarItem);
begin
  if AItem.UseLargeImages then AItem.LargeGlyphChanged;
end;

procedure TdxBarManager.DisableFloatToolBars;
var
  I: Integer;
begin
  FDisabledToolBarsList := TList.Create;
  for I := 0 to Bars.Count - 1 do
    if Bars[I].IsFloat then
      DisableWindow(FDisabledToolBarsList, Bars[I].Control.Handle);
end;

procedure TdxBarManager.EnableFloatToolBars;
begin
  EnableWindows(FDisabledToolBarsList);
  FreeAndNil(FDisabledToolBarsList);
end;

procedure TdxBarManager.ActivateFloatToolbars(AActivate, AForceOperation: Boolean; AActiveWindow: HWND);
begin
  if (AActivate <> FMainFormActive) or AForceOperation then
  begin
    FMainFormActive := AActivate;
    ShowToolbars(AActivate, AForceOperation, AActiveWindow);
  end;
end;

function TdxBarManager.IsInternalDockControl(
  ADockControl: TdxDockControl): Boolean;
var
  ADockingStyle: TdxBarDockedDockingStyle;
begin
  for ADockingStyle := Low(TdxBarDockedDockingStyle) to High(TdxBarDockedDockingStyle) do
  begin
    Result := ADockControl = InternalDockControls[ADockingStyle];
    if Result then
      Break;
  end;
end;

function TdxBarManager.IsUpdateLocked: Boolean;
begin
  Result := FLockUpdateCount > 0;
end;

procedure TdxBarManager.Loaded;

  procedure SortItems;
  var
    I: Integer;
    ASorted: Boolean;
  begin
    repeat
      ASorted := True;
      for I := 0 to ItemCount - 2 do
        if Items[I].Category > Items[I + 1].Category then
        begin
          MoveItem(I + 1, I);
          ASorted := False;
        end;
    until ASorted;
  end;

  procedure CheckBrokenLinks;

  var
    ALinksList: TdxObjectList;

    procedure CheckLink(ALink: TdxBarItemLink);
    begin
      if ALink.Item = nil then
        ALinksList.Add(ALink);
    end;

    procedure CheckLinks(ALinks: TdxBarItemLinks);
    var
      I: Integer;
    begin
      if ALinks <> nil then
        for I := 0 to ALinks.Count - 1 do
          CheckLink(ALinks[I]);
    end;

  const
    AMessage = ' has broken bar item links. These links are not associated with any bar item, and may cause problems when creating a bar layout.'+#13#10+#13#10+'Do you want to delete broken bar item links?';
  var
    I: Integer;
  begin
    ALinksList := TdxObjectList.Create;
    try
      for I := 0 to ItemCount - 1 do
        CheckLinks(Items[I].GetItemLinks);

      for I := 0 to FBars.Count - 1 do
        CheckLinks(FBars[I].ItemLinks);

      if ALinksList.Count > 0 then
        case MessageBox(0, PChar(cxGetFullComponentName(Self) + AMessage), 'ExpressBars', MB_ICONWARNING or MB_YESNOCANCEL) of
          IDYES:
            begin
              ALinksList.OwnsObjects := True;
              ALinksList.Clear;
              DesignerModified;
            end;
          IDCANCEL: Abort;
        end;
    finally
      ALinksList.Free;
    end;
  end;

var
  I: Integer;
begin
  inherited Loaded;

  if IsUpdateLocked then Exit;

  Include(FInternalState, bisAfterLoading);
  try
    LoadLinkItemNames;
    if Designing then
      SortItems;
    Include(FInternalState, bisBarsLoading);
    try
      for I := 0 to ItemCount - 1 do
        with Items[I] do
          Visible := FLoadedVisible;
      for I := 0 to FBars.Count - 1 do
        with FBars[I] do
        begin
          FIsPredefined := True;
          DockControl := FLoadedDockControl;
          if DockControl = nil then
            DockingStyle := FLoadedDockingStyle;
          Visible := FLoadedVisible;
        end;
      SaveState;
      if not Designing then
      begin
        if FStoreInRegistry then LoadFromRegistry(FRegistryPath);
        if FStoreInIniFile then LoadFromIniFile(FIniFileName);
      end;
    finally
      Exclude(FInternalState, bisBarsLoading);
    end;

    BeginUpdate;
    try
      for I := 0 to FCategories.Count - 1 do
        if FCategories.Objects[I] <> nil then
          CategoryItemsVisible[I] := TdxBarCategoryData(FCategories.Objects[I]).LoadedItemsVisible;
    finally
      EndUpdate;
    end;

    for I := 0 to DockControlCount - 1 do
      DockControls[I].UpdateDock;
  finally
    Exclude(FInternalState, bisAfterLoading);
  end;

  if csDesigning in ComponentState then
    CheckBrokenLinks;
end;

procedure TdxBarManager.LockDesignerModified(ALock: Boolean;
  AInvokeDesignerModifiedOnUnlock: Boolean = True);
begin
  if ALock then
  begin
    if FLockDesignerModifiedCount = 0 then
      FDesignerModifiedInvoked := False;
    Inc(FLockDesignerModifiedCount);
  end
  else
  begin
    Dec(FLockDesignerModifiedCount);
    if (FLockDesignerModifiedCount = 0) and AInvokeDesignerModifiedOnUnlock and FDesignerModifiedInvoked then
      DesignerModified;
  end;
end;

procedure TdxBarManager.Notification(AComponent: TComponent; Operation: TOperation);
var
  I: Integer;
begin
  inherited;
  if Operation = opRemove then
  begin
    if AComponent is TControl then
      for I := 0 to FPopupMenuLinks.Count - 1 do
        if FPopupMenuLinks[I].Control = AComponent then
          FPopupMenuLinks[I].Control := nil;
    if AComponent is TdxBarPopupMenu then
      for I := 0 to FPopupMenuLinks.Count - 1 do
        if FPopupMenuLinks[I].PopupMenu = AComponent then
          FPopupMenuLinks[I].PopupMenu := nil;
  end;
end;

procedure TdxBarManager.ReadState(Reader: TReader);
begin
  inherited;
  Inc(FReadStateCount);
end;

procedure TdxBarManager.SetName(const NewName: TComponentName);
var
  I: Integer;
  OldName, ItemName, NamePrefix: TComponentName;
  Item: TdxBarItem;
begin
  OldName := Name;
  inherited SetName(NewName);
  if Designing and (Name <> OldName) then
    for I := 0 to FItems.Count - 1 do
    begin
      Item := Items[I];
      if Item.Owner = Owner then
      begin
        ItemName := Item.Name;
        NamePrefix := ItemName;
        if Length(NamePrefix) > Length(OldName) then
        begin
          SetLength(NamePrefix, Length(OldName));
          if CompareText(OldName, NamePrefix) = 0 then
          begin
            System.Delete(ItemName, 1, Length(OldName));
            System.Insert(NewName, ItemName, 1);
            try
              Item.Name := ItemName;
            except
              on EComponentError do
            end;
          end;
        end;
      end;
    end;
end;

procedure TdxBarManager.ShowToolbars(AShow, AForceOperation: Boolean; AActiveWindow: HWND);

  function CanHideToolbars: Boolean;
  begin
    Result := HideFloatingBarsWhenInactive or AForceOperation;
  end;

  procedure InvalidateBarsCaptions;
  var
    I: Integer;
  begin
    for I := 0 to Bars.Count - 1 do
      if Bars[I].IsFloat then
        Bars[I].Control.FrameChanged;
  end;

var
  I: Integer;
begin
  if bisToolbarsVisibleChanging in FInternalState then
    Exit;
  Include(FInternalState, bisToolbarsVisibleChanging);
  try
    if not CanHideToolbars then
      InvalidateBarsCaptions;
    if not AShow then
    begin
      if GetParent(AActiveWindow) = GetMainForm.Handle then
        Exit;
      if (ActiveBarControl <> nil) and ActiveBarControl.CanDeactivate(Self, AActiveWindow) then //#DG rollback to 302-nd version
//#DG      while (ActiveBarControl <> nil) and ActiveBarControl.CanDeactivate(Self, ActiveWindow) do
        ActiveBarControl.HideAll;

      BarNavigationController.StopKeyboardHandling;

      if not CanHideToolbars then
      begin
        if BarDesignController.QuickControl <> nil then
          BarDesignController.QuickControl.CloseUp;
        Exit;
      end;
      if (AActiveWindow = 0) or (FindControl(AActiveWindow) is TCustomForm) and
        ((dxBarCustomizingForm = nil) or (AActiveWindow <> dxBarCustomizingForm.Handle) or not FIsCustomizing) or
        IsAnotherApplicatonWindow(AActiveWindow) or
        (AActiveWindow = Application.Handle) then
      begin
        for I := 0 to Bars.Count - 1 do
          if Bars[I].IsFloat and Bars[I].Control.CanHide then
            Bars[I].Control.Hide;
        if not AForceOperation then
          SendMessage(ParentForm.Handle, WM_NCACTIVATE, 0, 0);
      end;
    end
    else
      if IsOwnerVisible or IsOwnerMDIChild(True) then
        for I := 0 to Bars.Count - 1 do
          if Bars[I].IsFloat and Bars[I].Visible then
            Bars[I].Control.Show;
  finally
    Exclude(FInternalState, bisToolbarsVisibleChanging);
  end;
end;

function TdxBarManager.IsOwnerVisible: Boolean;
var
  AWnd: HWND;
begin
  Result := IsControlVisible(Owner);
  if Result then
  begin
    AWnd := Owner.Handle;
    while not IsIconic(AWnd) and IsChildClassWindow(AWnd) do
      AWnd := GetParent(AWnd);
    Result := not IsIconic(AWnd);
  end;
end;

function TdxBarManager.IsUncustomizable: Boolean;
var
  ACustomizingBarManager: TdxBarManager;
begin
  ACustomizingBarManager := dxBarManagerList.GetCustomizingBarManager;
  Result := (ACustomizingBarManager <> nil) and (Self <> ACustomizingBarManager);
end;

function TdxBarManager.CanAddComponents: Boolean;
begin
  Result := Owner.ComponentState * [csDesigning, csInline] <> [csDesigning, csInline];
end;

function TdxBarManager.GetLightColor(ABtnFaceColorPart, AHighlightColorPart, AWindowColorPart: Integer): COLORREF;
begin
  Result := dxOffice11.GetLightColor(ABtnFaceColorPart, AHighlightColorPart, AWindowColorPart);
end;

function TdxBarManager.BarByCaption(const ACaption: string): TdxBar;
var
  I: Integer;
begin
  for I := 0 to FBars.Count - 1 do
  begin
    Result := FBars[I];
    if Result.Caption = ACaption then Exit;
  end;
  Result := nil;
end;

function TdxBarManager.BarByComponentName(const AName: string): TdxBar;
var
  I: Integer;
begin
  Result := nil;
  for I := 0 to Bars.Count - 1 do
    if Bars[I].Name = AName then
    begin
      Result := Bars[I];
      Break;
    end;
end;

function TdxBarManager.BarByOldName(const AName: string): TdxBar;
var
  I: Integer;
begin
  Result := nil;
  for I := 0 to Bars.Count - 1 do
    if Bars[I].OldName = AName then
    begin
      Result := Bars[I];
      Break;
    end;
end;

//function TdxBarManager.CheckBarName(const AName: string): string;
//begin
//  if BarByNewName(AName) = nil then
//    Result := AName
//  else
//    Result := GetUniqueToolbarName(AName);
//end;

function TdxBarManager.GetUniqueToolbarCaption(const ABaseName: string): string;
var
  I: Integer;
begin
  I := 0;
  repeat
    Inc(I);
    Result := ABaseName + IntToStr(I);
  until BarByCaption(Result) = nil;
end;

function TdxBarManager.GetUniqueToolbarName(const ABaseName: string): string;
var
  I: Integer;
begin
  if not IsLoading and Designing then
    Result := UniqueName(ABaseName)
  else
  begin
    I := 0;
    repeat
      Inc(I);
      Result := ABaseName + IntToStr(I);
    until BarByNewName(Result) = nil;
  end;
end;

function TdxBarManager.GetAllItemsByCategory(ACategory: Integer; List: TList): Integer;
var
  I: Integer;
begin
  List.Clear;
  if (0 <= ACategory) and (ACategory < Categories.Count) then
    for I := 0 to ItemCount - 1 do
      if Items[I].Category = ACategory then List.Add(Items[I]);
  Result := List.Count;
end;

function TdxBarManager.GetCountByCategory(ACategory: Integer): Integer;
var
  I: Integer;
begin
  Result := 0;
  if (0 <= ACategory) and (ACategory < Categories.Count) then
    for I := 0 to ItemCount - 1 do
      with Items[I] do
        if (Category = ACategory) and
          (Designing or ActuallyVisible and not Hidden) then
          Inc(Result);
end;

function TdxBarManager.GetItemByCategory(ACategory, AIndex: Integer): TdxBarItem;
var
  AList: TList;
begin
  Result := nil;
  AList := TList.Create;
  try
    GetItemsByCategory(ACategory, AList);
    if (0 <= AIndex) and (AIndex < AList.Count) then
      Result := TdxBarItem(AList[AIndex]);
  finally
    AList.Free;
  end;
end;

function TdxBarManager.GetItemByName(const AName: string): TdxBarItem;
var
  I: Integer;
begin
  Result := nil;
  for I := 0 to ItemCount - 1 do
    if CompareText(Items[I].Name, AName) = 0 then
    begin
      Result := Items[I];
      Break;
    end;
end;

function TdxBarManager.GetItemsByCategory(ACategory: Integer; List: TList): Integer;
var
  I: Integer;
begin
  if Designing then
    Result := GetAllItemsByCategory(ACategory, List)
  else
  begin
    List.Clear;
    if (0 <= ACategory) and (ACategory < Categories.Count) then
      for I := 0 to ItemCount - 1 do
        with Items[I] do
          if (Category = ACategory) and ActuallyVisible and not Hidden then
            List.Add(Items[I]);
    Result := List.Count;
  end;
end;

function TdxBarManager.GetUniqueItemName(ABarItemClass: TdxBarItemClass): string;
var
  S, S1: string;
  I, J: Integer;
  AFound: Boolean;
begin
  S := ABarItemClass.ClassName;
  Delete(S, 1, 1);
  if Designing then
    Result := UniqueName(S)
  else
  begin
    J := 0;
    repeat
      Inc(J);
      S1 := S + IntToStr(J);
      AFound := False;
      for I := 0 to ItemCount - 1 do
        if CompareText(S1, Items[I].Name) = 0 then
        begin
          AFound := True;
          Break;
        end;
    until not AFound;
    Result := S1;
  end;
end;

function TdxBarManager.AddButton: TdxBarButton;
begin
  Result := TdxBarButton(AddItem(TdxBarButton));
end;

function TdxBarManager.AddItem(AClass: TdxBarItemClass): TdxBarItem;
var
  ACategoryIndex: Integer;
begin
  Result := AClass.Create(Self);
  ACategoryIndex := Categories.IndexOf(dxSBAR_DEFAULTCATEGORYNAME);
  if ACategoryIndex = -1 then
    ACategoryIndex := 0;
  Result.Category := ACategoryIndex;
end;

function TdxBarManager.AddSubItem: TdxBarSubItem;
begin
  Result := TdxBarSubItem(AddItem(TdxBarSubItem));
end;

function TdxBarManager.AddToolBar(AIsMainMenu: Boolean = False;
  ANeedEditCaption: Boolean = False): TdxBar;
var
  AWorkArea: TRect;
  ACaption: string;
begin
  Result := nil;
  ACaption := GetUniqueToolbarCaption(cxGetResourceString(@dxSBAR_TOOLBARNEWNAME));
  if ANeedEditCaption and not dxBarEditName(ACaption, 0, 0, Self, nil) then
    Exit;
  BeginUpdate;
  try
    Bars.BeginUpdate; // TODO FIX!!!
    try
      Result := Bars.Add;
      Result.Caption := ACaption;
      AWorkArea := GetWorkArea(Point(Owner.Left, Owner.Top));
      Result.FloatLeft := Owner.Left - 50;
      if Result.FloatLeft < AWorkArea.Left then
        Result.FloatLeft := Owner.Left + Owner.Width + 10;
      Result.FloatTop := Owner.Top;
      if Result.FloatTop < AWorkArea.Top then
        Result.FloatTop := AWorkArea.Top + 10;
      Result.DockingStyle := dsTop;
      if AIsMainMenu then
      begin
        Result.Row := 0;
        Result.IsMainMenu := True;
        Result.Visible := True;
      end
      else
      begin
        Result.Row := Result.RealDockControl.RowCount;
        Result.OneOnRow := True;
        Result.Visible := True;
        Result.OneOnRow := False;
      end;
      BarDesignController.SelectItem(Result);
    finally
      Bars.EndUpdate;
    end;
  finally
    EndUpdate;
  end;
end;

procedure TdxBarManager.DeleteToolBar(ABar: TdxBar; AConfirmation: Boolean);
begin
  if ABar = nil then
    Exit;
  if not AConfirmation or
       (dxBarMessageBox(Format(cxGetResourceString(@dxSBAR_WANTTODELETETOOLBAR), [ABar.Caption]),
         MB_ICONEXCLAMATION or MB_OKCANCEL) = ID_OK) then
    ABar.Free;
end;

procedure TdxBarManager.ExchangeItems(Index1, Index2: Integer);
begin
  FItems.Exchange(Index1, Index2);
  DesignerModified;
end;

{procedure TdxBarManager.FocusItem(AItem: TdxBarItem);
var
  AdxBarItemLink : TdxBarItemLink;
begin
  AdxBarItemLink := AItem.GetCurItemLink;
  if AdxBarItemLink = nil then
    AdxBarItemLink := AItem.GetLinks(0);
  if (AdxBarItemLink <> nil) then
    begin
      if AdxBarItemLink.BarControl = nil then
        TdxBarSubItem(TdxBarItemLinks(AdxBarItemLink.owner).owner).DropDown;
      if AdxBarItemLink.FControl <> nil then
      begin
        TdxBarWinControl(AdxBarItemLink.FControl).SetFocused(True);
        AdxBarItemLink.GetBarControl.SetSelectedItem(AdxBarItemLink.FControl);
      end;
    end;
end;}

procedure TdxBarManager.MoveItem(CurIndex, NewIndex: Integer);
begin
  FItems.Move(CurIndex, NewIndex);
  DesignerModified;
end;

procedure TdxBarManager.RenameToolBar(ABar: TdxBar);
var
  ACaption: string;
begin
  if ABar = nil then
    Exit;
  ACaption := ABar.Caption;
  if dxBarEditName(ACaption, 0, 1, Self, ABar) then
    ABar.Caption := ACaption;
end;

procedure TdxBarManager.ResetToolBar(ABar: TdxBar);
begin
  if ABar <> nil then
    ABar.ResetWithConfirmation;
end;

procedure TdxBarManager.Merge(ABarManager: TdxBarManager;
  ACanCreateNewBar: Boolean = True);
var
  ABar, ANewBar: TdxBar;
  I: Integer;
begin
  if (ABarManager = nil) or (ABarManager = Self) then
    raise EdxException.Create(cxGetResourceString(@dxSBAR_CANTMERGEBARMANAGER));
  for I := 0 to ABarManager.Bars.Count - 1 do
  begin
    ABar := ABarManager.Bars[I];
    if ABar.MergeData.MergedWith <> nil then
      raise EdxException.Create(cxGetResourceString(@dxSBAR_ONEOFTOOLBARSALREADYMERGED));
    if ABar.MergeData.MergedBarList.Count <> 0 then
      raise EdxException.Create(cxGetResourceString(@dxSBAR_ONEOFTOOLBARSHASMERGEDTOOLBARS));
  end;

  for I := 0 to ABarManager.Bars.Count - 1 do
  begin
    ABar := ABarManager.Bars[I];
    if ABar.Visible and (BarByCaption(ABar.Caption) <> nil) then
      BarByCaption(ABar.Caption).Merge(ABar);
  end;

  if ACanCreateNewBar then
    for I := 0 to ABarManager.Bars.Count - 1 do
    begin
      ABar := ABarManager.Bars[I];
      if ABar.Visible and (ABar.MergeData.MergedWith = nil) then
      begin
        ANewBar := CreateBarAsByMerging;
        ANewBar.Caption := ABar.Caption;
        ANewBar.Merge(ABar);
        ANewBar.Visible := True;
      end;
    end;
end;

procedure TdxBarManager.Unmerge(ABarManager: TdxBarManager = nil);
begin
  InternalUnmerge(ABarManager, False);
end;

procedure TdxBarManager.Customizing(Show: Boolean);
var
  APrevBarCount, I: Integer;
begin
  if (FIsCustomizing <> Show) and (not Show or (dxBarCustomizingForm = nil)) then
  begin
//    BeginUpdate; //#DG flickers
    try
      for I := Bars.Count - 1 downto 0 do
        if Bars[I].Control <> nil then
          with Bars[I].Control do
          begin
            APrevBarCount := Self.Bars.Count;
            HideAll;
            if APrevBarCount = Self.Bars.Count then // HideAll can destroy Bar
              DestroyControls;
          end;
      FIsCustomizing := Show;
      for I := 0 to Bars.Count - 1 do
        with Bars[I] do
        begin
          ItemLinks.RefreshVisibilityLists;
          if Control <> nil then Control.CreateControls;
        end;
      for I := 0 to ItemCount - 1 do
        if Items[I] is TCustomdxBarSubItem then
           TCustomdxBarSubItem(Items[I]).ItemLinks.RefreshVisibilityLists;
      for I := 0 to FPopupMenus.Count - 1 do
        TdxBarPopupMenu(FPopupMenus[I]).ItemLinks.RefreshVisibilityLists;
    finally
//      EndUpdate(False);
    end;
    dxBarCustomizing(Self, Show);
    for I := 0 to Bars.Count - 1 do
      with Bars[I] do
        if Control <> nil then
          with Control do
          begin
            UpdateControlState;
            RepaintBar;
          end;
  end;
end;

procedure TdxBarManager.HideAll;
begin
  if (ActiveBarControl <> nil) {and (ActiveBarControl.BarManager = Self) }then
    ActiveBarControl.HideAll;
end;

procedure TdxBarManager.ResetUsageData;
var
  ABarIndex: Integer;
  I: Integer;
begin
  BeginUpdate;
  try
    for I := 0 to ItemCount - 1 do
      Items[I].LoadUsageData(SavedState, GetBaseIniSection);

    for I := 0 to Bars.Count - 1 do
    begin
      ABarIndex := GetSavedBarIndex(Bars[I].Caption);
      if ABarIndex <> -1 then
        Bars[I].LoadUsageData(SavedState, GetBaseIniSection, ABarIndex);
    end;
  finally
    EndUpdate;
  end;
end;

procedure TdxBarManager.ResetUsageDataWithConfirmation;
begin
  if dxBarMessageBox(cxGetResourceString(@dxSBAR_WANTTORESETUSAGEDATA),
       MB_YESNO or MB_DEFBUTTON2 or MB_ICONEXCLAMATION) = ID_YES then
    ResetUsageData;
end;

function GetComponentPath(ABarManagerOwner, AComponent: TComponent): string;
begin
  Result := AComponent.Name;
  if (Result <> '') and (AComponent.Owner <> ABarManagerOwner) then
    while not (AComponent is TCustomForm) and (AComponent.Owner <> nil) and
      (AComponent.Owner.Name <> '') do
    begin
      AComponent := AComponent.Owner;
      Result := AComponent.Name + '.' + Result;
    end;
end;

function TdxBarManager.GetBarManagerSection(const ABaseSection: string;
  AStoringKind: TdxBarStoringKind): string;
begin
  Result := ABaseSection;
  if AStoringKind = skIni then
    Result := Result + 'Main';
end;

function TdxBarManager.GetBaseIniSection: string;
var
  AOwner: TComponent;
begin
  Result := Name + GetSectionDelimiter(skIni);
  AOwner := Owner;
  while (AOwner <> nil) and (AOwner.Name <> '') do
  begin
    Result := AOwner.Name + GetSectionDelimiter(skIni) + Result;
    if AOwner is TCustomForm then
      Break;
    AOwner := AOwner.Owner;
  end;
end;

procedure TdxBarManager.LoadBarManager(ASource: TCustomIniFile; const ASection: string; AStoringKind: TdxBarStoringKind);
var
  ABarCount, AItemCount, I: Integer;
  ACurrentSection: string;
begin
  ACurrentSection := GetBarManagerSection(ASection, AStoringKind);
  BeginUpdate;
  try
    if CanShowRecentItems then
    begin
      MenusShowRecentItemsFirst := ASource.ReadBool(ACurrentSection, 'MenusShowRecentItemsFirst', MenusShowRecentItemsFirst);
      ShowFullMenusAfterDelay := ASource.ReadBool(ACurrentSection, 'ShowFullMenusAfterDelay', ShowFullMenusAfterDelay);
    end;
    LargeIcons := ASource.ReadBool(ACurrentSection, 'LargeIcons', LargeIcons);
    MenuAnimations := TdxBarMenuAnimations(ASource.ReadInteger(ACurrentSection, 'MenuAnimations', Byte(MenuAnimations)));
    ShowHint := ASource.ReadBool(ACurrentSection, 'ShowHint', ShowHint);
    ShowShortCutInHint := ASource.ReadBool(ACurrentSection, 'ShowShortCutInHint', ShowShortCutInHint);
    ABarCount := ASource.ReadInteger(ACurrentSection, 'BarCount', 0);
    AItemCount := ASource.ReadInteger(ASection + 'Items', 'ItemCount', -1);
    if AItemCount > -1 then
    begin
      FNewItems := TStringList.Create;
      for I := 0 to ItemCount - 1 do
        if not ASource.ReadBool(ASection + 'Items', Items[I].Name, False) then
          FNewItems.Add(Items[I].Name);
    end;
    if ABarCount > 0 then
    begin
      for I := 0 to Bars.Count - 1 do
      begin
        Bars[I].Visible := False;
        Bars[I].DockRow := nil;
      end;
      for I := 0 to ABarCount - 1 do
      begin
        if I >= Bars.Count then
          Bars.Add;
        Bars[I].LoadFromIni(ASource, ASection, I, AStoringKind);
      end;
    end;
    for I := 0 to ItemCount - 1 do
      Items[I].LoadFromIni(ASource, ASection, AStoringKind);
    if AItemCount > -1 then
      FreeAndNil(FNewItems);
    IniFileCollectionCallMethods(ReadIniFileHandlers, ASource, AStoringKind, ASection);
  finally
    EndUpdate;
  end;
end;

procedure TdxBarManager.SaveBarManager(ADestination: TCustomIniFile; const ASection: string; AStoringKind: TdxBarStoringKind);

  procedure ClearOldData(ADestination: TCustomIniFile; const ASection: string);
  var
    AKeys: TStringList;
    I: Integer;
  begin
    AKeys := TStringList.Create;
    try
      ADestination.ReadSections(AKeys);
      for I := 0 to AKeys.Count - 1 do
        if Copy(AKeys[I], 1, Length(ASection)) = ASection then
          ADestination.EraseSection(AKeys[I]);
    finally
      AKeys.Free;
    end;
    if AStoringKind = skReg then
      ADestination.EraseSection(ASection);
  end;

  function GetBarCount: Integer;
  var
    I: Integer;
  begin
    Result := 0;
    for I := 0 to Bars.Count - 1 do
      if not Bars[I].MergeData.CreatedByMerging then
        Inc(Result);
  end;

var
  ACurrentSection: string;
  I: Integer;
begin
  ClearOldData(ADestination, ASection);
  ACurrentSection := GetBarManagerSection(ASection, AStoringKind);
  ADestination.WriteInteger(ACurrentSection, 'Version', dxBuildNumber);
  if CanShowRecentItems then
  begin
    ADestination.WriteBool(ACurrentSection, 'MenusShowRecentItemsFirst', MenusShowRecentItemsFirst);
    ADestination.WriteBool(ACurrentSection, 'ShowFullMenusAfterDelay', ShowFullMenusAfterDelay);
  end;
  ADestination.WriteBool(ACurrentSection, 'LargeIcons', LargeIcons);
  ADestination.WriteInteger(ACurrentSection, 'MenuAnimations', Ord(MenuAnimations));
  ADestination.WriteBool(ACurrentSection, 'ShowHint', ShowHint);
  ADestination.WriteBool(ACurrentSection, 'ShowShortCutInHint', ShowShortCutInHint);
  ADestination.WriteInteger(ACurrentSection, 'BarCount', GetBarCount);
  ADestination.WriteInteger(ASection + 'Items', 'ItemCount', ItemCount);
  for I := 0 to ItemCount - 1 do
    ADestination.WriteBool(ASection + 'Items', Items[I].Name, True);
  for I := 0 to Bars.Count - 1 do
    if not Bars[I].MergeData.CreatedByMerging then
      Bars[I].SaveToIni(ADestination, ASection, I, AStoringKind);
  for I := 0 to ItemCount - 1 do
    Items[I].SaveToIni(ADestination, ASection, AStoringKind);
  IniFileCollectionCallMethods(WriteIniFileHandlers, ADestination, AStoringKind, ASection);
end;

procedure TdxBarManager.SaveState;
begin
  if SavedState <> nil then
  begin
    Include(FInternalState, bisStateSaving);
    try
      SaveBarManager(SavedState, GetBaseIniSection, skIni);
    finally
      Exclude(FInternalState, bisStateSaving);
    end;
  end;
end;

function TdxBarManager.CreateBarAsByMerging: TdxBar;
begin
  Result := Bars.Add;
  Result.MergeData.CreatedByMerging := True;
  Result.Move(dsTop, DockControls[Integer(dsTop) - 1].RowCount, 0);
end;

procedure TdxBarManager.InternalUnmerge(ABarManager: TdxBarManager;
  AForCustomization: Boolean);
var
  ABar: TdxBar;
  ABarLink: TcxObjectLink;
  ABarList: TList;
  I: Integer;
begin
  ABarList := nil;
  try
    if AForCustomization then
    begin
      ABarManager := nil;
      ABarList := TList.Create;
      for I := 0 to Bars.Count - 1 do
        if (Bars[I].MergeData.MergedWith <> nil) and
          (Bars[I].MergeData.MergedWith.BarManager = Self) then
            ABarList.Add(Bars[I]);
    end;

    for I := Bars.Count - 1 downto 0 do
    begin
      ABarLink := cxAddObjectLink(Bars[I]);
      try
        if AForCustomization then
        begin
          Bars[I].SaveMergeState;
          if Bars[I].MergeData.CreatedByMerging then
            Bars[I].ShouldNotBeDestroyedIfEmptyAfterUnmerge := True;
        end;
        Bars[I].InternalUnmergeFromBarManager(ABarManager, not AForCustomization);
        if ABarLink.Ref <> nil then
          Bars[I].ShouldNotBeDestroyedIfEmptyAfterUnmerge := False;
      finally
        cxRemoveObjectLink(ABarLink);
      end;
    end;

    if AForCustomization then
      for I := 0 to ABarList.Count - 1 do
      begin
        ABar := TdxBar(ABarList[I]);
        ABar.SetVisibility(ABar.MergeData.VisibleBeforeMerging);
      end;
  finally
    FreeAndNil(ABarList);
  end;
end;

procedure TdxBarManager.RestoreMergeState;
var
  ABar: TdxBar;
  I: Integer;
begin
  for I := 0 to Bars.Count - 1 do
  begin
    ABar := Bars[I];
    if not ABar.MergeData.CreatedByMerging then
      ABar.RestoreMergeState;
  end;

  for I := 0 to Bars.Count - 1 do
  begin
    ABar := Bars[I];
    if ABar.MergeData.CreatedByMerging then
    begin
      ABar.RestoreMergeState;
      ABar.Hidden := False;
      ABar.SetVisibility(ABar.MergeData.CreatedByMergingBarVisibleBeforeCustomization);
    end;
  end;
end;

procedure TdxBarManager.GetActiveSelection(AList: TList);
var
  I: Integer;
begin
  GetSelection(AList);
  for I := AList.Count - 1 downto 0 do
    if GetSelectionStatus(TPersistent(AList[I])) <> ssActiveSelected then
      AList.Delete(I);
end;

procedure TdxBarManager.BeginMouseTracking(ABarControl: TCustomdxBarControl);
begin
  if FMouseTrackingBarControl <> ABarControl then
  begin
    if FMouseTrackingBarControl <> nil then
      FMouseTrackingBarControl.MouseLeave;
    FMouseTrackingBarControl := ABarControl;
    cxControls.BeginMouseTracking(ABarControl, ABarControl.GetMouseTrackingBounds, ABarControl);
  end;
end;

procedure TdxBarManager.EndMouseTracking(ABarControl: TCustomdxBarControl);
begin
  if IsMouseTracking(ABarControl) then
    FMouseTrackingBarControl := nil;
  cxControls.EndMouseTracking(ABarControl);
end;

function TdxBarManager.IsMouseTracking(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := ABarControl = FMouseTrackingBarControl;
end;

procedure TdxBarManager.LoadFromRegistry(ARegistryPath: string);
var
  Registry: TRegistryIniFile;
begin
  if not CorrectRegistryPath(ARegistryPath) then
    Exit;
  Registry := TRegistryIniFile.Create(ARegistryPath);
  try
    LoadBarManager(Registry, ARegistryPath, skReg);
  finally
    Registry.Free;
  end;
end;

procedure TdxBarManager.SaveToRegistry(ARegistryPath: string);
var
  Registry: TRegistryIniFile;
begin
  if not CorrectRegistryPath(ARegistryPath) then
    Exit;
  Registry := TRegistryIniFile.Create(ARegistryPath);
  try
    SaveBarManager(Registry, ARegistryPath, skReg);
  finally
    Registry.Free;
  end;
end;

procedure TdxBarManager.LoadFromIniFile(const AFileName: string);
var
  AIniFile: TMemIniFile;
  ATempList: TStringList;
begin
  if (AFileName = '') and (FIniFileStream = nil) then
    Exit;
  AIniFile := TMemIniFile.Create(AFileName);
  try
    if FIniFileStream <> nil then
    begin
      ATempList := TStringList.Create;
      try
        ATempList.LoadFromStream(FIniFileStream);
        AIniFile.SetStrings(ATempList);
      finally
        ATempList.Free;
      end;
    end;
    LoadBarManager(AIniFile, GetBaseIniSection, skIni);
  finally
    AIniFile.Free;
  end;
end;

procedure TdxBarManager.SaveToIniFile(const AFileName: string);
var
  AIniFile: TMemIniFile;
  ATempList: TStringList;
begin
  if (AFileName = '') and (FIniFileStream = nil) then Exit;
  AIniFile := TMemIniFile.Create(AFileName);
  try
    SaveBarManager(AIniFile, GetBaseIniSection, skIni);
  finally
    if FIniFileStream = nil then
      AIniFile.UpdateFile
    else
    begin
      ATempList := TStringList.Create;
      try
        AIniFile.GetStrings(ATempList);
        ATempList.SaveToStream(FIniFileStream);
      finally
        ATempList.Free;
      end;
    end;
    AIniFile.Free;
  end;
end;

procedure TdxBarManager.LoadFromStream(AStream: TStream);
begin
  FIniFileStream := AStream;
  try
    LoadFromIniFile('');
  finally
    FIniFileStream := nil;
  end;
end;

procedure TdxBarManager.SaveToStream(AStream: TStream);
begin
  FIniFileStream := AStream;
  try
    SaveToIniFile('');
  finally
    FIniFileStream := nil;
  end;
end;

function TdxBarManager.CreateGroup: TdxBarGroup;
begin
  Result := TdxBarGroup.Create(Owner);//#DG
  AddGroup(Result);
end;

function TdxBarManager.CanShowRecentItems: Boolean;
begin
  Result := GetPaintStyle <> bmsStandard;
end;

function TdxBarManager.GetPaintStyle: TdxBarManagerStyle;
const
  AStyles: array[TcxLookAndFeelKind] of TdxBarManagerStyle = (
    bmsEnhanced, bmsStandard, bmsFlat{$IFDEF DXVER500}, bmsOffice11{$ENDIF});
begin
  if Style = bmsUseLookAndFeel then
  begin
    if LookAndFeel.NativeStyle and FThemeAvailable then
      Result := bmsXP
    else
      Result := AStyles[LookAndFeel.Kind]
  end
  else
    Result := Style;
end;

{ TdxBarManagerList }

destructor TdxBarManagerList.Destroy;
begin
  FinalizationBars;
  inherited Destroy;
end;

function TdxBarManagerList.GetBarManager(Index: Integer): TdxBarManager;
begin
  Result := TdxBarManager(inherited GetItem(Index));
end;

function TdxBarManagerList.GetCustomizingBarManager: TdxBarManager;
var
  I: Integer;
begin
  Result := nil;
  for I := 0 to Count - 1 do
    if BarManagers[I].FIsCustomizing then
    begin
      Result := BarManagers[I];
      Break;
    end;
end;

function TdxBarManagerList.NextActive(ABarManager: TdxBarManager;
  AGoForward: Boolean): TdxBarManager;

  function IsBarManagerValid(ABarManager: TdxBarManager;
    AMainForm: TCustomForm): Boolean;
  var
    AForm: TCustomForm;
  begin
    Result := IsBarManagerOwner(ABarManager, AMainForm.Handle);
    if Result then
    begin
      AForm := GetBarManagerForm(ABarManager, fkMainOrMDIChild);
      Result := not IsMDIChild(AForm) or (AForm.Handle = ABarManager.ActiveMDIChild);
    end;
  end;

var
  AMainForm: TCustomForm;
  AIndex, AStartIndex: Integer;
begin
  AMainForm := ABarManager.GetMainForm;
  AStartIndex := IndexOf(ABarManager);
  AIndex := AStartIndex;
  repeat
    if AGoForward then
    begin
      Inc(AIndex);
      if AIndex = Count then
        AIndex := 0;
    end
    else
    begin
      Dec(AIndex);
      if AIndex < 0 then
        AIndex := Count - 1;
    end
  until (AIndex = AStartIndex) or IsBarManagerValid(BarManagers[AIndex], AMainForm);
  Result := BarManagers[AIndex];
end;

{ TdxBarMergeData }

constructor TdxBarMergeData.Create;
begin
  inherited Create;
  FFreeNotificator := TcxFreeNotificator.Create(nil);
  FFreeNotificator.OnFreeNotification := FreeNotification;
  FMergedBarList := TList.Create;
  FSavedMergedBarList := TList.Create;
end;

destructor TdxBarMergeData.Destroy;
begin
  ClearSavedMergedBarList;
  FreeAndNil(FSavedMergedBarList);
  FreeAndNil(FMergedBarList);
  FreeAndNil(FFreeNotificator);
  inherited Destroy;
end;

procedure TdxBarMergeData.ClearSavedMergedBarList;
var
  I: Integer;
begin
  for I := 0 to SavedMergedBarCount - 1 do
    FreeNotificator.RemoveSender(FSavedMergedBarList[I]);
  FSavedMergedBarList.Clear;
end;

procedure TdxBarMergeData.SaveMergedBarList(AList: TList = nil);
var
  I: Integer;
begin
  if AList = nil then
    AList := FSavedMergedBarList;
  for I := 0 to MergedBarList.Count - 1 do
    AList.Add(MergedBarList[I]);
  if AList = FSavedMergedBarList then
    SetFreeNotifications;
end;

procedure TdxBarMergeData.FreeNotification(Sender: TComponent);
begin
  FSavedMergedBarList.Remove(Sender);
end;

function TdxBarMergeData.GetSavedMergedBar(AIndex: Integer): TdxBar;
begin
  Result := TdxBar(FSavedMergedBarList[AIndex]);
end;

function TdxBarMergeData.GetSavedMergedBarListCount: Integer;
begin
  Result := FSavedMergedBarList.Count;
end;

procedure TdxBarMergeData.SetFreeNotifications;
var
  I: Integer;
begin
  for I := 0 to SavedMergedBarCount - 1 do
    FreeNotificator.AddSender(TComponent(FSavedMergedBarList[I]));
end;

{ TdxBarAccessibilityHelper }

function TdxBarAccessibilityHelper.GetFirstSelectableObject: TdxBarAccessibilityHelper;
var
  I: Integer;
begin
  Result := nil;
  if Visible then
    if Selectable then
      Result := Self
    else
      for I := 0 to ChildCount - 1 do
      begin
        Result := Childs[I].GetFirstSelectableObject;
        if Result <> nil then
          Break;
      end;
end;

// IcxAccessibilityHelper
procedure TdxBarAccessibilityHelper.OwnerObjectDestroyed;
begin
  inherited OwnerObjectDestroyed;
  if BarNavigationController <> nil then
    BarNavigationController.UnassignObject(Self);
end;

// IdxBarAccessibilityHelper
function TdxBarAccessibilityHelper.AreKeyTipsSupported(
  out AKeyTipWindowsManager: IdxBarKeyTipWindowsManager): Boolean;
begin
  if ParentForKeyTip <> nil then
    Result := ParentForKeyTip.AreKeyTipsSupported(AKeyTipWindowsManager)
  else
    Result := False;
end;

function TdxBarAccessibilityHelper.CanNavigateToChildren(AKey: Word): Boolean;
begin
  Result := True;
end;

function TdxBarAccessibilityHelper.GetBarHelper: TdxBarAccessibilityHelper;
begin
  Result := Self;
end;

function TdxBarAccessibilityHelper.GetBarManager: TdxBarManager;
begin
  raise EdxException.Create('');
end;

function TdxBarAccessibilityHelper.GetDefaultAccessibleObject: IdxBarAccessibilityHelper;
begin
  raise EdxException.Create('');
end;

function TdxBarAccessibilityHelper.GetNextAccessibleObject(
  ADirection: TcxAccessibilityNavigationDirection): IdxBarAccessibilityHelper;
var
  AObjects: TList;
begin
  AObjects := TList.Create;
  try
    GetChildrenForNavigation(Self, GetRootAccessibleObject.GetBarHelper,
      GetScreenBounds(cxAccessibleObjectSelfID), ADirection, True, AObjects);
    Result := dxBar.GetNextAccessibleObject(
      BarNavigationController.SelectedObject.GetBarHelper, AObjects, ADirection, True);
  finally
    AObjects.Free;
  end;
end;

function TdxBarAccessibilityHelper.GetRootAccessibleObject: IdxBarAccessibilityHelper;
begin
  Result := GetRootHelper as IdxBarAccessibilityHelper;
end;

function TdxBarAccessibilityHelper.HandleNavigationKey(var AKey: Word): Boolean;
begin
  Result := False;
end;

function TdxBarAccessibilityHelper.IsNavigationKey(AKey: Word): Boolean;
begin
  Result := False;
end;

function TdxBarAccessibilityHelper.IsSelected: Boolean;
var
  ASelectedObject: IdxBarAccessibilityHelper;
begin
  ASelectedObject := BarNavigationController.SelectedObject;
  Result := (ASelectedObject <> nil) and (ASelectedObject.GetHelper = Self);
end;

function TdxBarAccessibilityHelper.LogicalNavigationGetNextAccessibleObject(
  AGoForward: Boolean): IdxBarAccessibilityHelper;
begin
  Result := Parent.LogicalNavigationGetNextChild(Parent.LogicalNavigationGetChildIndex(Self), AGoForward);
end;

procedure TdxBarAccessibilityHelper.Select(ASetFocus: Boolean);
begin
  BarNavigationController.SelectedObject := Self;
  BarNavigationController.SelectedObjectParent := Parent;
end;

procedure TdxBarAccessibilityHelper.Unselect(
  ANextSelectedObject: IdxBarAccessibilityHelper);
begin
  BarNavigationController.SelectedObject := nil;
  BarNavigationController.SelectedObjectParent := nil;
end;

procedure TdxBarAccessibilityHelper.GetChildrenForNavigation(
  ASelectedObject, AParentObject: TdxBarAccessibilityHelper;
  const ASelectedObjectScreenBounds: TRect;
  ADirection: TcxAccessibilityNavigationDirection;
  AAreOnlyNearObjectsAccepted: Boolean; AObjects: TList);

  function CheckObject(AObject: TdxBarAccessibilityHelper): Boolean;
  var
    R: TRect;
  begin
    Result := AObject.Selectable;
    if not Result then
      Exit;
    R := AObject.GetScreenBounds(cxAccessibleObjectSelfID);
    if AAreOnlyNearObjectsAccepted then
      if ADirection in [andLeft, andRight] then
        Result := (R.Bottom > ASelectedObjectScreenBounds.Top) and (R.Top < ASelectedObjectScreenBounds.Bottom)
      else
        Result := (R.Right > ASelectedObjectScreenBounds.Left) and (R.Left < ASelectedObjectScreenBounds.Right);
    if Result then
      case ADirection of
        andLeft, andRight:
          Result := not ((R.Left = ASelectedObjectScreenBounds.Left) and (R.Right = ASelectedObjectScreenBounds.Right));
        andUp:
          Result := R.Bottom <= ASelectedObjectScreenBounds.Top;
        andDown:
          Result := R.Top >= ASelectedObjectScreenBounds.Bottom;
      end;
  end;

var
  I: Integer;
begin
  if (AParentObject <> ASelectedObject) and AParentObject.Visible then
  begin
    if CheckObject(AParentObject) then
      AObjects.Add(AParentObject);
    for I := 0 to AParentObject.ChildCount - 1 do
      GetChildrenForNavigation(ASelectedObject, AParentObject.Childs[I],
        ASelectedObjectScreenBounds, ADirection, AAreOnlyNearObjectsAccepted, AObjects)
  end;
end;

procedure TdxBarAccessibilityHelper.GetChilds(AChilds: TList; AOnlyVisible: Boolean);
var
  AChild: TdxBarAccessibilityHelper;
  I: Integer;
begin
  if not AOnlyVisible or Visible then
    for I := 0 to ChildCount - 1 do
    begin
      AChild := Childs[I];
      if AChild.Selectable then
        AChilds.Add(AChild)
      else
        AChild.GetChilds(AChilds);
    end;
end;

function TdxBarAccessibilityHelper.GetKeyTip: string;
begin
  if GetAssignedKeyTip <> '' then
    Result := GetAssignedKeyTip
  else
    Result := GetDefaultKeyTip;
  if Length(Result) > 3 then
    SetLength(Result, 3);
end;

function TdxBarAccessibilityHelper.CreateKeyTipData: TdxBarKeyTipData;
var
  AKeyTipInfo: TdxBarKeyTipInfo;
begin
  GetKeyTipInfo(AKeyTipInfo);
  Result := TdxBarKeyTipData.Create(AKeyTipInfo);
end;

procedure TdxBarAccessibilityHelper.GetKeyTipInfo(out AKeyTipInfo: TdxBarKeyTipInfo);
begin
  cxZeroMemory(@AKeyTipInfo, SizeOf(AKeyTipInfo));
  AKeyTipInfo.KeyTip := GetKeyTip;
  AKeyTipInfo.Visible := Visible;
  AKeyTipInfo.OnExecute := KeyTipHandler;
end;

procedure TdxBarAccessibilityHelper.GetKeyTipData(AKeyTipsData: TList);
begin
  AKeyTipsData.Add(CreateKeyTipData);
end;

procedure TdxBarAccessibilityHelper.DoGetKeyTipsData(AKeyTipsData: TList);
var
  AChild: TdxBarAccessibilityHelper;
  I: Integer;
begin
  if Visible then
    for I := 0 to ChildCount - 1 do
    begin
      AChild := Childs[I];
      if AChild.Selectable then
        AChild.GetKeyTipData(AKeyTipsData)
      else
        AChild.DoGetKeyTipsData(AKeyTipsData);
    end;
end;

procedure TdxBarAccessibilityHelper.GetKeyTipsData(AKeyTipsData: TList);
begin
  DoGetKeyTipsData(AKeyTipsData);
  GenerateUniqueKeyTips(AKeyTipsData);
end;

procedure TdxBarAccessibilityHelper.GenerateUniqueKeyTips(AKeyTipsData: TList);

  function GetKeyTip(AList: TList; AIndex: Integer): string; // TODO TdxBarKeyTipsDataList
  begin
    Result := TdxBarKeyTipData(AList[AIndex]).KeyTip;
  end;

  function RemoveCollision(AIndex: Integer): Boolean;

    function GetSuffix(ATotalCount, AIndex: Integer): string;
    var
      I: Integer;
    begin
      Result := IntToStr(AIndex + 1);
      for I := Length(Result) to Length(IntToStr(ATotalCount)) - 1 do
        Result := '0' + Result;
    end;

    procedure InternalRemoveCollision(ACollisions: TdxObjectList);
    var
      I: Integer;
    begin
      for I := 0 to ACollisions.Count - 1 do
        TdxBarKeyTipData(ACollisions[I]).KeyTip := GetKeyTip(ACollisions, I) + GetSuffix(ACollisions.Count, I);
    end;

  var
    ACollisions: TdxObjectList;
    I: Integer;
  begin
    ACollisions := TdxObjectList.Create;
    try
      for I := 0 to AKeyTipsData.Count - 1 do
        if GetKeyTip(AKeyTipsData, AIndex) = GetKeyTip(AKeyTipsData, I) then
          ACollisions.Add(AKeyTipsData[I]);
      Result := ACollisions.Count > 1;
      if Result then
        InternalRemoveCollision(ACollisions)
      else
      begin
        for I := 0 to AKeyTipsData.Count - 1 do
          if (I <> AIndex) and (Pos(GetKeyTip(AKeyTipsData, AIndex), GetKeyTip(AKeyTipsData, I)) = 1) then
          begin
            InternalRemoveCollision(ACollisions);
            Result := True;
            Break;
          end;
      end;
    finally
      ACollisions.Free;
    end;
  end;

var
  I: Integer;
  AHasCollisions: Boolean;
begin
  repeat
    AHasCollisions := False;
    for I := 0 to AKeyTipsData.Count - 1 do
      AHasCollisions := RemoveCollision(I) or AHasCollisions;
  until not AHasCollisions;
end;

function TdxBarAccessibilityHelper.GetParentForKeyTip: TdxBarAccessibilityHelper;
begin
  Result := Parent;
end;

function TdxBarAccessibilityHelper.IsKeyTipContainer: Boolean;
begin
  Result := Selectable;
end;

procedure TdxBarAccessibilityHelper.KeyTipHandler(Sender: TObject);
begin
end;

procedure TdxBarAccessibilityHelper.KeyTipsEscapeHandler;
var
  ANewKeyTipContainer: IdxBarAccessibilityHelper;
begin
  ANewKeyTipContainer := GetKeyTipContainerParent(Self);
  if ANewKeyTipContainer = nil then
    BarNavigationController.StopKeyboardHandling
  else
  begin
    BarNavigationController.SetKeyTipsShowingState(ANewKeyTipContainer, '');
    BarNavigationController.ChangeSelectedObject(True, Self);
  end;
end;

function TdxBarAccessibilityHelper.LogicalNavigationGetChild(
  AIndex: Integer): TdxBarAccessibilityHelper;
begin
  Result := Childs[AIndex];
end;

function TdxBarAccessibilityHelper.LogicalNavigationGetChildCount: Integer;
begin
  Result := ChildCount;
end;

function TdxBarAccessibilityHelper.LogicalNavigationGetChildIndex(
  AChild: TdxBarAccessibilityHelper): Integer;
begin
  Result := GetChildIndex(AChild);
end;

function TdxBarAccessibilityHelper.LogicalNavigationGetNextChild(
  AChildIndex: Integer; AGoForward: Boolean): TdxBarAccessibilityHelper;

  function LogicalNavigationGetFirstChild(AContainer: TdxBarAccessibilityHelper): TdxBarAccessibilityHelper;
  var
    AChild: TdxBarAccessibilityHelper;
    I: Integer;
  begin
    Result := nil;
    if AGoForward then
      I := 0
    else
      I := AContainer.LogicalNavigationGetChildCount - 1;
    while (Result = nil) and (I >= 0) and (I < AContainer.LogicalNavigationGetChildCount) do
    begin
      AChild := AContainer.LogicalNavigationGetChild(I);
      if AChild.Selectable then
        Result := AChild
      else
        Result := LogicalNavigationGetFirstChild(AChild);
      if AGoForward then
        Inc(I)
      else
        Dec(I);
    end;
  end;

var
  AChild: TdxBarAccessibilityHelper;
begin
  Result := nil;
  while Result = nil do
  begin
    if AGoForward then
      Inc(AChildIndex)
    else
      Dec(AChildIndex);
    if (AChildIndex = -1) or (AChildIndex = LogicalNavigationGetChildCount) then
    begin
      if Parent = nil then
        Result := LogicalNavigationGetFirstChild(Self)
      else
        Result := Parent.LogicalNavigationGetNextChild(
          Parent.LogicalNavigationGetChildIndex(Self), AGoForward);
      Exit;
    end;
    AChild := LogicalNavigationGetChild(AChildIndex);
    if AChild.Selectable then
      Result := AChild
    else
      Result := LogicalNavigationGetFirstChild(AChild);
  end;
end;

function TdxBarAccessibilityHelper.InternalGetChild(
  AIndex: Integer): TdxBarAccessibilityHelper;
begin
  Result := TdxBarAccessibilityHelper(GetChild(AIndex));
end;

function TdxBarAccessibilityHelper.InternalGetParent: TdxBarAccessibilityHelper;
begin
  Result := TdxBarAccessibilityHelper(GetParent);
end;

{ TdxBarCaptionButton }

constructor TdxBarCaptionButton.Create(Collection: TCollection);
begin
  inherited;
  FGlyph := dxBarCreateBitmap(GlyphChanged);

  FNotifyComponent := TcxFreeNotificator.Create(nil);
  FNotifyComponent.OnFreeNotification := FreeNotification;
  Enabled := True;
end;

destructor TdxBarCaptionButton.Destroy;
begin
  BarAccessibilityHelperOwnerObjectDestroyed(FIAccessibilityHelper);
  FreeAndNil(FNotifyComponent);
  FreeAndNil(FGlyph);
  inherited;
end;

procedure TdxBarCaptionButton.Assign(Source: TPersistent);
begin
  if Source is TdxBarCaptionButton then
  begin
    Enabled := TdxBarCaptionButton(Source).Enabled;
    Glyph := TdxBarCaptionButton(Source).Glyph;
    Hint := TdxBarCaptionButton(Source).Hint;
    KeyTip := TdxBarCaptionButton(Source).KeyTip;
    Rect := TdxBarCaptionButton(Source).Rect;
    ScreenTip := TdxBarCaptionButton(Source).ScreenTip;
    OnClick := TdxBarCaptionButton(Source).OnClick;
  end
  else
    inherited Assign(Source);
end;

procedure TdxBarCaptionButton.Click;
begin
  CallNotify(OnClick, Self);
end;

function TdxBarCaptionButton.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarCaptionButtonAccessibilityHelper;
end;

// IdxBarHintKeeper
function TdxBarCaptionButton.DoHint(var ANeedDeactivate: Boolean; out AHintText: string; out AShortCut: string): Boolean;
begin
  Result := False;
  ANeedDeactivate := False;
  AShortCut := '';
  AHintText := '';

  if State = DXBAR_HOT then
  begin
    AHintText := Hint;
    Result := True;
  end;
end;

function TdxBarCaptionButton.CreateHintViewInfo(const AHintText, AShortCut: string): TdxBarCustomHintViewInfo;
begin
  Result := Parent.CreateHintViewInfo(AHintText, AShortCut, ScreenTip);
end;

function TdxBarCaptionButton.GetEnabled: Boolean;
begin
  Result := State <> DXBAR_DISABLED; 
end;

function TdxBarCaptionButton.GetHintPosition(const ACursorPos: TPoint; AHeight: Integer): TPoint;
begin
  Result := Parent.GetHintPosition(Rect, ACursorPos, AHeight);
end;

function TdxBarCaptionButton.GetCollection: TdxBarCaptionButtons;
begin
  Result := TdxBarCaptionButtons(inherited Collection);
end;

function TdxBarCaptionButton.GetIAccessibilityHelper: IdxBarAccessibilityHelper;
begin
  if FIAccessibilityHelper = nil then
    FIAccessibilityHelper := GetAccessibilityHelper(GetAccessibilityHelperClass.Create(Self));
  Result := FIAccessibilityHelper;
end;

function TdxBarCaptionButton.GetParent: TdxBarControl;
begin
  Result := Collection.Bar.Control;
end;

procedure TdxBarCaptionButton.GlyphChanged(Sender: TObject);
begin
  Changed(False);
end;

procedure TdxBarCaptionButton.SetEnabled(Value: Boolean);
begin
  FEnabled := Value;
  if Value then
    State := DXBAR_NORMAL
  else
    State := DXBAR_DISABLED;
end;

procedure TdxBarCaptionButton.SetGlyph(Value: TBitmap);
begin
  FGlyph.Assign(Value);
end;

procedure TdxBarCaptionButton.SetScreenTip(Value: TdxBarScreenTip);
begin
  if FScreenTip <> Value then
  begin
    if FScreenTip <> nil then
      FNotifyComponent.RemoveFreeNotification(FScreenTip);
    FScreenTip := Value;
    if FScreenTip <> nil then
      FNotifyComponent.FreeNotification(FScreenTip);
  end;
end;

procedure TdxBarCaptionButton.SetState(Value: Integer);
begin
  if FState <> Value then
  begin
    FState := Value;
    if Parent <> nil then
      Parent.ActivateHint(FState = DXBAR_HOT, Hint, Self);
    Changed(False);
  end;
end;

procedure TdxBarCaptionButton.SetOnClick(Value: TNotifyEvent);
begin
  FOnClick := Value;
  Changed(True);
end;

procedure TdxBarCaptionButton.FreeNotification(AComponent: TComponent);
begin
  FScreenTip := nil;
end;

{ TdxBarCaptionButtons }

constructor TdxBarCaptionButtons.Create(ABar: TdxBar);
begin
  inherited Create(ABar, TdxBarCaptionButton);
end;

destructor TdxBarCaptionButtons.Destroy;
begin
  BarAccessibilityHelperOwnerObjectDestroyed(FIAccessibilityHelper);
  inherited Destroy;
end;

function TdxBarCaptionButtons.Add: TdxBarCaptionButton;
begin
  BeginUpdate;
  try
    Result := TdxBarCaptionButton(inherited Add);
  finally
    EndUpdate;
  end;
end;

procedure TdxBarCaptionButtons.UpdateButtonStates(const AMousePos: TPoint; AMousePressed: Boolean = False);
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
    if Items[I].Enabled then
      if PtInRect(Items[I].Rect, AMousePos) or Items[I].IAccessibilityHelper.IsSelected then
        if AMousePressed then
          Items[I].State := DXBAR_PRESSED
        else
          Items[I].State := DXBAR_HOT
      else
        Items[I].State := DXBAR_NORMAL;
end;

function TdxBarCaptionButtons.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarCaptionButtonsAccessibilityHelper;
end;

function TdxBarCaptionButtons.GetButtonIndex(const APoint: TPoint): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := 0 to Count - 1 do
    if Items[I].Enabled and PtInRect(Items[I].Rect, APoint) then
    begin
      Result := I;
      Break;
    end;
end;

function TdxBarCaptionButtons.GetBar: TdxBar;
begin
  Result := TdxBar(Owner);
end;

function TdxBarCaptionButtons.GetIAccessibilityHelper: IdxBarAccessibilityHelper;
begin
  if FIAccessibilityHelper = nil then
    FIAccessibilityHelper := GetAccessibilityHelper(GetAccessibilityHelperClass.Create(Self));
  Result := FIAccessibilityHelper;
end;

function TdxBarCaptionButtons.GetItem(Index: Integer): TdxBarCaptionButton;
begin
  Result := TdxBarCaptionButton(inherited GetItem(Index));
end;

function TdxBarCaptionButtons.GetRect: TRect;
var
  I: Integer;
begin
  Result := cxEmptyRect;
  for I := 0 to Count - 1 do
    if not IsRectEmpty(Items[I].Rect) then
      UnionRect(Result, Result, Items[I].Rect);
end;

procedure TdxBarCaptionButtons.SetItem(Index: Integer; Value: TdxBarCaptionButton);
begin
  inherited SetItem(Index, Value);
end;

{ TdxBar }

constructor TdxBar.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FAlphaBlendValue := 255;
  FBackgroundBitmap := dxBarCreateBitmap(BitmapChanged);
  FAllowClose := True;
  FAllowCustomizing := True;
  FAllowQuickCustomizing := True;
  FAllowReset := True;
  FBorderStyle := bbsSingle;
  FColor := clDefault;
  FDockedDockingStyle := dsTop;
  FEditFont := TFont.Create;
  FFont := TFont.Create;
  FFont.OnChange := FontChanged;
  FFreeNotificationItems := TList.Create;
  FGlyph := dxBarCreateBitmap(GlyphChanged);
  FMergeData := TdxBarMergeData.Create;
  FRotateWhenVertical := True;
  FShowMark := True;
  FSizeGrip := True;

  FCaptionButtons := TdxBarCaptionButtons.Create(Self);
  FCaptionButtons.OnChange := CaptionButtonsNotification;
end;

destructor TdxBar.Destroy;
begin
  DoDestroy;
  if not BarManager.IsDestroying and Assigned(BarManager.FOnBarDelete) then
    BarManager.OnBarDelete(BarManager, Self);

  FreeAndNil(FCaptionButtons);

  if FMergeData.MergedWith <> nil then
    FMergeData.MergedWith.Unmerge(Self);
  Unmerge;
  FreeAndNil(FMergeData);

//#DG  BarDesignController.DeselectIfSelected(Self);

  Visible := False;
  RemoveFromDockRow(True);
  MakeFreeNotification;
  FreeAndNil(FFreeNotificationItems);
  if BarManager.MainMenuBar = Self then
    BarManager.FMainMenuBar := nil;
  FreeAndNil(FItemLinks);
  FreeAndNil(FGlyph);
  FreeAndNil(FFont);
  FreeAndNil(FEditFont);
  FreeAndNil(FBackgroundBitmap);
  cxClearObjectLinks(Self);
  inherited Destroy;
end;

procedure TdxBar.Assign(Source: TPersistent);
var
  Bar: TdxBar;
begin
  if Source is TdxBar then
  begin
    Bar := TdxBar(Source);

    AllowClose := Bar.AllowClose;
    AllowCustomizing := Bar.AllowCustomizing;
    AllowQuickCustomizing := Bar.AllowQuickCustomizing;
    AllowReset := Bar.AllowReset;
    BorderStyle := Bar.BorderStyle;
    Caption := Bar.Caption;
    CaptionButtons := Bar.CaptionButtons;
    DockedDockControl := Bar.DockedDockControl;
    DockedDockingStyle := Bar.DockedDockingStyle;
    DockedLeft := Bar.DockedLeft;
    DockedTop := Bar.DockedTop;
    FloatLeft := Bar.FloatLeft;
    FloatTop := Bar.FloatTop;
    FloatClientWidth := Bar.FloatClientWidth;
    FloatClientHeight := Bar.FloatClientHeight;
    Hidden := Bar.Hidden;
    IsMainMenu := Bar.IsMainMenu;
    ItemLinks := Bar.ItemLinks;
    NotDocking := Bar.NotDocking;
    OldName := Bar.OldName;
    OneOnRow := Bar.OneOnRow;
    RotateWhenVertical := Bar.RotateWhenVertical;
    Row := Bar.Row;
    ShowMark := Bar.ShowMark;
    SizeGrip := Bar.SizeGrip;
    WholeRow := Bar.WholeRow;
    ChangeDockingStyle(Bar.DockingStyle, Bar.DockControl);
    UseRecentItems := Bar.UseRecentItems;
    UseRestSpace := Bar.UseRestSpace;
    Color := Bar.Color;
    Font := Bar.Font;
    UseOwnFont := Bar.UseOwnFont;
    Visible := Bar.Visible;
  end
  else inherited Assign(Source);
end;

procedure TdxBar.BitmapChanged(Sender: TObject);
begin
  if Control <> nil then
    Control.RebuildBar;
end;

procedure TdxBar.DoDestroy;
begin
//#DG  Destroying;
  CallNotify(FOnDestroy, Self);
end;

function TdxBar.GetBars: TdxBars;
begin
  if GetBarManager = nil then
    Result := nil
  else
    Result := GetBarManager.Bars;
end;

function TdxBar.GetControl: TdxBarControl;
begin
  if ItemLinks <> nil then
    Result := TdxBarControl(ItemLinks.FBarControl)
  else
    Result := nil;
end;

function TdxBar.GetDockControl: TdxBarDockControl;
begin
  if IsAncestorComponentDifferencesDetection(Self) then
    Result := FLoadedDockControl
  else
    Result := FDockControl;
end;

function TdxBar.GetDockedDockingStyle: TdxBarDockingStyle;
begin
  if FDockedDockControl = nil then
    Result := FDockedDockingStyle
  else
    Result := FDockedDockControl.DockingStyle;
end;

function TdxBar.GetDockingStyle: TdxBarDockingStyle;
begin
  if IsAncestorComponentDifferencesDetection(Self) then
    Result := FLoadedDockingStyle
  else
    if FDockControl = nil then
      Result := FDockingStyle
    else
      Result := FDockControl.DockingStyle;
end;

function TdxBar.GetNext: TdxBar;
begin
  if Index + 1 < Bars.Count then
    Result := Bars[Index + 1]
  else
    if Index <> 0 then
      Result := Bars[0]
    else
      Result := nil;
end;

function TdxBar.GetNotDocking: TdxBarDockingStyles;
begin
  Result := FNotDocking;
end;

function TdxBar.GetPainter: TdxBarPainter;
begin
  if RealDockControl <> nil then
    Result := RealDockControl.Painter
  else
    Result := BarManager.DefaultPainter;
end;

function TdxBar.GetRealDockControl: TdxDockControl;
begin
  Result := FDockControl;
  if (Result = nil) and (FDockingStyle <> dsNone) then
    Result := Bars.FDockControls[FDockingStyle];
end;

function TdxBar.GetRow: Integer;
begin
  if DockRow <> nil then
    Result := DockRow.DockControl.RowList.IndexOf(DockRow)
  else
    Result := FRow;
end;

function TdxBar.GetUseRecentItems: Boolean;
begin
  Result := FItemLinks.FUseRecentItems;
end;

function TdxBar.GetVisible: Boolean;
begin
  if IsAncestorComponentDifferencesDetection(Self) then
    Result := FLoadedVisible
  else
    Result := FVisible;
end;

procedure TdxBar.GlyphChanged(Sender: TObject);
begin
  if Control <> nil then
    Control.GlyphChanged;
end;

procedure TdxBar.SetAllowClose(Value: Boolean);
begin
  if FAllowClose <> Value then
  begin
    FAllowClose := Value;
    if (DockingStyle = dsNone) and (Control <> nil) then
      Control.CaptionChanged;
    Changed(False);
  end;
end;

procedure TdxBar.SetAllowQuickCustomizing(Value: Boolean);
begin
  if FAllowQuickCustomizing <> Value then
  begin
    FAllowQuickCustomizing := Value;
    if Control <> nil then
      if DockingStyle = dsNone then
        Control.CaptionChanged
      else
        if BarManager.CanShowRecentItems then
          Control.RepaintBar;
  end;
end;

procedure TdxBar.SetAlphaBlendValue(Value: Byte);
begin
  if FAlphaBlendValue <> Value then
  begin
    FAlphaBlendValue := Value;
    if (Control <> nil) and (Control.DockingStyle = dsNone) then
      Control.SetLayeredAttributes;
  end;
end;

procedure TdxBar.SetBackgroundBitmap(Value: TBitmap);
var
  AChanged: Boolean;
begin
  AChanged := not ((Value = nil) and FBackgroundBitmap.Empty);
  FBackgroundBitmap.Assign(Value);
  if AChanged then
    BitmapChanged(nil);
end;

procedure TdxBar.SetBorderStyle(Value: TdxBarBorderStyle);
begin
  if FBorderStyle <> Value then
  begin
    FBorderStyle := Value;
    if Control <> nil then Control.RebuildBar;
  end;
end;

procedure TdxBar.SetCaption(Value: string);
begin
  if FCaption <> Value then
  begin
    if BarManager.BarByCaption(Value) <> nil then
      Exit;
    FCaption := Value;
    if Control <> nil then
      Control.CaptionChanged;
//    if (Name = '') and not BarManager.IsLoading then
//      CheckBarName(Value);
    Changed(False);
  end;
end;

procedure TdxBar.SetCaptionButtons(Value: TdxBarCaptionButtons);
begin
  FCaptionButtons.Assign(Value);
end;

procedure TdxBar.SetColor(Value: TColor);
begin
  if FColor <> Value then
  begin
    FColor := Value;
    if Control <> nil then
      Control.RebuildBar;
  end;
end;

procedure TdxBar.SetDockControl(Value: TdxBarDockControl);
var
  PrevDockingStyle: TdxBarDockingStyle;
  NeedHiding: Boolean;
begin
  if (Value <> nil) and (Value.BarManager <> BarManager) then Exit;
  if BarManager.IsLoading then
  begin
    FLoadedDockControl := Value;
    Exit;
  end;
  if FDockControl <> Value then
  begin
    PrevDockingStyle := DockingStyle;
    NeedHiding := not FChangingDockingStyle and (Control <> nil);
    if NeedHiding then
      if Value = nil then
//        NeedHiding := (DockingStyle <> dsNone) and (Control.DockControl <> Value)
        NeedHiding :=
          (DockingStyle <> dsNone) and
          not ((Control.DockControl <> nil) and Control.DockControl.Main)
      else
        NeedHiding := Control.DockControl <> Value;
    if NeedHiding then Visible := False;
    FDockControl := Value;
    ItemLinks.RecentItemCount := -1;
    if not FChangingDockingStyle then
    begin
      FChangingDockingStyle := True;
      try
        if Value = nil then
          DockingStyle := PrevDockingStyle//dsNone
        else
          DockingStyle := Value.DockingStyle;
      finally
        FChangingDockingStyle := False;
      end;
    end;
    if NeedHiding then Visible := True;
    if Control <> nil then
      Control.DockControl := RealDockControl;
    if not FChangingDockingStyle then
      BarManager.DoBarDockingStyleChanged(Self);
  end;
end;

procedure TdxBar.SetDockedDockControl(Value: TdxBarDockControl);
begin
  if (Value <> nil) and (Value.BarManager <> BarManager) then Exit;
  if FDockedDockControl <> Value then
  begin
    FDockedDockControl := Value;
    Changed(False);
  end;
end;

procedure TdxBar.SetDockedValue(Index: Integer; Value: Integer);
var
  PrevValue: Integer;
begin
  if Value < 0 then Value := 0;
  PrevValue := 0;
  case Index of
    1: PrevValue := FDockedLeft;
    2: PrevValue := FDockedTop;
  end;
  if PrevValue <> Value then
  begin
    case Index of
      1: FDockedLeft := Value;
      2: FDockedTop := Value;
    end;
    if csUpdating in ComponentState then
      FNeedUpdateControlPosition := True
    else
      UpdateControlPosition;
    Changed(False);
  end;
end;

procedure TdxBar.SetDockingStyle(Value: TdxBarDockingStyle);
var
  ControlExists: Boolean;
begin
  if BarManager.IsLoading then
  begin
    FLoadedDockingStyle := Value;
    Exit;
  end;
  if FDockingStyle <> Value then
  begin
    ControlExists :=
      not FChangingDockingStyle and
      (Control <> nil) and (Control.DockingStyle <> Value);
    if ControlExists then Visible := False;
    FDockingStyle := Value;
    if not FChangingDockingStyle then
    begin
      FChangingDockingStyle := True;
      try
        DockControl := nil;
      finally
        FChangingDockingStyle := False;
      end;
    end;
    ItemLinks.RecentItemCount := -1;
    if ControlExists then
    begin
      Visible := True;
      Control.DockingStyle := Value;
    end;
    if not FChangingDockingStyle then
      BarManager.DoBarDockingStyleChanged(Self);
  end;
end;

procedure TdxBar.SetDockRow(Value: TdxDockRow);
begin
  if (FDockRow = Value) or BarManager.IsDestroying then
    Exit;
  if FDockRow <> nil then FDockRow.DeleteBar(Self, True);
  FDockRow := Value;
  if Value <> nil then FDockRow.AddBar(Self);
end;

procedure TdxBar.SetFloatValue(Index: Integer; Value: Integer);
var
  PrevValue: Integer;
begin
  PrevValue := 0;
  case Index of
    1: PrevValue := FFloatLeft;
    2: PrevValue := FFloatTop;
    3: PrevValue := FFloatClientWidth;
    4: PrevValue := FFloatClientHeight;
  end;
  if PrevValue <> Value then
  begin
    case Index of
      1: FFloatLeft := Value;
      2: FFloatTop := Value;
      3: FFloatClientWidth := Value;
      4: FFloatClientHeight := Value;
    end;
    if csUpdating in ComponentState then
      FNeedUpdateControlPosition := True
    else
      UpdateControlPosition;
    Changed(False);
  end;
end;

procedure TdxBar.SetFont(Value: TFont);
begin
  Font.Assign(Value);
end;

procedure TdxBar.SetGlyph(Value: TBitmap);
begin
  Glyph.Assign(Value);
end;

procedure TdxBar.SetHidden(Value: Boolean);
begin
  if FHidden <> Value then
  begin
    FHidden := Value;
    Changed(False);
  end;
end;

procedure TdxBar.SetIsMainMenu(Value: Boolean);
begin
  if FIsMainMenu <> Value then
  begin
    BarManager.BeginUpdate;
    try
      if Value and (BarManager.MainMenuBar <> nil) then
        BarManager.MainMenuBar.IsMainMenu := False;
      FIsMainMenu := Value;
      if Value then
      begin
        BarManager.FMainMenuBar := Self;
        WholeRow := True;
        MultiLine := True;
      end
      else
      begin
        BarManager.FMainMenuBar := nil;
        MultiLine := False;
        WholeRow := False;
      end;
      if BarManager.IsLoading then Exit;
      if Control <> nil then
        if FDockingStyle = dsNone then
          Control.CaptionChanged
        else
          Control.RepaintBar;
      Changed(False);
    finally
      BarManager.EndUpdate;
    end;  
  end;
end;

procedure TdxBar.SetItemLinks(Value: TdxBarItemLinks);
begin
  FItemLinks.Assign(Value);
end;

procedure TdxBar.SetLockUpdate(Value: Boolean);
begin
  if Value <> FLockUpdate then
  begin
    FLockUpdate := Value;
    if FLockUpdate then
      BarManager.BeginUpdate
    else
      BarManager.EndUpdate;
  end;
end;

procedure TdxBar.SetMultiLine(Value: Boolean);
begin
  if (FMultiLine <> Value) and (Value or not IsMainMenu) then
  begin
    FMultiLine := Value;
    if (Control <> nil) and (DockingStyle <> dsNone) then
      Control.RepaintBar;
  end;
end;

procedure TdxBar.SetName(const NewName: TComponentName);
begin
  if FIsNameLocked then
    FOldName := NewName
  else
    inherited SetName(NewName);
end;

procedure TdxBar.Updated;
begin
  inherited Updated;
  if FNeedUpdateControlPosition then
    UpdateControlPosition;
end;

procedure TdxBar.Updating;
begin
  inherited Updating;
  FNeedUpdateControlPosition := False;
end;

procedure TdxBar.SetNotDocking(Value: TdxBarDockingStyles);
begin
  if FNotDocking <> Value then
  begin
    FNotDocking := Value;
    if Control <> nil then Control.RepaintBar;
  end;
end;

procedure TdxBar.SetOneOnRow(Value: Boolean);
begin
  if (RealDockControl = nil) or not RealDockControl.IsBarHandleDestroying then
    FOneOnRow := Value;
end;

function TdxBar.CreateControl: TdxBarControl;
begin
  Result := GetControlClass.CreateEx(BarManager, Self);
  Result.UpdateFont;
end;

function TdxBar.GetControlClass: TdxBarControlClass;
begin
  if RealDockControl <> nil then
    Result := RealDockControl.GetDockedBarControlClass
  else
    Result := TdxBarControl;
end;

procedure TdxBar.ShowControl;

  function CanShowBar: Boolean;
  begin
    Result := (DockingStyle <> dsNone) or BarManager.IsOwnerVisible and
      (not BarManager.HideFloatingBarsWhenInactive or BarManager.FIsCustomizing or IsFormActive(BarManager.ParentForm));
  end;

var
  P: TPoint;
begin
  if DockingStyle <> dsNone then
  begin
    Control.BeginInternal;
    try
      Control.ChangeStyleWinTo(DockingStyle, RealDockControl);
      P := Point(DockedLeft, DockedTop);
      Windows.ClientToScreen(RealDockControl.Handle, P);
      Bars.RegInDock(DockingStyle, RealDockControl, Control, P);
    finally
      Control.EndInternal;
    end;
  end
  else
  begin
    Control.BeginInternal;
    try
      Control.ChangeStyleWinTo(DockingStyle, nil);
    finally
      Control.EndInternal;
    end;
    P := Control.GetTrackSize(DockingStyle);
    Control.SetBounds(FloatLeft, FloatTop, P.X, P.Y);
  end;
  if CanShowBar then
    ShowWindow(Control.Handle, SW_SHOWNA);
  BarManager.RemoveBarFromRestoringList(Self);
end;

class function TdxBar.GetIniSection(const ABaseSection: string; ABarIndex: Integer): string;
begin
  Result := ABaseSection + 'Bar' + IntToStr(ABarIndex);
end;

procedure TdxBar.LoadFromIni(ASource: TCustomIniFile; const ABaseSection: string;
  ABarIndex: Integer; AStoringKind: TdxBarStoringKind; AFullLoad: Boolean = True);

  procedure ReadDockControl(const ASection: string);
  var
    ADockControl: TdxBarDockControl;
  begin
    ADockControl := BarManager.FindDockControl(ASource.ReadString(ASection, 'DockControl', ''));
    if (ADockControl <> nil) or (DockControl <> nil) and DockControl.AllowUndockWhenLoadFromIni then
      DockControl := ADockControl;
  end;

var
  ASection: string;
begin
  ASection := GetIniSection(ABaseSection, ABarIndex);
  ItemLinks.LoadFromIni(ASource, ASection, AStoringKind);
  if AFullLoad then
    try
      with ASource do
      begin
        Caption := ReadString(ASection, 'Caption', Caption);
        DockedDockControl := BarManager.FindDockControl(ReadString(ASection, 'DockedDockControl', ''));
        DockedDockingStyle := TdxBarDockingStyle(ReadInteger(ASection, 'DockedDockingStyle', Integer(DockedDockingStyle)));
        DockedLeft := ReadInteger(ASection, 'DockedLeft', DockedLeft);
        DockedTop := ReadInteger(ASection, 'DockedTop', DockedTop);
        OneOnRow := ReadBool(ASection, 'OneOnRow', OneOnRow);
        FloatLeft := ReadInteger(ASection, 'FloatLeft', FloatLeft);
        FloatTop := ReadInteger(ASection, 'FloatTop', FloatTop);
        FloatClientWidth := ReadInteger(ASection, 'FloatClientWidth', FloatClientWidth);
        FloatClientHeight := ReadInteger(ASection, 'FloatClientHeight', FloatClientHeight);

        ReadDockControl(ASection);
        DockingStyle := TdxBarDockingStyle(ReadInteger(ASection, 'DockingStyle', Integer(DockingStyle)));
        Row := ReadInteger(ASection, 'Row', Row);
        Visible := ReadBool(ASection, 'Visible', False);
        MergeData.MergedWith := nil;
      end;
    except
      Visible := True;
    end;
end;

procedure TdxBar.LoadUsageData(ASource: TCustomIniFile; const ABaseSection: string; ABarIndex: Integer);
begin
  ItemLinks.LoadUsageData(ASource, GetIniSection(ABaseSection, ABarIndex));
end;

procedure TdxBar.SaveToIni(ADestination: TCustomIniFile; const ABaseSection: string; ABarIndex: Integer; AStoringKind: TdxBarStoringKind);
var
  ASection: string;
  APath: string;
begin
  ASection := GetIniSection(ABaseSection, ABarIndex);
  with ADestination do
  begin
    WriteString(ASection, 'Caption', Caption);
    if DockControl <> nil then
    begin
      APath := GetComponentPath(BarManager.Owner, DockControl);
      if APath <> '' then
        WriteString(ASection, 'DockControl', APath);
    end;
    if DockedDockControl <> nil then
    begin
      APath := GetComponentPath(BarManager.Owner, DockedDockControl);
      if APath <> '' then
        WriteString(ASection, 'DockedDockControl', APath);
    end;
    WriteInteger(ASection, 'DockedDockingStyle', Ord(DockedDockingStyle));
    WriteInteger(ASection, 'DockedLeft', DockedLeft);
    WriteInteger(ASection, 'DockedTop', DockedTop);
    WriteInteger(ASection, 'DockingStyle', Ord(DockingStyle));
    WriteInteger(ASection, 'FloatClientHeight', FloatClientHeight);
    WriteInteger(ASection, 'FloatClientWidth', FloatClientWidth);
    WriteInteger(ASection, 'FloatLeft', FloatLeft);
    WriteInteger(ASection, 'FloatTop', FloatTop);
    WriteBool(ASection, 'OneOnRow', OneOnRow);
    WriteInteger(ASection, 'Row', Row);
    if MergeData.MergedWith = nil then
      WriteBool(ASection, 'Visible',
        Visible or (BarManager.GetBarIndexInRestoringList(Self) <> -1))
    else
      WriteBool(ASection, 'Visible', MergeData.VisibleBeforeMerging);
  end;
  ItemLinks.SaveToIni(ADestination, ASection, AStoringKind);
end;

procedure TdxBar.InternalMerge(ABar: TdxBar; ASaveMergingBarVisibility: Boolean);
var
  AIsBarMerged: Boolean;
begin
  if MergeData.MergedWith <> nil then
    raise EdxException.Create(cxGetResourceString(@dxSBAR_CANTMERGEWITHMERGEDTOOLBAR));
  if (ABar = Self) or (ABar = nil) then
    raise EdxException.Create(cxGetResourceString(@dxSBAR_CANTMERGETOOLBAR));
  if ABar.MergeData.MergedWith = Self then
    raise EdxException.Create(Format(cxGetResourceString(@dxSBAR_TOOLBARSALREADYMERGED), [ABar.Caption, Caption]));
  if ABar.MergeData.MergedBarList.Count > 0 then
    raise EdxException.Create(Format(cxGetResourceString(@dxSBAR_TOOLBARHASMERGEDTOOLBARS), [ABar.Caption]));
  AIsBarMerged := ABar.MergeData.MergedWith <> nil;
  if AIsBarMerged then
    ABar.MergeData.MergedWith.InternalUnmergeFromBar(ABar, False);
  FMergingWith := ABar;
  try
    ABar.MergeData.MergedWith := Self;
    MergeData.MergedBarList.Add(ABar);
    BarManager.BeginUpdate;
    try
      ItemLinks.Merge(ABar.ItemLinks);
    finally
      BarManager.EndUpdate;
    end;
    if not AIsBarMerged and ASaveMergingBarVisibility then
      ABar.MergeData.VisibleBeforeMerging := ABar.Visible;
    ABar.SetVisibility(False);
  finally
    FMergingWith := nil;
  end;
end;

procedure TdxBar.InternalUnmergeFromBar(ABar: TdxBar;
  ARestoreMergedBarsVisibility: Boolean);

  procedure RestoreMergedBar(ABar: TdxBar);
  begin
    ABar.MergeData.MergedWith := nil;
    MergeData.MergedBarList.Remove(ABar);
    if ARestoreMergedBarsVisibility then
      ABar.SetVisibility(ABar.MergeData.VisibleBeforeMerging);
  end;

  procedure RestoreMergedBars;
  var
    I: Integer;
  begin
    if ABar <> nil then
      RestoreMergedBar(ABar)
    else
      for I := MergeData.MergedBarList.Count - 1 downto 0 do
        RestoreMergedBar(TdxBar(MergeData.MergedBarList[I]));
  end;

begin
  if ABar = Self then
    raise EdxException.Create(cxGetResourceString(@dxSBAR_CANTUNMERGETOOLBAR));
  if (ABar <> nil) and (ABar.MergeData.MergedWith = nil) then
    Exit;
  if (ABar <> nil) and (ABar.MergeData.MergedWith <> Self) then
    raise EdxException.Create(Format(cxGetResourceString(@dxSBAR_TOOLBARSARENOTMERGED), [ABar.Caption, Caption]));
  if MergeData.MergedBarList.Count = 0 then
    Exit;

  BarManager.BeginUpdate;
  try
    ItemLinks.Unmerge(ABar);
  finally
    BarManager.EndUpdate;
  end;
  RestoreMergedBars;

  if (MergeData.MergedBarList.Count = 0) and MergeData.CreatedByMerging then
    if ShouldNotBeDestroyedIfEmptyAfterUnmerge then
    begin
      MergeData.CreatedByMergingBarVisibleBeforeCustomization := Visible;
      SetVisibility(False);
      Hidden := True;
    end
    else
      Free;
end;

procedure TdxBar.InternalUnmergeFromBarManager(ABarManager: TdxBarManager;
  ARestoreMergedBarsVisibility: Boolean);
var
  ABar: TdxBar;
  I: Integer;
begin
  for I := MergeData.MergedBarList.Count - 1 downto 0 do
  begin
    ABar := MergeData.MergedBarList[I];
    if (ABarManager = nil) or (ABar.BarManager = ABarManager) then
      InternalUnmergeFromBar(ABar, ARestoreMergedBarsVisibility);
  end;
end;

procedure TdxBar.RestoreMergeState;
var
  ABar: TdxBar;
  I: Integer;
begin
  for I := 0 to MergeData.SavedMergedBarCount - 1 do
  begin
    ABar := TdxBar(MergeData.SavedMergedBars[I]);
    InternalMerge(ABar, ABar.BarManager = BarManager);
  end;
  MergeData.ClearSavedMergedBarList;
end;

procedure TdxBar.SaveMergeState;
begin
  MergeData.SaveMergedBarList;
end;

procedure TdxBar.SetVisibility(Value: Boolean);

  procedure SetMDIChildRightWindowRect(out APrevBoundsRect: TRect);
  var
    AHandle: HWND;
    AParentForm: TCustomForm;
    R: TRect;
  begin
    AParentForm := TCustomForm(BarManager.Owner);
    if AParentForm.HandleAllocated then
    begin
      AHandle := AParentForm.Handle;
      APrevBoundsRect := AParentForm.BoundsRect;
      R := cxGetWindowRect(AHandle);
      MapWindowPoints(0, GetParent(AHandle), R, 2);
      TCustomFormAccess(AParentForm).WindowHandle := 0;
      AParentForm.BoundsRect := R;
      TCustomFormAccess(AParentForm).WindowHandle := AHandle;
    end;
  end;

  procedure RestoreMDIChildWindowRect(const APrevBoundsRect: TRect);
  var
    AHandle: HWND;
    AParentForm: TCustomForm;
  begin
    AParentForm := TCustomForm(BarManager.Owner);
    if AParentForm.HandleAllocated then
    begin
      AHandle := AParentForm.Handle;
      TCustomFormAccess(AParentForm).WindowHandle := 0;
      AParentForm.BoundsRect := APrevBoundsRect;
      TCustomFormAccess(AParentForm).WindowHandle := AHandle;
    end;
  end;

var
  APrevBoundsRect: TRect;
begin
  if Value <> Visible then
  begin
    if BarManager.IsOwnerMDIChild(False) then
      SetMDIChildRightWindowRect(APrevBoundsRect);
    Visible := Value;
    if BarManager.IsOwnerMDIChild(False) then
      RestoreMDIChildWindowRect(APrevBoundsRect);
  end;
end;

procedure TdxBar.CaptionButtonsNotification(Sender: TObject; AItem: TCollectionItem);
begin
  if Control <> nil then
    Control.UpdateCaptionButton(TdxBarCaptionButton(AItem));
end;

procedure TdxBar.DoChanged;
begin
  FChanged := True;
end;

procedure TdxBar.SetRotateWhenVertical(Value: Boolean);
begin
  if FRotateWhenVertical <> Value then
  begin
    FRotateWhenVertical := Value;
    if Control <> nil then Control.Perform(CM_FONTCHANGED, 0, 0);
  end;
end;

procedure TdxBar.SetRow(Value: Integer);
var
  ADockRow: TdxDockRow;
begin
  if Value < 0 then
    Value := 0;
  if (Row = Value) and (DockRow <> nil) then
    Exit;
  FRow := Value;
  if RealDockControl <> nil then
  begin
    if FRow > RealDockControl.RowCount - 1 then
    begin
      repeat
        ADockRow := TdxDockRow.Create(RealDockControl);
        RealDockControl.RowList.Add(ADockRow);
      until not (BarManager.IsUpdateLocked or BarManager.BarsLoading) or (RealDockControl.RowCount > FRow);
      SetDockRow(ADockRow);
    end
    else
      SetDockRow(RealDockControl.RowList[FRow]);
  end;
  Changed(False);
  if RealDockControl <> nil then
    RealDockControl.UpdateDock;
end;

procedure TdxBar.SetShowMark(Value: Boolean);
begin
  if FShowMark <> Value then
  begin
    FShowMark := Value;
    if Control <> nil then Control.RepaintBar;
  end;
end;

procedure TdxBar.SetSizeGrip(Value: Boolean);
begin
  if FSizeGrip <> Value then
  begin
    FSizeGrip := Value;
    if IsStatusBar and (Control <> nil) then
      Control.RebuildBar;
  end;
end;

procedure TdxBar.SetUseOwnFont(Value: Boolean);
begin
  if FUseOwnFont <> Value then
  begin
    FUseOwnFont := Value;
    FInternalFontChange := True;
    try
      if FUseOwnFont then
        FontChanged(nil)
      else
        Font := BarManager.Font;
    finally
      FInternalFontChange := False;
    end;
  end;
end;

procedure TdxBar.SetUseRecentItems(Value: Boolean);
begin
  if UseRecentItems <> Value then
  begin
    FItemLinks.FUseRecentItems := Value;
    if Control <> nil then
      Control.RepaintBar;
  end;
end;

procedure TdxBar.SetUseRestSpace(Value: Boolean);
begin
  if FUseRestSpace <> Value then
  begin
    FUseRestSpace := Value;
    if Control <> nil then Control.RepaintBar;
  end;
end;

procedure TdxBar.SetVisible(Value: Boolean);
begin
  if Value and BarManager.IsDestroying then Exit;
  if not FVisible and not Value then
    BarManager.RemoveBarFromRestoringList(Self);

  if BarManager.IsLoading then
  begin
    if FVisible <> Value then
      FInternallyHidden := False;
    FLoadedVisible := Value;
    Exit;
  end;
  if FVisible <> Value then
  begin
    FInternallyHidden := False;
    if not Value and (Control <> nil) then Control.SavePos;
    FVisible := Value;
    if FVisible then
    begin
      FItemLinks.CreateBarControl;
      ShowControl;
    end
    else  // Visible = False
      ItemLinks.DestroyBarControl;

    Changed(False);//#DG

    if not BarManager.IsDestroying and Assigned(BarManager.FOnBarVisibleChange) then
      BarManager.FOnBarVisibleChange(BarManager, Self);
  end;
end;

procedure TdxBar.SetWholeRow(Value: Boolean);
begin
  if FWholeRow <> Value then
  begin
    FWholeRow := Value;
    if (Control <> nil) and (DockingStyle <> dsNone) then
    begin
      Visible := False;
      Visible := True;
    end;
  end;
end;

procedure TdxBar.FontChanged(Sender: TObject);
begin
  if not FInternalFontChange then
    FUseOwnFont := True;
  if FUseOwnFont then
    CreateEditFontHandle(Font, FEditFont, False);
  if Control <> nil then
    Control.UpdateFont;
end;

procedure TdxBar.Move(X, Y: Integer);
begin
  DockingStyle := dsNone;
  FloatLeft := X;
  FloatTop := Y;
end;

procedure TdxBar.Move(ADockControl: TdxDockControl; ARow, APosition: Integer);
var
  ADockRow: TdxDockRow;
  APrevOneOnRow, APrevVisible: Boolean;
begin
  if (RealDockControl = nil) and (ADockControl = nil) or
    (ADockControl <> nil) and (ADockControl.BarManager <> BarManager) then
      Exit;

  if ADockControl = nil then
    ADockControl := RealDockControl;
  if (ADockControl = RealDockControl) and (ARow = Row) and (APosition = GetDockedPosition) then
    Exit;

  APrevOneOnRow := OneOnRow;
  APrevVisible := Visible;
  Visible := False;

  if BarManager.IsInternalDockControl(ADockControl) then
    DockingStyle := ADockControl.DockingStyle
  else
    FDockControl := TdxBarDockControl(ADockControl);

  if ARow >= ADockControl.RowCount then
  begin
    ADockRow := TdxDockRow.Create(ADockControl);
    ADockControl.RowList.Add(ADockRow);
  end;
  if ADockControl.Vertical then
    DockedTop := APosition
  else
    DockedLeft := APosition;
  Row := ARow;
  OneOnRow := APrevOneOnRow;
  Visible := APrevVisible;
  RealDockControl.AssignPositions;
end;

procedure TdxBar.Move(ADockingStyle: TdxBarDockedDockingStyle;
  ARow, APosition: Integer);
begin
  Move(BarManager.InternalDockControls[ADockingStyle], ARow, APosition);
end;

procedure TdxBar.Move(ABar: TdxBar; AInsertAfter: Boolean = True);
var
  APosition: Integer;
begin
  if (ABar.RealDockControl = nil) or (ABar.BarManager <> BarManager) or
    AInsertAfter and (ABar.Control = nil) then
      Exit;
  APosition := ABar.GetDockedPosition;
  if AInsertAfter then
    if ABar.IsVertical then
      Inc(APosition, ABar.Control.Height)
    else
      Inc(APosition, ABar.Control.Width);
  OneOnRow := False;
  Move(ABar.RealDockControl, ABar.Row, APosition);
end;

procedure TdxBar.UpdateControlPosition;
var
  P: TPoint;
begin
  if (Control <> nil) and not Bars.IsMoving and not Control.FPosSaving then
    if DockingStyle = dsNone then
    begin
      P := Control.GetTrackSize(dsNone);
      Control.SetBounds(FloatLeft, FloatTop, P.X, P.Y);
    end
    else
    begin
      if DockRow <> nil then
        DockRow.DeleteCol(Control);
      ShowControl;
    end;
end;

function TdxBar.IsDockedDockingStyleStored: Boolean;
begin
  Result := FDockedDockControl = nil;
end;

function TdxBar.IsDockingStyleStored: Boolean;
begin
  Result := FDockControl = nil;
end;

procedure TdxBar.AddFreeNotification(AItem: TdxBarItem);
begin
  FFreeNotificationItems.Add(AItem);
end;

procedure TdxBar.RemoveFreeNotification(AItem: TdxBarItem);
begin
  FFreeNotificationItems.Remove(AItem);
end;

procedure TdxBar.MakeFreeNotification;
var
  I: Integer;
begin
  for I := FFreeNotificationItems.Count - 1 downto 0 do
    TdxBarItem(FFreeNotificationItems[I]).ObjectNotification(opRemove, Self);
end;

procedure TdxBar.RemoveFromDockRow(ADestroyEmptyDockRow: Boolean);
begin
  if FDockRow <> nil then
    FDockRow.DeleteBar(Self, ADestroyEmptyDockRow);
  FDockRow := nil;
end;

function TdxBar.BarNCSizeX(AStyle: TdxBarDockingStyle): Integer;
begin
  with Painter.GetToolbarContentOffsets(Self, AStyle, HasSizeGrip) do
    Result := Left + Right;
end;

function TdxBar.BarNCSizeY(AStyle: TdxBarDockingStyle): Integer;
begin
  with Painter.GetToolbarContentOffsets(Self, AStyle, HasSizeGrip) do
    Result := Top + Bottom;
end;

function TdxBar.CanClose: Boolean;
begin
  Result := FAllowClose and not FIsMainMenu and
    ((Control = nil) or Control.HasCaption);
end;

function TdxBar.CanMoving: Boolean;
const
  AllDockingStyles = [Low(TdxBarDockingStyle)..High(TdxBarDockingStyle)];
begin
  Result := (NotDocking <> AllDockingStyles) and
    (BarManager.NotDocking <> AllDockingStyles);
end;

function TdxBar.CanReset: Boolean;
begin
  Result := FIsPredefined and FAllowReset;
end;

function TdxBar.GetDockedPosition: Integer;
begin
  if IsVertical then
    Result := DockedTop
  else
    Result := DockedLeft;
end;

function TdxBar.HasSizeGrip: Boolean;
var
  Parent: HWND;
  R, CR: TRect;

  function FindForm(AHandle: HWND): TCustomForm;
  var
    AControl: TWinControl;
  begin
    AControl := FindControl(AHandle);
    if AControl is TCustomForm then
      Result := TCustomForm(AControl)
    else
      Result := nil;
  end;

  function IsBottom(AHandle: HWND): Boolean;
  begin
    Parent := GetParent(AHandle);
    Result := (Parent = 0) or IsMDIChild(FindForm(AHandle));
    if not Result then
    begin
      R := cxGetWindowRect(AHandle);
      MapWindowRect(0, Parent, R);
      GetClientRect(Parent, CR);
      Result := (R.Bottom = CR.Bottom) and IsBottom(Parent);
    end;
  end;

begin
  Result := IsStatusBar and SizeGrip and not IsZoomed(BarManager.Owner.Handle) and
    ((Control = nil) or IsBottom(Control.Handle));
end;

function TdxBar.IsFloat: Boolean;
begin
  Result := (Control <> nil) and (DockingStyle = dsNone);
end;

function TdxBar.IsShortCut(AShortCut: TShortCut): Boolean;
begin
  Result := FItemLinks.IsShortCut(AShortCut);
end;

function TdxBar.IsStatusBar: Boolean;
begin
  Result := (FBorderStyle = bbsNone) and (DockingStyle = dsBottom) and
    WholeRow; // !!!
end;

//IdxBarSelectableItem
function TdxBar.CanDelete(ADestruction: Boolean = False): Boolean;
begin
  Result := (BarManager.Designing or not IsPredefined and CanClose) and
    BarManager.CanDeleteComponent(Self);
end;

procedure TdxBar.DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean);
begin
  if CanDelete(ADestruction) then
  begin
    AReference := nil;
    Free;
  end;
end;

procedure TdxBar.ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction);
begin
// do nothing
end;

function TdxBar.GetBarManager: TdxBarManager;
begin
  Result := TdxBarManager(GetParentComponent);
end;

procedure TdxBar.GetMasterObjects(AList: TdxObjectList);
begin
  AList.Add(BarManager.Owner);
end;

function TdxBar.GetNextSelectableItem: IdxBarSelectableItem;
begin
  Result := GetNext;
end;

function TdxBar.GetSelectableParent: TPersistent;

  function FindSelectableParent(AControl: TWinControl): TWinControl;
  begin
    Result := nil;
    while (AControl <> nil) and (Result = nil) do
      if GetClass(AControl.ClassName) <> nil then
        Result := AControl
      else
        AControl := AControl.Parent;
  end;

begin
  Result := FindSelectableParent(DockControl);
  if Result = nil then
    Result := BarManager.Owner;
end;

function TdxBar.GetSelectionStatus: TdxBarSelectionStatus;
begin
  Result := BarManager.GetSelectionStatus(Self);
end;

function TdxBar.GetSupportedActions: TdxBarCustomizationActions;
begin
  Result := [caDelete];
end;

procedure TdxBar.Invalidate;
begin
  if Control <> nil then
    Control.Invalidate;
end;

function TdxBar.IsComplex: Boolean;
begin
  Result := False;
end;

function TdxBar.IsComponentSelected: Boolean;
begin
  Result := BarManager.IsComponentSelected(Self);
end;

procedure TdxBar.SelectComponent(ASelectionOperation: TdxBarSelectionOperation = soExclusive);
begin
  BarManager.SelectComponent(Self, ASelectionOperation);
end;

function TdxBar.SelectParentComponent: Boolean;
begin
  BarManager.SelectComponent(GetSelectableParent);
  Result := True;
end;

procedure TdxBar.SelectionChanged;
begin
  BarDesignController.SynchronizeLastSelectedItem;
  Invalidate;
end;

// IdxBarLinksOwner
function TdxBar.CanContainItem(AItem: TdxBarItem;
  out AErrorText: string): Boolean;
begin
  Result := AItem.CanBePlacedOn(pkBar, Self, AErrorText);
end;

function TdxBar.CreateBarControl: TCustomdxBarControl;
begin
  Result := CreateControl;
end;

function TdxBar.GetItemLinks: TdxBarItemLinks;
begin
  Result := FItemLinks;
end;

function TdxBar.GetComponentInstance: TComponent;
begin
  Result := Self;
end;

function TdxBar.GetPersistentInstance: TPersistent;
begin
  Result := Self;
end;

procedure TdxBar.ChangeDockingStyle(AStyle: TdxBarDockingStyle;
  ADockControl: TdxDockControl);
begin
  if (ADockControl <> nil) and ADockControl.Main then
    ADockControl := nil;
  if DockingStyle = AStyle then
    DockControl := TdxBarDockControl(ADockControl)
  else
    if DockControl = ADockControl then
      DockingStyle := AStyle
    else
      if ADockControl = nil then
        DockingStyle := AStyle
      else
        DockControl := TdxBarDockControl(ADockControl);
end;

function TdxBar.GetCollectionFromParent(AParent: TComponent): TcxComponentCollection;
begin
  Result := (AParent as TdxBarManager).Bars;
end;

function TdxBar.IsVertical: Boolean;
begin
  Result := (DockingStyle in [dsLeft, dsRight]) and RotateWhenVertical;
end;

procedure TdxBar.Reset;

  procedure InternalReset(ASource: TCustomIniFile; const ABaseSection: string; ABarIndex: Integer);
  begin
    ResettingToolbar := True;
    try
      LoadFromIni(ASource, ABaseSection, ABarIndex, skIni, BarManager.UseFullReset);
      LoadUsageData(ASource, ABaseSection, ABarIndex);
      ItemLinks.CheckLinks(ASource, ABaseSection);
    finally
      ResettingToolbar := False;
    end;
  end;

var
  ABarIndex: Integer;
  APrevVisible: Boolean;
begin
  ABarIndex := BarManager.GetSavedBarIndex(Caption);
  if ABarIndex <> -1 then
  begin
    BarManager.DoBarBeforeReset(Self);
    BarManager.BeginUpdate;
    try
      APrevVisible := Visible;
      if BarManager.UseFullReset then
        Visible := False;
      try
        InternalReset(BarManager.SavedState, BarManager.GetBaseIniSection, ABarIndex);
      finally
        if BarManager.UseFullReset then
          Visible := APrevVisible;
      end;
    finally
      BarManager.EndUpdate;
    end;
    BarManager.DoBarAfterReset(Self);
  end;
end;

procedure TdxBar.ResetWithConfirmation;
begin
  if dxBarMessageBox(Format(cxGetResourceString(@dxSBAR_WANTTORESETTOOLBAR), [Caption]),
       MB_OKCANCEL or MB_ICONEXCLAMATION) = ID_OK then
    Reset;
end;

procedure TdxBar.SetParentComponent(AParent: TComponent);
begin
  inherited SetParentComponent(AParent);
  FItemLinks := TdxBarControlItemLinks.Create(BarManager, Self);
  Font.OnChange := nil;
  Font.Assign(BarManager.Font);
  Font.OnChange := FontChanged;
  if not BarManager.IsLoading then
  begin
    if Assigned(BarManager.OnBarAdd) then
      BarManager.OnBarAdd(BarManager, Self);
    Changed(False);
  end;
end;

procedure TdxBar.Merge(ABar: TdxBar);
begin
  InternalMerge(ABar, True);
end;

procedure TdxBar.Unmerge(ABar: TdxBar = nil);
begin
  InternalUnmergeFromBar(ABar, True);
end;

{ TdxBars }

constructor TdxBars.Create(ABarManager: TdxBarManager);
var
  ADockingStyle: TdxBarDockingStyle;
begin
  inherited Create(ABarManager, TdxBar);
  FBarManager := ABarManager;
  FDockingZoneSize := MinToolbarSize;
  for ADockingStyle := dsLeft to dsBottom do
  begin
    FDockControls[ADockingStyle] := TdxDockControl.CreateEx(nil, FBarManager, ADockingStyle);
    FDockControls[ADockingStyle].Parent := FBarManager.Owner;
  end;
end;

destructor TdxBars.Destroy;
var
  I: TdxBarDockingStyle;
begin
  for I := dsLeft to dsBottom do
  begin
    FDockControls[I].Free;
    FDockControls[I] := nil;
  end;
  inherited;
end;

function TdxBars.GetDockControl(Index: TdxBarDockingStyle): TdxDockControl;
begin
  Result := FDockControls[Index];
end;

function TdxBars.GetItem(Index: Integer): TdxBar;
begin
  Result := TdxBar(inherited Items[Index]);
end;

procedure TdxBars.SetItem(Index: Integer; Value: TdxBar);
begin
  Items[Index].Assign(Value);
end;

{
function TdxBars.GetOwner: TPersistent;
begin
  Result := FBarManager;
end;
}

procedure TdxBars.RegInDock(AStyle: TdxBarDockingStyle; ADockControl: TdxDockControl;
  ABarControl: TdxBarControl; APos: TPoint);
begin
  if ADockControl <> nil then
    ADockControl.AddBarControl(ABarControl, APos, True)
  else
    if (AStyle <> dsNone) and (FDockControls[AStyle] <> nil) then
      FDockControls[AStyle].AddBarControl(ABarControl, APos, True);
end;

procedure TdxBars.UnregFromDock(AStyle: TdxBarDockingStyle;
  ADockControl: TdxDockControl; ABarControl: TdxBarControl);
begin
  if ADockControl <> nil then
    ADockControl.DeleteBarControl(ABarControl, nil, True)
  else
    if (AStyle <> dsNone) and (FDockControls[AStyle] <> nil) then
      FDockControls[AStyle].DeleteBarControl(ABarControl, nil, True);
end;

procedure DockTimerProc(Wnd: HWND; Msg: UINT; idEvent: UINT; Time: DWORD); stdcall;
var
  P: TPoint;
begin
  dxKillTimer(0, FDockTimerID);
  if FDockBarManager <> nil then
    with FDockBarManager.Bars do
    begin
      P := GetMouseCursorPos;
      Inc(P.X, FMovingOffset.X);
      Inc(P.Y, FMovingOffset.Y);
      FDocking := True;
      ChangeBarControlPos(FMovingBarControl, P);
      FDocking := False;
      FDockBarManager := nil;
    end;
end;

procedure TdxBars.ChangeBarControlPos(ABarControl: TdxBarControl; APos: TPoint);
var
  AStyle: TdxBarDockingStyle;
  ADockControl: TdxDockControl;
  ASize: TPoint;
begin
  AStyle := GetDockingStyleAtPos(ABarControl.Bar, APos, ADockControl);
  if not FBarManager.DoDocking(ABarControl.Bar, AStyle, ADockControl) then Exit;

  if not FDocking and (ABarControl.DockingStyle = dsNone) and (AStyle <> dsNone) then
  begin
    dxKillTimer(0, FDockTimerID);
    FDockBarManager := BarManager;
    FDockTimerID := SetTimer(0, 0, BarManager.WaitForDockingTime, @DockTimerProc);
    ADockControl := nil;
    AStyle := dsNone;
  end;

  if AStyle = dsNone then
  begin
    Dec(APos.X, FMovingOffset.X);
    Dec(APos.Y, FMovingOffset.Y);
  end;
  if (ABarControl.DockingStyle <> AStyle) or
    (ABarControl.DockControl <> ADockControl) then
  begin
    ABarControl.Hide;
    if ABarControl.DockingStyle <> dsNone then
    begin
      UnregFromDock(ABarControl.DockingStyle, ABarControl.DockControl, ABarControl);
      ABarControl.ItemLinks.RecentItemCount := -1;
    end;
    if AStyle <> dsNone then
    begin
      with ABarControl do
      begin
        BeginInternal; //!!!
        try
          ChangeStyleWinTo(AStyle, ADockControl);
        finally
          EndInternal;
        end;
      end;
      RegInDock(AStyle, ADockControl, ABarControl, APos);
    end
    else
      with ABarControl do
      begin
        BeginInternal;  // for WMSize
        try
          ChangeStyleWinTo(AStyle, nil);
        finally
          EndInternal;
        end;
        ASize := GetTrackSize(AStyle);
        with GetDragPointOffset(AStyle) do
          SetWindowPos(Handle, 0, APos.X - X, APos.Y - Y, ASize.X, ASize.Y,
            SWP_NOZORDER or SWP_NOACTIVATE);
      end;
    Windows.ShowWindow(ABarControl.Handle, SW_SHOWNA);
  end
  else
    if ABarControl.DockingStyle <> dsNone then
      ADockControl.MoveBarControl(ABarControl, APos)
    else
      with ABarControl, GetDragPointOffset(AStyle) do
        SetWindowPos(Handle, 0, APos.X - X, APos.Y - Y, 0, 0,
          SWP_NOZORDER or SWP_NOSIZE or SWP_NOACTIVATE);
end;

function TdxBars.GetDockingStyleAtPos(Bar: TdxBar; Pos: TPoint;
  var DockControl: TdxDockControl): TdxBarDockingStyle;
var
  ADockControl: TdxDockControl;

  function PtInControlRect(ADockControl: TWinControl; const R: TRect; P: TPoint): Boolean;
  var
    AParent: TWinControl;
  begin
    Result := PtInRect(R, P);
    if Result and ADockControl.HandleAllocated and
      (ADockControl.Parent <> nil) and (ADockControl.Parent.Parent <> nil) then
    begin
      AParent := ADockControl.Parent.Parent;
      P := AParent.ScreenToClient(P);
      Result := ADockControl.Parent.Handle =
        ChildWindowFromPointEx(AParent.Handle, P, CWP_SKIPINVISIBLE);
    end;
  end;

  function CheckDockZone(ADockingStyle: TdxBarDockingStyle): Boolean;
  var
    I: Integer;
  begin
    Result := False;
    for I := 0 to FBarManager.DockControlCount - 1 do
    begin
      ADockControl := FBarManager.DockControls[I];
      with ADockControl do
        if (DockingStyle = ADockingStyle) and (CanFocus or BarManager.Designing) then
        begin
          Result :=
            FBarManager.DoDocking(Bar, ADockingStyle, ADockControl) and
            PtInControlRect(ADockControl, GetDockZoneBounds, Pos);
          if Result then Break;
        end;
    end;
    if Result then
    begin
      DockControl := ADockControl;
      GetDockingStyleAtPos := ADockingStyle;
    end;
  end;

begin
  DockControl := nil;
  Result := dsNone;

  if FMoving and (GetAsyncKeyState(VK_CONTROL) < 0) then Exit;
  
  if CheckDockZone(dsLeft) then Exit;
  if CheckDockZone(dsRight) then Exit;
  if CheckDockZone(dsTop) then Exit;
  if CheckDockZone(dsBottom) then Exit;

  if FMoving then
  begin
    Dec(Pos.X, FMovingOffset.X);
    Dec(Pos.Y, FMovingOffset.Y);
  end;
  if CheckDockZone(dsLeft) then Exit;
  if CheckDockZone(dsRight) then Exit;
  if CheckDockZone(dsTop) then Exit;
  if CheckDockZone(dsBottom) then Exit;
end;

procedure TdxBars.Moving(AMovingBarControl: TdxBarControl);
var
  CaptureWnd: HWND;
  Msg: TMsg;
  PrevP, CalcP, P: TPoint;
begin
  // ---
  if not AMovingBarControl.CanMoving then Exit;

  with AMovingBarControl, Bar do
    if DockingStyle <> dsNone then
      GetDockCol.FPos := Point(DockedLeft, DockedTop);

  FMoving := True;
  AMovingBarControl.Moving := True;

  PrevP := GetMouseCursorPos;

  FMovingBarOriginalDockingStyle := FMovingBarControl.DockingStyle;
  FMovingOffset := cxNullPoint;
  FMovingStaticOffset := cxNullPoint;
  with FMovingBarControl, Bar do
    if DockingStyle <> dsNone then
    begin
      P := GetDockCol.Pos;
      Windows.ClientToScreen(RealDockControl.Handle, P);

      RealDockControl.DeleteBarControl(Control, nil, False);
      CalcP := PrevP;
      RealDockControl.GetPosForRow(Row, OneOnRow, CalcP);
      if Control.Vertical then
        FMovingOffset.X := CalcP.X - PrevP.X
      else
        FMovingOffset.Y := CalcP.Y - PrevP.Y;
      Control.BeginInternal;
      try
        RealDockControl.AddBarControl(Control, P, False);
      finally
        Control.EndInternal;
      end;

      FMovingStaticOffset := Point(Left, Top);
      Windows.ClientToScreen(RealDockControl.Handle, FMovingStaticOffset);
      with FMovingStaticOffset do
      begin
        X := PrevP.X - X;
        Y := PrevP.Y - Y;
      end;
    end;

  ProcessPaintMessages;

  Include(BarDesignController.FDesignStates, dsKeyAlreadyProcessed);
  CaptureWnd := BarManager.GetWindowForMouseCapturing;
  SetCapture(CaptureWnd);
  try
    while GetCapture = CaptureWnd do
    begin
      case Integer(GetMessage(Msg, 0, 0, 0)) of
        -1: Break;
        0: begin
            PostQuitMessage(Msg.wParam);
            Break;
          end;
      end;
      with Msg do
        if ((message = WM_KEYDOWN) or (message = WM_KEYUP)) and
          (wParam = VK_CONTROL) then
        begin
          message := WM_MOUSEMOVE;
          hwnd := 0;
          lParam := Windows.LPARAM(PointToSmallPoint(GetMouseCursorPos));
          PrevP := cxInvalidPoint;
        end;
      case Msg.message of
        WM_KEYDOWN, WM_KEYUP:
          if Msg.wParam = VK_ESCAPE then Break;
        WM_MOUSEMOVE:
          begin
            P := SmallPointToPoint(TSmallPoint(Msg.lParam));
            ClientToScreen(Msg.hwnd, P);
            if (P.X <> PrevP.X) or (P.Y <> PrevP.Y) then
            begin
              CalcP := P;
              Inc(CalcP.X, FMovingOffset.X);
              Inc(CalcP.Y, FMovingOffset.Y);
              ChangeBarControlPos(FMovingBarControl, CalcP);
              //ProcessPaintMessages;
              PrevP := P;
            end;
          end;
        WM_LBUTTONUP:
          Break;
      else
        TranslateMessage(Msg);
        DispatchMessage(Msg);
      end;
    end;
  finally
    if dxKillTimer(0, FDockTimerID) then
      FDockBarManager := nil;
    if GetCapture = CaptureWnd then ReleaseCapture;
    AMovingBarControl := FMovingBarControl;
    FMovingBarControl.Moving := False;
    if AMovingBarControl.DockingStyle <> dsNone then
      AMovingBarControl.DockControl.AssignPositions;
    FMoving := False;
    Exclude(BarDesignController.FDesignStates, dsKeyAlreadyProcessed);
  end;
end;

procedure TdxBars.Repaint;
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
    with Items[I] do
      if Control <> nil then
        Control.RepaintBar;
end;

procedure TdxBars.SetItemName(AItem: TcxComponentCollectionItem);
begin
  AItem.Name := GetUniqueToolBarName(BarManager.Name + 'Bar');
end;

procedure TdxBars.Update(AItem: TcxComponentCollectionItem; AAction: TcxComponentCollectionNotification);
begin
  inherited;
  if AAction = ccnChanged then
    BarManager.DesignerModified; //#DG
end;

function TdxBars.Add: TdxBar;
begin
  Result := TdxBar(inherited Add);
end;

function TdxBars.GetUniqueToolbarName(const ABaseName: string): string;
begin
  Result := BarManager.GetUniqueToolbarName(ABaseName);
end;

function TdxBars.Insert(Index: Integer): TdxBar;
begin
  Result := TdxBar(inherited Insert(Index));
end;

{ TdxBarItemOptions }

constructor TdxBarItemOptions.Create(AItemLinks: TdxBarItemLinks);
begin
  inherited Create;
  FItemLinks := AItemLinks;

  FShowDescriptions := GetDefaultValue(ioShowDescriptions);
  FShowShortCuts := GetDefaultValue(ioShowShortCuts);
  FSize := GetDefaultValue(ioSize);
end;

procedure TdxBarItemOptions.Assign(Source: TPersistent);
begin
  if Source is TdxBarItemOptions then
  begin
    FAssignedValues := TdxBarItemOptions(Source).FAssignedValues;
    FShowDescriptions := TdxBarItemOptions(Source).FShowDescriptions;
    FShowShortCuts := TdxBarItemOptions(Source).FShowShortCuts;
    FSize := TdxBarItemOptions(Source).FSize;
  end
  else
    inherited;
end;

function TdxBarItemOptions.GetAssignedValues: TdxBarItemOptionValues;
begin
  Result := FAssignedValues;
end;

function TdxBarItemOptions.GetDefaultValue(AOption: TdxBarItemOptionValue): Variant;
begin
  Result := FItemLinks.GetDefaultValue(AOption);
end;

function TdxBarItemOptions.GetValue(AOption: TdxBarItemOptionValue): Variant;
begin
  case AOption of
    ioShowDescriptions: Result := ShowDescriptions;
    ioShowShortCuts: Result := ShowShortCuts;
  else {ioSize}
    Result := Size;
  end;
end;

function TdxBarItemOptions.GetShowDescriptions: Boolean;
begin
  if IsShowDescriptionsStored then
    Result := FShowDescriptions
  else
    Result := GetDefaultValue(ioShowDescriptions);
end;

function TdxBarItemOptions.GetShowShortCuts: Boolean;
begin
  if IsShowShortCutsStored then
    Result := FShowShortCuts
  else
    Result := GetDefaultValue(ioShowShortCuts);
end;

function TdxBarItemOptions.GetSize: TdxBarMenuItemSize;
begin
  if IsSizeStored then
    Result := FSize
  else
    Result := GetDefaultValue(ioSize);
end;

procedure TdxBarItemOptions.SetAssignedValues(AValue: TdxBarItemOptionValues);
begin
  FAssignedValues := AValue;
{
  if FAssignedValues <> AValue then
  begin
    FAssignedValues := AValue;
    if not IsValueStored(ioShowDescriptions) then
      FShowDescriptions := GetDefaultValue(ioShowDescriptions);
    if not IsValueStored(ioShowShortCuts) then
      FShowShortCuts := GetDefaultValue(ioShowShortCuts);
    if not IsValueStored(ioSize) then
      FSize := GetDefaultValue(ioSize);
  end;
}  
end;

procedure TdxBarItemOptions.SetShowDescriptions(AValue: Boolean);
begin
  FShowDescriptions := AValue;
  Include(FAssignedValues, ioShowDescriptions);
end;

procedure TdxBarItemOptions.SetShowShortCuts(AValue: Boolean);
begin
  FShowShortCuts := AValue;
  Include(FAssignedValues, ioShowShortCuts);
end;

procedure TdxBarItemOptions.SetSize(AValue: TdxBarMenuItemSize);
begin
  FSize := AValue;
  Include(FAssignedValues, ioSize);
end;

function TdxBarItemOptions.IsValueStored(AOption: TdxBarItemOptionValue): Boolean;
begin
  Result := AOption in AssignedValues;
end;

function TdxBarItemOptions.IsShowDescriptionsStored: Boolean;
begin
  Result := IsValueStored(ioShowDescriptions);
end;

function TdxBarItemOptions.IsShowShortCutsStored: Boolean;
begin
  Result := IsValueStored(ioShowShortCuts)
end;

function TdxBarItemOptions.IsSizeStored: Boolean;
begin
  Result := IsValueStored(ioSize);
end;

{ TdxBarItemLink }

constructor TdxBarItemLink.Create(Collection: TCollection);
begin
  inherited Create(Collection);
  FButtonGroup := bgpNone;
  FDistributed := True;
  FLoadedRecentIndex := -1;
  FLoadedVisible := True;
  FMostRecentlyUsed := True;
  FPosition := ipBeginsNewRow;
  FUseCount := BarManager.FMostRecentlyUsedUseCount;
  FUserGlyph := dxBarCreateBitmap(OnUserGlyphChanged);
  FViewLevels := dxBarItemAllViewLevels;
  FVisible := True;
  AddToRecentList;
  if not BarManager.IsLoading and Assigned(BarManager.FOnItemLinkAdd) then
    BarManager.FOnItemLinkAdd(BarManager, Self);
end;

destructor TdxBarItemLink.Destroy;
var
  ABarControl: TCustomdxBarControl;
begin
  if not BarManager.IsDestroying and
    Assigned(BarManager.FOnItemLinkDelete) then
    BarManager.FOnItemLinkDelete(BarManager, Self);
  ABarControl := BarControl;

  if (ABarControl <> nil) and not ABarControl.IsDestroying then
  begin
    if ABarControl.SelectedLink = Self then
    begin
      BarManager.InternalSetSelectedItem(nil);
      ABarControl.SelectedLink := nil;
    end;
    if BarControl.FPrevTrackedLink = Self then
      BarControl.FPrevTrackedLink := nil;
  end;

  DestroyControl;
  if BarDesignController <> nil then
    BarDesignController.DropSelection(Self);
  if FItem <> nil then FItem.FLinks.Remove(Self);
  FreeAndNil(FUserGlyph);

  RemoveFromRecentList;
  inherited Destroy;

{  if (ABarControl <> nil) and ABarControl.HandleAllocated and
    not ABarControl.IsDestroying then
  begin
    ABarControl.RepaintBar;
    if Assigned(AItemLinks.FOnChange) then AItemLinks.FOnChange(AItemLinks);
  end;}
end;

function TdxBarItemLink.GetAllowedViewLevels: TdxBarItemViewLevels;
begin
  Result := ViewLevels;
end;

function TdxBarItemLink.GetAvailableIndex: Integer;
begin
  if Owner = nil then
    Result := -1
  else
    Result := Owner.AvailableIndexOf(Self);
end;

function TdxBarItemLink.GetBarControl: TCustomdxBarControl;
begin
  Result := Owner.FBarControl;
end;

function TdxBarItemLink.GetBeginGroup: Boolean;
var
  AVisibleIndex: Integer;

  function NeedShowHiddenBeginGroup: Boolean;
  begin
    Result := not((Control <> nil) and
      (bboExtendItemWhenAlignedToClient in Control.Parent.BehaviorOptions) and
      (Control.Align in [iaCenter, iaRight]));
  end;

  function HiddenBeginGroupExists: Boolean;
  var
    I: Integer;
  begin
    for I := Owner.VisibleItems[AVisibleIndex - 1].Index + 1 to Index - 1 do
    begin
      Result := Owner[I].BeginGroup;
      if Result then Exit;
    end;
    Result := False;
  end;

begin
  AVisibleIndex := VisibleIndex;
  Result := FBeginGroup and (AVisibleIndex <> 0) and
    ((AVisibleIndex = -1) or not(Owner.VisibleItems[AVisibleIndex - 1].Item is TdxBarSeparator)) or
    (AVisibleIndex > 0) and NeedShowHiddenBeginGroup and HiddenBeginGroupExists;
end;

function TdxBarItemLink.GetCanVisibleIndex: Integer;
begin
  if Owner = nil then
    Result := -1
  else
    Result := Owner.CanVisibleIndexOf(Self);
end;

function TdxBarItemLink.GetCaption: string;
begin
  if not (udCaption in FUserDefine) and (FItem <> nil) then
    Result := FItem.Caption
  else
    Result := FUserCaption;
end;

function TdxBarItemLink.GetCollection: TdxBarItemLinks;
begin
  Result := TdxBarItemLinks(inherited Collection);
end;

function TdxBarItemLink.GetGlyph: TBitmap;
begin
  if not (udGlyph in FUserDefine) and (FItem <> nil) then
    Result := FItem.Glyph
  else
    Result := FUserGlyph;
end;

function TdxBarItemLink.GetNext: TdxBarItemLink;
begin
  if Collection.Next(Self, True) <> Self then
    Result := Collection.Next(Self, True)
  else
    Result := nil;
end;

function TdxBarItemLink.GetOwnerValue: TdxBarItemLinks;
begin
  Result := Collection;
end;

function TdxBarItemLink.GetPaintStyle: TdxBarPaintStyle;
begin
  if not (udPaintStyle in FUserDefine) and (FItem <> nil) then
    Result := FItem.PaintStyle
  else
    Result := FUserPaintStyle;
end;

function TdxBarItemLink.GetUserDefine: TdxBarUserDefines;
begin
  Result := FUserDefine;
end;

function TdxBarItemLink.GetVisibleIndex: Integer;
begin
  if Owner = nil then
    Result := -1
  else
    Result := Owner.VisibleIndexOf(Self);
end;

function TdxBarItemLink.GetWidth: Integer;
begin
  if udWidth in FUserDefine then
    Result := FUserWidth
  else
    if Item is TdxCustomBarEdit then
      Result := TdxCustomBarEdit(Item).Width
    else
      Result := 0
end;

procedure TdxBarItemLink.ReadItemName(AReader: TReader);
begin
  FLoadedItemName := AReader.ReadString;
end;

procedure TdxBarItemLink.SetBeginGroup(Value: Boolean);
begin
  if FBeginGroup <> Value then
  begin
    FBeginGroup := Value;
    if Control <> nil then Control.BeginGroupChanged;
    Changed(False);
//#DG    ItemLinkChanged;
  end;
end;

procedure TdxBarItemLink.SetButtonGroup(Value: TdxBarButtonGroupPosition);
begin
  if Value <> FButtonGroup then
  begin
    FButtonGroup := Value;
    Changed(True);
  end;
end;

procedure TdxBarItemLink.SetCollection(Value: TdxBarItemLinks);
begin
  inherited Collection := Value;
end;

procedure TdxBarItemLink.SetDistributed(const Value: Boolean);
begin
  if FDistributed <> Value then
  begin
    FDistributed := Value;
    Owner.FPrimaryForDistributionItems.Add(Self);
    Changed(True);
  end
end;

procedure TdxBarItemLink.SetDistributedByPrimaryLink(const Value: Boolean);
begin
  if FDistributed <> Value then
  begin
    FDistributed := Value;
    Owner.DesignerModified;
  end;
  Owner.FPrimaryForDistributionItems.Remove(Self);
end;

procedure TdxBarItemLink.SetItem(Value: TdxBarItem);
var
  AErrorText: string;
begin
  if FItem <> Value then
  begin
    Owner.BeginUpdate;
    try
      DestroyControl;
      if FItem <> nil then FItem.FLinks.Remove(Self);
      FItem := nil;
      if Value <> nil then
      begin
        try
          if not Owner.CanContainItem(Value, AErrorText) then
            raise EdxException.Create(AErrorText);
          FItem := Value;
          FItem.FLinks.Add(Self);
          Owner.RefreshVisibilityLists;
          if (Owner.Owner <> nil) and not (csLoading in Owner.Owner.ComponentState) then
            CheckMostRecentlyUsed;
        finally
          if Owner.UpdateCount = 1 then
            BarManager.DoItemLinkChange(Self); // TdxBarItemLink.SetItem should fire OnItemLinkChange for compatibility with Bars5
        end;
      end
      else
        Free;
    finally
      Owner.EndUpdate;
    end;
//#DG    if (Owner.UpdateCount = 0) and (BarControl <> nil) then BarControl.RepaintBar;
  end;
end;

procedure TdxBarItemLink.SetItemRect(Value: TRect);
begin
  FItemRect := Value;
  if Control <> nil then
    Control.DoCalculateParts;
end;

procedure TdxBarItemLink.SetMostRecentlyUsed(Value: Boolean);
begin
  if FMostRecentlyUsed <> Value then
  begin
    FMostRecentlyUsed := Value;
    CheckMostRecentlyUsed;
    if BarControl <> nil then BarControl.RepaintBar;
    Changed(False); //#DG
//#DG    ItemLinkChanged;
  end;
end;

procedure TdxBarItemLink.SetPosition(Value: TdxBarItemPosition);
begin
  if Value <> FPosition then
  begin
    FPosition := Value;
    Changed(True);
  end;
end;

procedure TdxBarItemLink.ForceSetUserDefine(AValue: TdxBarUserDefine);
begin
  FUserDefine := FUserDefine - [AValue];
  UserDefine := UserDefine + [AValue];
end;

procedure TdxBarItemLink.SetUserDefine(Value: TdxBarUserDefines);

  procedure ExcludeProperty(AProperty: TdxBarUserDefine);
  begin
    Exclude(FUserDefine, AProperty);
    case AProperty of
      udCaption: FUserCaption := '';
      udGlyph: FUserGlyph.Assign(nil);
      udPaintStyle: FUserPaintStyle := psStandard;
      udWidth: FUserWidth := 0;
    end;
  end;

  function CheckChanges(AProperty: TdxBarUserDefine): Boolean;
  begin
    Result := True;
    if (AProperty in FUserDefine) and not(AProperty in Value) then
      ExcludeProperty(AProperty)
    else
      if not(AProperty in FUserDefine) and (AProperty in Value) then
        Include(FUserDefine, AProperty)
      else
        Result := False;
  end;

  procedure PropertyChanged(AProperty: TdxBarUserDefine);
  begin
    if Control <> nil then
      case AProperty of
        udCaption: Control.CaptionChanged;
        udGlyph: Control.GlyphChanged;
        udPaintStyle: Control.PaintStyleChanged;
        udWidth: Control.WidthChanged;
      end;
  end;

var
  AProperty: TdxBarUserDefine;
begin
  if FUserDefine <> Value then
  begin
    for AProperty := Low(TdxBarUserDefine) to High(TdxBarUserDefine) do
      if CheckChanges(AProperty) then
        PropertyChanged(AProperty);

    Changed(False); //#DG
  end;
end;

procedure TdxBarItemLink.SetUserCaption(const Value: string);
begin
  if FUserCaption <> Value then
  begin
    FUserCaption := Value;
    ForceSetUserDefine(udCaption);
  end;
end;

procedure TdxBarItemLink.SetUserGlyph(Value: TBitmap);
begin
  if FUserGlyph <> Value then
  begin
    FUserGlyph.Assign(Value);
    ForceSetUserDefine(udGlyph);
  end;
end;

procedure TdxBarItemLink.SetUserPaintStyle(Value: TdxBarPaintStyle);
begin
  if PaintStyle <> Value then
  begin
    FUserPaintStyle := Value;
    ForceSetUserDefine(udPaintStyle);
  end;
end;

procedure TdxBarItemLink.SetUserWidth(Value: Integer);
begin
  if Width <> Value then
  begin
    FUserWidth := Value;
    ForceSetUserDefine(udWidth);
  end;
end;

procedure TdxBarItemLink.SetViewLevels(Value: TdxBarItemViewLevels);
begin
  if Value <> FViewLevels then
  begin
    FViewLevels := Value;
    Changed(True);
  end;
end;

procedure TdxBarItemLink.SetVisible(Value: Boolean);
begin
  if BarManager.IsLoading or Owner.FAssigning then
  begin
    FLoadedVisible := Value;
    Exit;
  end;
  if FVisible <> Value then
  begin
    FVisible := Value;
    if not BarManager.Designing then
      VisibleChanged;
    Changed(False); //#DG
//#DG    ItemLinkChanged;
  end;
end;

procedure TdxBarItemLink.WriteItemName(AWriter: TWriter);
begin
  if Item <> nil then
    AWriter.WriteString(Item.Name)
  else
    AWriter.WriteString('');
end;

procedure TdxBarItemLink.AddToRecentList;
begin
  Owner.FRecentItems.Add(Self);
end;

procedure TdxBarItemLink.RemoveFromRecentList;
begin
  with Owner do
    if FRecentItems <> nil then FRecentItems.Remove(Self);
end;

procedure TdxBarItemLink.RestoreRecentIndex;
begin
  RecentIndex := FPrevRecentIndex;
end;

procedure TdxBarItemLink.SaveRecentIndex;
begin
  FPrevRecentIndex := RecentIndex;
end;

procedure TdxBarItemLink.InternalBringToTopInRecentList(IncCount: Boolean);
begin
  if (Owner <> nil) and not Owner.CanUseRecentItems then Exit;
  RecentIndex := 0;
  if IncCount then Inc(FUseCount);
end;

function TdxBarItemLink.IsPrimaryForDistribution: Boolean;
begin
  Result := Owner.FPrimaryForDistributionItems.IndexOf(Self) <> -1;
end;

procedure TdxBarItemLink.Synchronize(AItemLink: TdxBarItemLink);
begin
  FUseCount := AItemLink.FUseCount;
  RecentIndex := AItemLink.RecentIndex;
end;

procedure TdxBarItemLink.CheckMostRecentlyUsed;
begin
  if MostRecentlyUsed then
  begin
    FUseCount := BarManager.FMostRecentlyUsedUseCount;
    BringToTopInRecentList(False);
  end
  else
  begin
    FUseCount := 0;
    SendToBottomInRecentList;
  end
end;

function TdxBarItemLink.GetRecentIndex: Integer;
begin
  Result := Owner.FRecentItems.IndexOf(Self);
end;

procedure TdxBarItemLink.SetRecentIndex(Value: Integer);
begin
  if Owner = nil then
    FPrevRecentIndex := Value
  else
    with Owner, FRecentItems do
    begin
      if Value >= Count then Value := Count - 1;
      Move(IndexOf(Self), Value);
      RefreshVisibilityLists;
    end;
end;

function TdxBarItemLink.CanVisible: Boolean;
begin
  Result := Item.ActuallyVisible and Visible;
end;

function TdxBarItemLink.GetItem: TdxBarItem;
begin
  if (Owner <> nil) and (Owner.Owner <> nil) and (FLoadedItemName <> '') and
    IsAncestorComponentDifferencesDetection(Owner.Owner) then
      Result := BarManager.GetItemByName(FLoadedItemName)
  else
    Result := FItem;
end;

function TdxBarItemLink.GetRealItemLink: TdxBarItemLink;
begin
  if FOriginalItemLink <> nil then
    Result := FOriginalItemLink
  else
    Result := Self
end;

procedure TdxBarItemLink.OnUserGlyphChanged(Sender: TObject);
begin
  UserGlyphChanged;
end;

procedure TdxBarItemLink.DefineProperties(Filer: TFiler);

  function NeedWriteItemName: Boolean;
  var
    AAncestorItem: TdxBarItem;
  begin
    if Filer.Ancestor is TdxBarItemLink then
    begin
      AAncestorItem := TdxBarItemLink(Filer.Ancestor).Item;
      Result := (AAncestorItem = nil) and (Item <> nil) or
        (AAncestorItem <> nil) and (Item = nil) or
        (AAncestorItem <> nil) and (AAncestorItem.Name <> Item.Name);
    end
    else
      Result := Item <> nil;
  end;

begin
  inherited DefineProperties(Filer);
  Filer.DefineProperty('ItemName', ReadItemName, WriteItemName, NeedWriteItemName);
end;

procedure TdxBarItemLink.LoadItemName;
begin
  if FLoadedItemName <> '' then
  begin
    Item := BarManager.GetItemByName(FLoadedItemName);
    FLoadedItemName := '';
  end;
end;

class function TdxBarItemLink.GetIniSection(const ABaseSection: string; ALinkIndex: Integer;
  AStoringKind: TdxBarStoringKind): string;
begin
  Result := ABaseSection + GetSectionDelimiter(AStoringKind) + 'ItemLink' + IntToStr(ALinkIndex);
end;

procedure TdxBarItemLink.LoadFromIni(ASource: TCustomIniFile; const ABaseSection: string;
  ALinkIndex: Integer; AStoringKind: TdxBarStoringKind);

{$IFNDEF DELPHI6}
  function ReadBinaryStream(const ASection, AName: string; AValue: TMemoryStream): Integer;
  var
    Info: TRegDataInfo;
    Text: string;
    Pos: Integer;
  begin
    Result := 0;
    case AStoringKind of
      skReg:
        with TRegistryIniFile(ASource) do
          if RegIniFile.OpenKey(ASection, False) then
          try
            if RegIniFile.ValueExists(AName) then
            begin
              if RegIniFile.GetDataInfo(AName, Info) then
              begin
                if (Info.RegData = rdBinary) or (Info.RegData = rdUnknown) then
                begin
                  AValue.Size := AValue.Position + Info.DataSize;
                  Result := RegIniFile.ReadBinaryData(AName, Pointer(Integer(AValue.Memory) + AValue.Position)^, AValue.Size);
                end;
              end;
            end;
          finally
            RegIniFile.CloseKey;
          end;
      skIni:
        with ASource do
        begin
          Text := ReadString(ASection, AName, '');
          if Text <> '' then
          begin
            Pos := AValue.Position;
            AValue.SetSize(AValue.Size + Length(Text) div 2);
            HexToBin(PChar(Text), PChar(Integer(AValue.Memory) + AValue.Position), Length(Text) div 2);
            AValue.Position := Pos;
            Result := AValue.Size - Pos;
          end
        end;
    end;
  end;
{$ENDIF}

var
  ASection, S: string;
  AStream: TMemoryStream;
  AViewLevels: TdxBarItemViewLevels;
begin
  ASection := GetIniSection(ABaseSection, ALinkIndex, AStoringKind);
  if ASource.ReadString(ASection, 'ItemName', '') = '' then Exit;
  Item := BarManager.GetItemByName(ASource.ReadString(ASection, 'ItemName', ''));
  if Item = nil then
    Free
  else
    with ASource do
    begin
      AStream := TMemoryStream.Create;
      try
        BeginGroup := ReadBool(ASection, 'BeginGroup', False);
        if AStoringKind = skIni then
          S := ReadString(ASection, 'UserDefine', '')
        else
          S := '';
        if Length(S) = 1 then
          FUserDefine := TdxBarUserDefines(Byte(StrToInt(S))) // for compatibility with Bars 5
        else
          if ReadBinaryStream(ASection, 'UserDefine', AStream) <> 0 then
          begin
            AStream.Read(FUserDefine, SizeOf(TdxBarUserDefines));
            AStream.Position := 0;
          end;
        if udCaption in UserDefine then
          UserCaption := ReadString(ASection, 'UserCaption', '');
        if udPaintStyle in UserDefine then
          UserPaintStyle := TdxBarPaintStyle(ReadInteger(ASection, 'UserPaintStyle', 0));
        if udWidth in UserDefine then
          UserWidth := ReadInteger(ASection, 'UserWidth', 100);
        // don't load UserGlyph for IniFile
        if (AStoringKind = skReg) and (udGlyph in UserDefine) then
        begin
          if ReadBinaryStream(ASection, 'UserGlyph', AStream) <> 0 then
          begin
            UserGlyph.LoadFromStream(AStream);
            AStream.Position := 0;
          end;
        end;
        if Collection.Owner is TdxBar then
        begin
          ButtonGroup := TdxBarButtonGroupPosition(ReadInteger(ASection, 'ButtonGroup', Integer(bgpNone)));
          Position := TdxBarItemPosition(ReadInteger(ASection, 'Position', Integer(dxBarItemDefaultPosition)));
          if ReadBinaryStream(ASection, 'ViewLevels', AStream) <> 0 then
          begin
            AStream.Read(AViewLevels, SizeOf(TdxBarItemViewLevels));
            AStream.Position := 0;
            ViewLevels := AViewLevels;
          end;
          FLoadedVisible := ReadBool(ASection, 'Visible', True);
        end;
        if BarManager.CanShowRecentItems and TdxBarItemLinks(Collection).FUseRecentItems then
        begin
          FLoadedUseCount := ReadInteger(ASection, 'UseCount', 0);
          FLoadedRecentIndex := ReadInteger(ASection, 'RecentIndex', -1);
        end;
      finally
        AStream.Free;
      end;
    end;
end;

procedure TdxBarItemLink.LoadUsageData(ASource: TCustomIniFile; ABaseSection: string;
  ALinkIndex: Integer);
begin
  FMostRecentlyUsed := ASource.ReadBool(
    GetIniSection(ABaseSection, ALinkIndex, skIni), 'MostRecentlyUsed', True);
end;

procedure TdxBarItemLink.SaveToIni(ADestination: TCustomIniFile; const ABaseSection: string;
  ALinkIndex: Integer; AStoringKind: TdxBarStoringKind);

{$IFNDEF DELPHI6}
  procedure WriteBinaryStream(const Section, Name: string; AValue: TMemoryStream);
  var
    Text: string;
  begin
    case AStoringKind of
      skReg:
        with TRegistryIniFile(ADestination) do
          with RegIniFile do
          begin
            if OpenKey(Section, True) then
            try
              WriteBinaryData(Name, Pointer(Integer(AValue.Memory) + AValue.Position)^,
                AValue.Size - AValue.Position);
            finally
              CloseKey;
            end;
          end;
      skIni:
        with ADestination do
        begin
          SetLength(Text, (AValue.Size - AValue.Position) * 2);
          if Length(Text) > 0 then
            BinToHex(PChar(Integer(AValue.Memory) + AValue.Position), PChar(Text), AValue.Size - AValue.Position);
          WriteString(Section, Name, Text);
        end;
    end;
  end;
{$ENDIF}

var
  AStream: TMemoryStream;
  ASection: string;
begin
  with ADestination do
  begin
    ASection := GetIniSection(ABaseSection, ALinkIndex, AStoringKind);
    AStream := TMemoryStream.Create;
    try
      WriteString(ASection, 'ItemName', Item.Name);
      WriteBool(ASection, 'BeginGroup', FBeginGroup); // BeginGroup is complex
      AStream.SetSize(SizeOf(TdxBarUserDefines));
      AStream.Write(FUserDefine, SizeOf(TdxBarUserDefines));
      AStream.Position := 0;
      WriteBinaryStream(ASection, 'UserDefine', AStream);
      if udCaption in UserDefine then
        WriteString(ASection, 'UserCaption', UserCaption);
      if udPaintStyle in UserDefine then
        WriteInteger(ASection, 'UserPaintStyle', Ord(UserPaintStyle));
      if udWidth in UserDefine then
        WriteInteger(ASection, 'UserWidth', UserWidth);
      // don't save UserGlyph to IniFile
      if (AStoringKind = skReg) and (udGlyph in UserDefine) then
      begin
        UserGlyph.SaveToStream(AStream);
        AStream.Position := 0;
        WriteBinaryStream(ASection, 'UserGlyph', AStream);
      end;
      if Collection.Owner is TdxBar then
      begin
        WriteInteger(ASection, 'ButtonGroup', Ord(ButtonGroup));
        WriteInteger(ASection, 'Position', Ord(Position));
        AStream.SetSize(SizeOf(TdxBarItemViewLevels));
        AStream.Write(ViewLevels, SizeOf(TdxBarItemViewLevels));
        AStream.Position := 0;
        WriteBinaryStream(ASection, 'ViewLevels', AStream);
        WriteBool(ASection, 'Visible', Visible);
      end;
      if BarManager.CanShowRecentItems and TdxBarItemLinks(Collection).FUseRecentItems then
      begin
        WriteInteger(ASection, 'UseCount', FUseCount);
        WriteInteger(ASection, 'RecentIndex', RecentIndex);
      end;
      if BarManager.IsStateSaving then
        WriteBool(ASection, 'MostRecentlyUsed', MostRecentlyUsed);
    finally
      AStream.Free;
    end;
  end;
end;

procedure TdxBarItemLink.InitiateAction;
begin
  if (Item <> nil) and (Item.ActionLink <> nil) then Item.ActionLink.Update;
end;

function TdxBarItemLink.CanChangePaintStyle: Boolean;
begin
  Result := Item.CanChangePaintStyle;
end;

function TdxBarItemLink.HasItem(AItem: TdxBarItem): Boolean;
begin
  Result := FItem = AItem;
  if not Result and (FItem is TCustomdxBarSubItem) then
    Result := TCustomdxBarSubItem(FItem).ItemLinks.HasItem(AItem);
end;

function TdxBarItemLink.IsReferencedBy(ALinksOwner: IdxBarLinksOwner): Boolean;
var
  ASelfLinksOwner: IdxBarLinksOwner;
begin
  ASelfLinksOwner := GetLinksOwner(FItem);
  Result := (ASelfLinksOwner <> nil) and
    ((ASelfLinksOwner = ALinksOwner) or
      (ASelfLinksOwner.GetItemLinks <> nil) and (ASelfLinksOwner.GetItemLinks.IsReferencedBy(ALinksOwner)));
end;

function TdxBarItemLink.IsAccel(Key: Word; Shift: TShiftState): Boolean;
var
  Accel: Char;
  VK: SHORT;
  AShift: TShiftState;

  function GetAccel(S: string): Char;
  var
    APos: Integer;
  begin
    APos := GetAccelPos(S);
    if APos = 0 then
      Result := #0
    else
    begin
      Result := AnsiLowerCase(S[APos])[1];
      if Result <> S[APos] then
        Shift := Shift - [ssShift];
    end;
  end;

begin
  Accel := GetAccel(Caption);
  if Accel = #0 then
    Result := False
  else
    if dxCharInSet(Accel, ['0'..'9']) and (Key = Ord(Accel)) and (Shift = []) then
      Result := True
    else
    begin
      VK := VkKeyScan(Accel);
      if Lo(VK) = Key then
      begin
        VK := Hi(VK);
        AShift := [];
        if VK and 1 = 1 then Include(AShift, ssShift);
        if VK and 2 = 2 then Include(AShift, ssCtrl);
        Result := AShift = Shift;
      end
      else
        Result := False;
    end;
end;

procedure TdxBarItemLink.MoveBeginGroupItemIfNeeded;
var
  ANextItemLink: TdxBarItemLink;
begin
  if (Item <> nil) and
     (CanVisibleIndex < Owner.CanVisibleItemCount - 1) and
     ((CanVisibleIndex = 0) and Owner.CanVisibleItems[CanVisibleIndex + 1].BeginGroup or
       BeginGroup and not Owner.CanVisibleItems[CanVisibleIndex + 1].BeginGroup) then
  begin
    ANextItemLink := Owner.CanVisibleItems[CanVisibleIndex + 1];
    ANextItemLink.BeginGroup := not ANextItemLink.BeginGroup;
  end;
end;

function TdxBarItemLink.ScreenToClient(const AScreenPos: TPoint): TPoint;
begin
  Result := AScreenPos;
  Windows.ScreenToClient(BarControl.Handle, Result);
  Dec(Result.X, ItemRect.Left);
  Dec(Result.Y, ItemRect.Top);
end;

procedure TdxBarItemLink.UserGlyphChanged;
begin
  if Control <> nil then
    Control.GlyphChanged;
end;

procedure TdxBarItemLink.VisibleChanged;
begin
  Owner.RefreshVisibilityLists;
  if CanVisible then
  begin
    BringToTopInRecentList(False);
    if BarControl <> nil then
    begin
      CreateControl;
      Control.VisibleChanged;
    end;
  end
  else
  begin
    SendToBottomInRecentList;
    if Control <> nil then
    begin
      Control.VisibleChanged;
      DestroyControl;
    end;
  end;
end;

function TdxBarItemLink.CanDelete(ADestruction: Boolean = False): Boolean;
begin
  Result := True;
end;

procedure TdxBarItemLink.DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean);
begin
  if CanDelete(ADestruction) then
  begin
    AReference := nil;
    Free;
  end;
end;

procedure TdxBarItemLink.ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction);
begin
  case ABasicAction of
    caReset:
      UserDefine := [];
    caChangeCaption:
      Item.Caption := BarDesignController.CustomizingItemLink.Caption;
    caChangeButtonPaintStyle:
      UserPaintStyle := BarDesignController.CustomizingItemLink.UserPaintStyle;
    caChangePosition:
      Position := BarDesignController.CustomizingItemLink.Position;
    caChangeViewLevels:
      ViewLevels := BarDesignController.CustomizingItemLink.ViewLevels;
    caChangeButtonGroup:
      ButtonGroup := BarDesignController.CustomizingItemLink.ButtonGroup;
    caChangeDistributed:
      Distributed := BarDesignController.CustomizingItemLink.Distributed;
    caChangeBeginGroup:
      BeginGroup := BarDesignController.CustomizingItemLink.BeginGroup;
    caChangeVisible:
      Visible := BarDesignController.CustomizingItemLink.Visible;
    caChangeRecentList:
      MostRecentlyUsed := BarDesignController.CustomizingItemLink.MostRecentlyUsed;
  end;
end;

function TdxBarItemLink.GetBarManager: TdxBarManager;
begin
  Result := Owner.BarManager;
end;

function TdxBarItemLink.GetInstance: TPersistent;
begin
  Result := Self;
end;

procedure TdxBarItemLink.GetMasterObjects(AList: TdxObjectList);
begin
  AList.Add(BarControl.GetSelectableObject);
  AList.Add(FItem);
end;

function TdxBarItemLink.GetNextSelectableItem: IdxBarSelectableItem;
begin
  Result := GetNext;
end;

function TdxBarItemLink.GetSelectableParent: TPersistent;
begin
  if BarControl <> nil then
    Result := BarControl.GetSelectableObject
  else
    Result := nil;
end;

function TdxBarItemLink.GetSelectionStatus: TdxBarSelectionStatus;
begin
  Result := BarManager.GetSelectionStatus(Self);
end;

function TdxBarItemLink.GetSupportedActions: TdxBarCustomizationActions;
begin
  Result := Item.GetSupportedActions;
end;

procedure TdxBarItemLink.Invalidate;
begin
  RepaintItemControl(Control);
end;

function TdxBarItemLink.IsComplex: Boolean;
begin
  Result := False;
end;

function TdxBarItemLink.IsComponentSelected: Boolean;
begin
  Result := BarManager.IsComponentSelected(Self) or BarManager.IsComponentSelected(Item);
end;

procedure TdxBarItemLink.SelectComponent(ASelectionOperation: TdxBarSelectionOperation = soExclusive);
begin
  if ASelectionOperation = soExclude then
    BarManager.SelectComponent(Self, ASelectionOperation);
  BarManager.SelectComponent(Item, ASelectionOperation);
end;

function TdxBarItemLink.SelectParentComponent: Boolean;
begin
  Result := True;
  BarManager.InternalSetSelectedItem(nil); // otherwise HideAll will be executed
  BarControl.SetKeySelectedItem(nil);
  BarDesignController.SelectObject(GetSelectableParent);
end;

procedure TdxBarItemLink.SelectionChanged;
begin
  Item.SelectionChanged;
end;

procedure TdxBarItemLink.Assign(Source: TPersistent);

  function IsInheritanceUpdating: Boolean;
  begin
    //#DG TODO: LinksOwner
    Result := (csUpdating in BarManager.ComponentState) or
      ((Owner.Owner is TdxBarCustomPopupMenu) or (Owner.Owner is TCustomdxBarSubItem) or (Owner.Owner is TdxBar)) and
      (csUpdating in TComponent(Owner.Owner).ComponentState);
  end;

var
  Link: TdxBarItemLink;
begin
  if Source is TdxBarItemLink then
  begin
    Link := TdxBarItemLink(Source);
    Data := Link.Data;
    FUserCaption := Link.FUserCaption;
    FUserGlyph.Assign(Link.FUserGlyph);
    FUserPaintStyle := Link.FUserPaintStyle;
    FUserWidth := Link.FUserWidth;
    if ResettingToolbar then
      Item := TdxBarItem(BarManager.Owner.FindComponent(Link.Item.Name))
    else
    begin
      if Assigned(Link.Item) and IsInheritanceUpdating then
        Item := BarManager.GetItemByName(Link.Item.Name)
      else
        Item := Link.Item;
    end;
    UserDefine := Link.UserDefine;
    BeginGroup := Link.BeginGroup;
    ButtonGroup := Link.ButtonGroup;
    Distributed := Link.Distributed;
    Position := Link.Position;
    ViewLevels := Link.ViewLevels;
    Visible := Link.Visible;
    // do not assign MostRecentlyUsed property
    FCreatedFromMergingWith := FMergingWith;
  end
  else inherited Assign(Source);
end;

procedure TdxBarItemLink.BringToTopInRecentList(IncCount: Boolean);
var
  PrevVisibleIndex: Integer;
  AParentItem: TdxBarItem;
begin
  if not CanVisible then Exit;

  PrevVisibleIndex := VisibleIndex;
  InternalBringToTopInRecentList(IncCount);
  if CanVisibleIndex > -1 then
  begin
    if (PrevVisibleIndex = -1) and (BarControl <> nil) then
      BarControl.LayoutChanged;

    AParentItem := nil;
    with Owner do
      if Owner is TCustomdxBarSubItem then
        AParentItem := TCustomdxBarSubItem(Owner)
      else
        if Owner is TdxBarCustomPopupMenu then
          if (BarControl <> nil) and (TdxBarSubMenuControl(BarControl).FDropDownButton <> nil) then
            AParentItem := TdxBarSubMenuControl(BarControl).FDropDownButton.Item;
    if AParentItem <> nil then
      with AParentItem do
        if (CurItemLink <> nil) and (CurItemLink.RealItemLink <> nil) then
          CurItemLink.RealItemLink.BringToTopInRecentList(IncCount);
  end;
end;

procedure TdxBarItemLink.CreateControl;
begin
  if (FControl = nil) and (Item <> nil) and
//#DG    (BarControl <> nil) and not BarControl.FDestroyFlag then
    (BarControl <> nil) and not BarControl.IsDestroying then
      FControl := Item.GetControlClass(BarControl.IsVertical).Create(Self);
end;

procedure TdxBarItemLink.DestroyControl;
begin
  FreeAndNil(FControl);
end;

procedure TdxBarItemLink.RecreateControl;
begin
  if not BarManager.IsUpdateLocked then
  begin
    DestroyControl;
    CreateControl;
  end;
end;

procedure TdxBarItemLink.SendToBottomInRecentList;
var
  PrevVisibleIndex: Integer;
begin
  PrevVisibleIndex := VisibleIndex;
  RecentIndex := Owner.FRecentItems.Count - 1;
  if (PrevVisibleIndex > -1) and (BarControl <> nil) then
    BarControl.LayoutChanged;
end;

{ TdxBarItemLinks }

constructor TdxBarItemLinks.Create(ABarManager: TdxBarManager; ALinksOwner: IdxBarLinksOwner);
begin
  inherited Create(TdxBarItemLink);
  FBarManager := ABarManager;
  FLinksOwner := ALinksOwner;
  FAvailableItems := TList.Create;
  FCanVisibleItems := TList.Create;
  FVisibleItems := TList.Create;
  FRecentItems := TList.Create;
  FRecentItemCount := -1;
  FUseRecentItems := True;
  FItemOptions := TdxBarItemOptions.Create(Self);
  FPrimaryForDistributionItems := TList.Create;
end;

destructor TdxBarItemLinks.Destroy;
begin
  FreeAndNil(FPrimaryForDistributionItems);
  FreeAndNil(FItemOptions);
  if (FBarControl <> nil) and not FBarControl.IsDestroying then
    FreeAndNil(FBarControl);
  FreeAndNil(FRecentItems);
  FreeAndNil(FVisibleItems);
  FreeAndNil(FCanVisibleItems);
  FreeAndNil(FAvailableItems);
  inherited;
end;

procedure TdxBarItemLinks.DesignerModified;
begin
  if Owner is TdxBarCustomPopupMenu then
    TdxBarCustomPopupMenu(Owner).OwnerDesignerModified
  else
    BarManager.DesignerModified;
end;

function TdxBarItemLinks.GetAvailableItem(Index: Integer): TdxBarItemLink;
begin
  Result := TdxBarItemLink(FAvailableItems[Index]);
end;

function TdxBarItemLinks.GetAvailableItemCount: Integer;
begin
  Result := FAvailableItems.Count;
end;

function TdxBarItemLinks.GetCanVisibleItem(Index: Integer): TdxBarItemLink;
begin
  Result := TdxBarItemLink(FCanVisibleItems[Index]);
end;

function TdxBarItemLinks.GetCanVisibleItemCount: Integer;
begin
  Result := FCanVisibleItems.Count;
end;

function TdxBarItemLinks.GetIndexByItemName(const AItemName: string): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := 0 to Count - 1 do
    if Items[I].Item.Name = AItemName then
    begin
      Result := I;
      Break;
    end;
end;

function TdxBarItemLinks.GetItem(Index: Integer): TdxBarItemLink;
begin
  Result := TdxBarItemLink(inherited Items[Index]);
end;

function TdxBarItemLinks.GetMostRecentItemCount: Integer;
var
  AMinCount, AMaxCount, I, Level: Integer;
begin
  if CanUseRecentItems then
  begin
    AMinCount := MaxInt;
    AMaxCount := 0;
    for I := 0 to CanVisibleItemCount - 1 do
    begin
      AMinCount := Min(AMinCount, CanVisibleItems[I].FUseCount);
      AMaxCount := Max(AMaxCount, CanVisibleItems[I].FUseCount);
    end;
    Level := AMinCount +
      MulDiv(AMaxCount - AMinCount, 100 - BarManager.MostRecentItemsPercents, 100);
    Result := 0;
    for I := CanVisibleItemCount - 1 downto 0 do
      with TdxBarItemLink(FRecentItems[I]) do
        if (FUseCount >= Level) and (Owner = Self) then
        begin
          Result := I + 1;
          Break;
        end;
    if Result = CanVisibleItemCount then Result := -1;
  end
  else
    Result := -1;
end;

function TdxBarItemLinks.GetParentLinks: TdxBarItemLinks;
begin
  if (BarControl <> nil) and (BarControl.ParentBar <> nil) then
    Result := BarControl.ParentBar.ItemLinks
  else
    Result := nil;
end;

function TdxBarItemLinks.GetRealVisibleItemCount: Integer;
var
  R, AItemRect, ResultR: TRect;
  I: Integer;
begin
  Result := VisibleItemCount;
  if not IsScrollable then
  begin
    R := BarControl.ClientRect;
    for I := 0 to Result - 1 do
    begin
      AItemRect := VisibleItems[I].ItemRect;
      IntersectRect(ResultR, R, AItemRect);
      if not EqualRect(AItemRect, ResultR) or IsRectEmpty(AItemRect) then
      begin
        Result := I;
        Break;
      end;
    end;
  end;
end;

function TdxBarItemLinks.GetItemShowDescriptions: Boolean;
begin
  Result := GetOptionsValue(ioShowDescriptions, Self);
end;

function TdxBarItemLinks.GetItemShowShortCuts: Boolean;
begin
  Result := GetOptionsValue(ioShowShortCuts, Self);
end;

function TdxBarItemLinks.GetItemSize: TdxBarMenuItemSize;
begin
  Result := GetOptionsValue(ioSize, Self);
end;

function TdxBarItemLinks.GetVisibleItem(Index: Integer): TdxBarItemLink;
begin
  Result := TdxBarItemLink(FVisibleItems[Index]);
end;

function TdxBarItemLinks.GetVisibleItemCount: Integer;
begin
  Result := FVisibleItems.Count;
end;

procedure TdxBarItemLinks.SetItem(Index: Integer; Value: TdxBarItemLink);
begin
  Items[Index].Assign(Value);
end;

procedure TdxBarItemLinks.SetItemOptions(AValue: TdxBarItemOptions);
begin
  FItemOptions.Assign(AValue);
end;

procedure TdxBarItemLinks.SetRecentItemCount(Value: Integer);
begin
  FPrevRecentItemCount := FRecentItemCount;
  if not CanUseRecentItems then Value := -1;
  FRecentItemCount := Value;
  RefreshVisibilityLists;
end;

function VisibleItemsCompare(Item1, Item2: Pointer): Integer;
begin
  Result := TdxBarItemLink(Item1).CanVisibleIndex - TdxBarItemLink(Item2).CanVisibleIndex;
end;

function TdxBarItemLinks.IsUpdateLocked: Boolean;
begin
  Result := UpdateCount > 0;
end;

procedure TdxBarItemLinks.RefreshVisibilityLists;

  procedure InternalRefreshVisibilityLists;
  var
    AIsDesignTime: Boolean;
    I: Integer;
    AItemLink: TdxBarItemLink;
    AItem: TdxBarItem;
  begin
    if FAvailableItems = nil then
      Exit;
    FAvailableItems.Clear;
    FCanVisibleItems.Clear;
    FVisibleItems.Clear;
    AIsDesignTime := BarManager.Designing;
    for I := 0 to Count - 1 do
    begin
      AItemLink := Items[I];
      AItem := AItemLink.Item;
      if (AItem <> nil) and
        ({Item.AlwaysVisible or }AIsDesignTime or AItem.ActuallyVisible) then
      begin
        FAvailableItems.Add(AItemLink);
        if {Item.AlwaysVisible or }AIsDesignTime or AItemLink.Visible then
        begin
          FCanVisibleItems.Add(AItemLink);
          if {Item.AlwaysVisible or }AIsDesignTime or (RecentItemCount = -1) then
            FVisibleItems.Add(AItemLink);
        end;
      end;
    end;
    if not AIsDesignTime and (RecentItemCount > 0) then
    begin
      for I := 0 to FRecentItems.Count - 1 do
        if CanVisibleIndexOf(FRecentItems[I]) <> -1 then
        begin
          FVisibleItems.Add(FRecentItems[I]);
          if FVisibleItems.Count = RecentItemCount then Break;
        end;
      FVisibleItems.Sort(VisibleItemsCompare);
    end;
  end;

  procedure RefreshSeparatorsVisibility;

    function IsSeparator(ALink: TObject): Boolean;
    begin
      Result := TdxBarItemLink(ALink).Item is TdxBarSeparator;
    end;

    procedure HideSeparator(ALink: TdxBarItemLink);
    begin
      FCanVisibleItems.Remove(Alink);
      FVisibleItems.Remove(ALink);
    end;

  var
    I: Integer;
    APrevIsSeparator, ACurrentIsSeparator: Boolean;
  begin
    APrevIsSeparator := True;
    for I := FVisibleItems.Count - 1 downto 0 do
    begin
      ACurrentIsSeparator := IsSeparator(FVisibleItems[I]);
      if ACurrentIsSeparator and APrevIsSeparator then
        HideSeparator(FVisibleItems[I]);
      APrevIsSeparator := ACurrentIsSeparator;
    end;
  end;

begin
  InternalRefreshVisibilityLists;
  if not BarManager.IsCustomizing and not IsUpdateLocked then
    RefreshSeparatorsVisibility;
end;

procedure TdxBarItemLinks.RestoreRecentItemCount;
begin
  FRecentItemCount := FPrevRecentItemCount;
  RefreshVisibilityLists;
end;

procedure TdxBarItemLinks.Loaded(CheckVisible: Boolean);
var
  J, I: Integer;
begin
  for J := Count - 1 downto 0 do
    with Items[J] do
      if Item = nil then
        //Free
      else
        CheckMostRecentlyUsed;
  if CheckVisible then
    for J := Count - 1 downto 0 do
      with Items[J] do
        Visible := FLoadedVisible;
  for I := 0 to Count - 1 do
    for J := 0 to Count - 1 do
      with Items[J] do
        if FLoadedRecentIndex = I then
        begin
          FUseCount := FLoadedUseCount;
          RecentIndex := FLoadedRecentIndex;
          FLoadedRecentIndex := -1;
        end;
  if FBarControl <> nil then
    FBarControl.CreateControls;
end;

procedure TdxBarItemLinks.CheckVisibleIntegrity;
var
  I, J: Integer;
  ItemLink: TdxBarItemLink;
begin
  for I := 0 to FRecentItems.Count - 1 do
  begin
    ItemLink := TdxBarItemLink(FRecentItems[I]);
    if ItemLink.CanVisibleIndex = -1 then Break;
  end;
  for J := I + 1 to FRecentItems.Count - 1 do
  begin
    ItemLink := TdxBarItemLink(FRecentItems[J]);
    if ItemLink.CanVisibleIndex > -1 then
    begin
      ItemLink.RecentIndex := I;
      Inc(I);
    end;
  end;
end;

procedure TdxBarItemLinks.EmptyItemRects;
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
    SetRectEmpty(Items[I].FItemRect);
end;

function TdxBarItemLinks.CanUseRecentItems: Boolean;
begin
  Result := BarManager.CanShowRecentItems and FUseRecentItems and ((ParentLinks = nil) or (ParentLinks.CanUseRecentItems));
end;

procedure TdxBarItemLinks.InitiateActions;
var
  I: Integer;
begin
  for I := 0 to Count - 1 do Items[I].InitiateAction;
end;

function TdxBarItemLinks.IsShortCut(AShortCut: TShortCut): Boolean;
var
  I: Integer;
begin
  Result := False;
  if AShortCut = 0 then Exit;
  InitiateActions;
  for I := 0 to AvailableItemCount - 1 do
  begin
    Result := AvailableItems[I].Item.IsShortCut(AShortCut);
    if Result then Break;
  end;
end;

function TdxBarItemLinks.IsScrollable: Boolean;
begin
  Result := not (Owner is TdxBar);
end;

function TdxBarItemLinks.FindItemWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink;
begin
  AShift := AShift - [ssAlt];
  Result := DoFindItemWithAccel(AKey, AShift, ACurrentLink);
end;

function TdxBarItemLinks.First: TdxBarItemLink;
var
  I: Integer;
begin
  for I := 0 to RealVisibleItemCount - 1 do
  begin
    Result := VisibleItems[I];
    if Result.Control.CanSelect then Exit;
  end;
  Result := nil;
end;

function TdxBarItemLinks.Last: TdxBarItemLink;
var
  I: Integer;
begin
  for I := RealVisibleItemCount - 1 downto 0 do
  begin
    Result := VisibleItems[I];
    if Result.Control.CanSelect then Exit;
  end;
  Result := nil;
end;

function TdxBarItemLinks.Next(Current: TdxBarItemLink; AAnyone: Boolean = False): TdxBarItemLink;
var
  CurrentIndex, I, ACount: Integer;
begin
  if Current = nil then Result := First
  else
  begin
    CurrentIndex := Current.VisibleIndex;
    I := CurrentIndex;
    ACount := RealVisibleItemCount;
    repeat
      Inc(I);
      if I > ACount - 1 then I := 0;
      Result := VisibleItems[I];
      if AAnyone or Result.Control.CanSelect then Exit;
    until I = CurrentIndex;
    Result := nil;
  end;
end;

function TdxBarItemLinks.Prev(Current: TdxBarItemLink; AAnyone: Boolean = False): TdxBarItemLink;
var
  CurrentIndex, I: Integer;
begin
  if Current = nil then Result := Last
  else
  begin
    CurrentIndex := Current.VisibleIndex;
    I := CurrentIndex;
    repeat
      Dec(I);
      if I = -1 then I := RealVisibleItemCount - 1;
      Result := VisibleItems[I];
      if AAnyone or Result.Control.CanSelect then Exit;
    until I = CurrentIndex;
    Result := nil;
  end;
end;

procedure TdxBarItemLinks.CheckLinks(ASource: TCustomIniFile; const ABaseSection: string);
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
    Items[I].Item.CheckLinks(ASource, ABaseSection);
end;

procedure TdxBarItemLinks.LoadFromIni(ASource: TCustomIniFile; const ASection: string; AStoringKind: TdxBarStoringKind);
var
  I, ACount, ANewItemLinkCount: Integer;
begin
  BeginUpdate; //#DG
  try
    ANewItemLinkCount := 0;
    if (BarManager.FNewItems = nil) or (BarManager.FNewItems.Count = 0) then
      Clear
    else
      for I := Count - 1 downto 0 do
        if BarManager.FNewItems.IndexOf(Items[I].Item.Name) < 0 then
          Delete(I)
        else
        begin
          Items[I].FCreatedFromMergingWith := nil;
          Inc(ANewItemLinkCount);
          if I > 0 then
            Items[I].FPrevItemName := Items[I - 1].Item.Name;
        end;
    try
      ACount := ASource.ReadInteger(ASection, 'ItemLinkCount', 0);
      for I := ACount - 1 downto 0 do
        Insert(0).LoadFromIni(ASource, ASection, I, AStoringKind);
      for I := Count - ANewItemLinkCount to Count - 1 do
        if Items[I].FPrevItemName = '' then
          Move(I, 0)
        else
          if GetIndexByItemName(Items[I].FPrevItemName) > 0 then
            Move(I, GetIndexByItemName(Items[I].FPrevItemName) + 1);
      RefreshVisibilityLists;
    finally
      Loaded(True);
    end;
  finally
    EndUpdate;
  end;
end;

procedure TdxBarItemLinks.LoadUsageData(ASource: TCustomIniFile; ASection: string);
var
  ALinkCount, I: Integer;
begin
  // TODO search by unique ID, check merging
  ALinkCount := ASource.ReadInteger(ASection, 'ItemLinkCount', 0);
  for I := 0 to Count - 1 do
    if I < ALinkCount then
      Items[I].LoadUsageData(ASource, ASection, I);
  Loaded(False);
  CheckVisibleIntegrity;
end;

procedure TdxBarItemLinks.SaveToIni(ADestination: TCustomIniFile; const ASection: string; AStoringKind: TdxBarStoringKind);
var
  I, ACount: Integer;
begin
  ACount := 0;
  for I := 0 to Count - 1 do
    if (Items[I].Item <> nil) and (Items[I].Item.Name <> '') and (Items[I].FCreatedFromMergingWith = nil) then
    begin
      Items[I].SaveToIni(ADestination, ASection, ACount, AStoringKind);
      Inc(ACount);
    end;
  ADestination.WriteInteger(ASection, 'ItemLinkCount', ACount);
end;

procedure TdxBarItemLinks.Merge(AItemLinks: TdxBarItemLinks);

  procedure CheckMergeOperationParameters(AMergingLink: TdxBarItemLink;
    var AKind: TdxBarItemMergeKind; var ALinkIndex: Integer);
  begin
    if ALinkIndex < 0 then
      AKind := mkNone;
    if (AKind = mkMergeByCaption) and ((ALinkIndex >= Count) or
      not Items[ALinkIndex].Item.CanMergeWith(AMergingLink.Item)) then
        AKind := mkNone;
    if (AKind = mkAdd) and (ALinkIndex > Count) then
      AKind := mkNone;
  end;

  procedure GetMergeOperationParameters(AMergingLink: TdxBarItemLink;
    out AKind: TdxBarItemMergeKind; out ALinkIndex: Integer);
  var
    AItem: TdxBarItem;
    I: Integer;
  begin
    ALinkIndex := -1;
    AKind := AMergingLink.Item.MergeKind;
    if AKind <> mkNone then
    begin
      if AMergingLink.Item.MergeKind = mkMergeByCaption then
        for I := 0 to Count - 1 do
          if (Items[I].Item.MergeKind = mkMergeByCaption) and
            (Items[I].Caption = AMergingLink.Caption) and // TODO Accel chars
            Items[I].Item.CanMergeWith(AMergingLink.Item) then
              ALinkIndex := I;
      if ALinkIndex <> -1 then
        AKind := mkMergeByCaption
      else
      begin
        for I := 0 to Count - 1 do
        begin
          AItem := Items[I].Item;
          if AItem.MergeOrder <= AMergingLink.Item.MergeOrder then
            if (ALinkIndex = -1) or (AItem.MergeOrder >= Items[ALinkIndex].Item.MergeOrder) then
              ALinkIndex := I;
        end;
        Inc(ALinkIndex);
        AKind := mkAdd;
      end;
    end;
    BarManager.DoMergeItemLink(Self, AItemLinks, AMergingLink, AKind, ALinkIndex);
    CheckMergeOperationParameters(AMergingLink, AKind, ALinkIndex);
  end;

var
  AItemLink: TdxBarItemLink;
  AMergeKind: TdxBarItemMergeKind;
  AMergeLinkIndex, I: Integer;
begin
  for I := 0 to AItemLinks.Count - 1 do
  begin
    GetMergeOperationParameters(AItemLinks[I], AMergeKind, AMergeLinkIndex);
    if AMergeKind = mkMergeByCaption then
      Items[AMergeLinkIndex].Item.GetItemLinks.Merge(
        AItemLinks[I].Item.GetItemLinks)
    else
      if AMergeKind = mkAdd then
      begin
        AItemLink := Insert(AMergeLinkIndex);
        AItemLink.Assign(AItemLinks[I]);
      end;
  end;
end;

procedure TdxBarItemLinks.Unmerge(ABar: TdxBar);
var
  AItemLink: TdxBarItemLink;
  I: Integer;
begin
  for I := Count - 1 downto 0 do
  begin
    AItemLink := Items[I];
    if (AItemLink.FCreatedFromMergingWith <> nil) and
      ((ABar = nil) or (AItemLink.FCreatedFromMergingWith = ABar)) then
        AItemLink.Free
    else
      if AItemLink.Item.GetItemLinks <> nil then
        AItemLink.Item.GetItemLinks.Unmerge(ABar);
  end;
end;

function TdxBarItemLinks.AddItem(AItemClass: TdxBarItemClass; AOwner: TComponent): TdxBarItemLink;
begin
  Result := Add;
  try
    if AOwner = nil then
      AOwner := BarManager;
    Result.Item := AItemClass.Create(AOwner);
  except
    Result.Item.Free;
    Result.Item := nil;
    raise;
  end;
end;

function TdxBarItemLinks.GetOwner: TPersistent;
begin
  Result := GetOwnerComponent;
end;

function TdxBarItemLinks.GetOwnerComponent: TComponent;
begin
  if FLinksOwner <> nil then
    Result := FLinksOwner.GetInstance
  else
    Result := nil;
end;

procedure TdxBarItemLinks.LoadItemNames;
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
    Items[I].LoadItemName;
  Loaded(True);
end;

procedure TdxBarItemLinks.Update(Item: TCollectionItem);
begin
{ #DG
  if (Owner is TComponent) and not (Owner is TdxBar) and
    (csDestroying in TComponent(Owner).ComponentState) then
    Exit;
}
  if Item = nil then
    RefreshVisibilityLists;
  if csDestroying in Owner.ComponentState then
    Exit;

  inherited Update(Item);
  if not Internal then
    DesignerModified; //#DG
  if Item <> nil then
    BarManager.DoItemLinkChange(TdxBarItemLink(Item))
  else
  begin
    if (BarControl <> nil) and BarControl.Enabled then // #DG Enabled - why???
      BarControl.RepaintBar;
    CallNotify(OnChange, Self);
  end;
end;

function TdxBarItemLinks.GetDefaultValue(AOption: TdxBarItemOptionValue): Variant;
begin
  case AOption of
    ioShowDescriptions: Result := False;
    ioShowShortCuts: Result := True;
  else {ioSize}
    Result := misNormal;
  end;
end;

function TdxBarItemLinks.GetOptionsValue(AOption: TdxBarItemOptionValue; AItemLinks: TdxBarItemLinks): Variant;
begin
  if not ItemOptions.IsValueStored(AOption) and (GetParentLinks <> nil) then
    Result := GetParentLinks.GetOptionsValue(AOption, AItemLinks)
  else
    Result := ItemOptions.GetValue(AOption);
end;

function TdxBarItemLinks.Add: TdxBarItemLink;
begin
  Result := TdxBarItemLink(inherited Add);
end;

function TdxBarItemLinks.Add(AItem: TdxBarItem): TdxBarItemLink;
begin
  BeginUpdate;
  try
    Result := Add;
    Result.Item := AItem;
  finally
    EndUpdate;
  end;
end;

function TdxBarItemLinks.AddItem(AItemClass: TdxBarItemClass): TdxBarItemLink;
begin
  Result := Add(BarManager.AddItem(AItemClass));
end;

function TdxBarItemLinks.AddButton: TdxBarItemLink;
begin
  Result := Add(BarManager.AddButton);
end;

function TdxBarItemLinks.AddSubItem: TdxBarItemLink;
begin
  Result := Add(BarManager.AddSubItem);
end;

procedure TdxBarItemLinks.Assign(Source: TPersistent);
var
  ContainsMDISystemMenu: Boolean;
  SystemMenuSubItem: TSystemMenuSubItem;
  I: Integer;
begin
  ContainsMDISystemMenu :=
    (Count <> 0) and (Items[0].Item is TSystemMenuSubItem);
  if ContainsMDISystemMenu then
    SystemMenuSubItem := TSystemMenuSubItem(Items[0].Item)
  else
    SystemMenuSubItem := nil;
  FAssigning := True;
  try
    inherited Assign(Source);
  finally
    FAssigning := False;
    for I := 0 to Count - 1 do
      with Items[I] do
        Visible := FLoadedVisible;
    if ContainsMDISystemMenu then
      with Add do
      begin
        Item := SystemMenuSubItem;
        Index := 0;
      end;
  end;
end;

function TdxBarItemLinks.AvailableIndexOf(Value: TdxBarItemLink): Integer;
begin
  Result := FAvailableItems.IndexOf(Value);
end;

function TdxBarItemLinks.CanContainItem(AItem: TdxBarItem;
  out AErrorText: string): Boolean;
begin
  Result := FLinksOwner.CanContainItem(AItem, AErrorText);
end;

function TdxBarItemLinks.CanVisibleIndexOf(Value: TdxBarItemLink): Integer;
begin
  Result := FCanVisibleItems.IndexOf(Value);
end;

procedure TdxBarItemLinks.CreateBarControl;
begin
  FBarControl := FLinksOwner.CreateBarControl;
  FBarControl.ItemLinks := Self;
end;

procedure TdxBarItemLinks.DestroyBarControl;
begin
  FreeAndNil(FBarControl);
end;

procedure TdxBarItemLinks.FreeForeignItems(ForeignBarManager: TdxBarManager);
var
  I: Integer;
begin
  if Owner is TdxBar then
    TdxBar(Owner).BarManager.BeginUpdate;
  for I := 0 to Count - 1 do
    if (ForeignBarManager <> nil) and (Items[I].BarManager = ForeignBarManager) or
      (ForeignBarManager = nil) and (Items[I].BarManager <> BarManager) then
      begin
        Items[I].Free;
        Items[I] := nil;
      end;
  if Owner is TdxBar then
    TdxBar(Owner).BarManager.EndUpdate;
end;

function TdxBarItemLinks.HasItem(AItem: TdxBarItem): Boolean;
var
  I: Integer;
begin
  Result := False;
  for I := 0 to Count - 1 do
    if Items[I].HasItem(AItem) then
    begin
      Result := True;
      Break;
    end;
end;

function TdxBarItemLinks.IsControlExists(AItem: TdxBarItemControl): Boolean;
var
  I: Integer;
begin
  Result := False;
  for I := 0 to Count - 1 do
    if Items[I].Control = AItem then
    begin
      Result := True;
      Break;
    end;
end;

function TdxBarItemLinks.IsReferencedBy(ALinksOwner: IdxBarLinksOwner): Boolean;
var
  I: Integer;
begin
  Result := Self = ALinksOwner.GetItemLinks;
  if not Result then
    for I := 0 to Count - 1 do
      if Items[I].IsReferencedBy(ALinksOwner) then
      begin
        Result := True;
        Break;
      end;
end;

function TdxBarItemLinks.IndexOf(Value: TdxBarItemLink): Integer;
begin
  if (Value <> nil) and (Value.Collection = Self) then
    Result := Value.Index
  else
    Result := -1;
end;

function TdxBarItemLinks.Insert(AIndex: Integer): TdxBarItemLink;
begin
  Result := TdxBarItemLink(inherited Insert(AIndex));
end;

procedure TdxBarItemLinks.Move(ACurIndex, ANewIndex: Integer);
begin
  BeginUpdate;
  try
    if (ACurIndex < Count) and (ACurIndex > -1) and
       (ANewIndex < Count) and (ANewIndex > -1) and
       (ACurIndex <> ANewIndex) then
      Items[ACurIndex].SetIndex(ANewIndex);
  finally
    EndUpdate;
  end;
  if BarControl <> nil then BarControl.RepaintBar;
end;

function TdxBarItemLinks.VisibleIndexOf(Value: TdxBarItemLink): Integer;
begin
  Result := FVisibleItems.IndexOf(Value);
end;

{ TdxBarControlItemLinks }

function TdxBarControlItemLinks.DoFindItemWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink;
begin
  if IsControlVisible(BarControl) then
  begin
    Result := ACurrentLink;
    repeat
      Result := Next(Result);
      if Result = nil then Break;
      if Result.Item.HasAccel(Result) and Result.IsAccel(AKey, AShift) then Exit;
      if Result = ACurrentLink then Break;
      if ACurrentLink = nil then ACurrentLink := Result;
    until False;
  end;
  Result := nil;
end;

{ TdxBarSubMenuControlItemLinks }

function TdxBarSubMenuControlItemLinks.DoFindItemWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink;
begin
  if CanVisibleItemCount = 0 then
  begin
    Result := nil;
    Exit;
  end;
  if ACurrentLink = nil then ACurrentLink := CanVisibleItems[0];
  Result := ACurrentLink;
  repeat
    if Result = CanVisibleItems[CanVisibleItemCount - 1] then
      Result := CanVisibleItems[0]
    else
      Result := CanVisibleItems[Result.CanVisibleIndex + 1];
    if Result.Item.HasAccel(Result) and Result.IsAccel(AKey, AShift) then Exit;
  until Result = ACurrentLink;
  Result := nil;
end;

function TdxBarSubMenuControlItemLinks.IsScrollable: Boolean;
begin
  Result := True;
end;

{ TdxBarPopupMenu }

constructor TdxBarCustomPopupMenu.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  if dxBarManagerList.Count = 0 then
    raise EdxException.Create(cxGetResourceString(@dxSBAR_NOBARMANAGERS));
  FBackgroundBitmap := TBitmap.Create;
  BarManager := GetBarManagerByComponent(AOwner);
  if FBarManager = nil then
    BarManager := TdxBarManager(dxBarManagerList[0]);
  FEditFont := TFont.Create;
  FFont := TFont.Create;
  FFont.Assign(BarManager.Font);
  FFont.OnChange := FontChanged;
  FItemLinks := GetItemLinksClass.Create(FBarManager, Self);
  UseRecentItems := False;
  FShowAnimation := True;
  FUseOwnMessageLoop := True;
end;

destructor TdxBarCustomPopupMenu.Destroy;
begin
//#DG  Destroying;
//#DG  BarDesignController.DeselectIfSelected(Self);
  FreeAndNil(FItemLinks);
  FreeAndNil(FFont);
  FreeAndNil(FEditFont);
  FreeAndNil(FBackgroundBitmap);
  inherited Destroy;
end;

function TdxBarCustomPopupMenu.GetItemOptions: TdxBarItemOptions;
begin
  Result := FItemLinks.ItemOptions;
end;

function TdxBarCustomPopupMenu.GetSubMenuControl: TdxBarSubMenuControl;
begin
  Result := TdxBarSubMenuControl(FItemLinks.BarControl);
end;

function TdxBarCustomPopupMenu.GetUseRecentItems: Boolean;
begin
  Result := FItemLinks.FUseRecentItems;
end;

procedure TdxBarCustomPopupMenu.SetBackgroundBitmap(Value: TBitmap);
begin
  FBackgroundBitmap.Assign(Value);
end;

procedure TdxBarCustomPopupMenu.SetBarManager(Value: TdxBarManager);
begin
  if (FBarManager <> Value) and (Value <> nil) then
  begin
    if FBarManager <> nil then FBarManager.FPopupMenus.Remove(Self);
    FBarManager := Value;
    if FItemLinks <> nil then FItemLinks.FBarManager := Value;
    FBarManager.FPopupMenus.Add(Self);
  end;
end;

procedure TdxBarCustomPopupMenu.SetBarSize(Value: Integer);
begin
  if Value < 0 then Value := 0;
  FBarSize := Value;
end;

procedure TdxBarCustomPopupMenu.SetFont(Value: TFont);
begin
  Font.Assign(Value);
end;

procedure TdxBarCustomPopupMenu.SetItemLinks(Value: TdxBarItemLinks);
begin
  FItemLinks.Assign(Value);
end;

procedure TdxBarCustomPopupMenu.SetItemOptions(Value: TdxBarItemOptions);
begin
  FItemLinks.ItemOptions := Value;
end;

procedure TdxBarCustomPopupMenu.SetUseOwnFont(Value: Boolean);
begin
  if FUseOwnFont <> Value then
  begin
    FUseOwnFont := Value;
    FInternalFontChange := True;
    try
      if FUseOwnFont then
        FontChanged(nil)
      else
        Font := BarManager.Font;
    finally
      FInternalFontChange := False;
    end;
  end;
end;

procedure TdxBarCustomPopupMenu.SetUseRecentItems(Value: Boolean);
begin
  FItemLinks.FUseRecentItems := Value;
end;

procedure TdxBarCustomPopupMenu.FontChanged(Sender: TObject);
begin
  if not FInternalFontChange then
    FUseOwnFont := True;
  if FUseOwnFont then
    CreateEditFontHandle(Font, FEditFont, False);
end;

procedure TdxBarCustomPopupMenu.SubMenuCloseUp(Sender: TObject);
begin
  FPopupMenuVisible := False;
  DoCloseUp;
end;

procedure TdxBarCustomPopupMenu.SubMenuPopup(Sender: TObject);
begin
  FPopupMenuVisible := True;
  DoPopup;
end;

procedure TdxBarCustomPopupMenu.OwnerDesignerModified;
begin
  if [csDesigning, csLoading, csDestroying, csUpdating] * ComponentState = [csDesigning] then
    BarDesignController.DesignerModified(GetComponentForm(Self));
end;

function TdxBarCustomPopupMenu.GetEnabled: Boolean;
begin
  Result := True;
end;

procedure TdxBarCustomPopupMenu.SetEnabled(Value: Boolean);
begin
end;

procedure TdxBarCustomPopupMenu.SetVisible(Value: TdxBarItemVisible);
begin
end;

procedure TdxBarCustomPopupMenu.DoCloseUp;
begin
  CallNotify(OnCloseUp, Self);
end;

procedure TdxBarCustomPopupMenu.DoPopup;
begin
  CallNotify(OnPopup, Self);
end;

function TdxBarCustomPopupMenu.GetControlClass: TCustomdxBarControlClass;
begin
  Result := TdxBarSubMenuControl;
end;

function TdxBarCustomPopupMenu.GetItemLinksClass: TdxBarItemLinksClass;
begin
  Result := TdxBarSubMenuControlItemLinks;
end;

function TdxBarCustomPopupMenu.IsShortCut(AShortCut: TShortCut): Boolean;
begin
  Result := False;
end;

function TdxBarCustomPopupMenu.IsShortCutKey(var Message: TWMKey): Boolean;
var
  AShortCut: TShortCut;
begin
  AShortCut := GetShortCutFromMessageData(TMessage(Message).WParam, TMessage(Message).LParam);
  Result := (AShortCut <> 0) and ItemLinks.IsShortCut(AShortCut);
end;

procedure TdxBarCustomPopupMenu.Loaded;
begin
  inherited Loaded;
  BarDesignController.LockDesignerModified;
  try
    FItemLinks.LoadItemNames;
  finally
    BarDesignController.UnLockDesignerModified;
  end;
end;

// IdxBarLinksOwner
function TdxBarCustomPopupMenu.CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
begin
  Result := AItem.CanBePlacedOn(pkSubItemOrPopupMenu, nil, AErrorText);
  if Result then
  begin
    Result := (GetOwnedLinks(AItem) = nil) or not GetOwnedLinks(AItem).IsReferencedBy(Self);
    if not Result then
      AErrorText := cxGetResourceString(@dxSBAR_RECURSIVEMENUS);
  end;
end;

function TdxBarCustomPopupMenu.CreateBarControl: TCustomdxBarControl;
begin
  Result := GetControlClass.Create(BarManager);
end;

function TdxBarCustomPopupMenu.GetItemLinks: TdxBarItemLinks;
begin
  Result := FItemLinks;
end;

// IdxBarSubMenuOwner
function TdxBarCustomPopupMenu.GetBarSize: Integer;
begin
  Result := FBarSize;
end;

procedure TdxBarCustomPopupMenu.DoPaintBar(Canvas: TCanvas; const R: TRect);
begin
  if Assigned(FOnPaintBar) then FOnPaintBar(Self, Canvas, R);
end;

procedure TdxBarCustomPopupMenu.Popup(X, Y: Integer);
var
  Msg: TMsg;
  AIsMessageForMeaningParent: Boolean;
begin
  if FItemLinks.BarControl <> nil then
    Exit;

  dxBar.SendCancelMode;
  if not BarManager.IsCustomizing and (GetCapture <> 0) then
  begin
    SendMessage(GetCapture, CM_CANCELMODE, 0, 0);
    ReleaseCapture;
  end;

  if (FOwnerControl = nil) and (ActiveBarControl <> nil) and not ProcessMessage(GetFocus, AIsMessageForMeaningParent) then
    ActiveBarControl.HideAll;

  FItemLinks.CreateBarControl;

  FItemLinks.BarControl.Left := X;
  FItemLinks.BarControl.Top := Y;
  with TdxBarSubMenuControl(FItemLinks.BarControl) do
  begin
    if FOwnerItemControl <> nil then
      FOwnerItemControl.Parent.ChildBar := FItemLinks.BarControl;

    if Self.FOwnerBounds <> nil then
      OwnerBounds := Self.FOwnerBounds^;
    FOwnerControl := Self.FOwnerControl;
    OwnerWidth := Self.FOwnerWidth;
    OwnerHeight := Self.FOwnerHeight;
    if Self.Owner is TWinControl then
      FParentWnd := TWinControl(Self.Owner).Handle;
    OnCloseUp := SubMenuCloseUp;
    OnPopup := SubMenuPopup;
    FShowAnimation := Self.FShowAnimation;
    try
      Show;
    except
      HideAll;
      raise;
    end;

    if FUseOwnMessageLoop then
      repeat
        case Integer(GetMessage(Msg, 0, 0, 0)) of
          -1: Break;
          0: begin
              PostQuitMessage(Msg.wParam);
              Break;
            end;
        end;
        if not FPopupMenuVisible then
          with Msg do
            PostMessage(hwnd, message, wParam, lParam)
        else
          if Msg.message = WM_COMMAND then  // do nothing
          else
          begin
            TranslateMessage(Msg);
            DispatchMessage(Msg);
          end;
      until not FPopupMenuVisible;
  end;
end;

procedure TdxBarCustomPopupMenu.PopupEx(X, Y, AOwnerWidth, AOwnerHeight: Integer;
  AShowAnimation: Boolean; AOwnerBounds: PRect; AUseOwnMessageLoop: Boolean = True;
  AOwnerControl: TWinControl = nil);
begin
  FOwnerWidth := AOwnerWidth;
  FOwnerHeight := AOwnerHeight;
  FShowAnimation := AShowAnimation;
  FOwnerBounds := AOwnerBounds;
  FOwnerControl := AOwnerControl;
  FUseOwnMessageLoop := AUseOwnMessageLoop;
  Popup(X, Y);
  FUseOwnMessageLoop := True;
  FOwnerControl := nil;
  FOwnerWidth := 0;
  FOwnerHeight := 0;
  FShowAnimation := True;
end;

procedure TdxBarCustomPopupMenu.PopupFromCursorPos;
begin
  with GetMouseCursorPos do
    Popup(X, Y);
end;

{ TdxBarCustomApplicationMenu }

type
  { TdxBarExtraPaneDockControlAccessibilityHelper }

  TdxBarExtraPaneDockControlAccessibilityHelper = class(TdxDockControlAccessibilityHelper)
  protected
    function GetParent: TcxAccessibilityHelper; override;
  end;

  { TdxBarExtraPaneControlAccessibilityHelper }

  TdxBarExtraPaneControlAccessibilityHelper = class(TdxBarControlAccessibilityHelper)
  protected
    procedure DoGetKeyTipsData(AKeyTipsData: TList); override;
    function GetNextAccessibleObject(AItemControl: TdxBarItemControl;
      ADirection: TcxAccessibilityNavigationDirection): IdxBarAccessibilityHelper; override;
    function HandleNavigationKey(var AKey: Word): Boolean; override;
  end;

  { TdxBarApplicationMenuControlAccessibilityHelper }

  TdxBarApplicationMenuControlAccessibilityHelper = class(TdxBarSubMenuControlAccessibilityHelper)
  private
    function GetBarControl: TdxBarApplicationMenuControl;
    function GetNextLinks(ACurrentLinks: TdxBarItemLinks): TdxBarItemLinks;
    function GetPreviousLinks(ACurrentLinks: TdxBarItemLinks): TdxBarItemLinks;
    function InternalGetNextItemLink(ACurrentLinks: TdxBarItemLinks;
      ASelectedLink: TdxBarItemLink; AUpKey: Boolean; AFirstVisibleIndex: Integer = 0): TdxBarItemLink;
    procedure PopulateNavigationList(AList: TList);
  protected
    function GetChild(AIndex: Integer): TcxAccessibilityHelper; override;
    function GetChildCount: Integer; override;
    function GetChildIndex(AChild: TcxAccessibilityHelper): Integer; override;

    procedure GetItemControlKeyTipPosition(AItemControl: TdxBarItemControl;
      out ABasePoint: TPoint; out AHorzAlign: TAlignment; out AVertAlign: TcxAlignmentVert); override;
    function GetNextAccessibleObject(AItemControl: TdxBarItemControl;
      ADirection: TcxAccessibilityNavigationDirection): IdxBarAccessibilityHelper; override;
    function GetNextItemLink(AItemLink: TdxBarItemLink;
      AGoForward: Boolean): TdxBarItemLink; override;
    function GetParentForKeyTip: TdxBarAccessibilityHelper; override;

    property BarControl: TdxBarApplicationMenuControl read GetBarControl;
  end;

  TdxBarApplicationMenuControlDesignHelper = class(TCustomdxBarControlDesignHelper);

  TdxBarApplicationMenuItemLinks = class(TdxBarSubMenuControlItemLinks)
  private
    function GetInternalDefaultValue(AOption: TdxBarItemOptionValue; AItemLinks: TdxBarItemLinks): Variant;
  protected
    function GetDefaultValue(AOption: TdxBarItemOptionValue): Variant; override;
    function GetOptionsValue(AOption: TdxBarItemOptionValue; AItemLinks: TdxBarItemLinks): Variant; override;
  end;

{ TdxBarExtraPaneDockControl }

constructor TdxBarExtraPaneDockControl.Create(AOwner: TComponent);
begin
  inherited;
  AllowDocking := False;
end;

procedure TdxBarExtraPaneDockControl.CalcRowToolbarPositions(ARowIndex: Integer; AClientSize: Integer);
var
  AToolbar: TdxBarControl;
  R: TRect;
begin
  R := ClientRect;
  AToolbar := Rows[0].Cols[0].BarControl;
  if (AToolbar.Left <> R.Left) or (AToolbar.Top <> R.Top) or
    (AToolbar.Width <> cxRectWidth(R)) or (AToolbar.Height <> cxRectHeight(R)) then
  begin
    if AToolbar.HandleAllocated then
    begin
      SetWindowPos(AToolbar.Handle, 0, R.Left, R.Top,
        cxRectWidth(R), cxRectHeight(R), SWP_NOZORDER or SWP_NOACTIVATE);
      SendMessage(AToolbar.Handle, WM_NCPAINT, 0, 0);
    end
    else
      AToolbar.SetBounds(R.Left, R.Top, cxRectWidth(R), cxRectHeight(R));
  end;
end;

function TdxBarExtraPaneDockControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarExtraPaneDockControlAccessibilityHelper;
end;

function TdxBarExtraPaneDockControl.GetDockedBarControlClass: TdxBarControlClass;
begin
  Result := TdxBarExtraPaneControl;
end;

{ TdxBarExtraPaneDockControlAccessibilityHelper }

function TdxBarExtraPaneDockControlAccessibilityHelper.GetParent: TcxAccessibilityHelper;
begin
  Result := TdxBarApplicationMenuControl(DockControl.Parent).IAccessibilityHelper.GetBarHelper;
end;

{ TdxBarExtraPaneControl }

destructor TdxBarExtraPaneControl.Destroy;
begin
  inherited;
end;

procedure TdxBarExtraPaneControl.CalcControlsPositions;
begin
  if not FIsControlsCreated then
    CreateControls;
  inherited;
  CalcItemRects(ptMenu);
end;

procedure TdxBarExtraPaneControl.CalcItemsRect;
begin
  inherited;
  FItemsRect.Left := FItemsRect.Left + MenuSeparatorSize;
end;

function TdxBarExtraPaneControl.CanMoving: Boolean;
begin
  Result := False;
end;

function TdxBarExtraPaneControl.CanProcessMouseMessage: Boolean;
begin
  Result := inherited CanProcessMouseMessage or TdxBarApplicationMenuControl(BasicControl).CanProcessMouseMessage;
end;

procedure TdxBarExtraPaneControl.DoCreateControls;
begin
  FIsControlsCreated := True;
  if not IsCustomizing then
    ExpandContainerItems;
  inherited DoCreateControls;
end;

procedure TdxBarExtraPaneControl.DoDestroyControls;
begin
  inherited DoDestroyControls;
  if not IsCustomizing then
    CollapseContainerItems;
  FIsControlsCreated := False;
end;

procedure TdxBarExtraPaneControl.DoDrawBeginGroup(const ASeparatorRect: TRect; AHorz: Boolean);
begin
  Painter.ExtraMenuControlDrawBeginGroup(Self, Canvas, ASeparatorRect, ToolbarBrush, AHorz);
end;

procedure TdxBarExtraPaneControl.DoNCPaint(DC: HDC);
begin
// do nothing
end;

procedure TdxBarExtraPaneControl.DoHideAll;
begin
  inherited;
  BasicControl.HideAll;
end;

procedure TdxBarExtraPaneControl.DrawContentBackground;
begin
  DrawBackground(Canvas, ClientRect, ToolbarBrush, clNone);
end;

procedure TdxBarExtraPaneControl.FillBackground(ADC: HDC; const ARect: TRect; ABrush: HBRUSH; AColor: TColor;
  AIsClientArea: Boolean);
begin
  BarCanvas.BeginPaint(ADC);
  try
    DrawBackground(BarCanvas, ARect, ABrush, AColor);
  finally
    BarCanvas.EndPaint;
  end;
end;

function TdxBarExtraPaneControl.FindLinkWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink; out ADuplicate: Boolean): TdxBarItemLink;
begin
  Result := BasicControl.FindLinkWithAccel(AKey, AShift, ACurrentLink, ADuplicate);
end;

function TdxBarExtraPaneControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarExtraPaneControlAccessibilityHelper;
end;

function TdxBarExtraPaneControl.GetBehaviorOptions: TdxBarBehaviorOptions;
begin
  Result := BasicControl.BehaviorOptions;
end;

function TdxBarExtraPaneControl.GetPainter: TdxBarPainter;
begin
  Result := BasicControl.Painter;
end;

function TdxBarExtraPaneControl.GetViewInfoClass: TCustomdxBarControlViewInfoClass;
begin
  Result := TdxBarExtraPaneControlViewInfo;
end;

procedure TdxBarExtraPaneControl.HideAllByEscape;
begin
  TdxBarApplicationMenuControl(BasicControl).HideByEscape;
end;

procedure TdxBarExtraPaneControl.LayoutChanged;
begin
// do nothing;
end;

procedure TdxBarExtraPaneControl.SetAccelSelectedItem(AItemControl: TdxBarItemControl; ADuplicate: Boolean);
begin
  BasicControl.SetAccelSelectedItem(AItemControl, ADuplicate);
end;

function TdxBarExtraPaneControl.CanShowPopupMenuOnMouseClick(AMousePressed: Boolean): Boolean;
begin
  Result := BasicControl.CanShowPopupMenuOnMouseClick(AMousePressed);
end;

procedure TdxBarExtraPaneControl.InitCustomizationPopup(AItemLinks: TdxBarItemLinks);
begin
  BasicControl.InitCustomizationPopup(AItemLinks);
end;

procedure TdxBarExtraPaneControl.ShowPopup(AItem: TdxBarItemControl);
begin
  BasicControl.ShowPopup(AItem);
end;

procedure TdxBarExtraPaneControl.DrawBackground(ACanvas: TcxCanvas; const ARect: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  Painter.ExtraMenuControlDrawBackground(Self, ACanvas, ARect, ABrush, AColor);
end;

function TdxBarExtraPaneControl.GetBasicControl: TCustomdxBarControl;
begin
  Result := TCustomdxBarControl(DockControl.Parent);
end;

procedure TdxBarExtraPaneControl.WMNCCalcSize(var Message: TWMNCCalcSize);
begin
  if Message.CalcValidRects then
    Message.Result := 0
  else
    inherited;
end;

{ TdxBarExtraPaneControlViewInfo }

procedure TdxBarExtraPaneControlViewInfo.DoCalcSeparatorInfo(AItemLink: TdxBarItemLink; const AItemRect: TRect);
var
  R: TRect;
begin
  R := Rect(AItemRect.Left, AItemRect.Top - BarControl.BeginGroupSize,
    AItemRect.Right, AItemRect.Top);
  AddSeparatorInfo(R, skHorizontal, AItemLink.Control);
end;

{ TdxBarExtraPaneControlAccessibilityHelper }

procedure TdxBarExtraPaneControlAccessibilityHelper.DoGetKeyTipsData(
  AKeyTipsData: TList);
begin
end;

function TdxBarExtraPaneControlAccessibilityHelper.GetNextAccessibleObject(
  AItemControl: TdxBarItemControl;
  ADirection: TcxAccessibilityNavigationDirection): IdxBarAccessibilityHelper;

  function BasicControlObject: TdxBarApplicationMenuControlAccessibilityHelper;
  begin
    Result := TdxBarApplicationMenuControlAccessibilityHelper(
      TdxBarExtraPaneControl(BarControl).BasicControl.IAccessibilityHelper.GetHelper);
  end;

begin
  Result := BasicControlObject.GetNextAccessibleObject(AItemControl, ADirection);
end;

function TdxBarExtraPaneControlAccessibilityHelper.HandleNavigationKey(var AKey: Word): Boolean;
var
  AShift: TShiftState;
begin
  Result := False;
  AShift := InternalGetShiftState;
  if AKey = VK_TAB then
    if AShift = [] then
      AKey := VK_DOWN
    else
      AKey := VK_UP
  else
    Result := inherited HandleNavigationKey(AKey);
end;

{ TdxBarApplicationMenuControl }

constructor TdxBarApplicationMenuControl.Create(AOwner: TComponent);
begin
  inherited;

  // to prohibit FBar from appearing in the Object TreeView
  if NeedExtraPane then
  begin
    FDockControl := GetExtraPaneDockControlClass.Create(AOwner);
    FDockControl.Align := dalNone;
    FDockControl.BarManager := BarManager;
    FDockControl.Parent := Self;

    BarManager.Bars.BeginUpdate;
    try
      FBar := BarManager.Bars.Add;
      FBar.AllowQuickCustomizing := False;
      FBar.AllowCustomizing := False;
      FBar.NotDocking := [dsNone];
      FBar.Hidden := True;
      FBar.Font := Font;
      FBar.UseOwnFont := False;
    finally
      BarManager.Bars.EndUpdate(False);
    end;
  end;
  FButtonLinks := TdxBarApplicationMenuButtonItemLinks.Create(BarManager, nil);
  FButtonLinks.BarControl := Self;
end;

destructor TdxBarApplicationMenuControl.Destroy;
begin
  FreeAndNil(FButtonLinks);
  FreeAndNil(FTotalItemLinks);
  FreeAndNil(FBar);
  FreeAndNil(FDockControl);

  inherited;
end;

procedure TdxBarApplicationMenuControl.CalcItemRects(APaintStyle: TdxBarPaintType; ATopIndex: Integer);
begin
  inherited CalcItemRects(APaintStyle, ATopIndex);

  ButtonLinks.CalcItemsRects(FButtonsRect);
end;

procedure TdxBarApplicationMenuControl.CalcItemsRect;
begin
  inherited CalcItemsRect;
  FButtonsRect := FItemsRect;
  FButtonsRect.Top := FItemsRect.Bottom;
  FButtonsRect.Bottom := ContentRect.Bottom;
  FButtonsRect := cxRectInflate(FButtonsRect, 0, -4, 1, -1);
  if NeedExtraPane then
  begin
    FExtraPaneRect := FItemsRect;
    Dec(FItemsRect.Right, FExtraPaneSize);
    FExtraPaneRect.Left := FItemsRect.Right;
  end;
end;

function TdxBarApplicationMenuControl.CalcChildBarBounds(out ARect: TRect): Boolean;
begin
  Result := NeedExtraPane;
  if Result then
  begin
    ARect := FExtraPaneRect;
    MapWindowRect(Handle, 0, ARect);
  end;
end;

procedure TdxBarApplicationMenuControl.DoCalcSize(out ASize: TSize);
begin
  inherited DoCalcSize(ASize);
  if ASize.cx = 0 then
    ASize.cx := dxBarEmptySubMenuControlContentWidth;
  if NeedExtraPane then
  begin
    if ApplicationMenu.ExtraPaneSize <> 0 then
      FExtraPaneSize := MulDiv(ApplicationMenu.ExtraPaneSize, TextSize, Painter.SubMenuControlNormalItemHeight)
    else
      FExtraPaneSize := Round(ASize.cx * ApplicationMenu.ExtraPaneWidthRatio);
    Inc(ASize.cx, FExtraPaneSize);
  end;
end;

function TdxBarApplicationMenuControl.GetViewInfoClass: TCustomdxBarControlViewInfoClass;
begin
  Result := TdxBarApplicationMenuControlViewInfo;
end;

function TdxBarApplicationMenuControl.GetExtraPaneDockControlClass: TdxBarDockControlClass;
begin
  Result := TdxBarExtraPaneDockControl;
end;

procedure TdxBarApplicationMenuControl.DoNCPaint(DC: HDC; const ARect: TRect);
begin
  Painter.ApplicationMenuDrawBorder(Self, DC, ARect);
end;

procedure TdxBarApplicationMenuControl.DoShow;
begin
  if NeedExtraPane then
    InitializeExtraPaneControl;
  HandleNeeded;
  CalcControlsPositions;
  if NeedExtraPane then
    ShowExtraPaneControl;
  inherited;
end;

procedure TdxBarApplicationMenuControl.DrawContent;
begin
  inherited;
  DrawContentArea(Canvas);
end;

procedure TdxBarApplicationMenuControl.DrawContentArea(ACanvas: TcxCanvas);
var
  AItemsArea: TRect;
begin
  UnionRect(AItemsArea, ItemsRect, FExtraPaneRect);
  UnionRect(AItemsArea, AItemsArea, BarRect);
  ACanvas.SaveClipRegion;
  try
    ACanvas.SetClipRegion(TcxRegion.Create(ContentRect), roIntersect);
    Painter.ApplicationMenuDrawContentArea(Self, ACanvas, ContentRect, AItemsArea);
  finally
    ACanvas.RestoreClipRegion;
  end;
end;

procedure TdxBarApplicationMenuControl.DoFillBackgroundEx(ACanvas: TcxCanvas;
  const ARect: TRect; ABrush: HBRUSH; AColor: TColor; AIsClientArea: Boolean);
begin
  inherited;
  DrawContentArea(ACanvas);
end;

function TdxBarApplicationMenuControl.DoFindLinkWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink;
begin
  Result := TotalItemLinks.FindItemWithAccel(AKey, AShift, ACurrentLink);
end;

function TdxBarApplicationMenuControl.FindLinkWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink; out ADuplicate: Boolean): TdxBarItemLink;

  procedure PopulateTotalItemLinks;

    procedure InternalAssign(AItemLinks: TdxBarItemLinks);
    var
      I: Integer;
      ALink: TdxBarItemLink;
    begin
      if AItemLinks <> nil then
        for I := 0 to AItemLinks.Count - 1 do
        begin
          ALink := TotalItemLinks.Add;
          ALink.Assign(AItemLinks[I]);
          ALink.Data := Integer(AItemLinks[I]);
        end;
    end;

  begin
    TotalItemLinks.BeginUpdate;
    try
      TotalItemLinks.Clear;
      InternalAssign(ItemLinks);
      InternalAssign(ExtraPaneItemLinks);
      InternalAssign(ButtonLinks);
    finally
      TotalItemLinks.EndUpdate;
    end;
  end;

  function ImportCurrentLink(ACurrentLink: TdxBarItemLink): TdxBarItemLink;
  var
    I: Integer;
  begin
    Result := nil;
    if ACurrentLink <> nil then
      for I := 0 to TotalItemLinks.Count - 1 do
        if TotalItemLinks[I].Data = Integer(ACurrentLink) then
        begin
          Result := TotalItemLinks[I];
          Break;
        end;
  end;

  function ExportCurrentLink(ACurrentLink: TdxBarItemLink): TdxBarItemLink;
  begin
    if ACurrentLink <> nil then
      Result := TdxBarItemLink(ACurrentLink.Data)
    else
      Result := nil;
  end;

begin
  PopulateTotalItemLinks;
  Result := ExportCurrentLink(inherited FindLinkWithAccel(AKey, AShift, ImportCurrentLink(ACurrentLink), ADuplicate));
end;

function TdxBarApplicationMenuControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarApplicationMenuControlAccessibilityHelper;
end;

function TdxBarApplicationMenuControl.GetBehaviorOptions: TdxBarBehaviorOptions;
begin
  Result := [bboAllowSelectWindowItemsWithoutFocusing, bboAllowShowHints,
    bboClickItemsBySpaceKey, bboExtendItemWhenAlignedToClient, bboUnmoved];
end;

function TdxBarApplicationMenuControl.GetItemsRectOffset: TRect;

  function Scale(const ARect: TRect; ARatio: Double): TRect;
  begin
    Result.Left := Round(ARect.Left * ARatio);
    Result.Top := Round(ARect.Top * ARatio);
    Result.Right := Round(ARect.Right * ARatio);
    Result.Bottom := Round(ARect.Bottom * ARatio);
  end;

var
  AFrameSizes: TRect;
begin
  Result := inherited GetItemsRectOffset;
  AFrameSizes := Scale(Painter.ApplicationMenuGetFrameSizes, Ratio);
  Result.Left := Result.Left + AFrameSizes.Left;
  Result.Top := Result.Top + AFrameSizes.Top;
  Result.Right := Result.Right + AFrameSizes.Right;
  Result.Bottom := Result.Bottom + AFrameSizes.Bottom;
end;

function TdxBarApplicationMenuControl.IsControlExists(ABarItemControl: TdxBarItemControl): Boolean;
begin
  Result := inherited IsControlExists(ABarItemControl) or (ButtonLinks.IsControlExists(ABarItemControl));
end;

procedure TdxBarApplicationMenuControl.SetAccelSelectedItem(AItemControl: TdxBarItemControl; ADuplicate: Boolean);
begin
  if BarNavigationController.SelectedObject <> nil then
    BarNavigationController.SelectedObject.Unselect(AItemControl.IAccessibilityHelper);
  AItemControl.IAccessibilityHelper.Select(True);
  if not ADuplicate then
    SendMessage(AItemControl.Parent.Handle, WM_KEYDOWN, VK_RETURN, 0);
end;

procedure TdxBarApplicationMenuControl.SetControlVisible(AControl: TdxBarItemControl);
begin
  if AControl.GetPaintType = ptMenu then
    inherited SetControlVisible(AControl);
end;

procedure TdxBarApplicationMenuControl.SetItemLinks(Value: TdxBarItemLinks);
begin
  inherited;
  FButtonLinks.FLinksOwner := ApplicationMenu;
end;

procedure TdxBarApplicationMenuControl.InitializeExtraPaneControl;
begin
  ApplicationMenu.Buttons.PopulateItemLinks(ButtonLinks);
  ExtraPaneItemLinks.Add(ApplicationMenu.ExtraPane.ListItem);
end;

procedure TdxBarApplicationMenuControl.ShowExtraPaneControl;
begin
  FBar.DockControl := FDockControl;
  FBar.BorderStyle := bbsNone;
  FBar.Visible := True;
  SetWindowPos(FDockControl.Handle, 0,
    FExtraPaneRect.Left, FExtraPaneRect.Top, cxRectWidth(FExtraPaneRect), cxRectHeight(FExtraPaneRect),
    SWP_NOZORDER or SWP_NOACTIVATE or SWP_SHOWWINDOW);
end;

function TdxBarApplicationMenuControl.GetApplicationMenu: TdxBarCustomApplicationMenu;
begin
  Result := TdxBarCustomApplicationMenu(ItemLinks.Owner);
end;

function TdxBarApplicationMenuControl.GetExtraPaneItemLinks: TdxBarItemLinks;
begin
  if NeedExtraPane then
    Result := FBar.ItemLinks
  else
    Result := nil;
end;

function TdxBarApplicationMenuControl.GetTotalItemLinks: TdxBarItemLinks;
begin
  if FTotalItemLinks = nil then
     FTotalItemLinks := TdxBarSubMenuControlItemLinks.Create(BarManager, ApplicationMenu);
  Result := FTotalItemLinks;
end;

function TdxBarApplicationMenuControl.NeedExtraPane: Boolean;
begin
  // see constructor
  Result := not IsCustomizing;
end;

{ TdxBarApplicationMenuControlViewInfo }

function TdxBarApplicationMenuControlViewInfo.GetBarControl: TdxBarApplicationMenuControl;
begin
  Result := TdxBarApplicationMenuControl(inherited GetBarControl);
end;

procedure TdxBarApplicationMenuControlViewInfo.Calculate;
var
  I: Integer;
  AControl: TdxBarItemControl;
  ALinks: TdxBarItemLinks;
  AVisibleItemRect: TRect;
begin
  inherited Calculate;
  if ItemControlCount > 0 then
  begin
    ALinks := BarControl.ButtonLinks;
    for I := 0 to ALinks.VisibleItemCount - 1 do
    begin
      AControl := ALinks.VisibleItems[I].Control;
      AVisibleItemRect := BarControl.GetItemRect(AControl);
      if not IsRectEmpty(AVisibleItemRect) then
      begin
        AddItemControlViewInfo(AControl.ViewInfo);
        IdxBarItemControlViewInfo(AControl.ViewInfo).SetBounds(AVisibleItemRect);
      end;
    end;
  end;
end;

{ TdxBarApplicationMenuControlAccessibilityHelper }

function TdxBarApplicationMenuControlAccessibilityHelper.GetChild(
  AIndex: Integer): TcxAccessibilityHelper;
begin
  if AIndex = ChildCount - 1 then
    Result := BarControl.ExtraPaneControlDockControl.IAccessibilityHelper.GetHelper
  else
    Result := inherited GetChild(AIndex);
end;

function TdxBarApplicationMenuControlAccessibilityHelper.GetChildCount: Integer;
begin
  Result := inherited GetChildCount + 1;
end;

function TdxBarApplicationMenuControlAccessibilityHelper.GetChildIndex(
  AChild: TcxAccessibilityHelper): Integer;
begin
  if AChild = BarControl.ExtraPaneControlDockControl.IAccessibilityHelper.GetHelper then
    Result := inherited GetChildCount
  else
    Result := inherited GetChildIndex(AChild);
end;

procedure TdxBarApplicationMenuControlAccessibilityHelper.GetItemControlKeyTipPosition(
  AItemControl: TdxBarItemControl; out ABasePoint: TPoint;
  out AHorzAlign: TAlignment; out AVertAlign: TcxAlignmentVert);
begin
  if BarControl.ButtonLinks.IndexOf(AItemControl.ItemLink) <> -1 then
  begin
    ABasePoint := cxRectCenter(GetItemControlScreenBounds(AItemControl));
    AHorzAlign := taCenter;
    AVertAlign := vaBottom;
  end
  else
    inherited GetItemControlKeyTipPosition(AItemControl, ABasePoint, AHorzAlign, AVertAlign);
end;

function TdxBarApplicationMenuControlAccessibilityHelper.GetNextAccessibleObject(
  AItemControl: TdxBarItemControl;
  ADirection: TcxAccessibilityNavigationDirection): IdxBarAccessibilityHelper;

  function GetScreenBoundsForNavigation: TRect;
  begin
    if (BarControl.ItemLinks.IsControlExists(AItemControl)) then
    begin
      Result := AItemControl.ItemBounds;
      Result.Top := BarControl.ItemsRect.Top;
      if BarControl.ExtraPaneItemLinks.RealVisibleItemCount > 1 then
        Result.Bottom := BarControl.ItemsRect.Bottom
      else
        Result.Bottom := BarControl.ContentRect.Bottom;
      Result.TopLeft := BarControl.ClientToScreen(Result.TopLeft);
      Result.BottomRight := BarControl.ClientToScreen(Result.BottomRight);
    end
    else
      Result := AItemControl.IAccessibilityHelper.GetBarHelper.GetScreenBounds(cxAccessibleObjectSelfID);
  end;

var
  AObjects: TList;
  AItemLink: TdxBarItemLink;
  ASelectedLink: TdxBarItemLink;
begin
  if ADirection in [andUp, andDown] then
  begin
    ASelectedLink := BarControl.FBar.Control.SelectedLink;
    if ASelectedLink = nil then
      AItemLink := BarControl.ItemLinks.First
    else
      AItemLink := InternalGetNextItemLink(BarControl.ExtraPaneItemLinks, ASelectedLink, ADirection = andUp, 1);
    if AItemLink <> nil then
      Result := AItemLink.Control.IAccessibilityHelper;
  end
  else
  begin
    AObjects := TList.Create;
    try
      GetChildrenForNavigation(AItemControl.IAccessibilityHelper.GetBarHelper, Self,
        GetScreenBoundsForNavigation, ADirection, True, AObjects);
      Result := dxBar.GetNextAccessibleObject(
        AItemControl.IAccessibilityHelper.GetBarHelper, AObjects, ADirection, True);
    finally
      AObjects.Free;
    end;
  end;
end;

function TdxBarApplicationMenuControlAccessibilityHelper.GetNextItemLink(
  AItemLink: TdxBarItemLink; AGoForward: Boolean): TdxBarItemLink;
var
  ACurrentLinks: TdxBarItemLinks;
begin
  if AItemLink = nil then
  begin
    if ItemLinks.RealVisibleItemCount > 0 then
      Result := ItemLinks.First
    else
      Result := nil;
  end
  else
  begin
    ACurrentLinks := ItemLinks;
    if BarControl.ButtonLinks.IsControlExists(AItemLink.Control) then
      ACurrentLinks := BarControl.ButtonLinks;
    Result := InternalGetNextItemLink(ACurrentLinks, AItemLink, not AGoForward);
  end;
end;

function TdxBarApplicationMenuControlAccessibilityHelper.GetParentForKeyTip: TdxBarAccessibilityHelper;
var
  AIAccessibleObject: IdxBarAccessibleObject;
begin
  if Supports(BarControl.RealOwnerControl, IdxBarAccessibleObject, AIAccessibleObject) then
    Result := AIAccessibleObject.GetAccessibilityHelper.GetBarHelper
  else
    Result := nil;
end;

function TdxBarApplicationMenuControlAccessibilityHelper.GetBarControl: TdxBarApplicationMenuControl;
begin
  Result := TdxBarApplicationMenuControl(FOwnerObject);
end;

function TdxBarApplicationMenuControlAccessibilityHelper.GetNextLinks(ACurrentLinks: TdxBarItemLinks): TdxBarItemLinks;
var
  AIndex: Integer;
  AList: TList;
begin
  AList := TList.Create;
  try
    PopulateNavigationList(AList);
    AIndex := AList.IndexOf(ACurrentLinks);
    if AIndex < AList.Count - 1 then
      Inc(AIndex)
    else
      AIndex := 0;
    Result := TdxBarItemLinks(AList[AIndex])
  finally
    AList.Free;
  end;
end;

function TdxBarApplicationMenuControlAccessibilityHelper.GetPreviousLinks(ACurrentLinks: TdxBarItemLinks): TdxBarItemLinks;
var
  AIndex: Integer;
  AList: TList;
begin
  AList := TList.Create;
  try
    PopulateNavigationList(AList);
    AIndex := AList.IndexOf(ACurrentLinks);
    if AIndex > 0 then
      Dec(AIndex)
    else
      AIndex := AList.Count - 1;
    Result := TdxBarItemLinks(AList[AIndex])
  finally
    AList.Free;
  end;
end;

function TdxBarApplicationMenuControlAccessibilityHelper.InternalGetNextItemLink(ACurrentLinks: TdxBarItemLinks;
  ASelectedLink: TdxBarItemLink; AUpKey: Boolean; AFirstVisibleIndex: Integer = 0): TdxBarItemLink;
begin
  if AUpKey then
    if ASelectedLink.VisibleIndex = AFirstVisibleIndex then
      Result := GetPreviousLinks(ACurrentLinks).Last
    else
      Result := ACurrentLinks.Prev(ASelectedLink)
  else
    if ASelectedLink.VisibleIndex = ACurrentLinks.RealVisibleItemCount - 1 then
      Result := GetNextLinks(ACurrentLinks).First
    else
      Result := ACurrentLinks.Next(ASelectedLink);
end;

procedure TdxBarApplicationMenuControlAccessibilityHelper.PopulateNavigationList(AList: TList);
begin
  if BarControl.ItemLinks.RealVisibleItemCount > 0 then
    AList.Add(BarControl.ItemLinks);
  if BarControl.ExtraPaneItemLinks.RealVisibleItemCount > 1 then
    AList.Add(BarControl.ExtraPaneItemLinks);
  if BarControl.ButtonLinks.RealVisibleItemCount > 0 then
    AList.Add(BarControl.ButtonLinks);
end;

{ TdxBarApplicationMenuItemLinks }

function TdxBarApplicationMenuItemLinks.GetDefaultValue(AOption: TdxBarItemOptionValue): Variant;
begin
  Result := GetInternalDefaultValue(AOption, nil);
end;

function TdxBarApplicationMenuItemLinks.GetOptionsValue(AOption: TdxBarItemOptionValue; AItemLinks: TdxBarItemLinks): Variant;
begin
  if not ItemOptions.IsValueStored(AOption) and (GetParentLinks = nil) then
    Result := GetInternalDefaultValue(AOption, AItemLinks)
  else
    Result := inherited GetOptionsValue(AOption, AItemLinks);
end;

function TdxBarApplicationMenuItemLinks.GetInternalDefaultValue(AOption: TdxBarItemOptionValue; AItemLinks: TdxBarItemLinks): Variant;
begin
  case AOption of
    ioShowDescriptions: Result := AItemLinks <> Self;
    ioShowShortCuts: Result := False;
  else {ioSize}
    Result := misLarge;
  end;
end;

{ TdxExtraPaneItem }

constructor TdxBarExtraPaneItem.Create(Collection: TCollection);
begin
  inherited;
  ImageIndex := -1;
end;

procedure TdxBarExtraPaneItem.Assign(Source: TPersistent);
begin
  if Source is TdxBarExtraPaneItem then
  begin
    Data := TdxBarExtraPaneItem(Source).Data;
    DisplayText := TdxBarExtraPaneItem(Source).DisplayText;
    ImageIndex := TdxBarExtraPaneItem(Source).ImageIndex;
    Text := TdxBarExtraPaneItem(Source).Text;
  end
  else
    inherited;
end;

procedure TdxBarExtraPaneItem.SetDisplayText(const Value: string);
begin
  if DisplayText <> Value then
  begin
    FDisplayText := Value;
    Changed(False);
  end;
end;

procedure TdxBarExtraPaneItem.SetText(const Value: string);
begin
  if Text <> Value then
  begin
    FText := Value;
    Changed(False);
  end;
end;

{ TdxExtraPaneItems }

constructor TdxBarExtraPaneItems.Create(AApplicationMenu: TdxBarCustomApplicationMenu);
begin
  inherited Create(TdxBarExtraPaneItem);
  FApplicationMenu := AApplicationMenu;
end;

function TdxBarExtraPaneItems.Add: TdxBarExtraPaneItem;
begin
  Result := TdxBarExtraPaneItem(inherited Add);
end;

function TdxBarExtraPaneItems.IndexOf(const AItemText: string): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := 0 to Count - 1 do
    if Items[I].Text = AItemText then
    begin
      Result := I;
      Break;
    end;
end;

function TdxBarExtraPaneItems.Insert(AIndex: Integer): TdxBarExtraPaneItem;
begin
  Result := TdxBarExtraPaneItem(inherited Insert(AIndex));
end;

function TdxBarExtraPaneItems.GetOwner: TPersistent;
begin
  Result := FApplicationMenu;
end;

function TdxBarExtraPaneItems.GetItem(Index: Integer): TdxBarExtraPaneItem;
begin
  Result := TdxBarExtraPaneItem(inherited GetItem(Index));
end;

procedure TdxBarExtraPaneItems.SetItem(Index: Integer; Value: TdxBarExtraPaneItem);
begin
  inherited SetItem(Index, Value);
end;

{ TdxBarApplicationMenuExtraPane }

constructor TdxBarApplicationMenuExtraPane.Create(AnApplicationMenu: TdxBarCustomApplicationMenu);
begin
  inherited Create;

  FApplicationMenu := AnApplicationMenu;
  
  FWidthRatio := dxBarExtraPaneWidthRatio;
  FListItem := TdxBarExtraPaneListItem.Create(FApplicationMenu.BarManager);
  FListItem.Caption := dxBarExtraPaneHeader;
  FListItem.OnClick := ItemClick;
  FListItem.OnGetDisplayText := GetItemDisplayText;
  BarDesignController.RemoveItemFromBarManagerList(FListItem);
  FItems := TdxBarExtraPaneItems.Create(FApplicationMenu);
end;

destructor TdxBarApplicationMenuExtraPane.Destroy;
begin
  FreeAndNil(FItems);
  FreeAndNil(FListItem);
  inherited;
end;

procedure TdxBarApplicationMenuExtraPane.Assign(Source: TPersistent);
var
  AExtraPane: TdxBarApplicationMenuExtraPane;
begin
  if Source is TdxBarApplicationMenuExtraPane then
  begin
    AExtraPane := TdxBarApplicationMenuExtraPane(Source);
    WidthRatio := AExtraPane.WidthRatio;
    Size := AExtraPane.Size;
    Items := AExtraPane.Items;
    Header := AExtraPane.Header;
    OnItemClick := AExtraPane.OnItemClick;
  end
  else
    inherited;
end;

function TdxBarApplicationMenuExtraPane.GetOwner: TPersistent;
begin
  Result := FApplicationMenu;
end;

function TdxBarApplicationMenuExtraPane.IsHeaderStored: Boolean;
begin
  Result := Header <> dxBarExtraPaneHeader;
end;

function TdxBarApplicationMenuExtraPane.IsWidthRatioStored: Boolean;
begin
  Result := FWidthRatio <> dxBarExtraPaneWidthRatio;
end;

function TdxBarApplicationMenuExtraPane.GetHeader: string;
begin
  Result := FListItem.Caption;
end;

function TdxBarApplicationMenuExtraPane.GetListItem: TdxBarExtraPaneListItem;
var
  I: Integer;
begin
  FListItem.Items.BeginUpdate;
  try
    FListItem.Items.Clear;
    for I := 0 to FItems.Count - 1 do
      FListItem.Items.AddObject(FItems[I].Text, FItems[I]);
  finally
    FListItem.Items.EndUpdate;
  end;
  Result := FListItem;
end;

procedure TdxBarApplicationMenuExtraPane.SetItems(AValue: TdxBarExtraPaneItems);
begin
  FItems.Assign(AValue);
end;

procedure TdxBarApplicationMenuExtraPane.SetHeader(AValue: string);
begin
  FListItem.Caption := AValue;
end;

procedure TdxBarApplicationMenuExtraPane.SetSize(AValue: Integer);
begin
  if AValue >= 0 then
    FSize := AValue;
end;

procedure TdxBarApplicationMenuExtraPane.SetWidthRatio(AValue: Double);
begin
  if AValue >= 0 then
    FWidthRatio := AValue;
end;

procedure TdxBarApplicationMenuExtraPane.ItemClick(Sender: TObject);
begin
  if Assigned(OnItemClick) then
    OnItemClick(FApplicationMenu, FListItem.ItemIndex);
end;

procedure TdxBarApplicationMenuExtraPane.GetItemDisplayText(Sender: TObject; AIndex: Integer; var ADisplayText: string);
begin
  if Assigned(OnGetItemDisplayText) then
    OnGetItemDisplayText(FApplicationMenu, AIndex, ADisplayText);
end;

{ TdxBarApplicationMenuButton }

constructor TdxBarApplicationMenuButton.Create(Collection: TCollection);
begin
  inherited Create(Collection);

  FInternalItem := TdxBarApplicationMenuButtonItem.Create(Self.Collection.FApplicationMenu.BarManager);
  InternalItem.Visible := ivNever;
  InternalItem.OnClick := ButtonClick;
  BarDesignController.RemoveItemFromBarManagerList(FInternalItem);

  FNotifyList := TdxBarComponentList.Create;
  FNotifyList.OnComponentListChanged := ExternalItemChanged;
end;

destructor TdxBarApplicationMenuButton.Destroy;
begin
  FreeAndNil(FNotifyList);
  FreeAndNil(FInternalItem);
  inherited Destroy;
end;

procedure TdxBarApplicationMenuButton.Assign(Source: TPersistent);
var
  ASource: TdxBarApplicationMenuButton;
begin
  if Source is TdxBarApplicationMenuButton then
  begin
    ASource := TdxBarApplicationMenuButton(Source);
    Width := ASource.Width;
    Item := ASource.Item;
  end
  else
    inherited Assign(Source);
end;

function TdxBarApplicationMenuButton.GetCollection: TdxBarApplicationMenuButtons;
begin
  Result := TdxBarApplicationMenuButtons(inherited Collection);
end;

function TdxBarApplicationMenuButton.GetWidth: Integer;
begin
  Result := FInternalItem.Width;
end;

procedure TdxBarApplicationMenuButton.SetItem(Value: TdxBarButton);
begin
  if FExternalItem <> Value then
  begin
    FNotifyList.BeginUpdate;
    try
      FNotifyList.Extract(FExternalItem);
      FNotifyList.Add(Value);
      FExternalItem := Value;
    finally
      FNotifyList.EndUpdate;
    end;
  end;
end;

procedure TdxBarApplicationMenuButton.SetWidth(Value: Integer);
begin
  InternalItem.Width := Value;
end;

procedure TdxBarApplicationMenuButton.ButtonClick(Sender: TObject);
begin
  if Item <> nil then
    CallNotify(Item.OnClick, Item);
end;

procedure TdxBarApplicationMenuButton.ExternalItemChanged(Sender: TObject;
  AComponent: TComponent; AAction: TcxComponentCollectionNotification);
begin
  if AAction = ccnExtracted then
    Item := nil
  else
    UpdateInternalItem;
end;

procedure TdxBarApplicationMenuButton.UpdateInternalItem;
var
  AItem: TdxBarButton;
begin
  AItem := Item;
  if Item <> nil then
  begin
    InternalItem.Caption := AItem.Caption;
    InternalItem.Enabled := AItem.Enabled;
    InternalItem.Glyph := AItem.Glyph;
    InternalItem.Hint := AItem.Hint;
    InternalItem.ImageIndex := AItem.ImageIndex;
    InternalItem.ScreenTip := AItem.ScreenTip;
    InternalItem.Visible := AItem.Visible;
  end
  else
  begin
    InternalItem.Caption := '';
    InternalItem.Enabled := True;
    InternalItem.Glyph := nil;
    InternalItem.Hint := '';
    InternalItem.ImageIndex := -1;
    InternalItem.ScreenTip := nil;
    InternalItem.Visible := ivNever;
  end;
end;

{ TdxBarApplicationMenuButtons }

constructor TdxBarApplicationMenuButtons.Create(AApplicationMenu: TdxBarCustomApplicationMenu);
begin
  inherited Create(TdxBarApplicationMenuButton);
  FApplicationMenu := AApplicationMenu;
end;

function TdxBarApplicationMenuButtons.Add: TdxBarApplicationMenuButton;
begin
  Result := TdxBarApplicationMenuButton(inherited Add);
end;

function TdxBarApplicationMenuButtons.Insert(AIndex: Integer): TdxBarApplicationMenuButton;
begin
  Result := TdxBarApplicationMenuButton(inherited Insert(AIndex));
end;

function TdxBarApplicationMenuButtons.GetOwner: TPersistent;
begin
  Result := FApplicationMenu;
end;

function TdxBarApplicationMenuButtons.GetItem(Index: Integer): TdxBarApplicationMenuButton;
begin
  Result := TdxBarApplicationMenuButton(inherited GetItem(Index));
end;

procedure TdxBarApplicationMenuButtons.SetItem(Index: Integer; Value: TdxBarApplicationMenuButton);
begin
  inherited SetItem(Index, Value);
end;

procedure TdxBarApplicationMenuButtons.PopulateItemLinks(AItemLinks: TdxBarItemLinks);
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
    AItemLinks.Add(Items[I].InternalItem);
end;

{ TdxBarApplicationMenuButtonItemLinks }

procedure TdxBarApplicationMenuButtonItemLinks.CalcItemsRects(ARect: TRect);
const
  ApplicationMenuButtonsControlOffset = 6; // !!!
var
  I: Integer;
  AItemLink: TdxBarItemLink;
  AItemRect: TRect;
  AOffsetItemBounds: Integer;
begin
  EmptyItemRects;
  AItemRect := ARect;
  for I := 0 to VisibleItemCount - 1 do
  begin
    AItemLink := VisibleItems[I];
    AItemLink.CreateControl;
    AItemRect.Right := AItemRect.Left + AItemLink.Control.Width;
    if AItemRect.Right > ARect.Right then
      Break;
    AItemLink.ItemRect := AItemRect;
    AItemRect.Left := AItemRect.Right + ApplicationMenuButtonsControlOffset;
  end;
  if RealVisibleItemCount > 0 then
    AOffsetItemBounds := ARect.Right - VisibleItems[RealVisibleItemCount - 1].ItemRect.Right
  else
    AOffsetItemBounds := 0;
  for I := 0 to RealVisibleItemCount - 1 do
  begin
    AItemLink := VisibleItems[I];
    AItemLink.ItemRect := cxRectOffsetHorz(AItemLink.ItemRect, AOffsetItemBounds);
  end;
end;

function TdxBarApplicationMenuButtonItemLinks.IsScrollable: Boolean;
begin
  Result := False;
end;

{ TdxBarCustomApplicationMenu }

constructor TdxBarCustomApplicationMenu.Create(AOwner: TComponent);
begin
  inherited;
  FExtraPane := TdxBarApplicationMenuExtraPane.Create(Self);
  FButtons := TdxBarApplicationMenuButtons.Create(Self);
end;

destructor TdxBarCustomApplicationMenu.Destroy;
begin
  FreeAndNil(FButtons);
  FreeAndNil(FExtraPane);
  inherited;
end;

function TdxBarCustomApplicationMenu.GetControlClass: TCustomdxBarControlClass;
begin
  Result := TdxBarApplicationMenuControl;
end;

function TdxBarCustomApplicationMenu.GetItemLinksClass: TdxBarItemLinksClass;
begin
  Result := TdxBarApplicationMenuItemLinks;
end;

function TdxBarCustomApplicationMenu.IsShortCut(AShortCut: TShortCut): Boolean;
begin
  Result := ItemLinks.IsShortCut(AShortCut);
end;

function TdxBarCustomApplicationMenu.GetExtraPaneWidthRatio: Double;
begin
  Result := FExtraPane.WidthRatio;
end;

function TdxBarCustomApplicationMenu.GetExtraPaneSize: Integer;
begin
  Result := FExtraPane.Size;
end;

function TdxBarCustomApplicationMenu.GetExtraPaneItems: TdxBarExtraPaneItems;
begin
  Result := FExtraPane.Items;
end;

function TdxBarCustomApplicationMenu.GetExtraPaneHeader: string;
begin
  Result := FExtraPane.Header;
end;

function TdxBarCustomApplicationMenu.GetOnExtraPaneItemClick: TdxBarExtraPaneNotifyEvent;
begin
  Result := FExtraPane.OnItemClick;
end;

procedure TdxBarCustomApplicationMenu.SetButtons(AValue: TdxBarApplicationMenuButtons);
begin
  FButtons.Assign(AValue);
end;

procedure TdxBarCustomApplicationMenu.SetExtraPane(AValue: TdxBarApplicationMenuExtraPane);
begin
  FExtraPane.Assign(AValue);
end;

procedure TdxBarCustomApplicationMenu.SetExtraPaneWidthRatio(AValue: Double);
begin
  FExtraPane.WidthRatio := AValue;
end;

procedure TdxBarCustomApplicationMenu.SetExtraPaneSize(AValue: Integer);
begin
  FExtraPane.Size := AValue;
end;

procedure TdxBarCustomApplicationMenu.SetExtraPaneItems(AValue: TdxBarExtraPaneItems);
begin
  FExtraPane.Items := AValue;
end;

procedure TdxBarCustomApplicationMenu.SetExtraPaneHeader(AValue: string);
begin
  FExtraPane.Header := AValue;
end;

procedure TdxBarCustomApplicationMenu.SetOnExtraPaneItemClick(AValue: TdxBarExtraPaneNotifyEvent);
begin
 FExtraPane.OnItemClick := AValue;
end;

{ TdxDockControl }

constructor TdxDockControl.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FBackgroundBitmap := dxBarCreateBitmap(BitmapChanged);
  FBackgroundTempBitmap := TBitmap.Create;
  ParentColor := True;
  FAllowDocking := True;
  FRowMarginSize := InsertZone;
  FRowList := TList.Create;
end;

constructor TdxDockControl.CreateEx(AOwner: TComponent;
  ABarManager: TdxBarManager; ADockStyle: TdxBarDockingStyle);
const
  Styles: array[dsLeft..dsBottom] of TAlign =
    (alLeft, alTop, alRight, alBottom);
begin
  Create(AOwner);
  Align := Styles[ADockStyle];
  ControlStyle := [csDoubleClicks, csNoDesignVisible];
  if ADockStyle = dsTop then
    ControlStyle := ControlStyle + [csActionClient];
  FDockingStyle := ADockStyle;
  BarManager := ABarManager;
end;

destructor TdxDockControl.Destroy;
begin
//#DG  Destroying;
  BarAccessibilityHelperOwnerObjectDestroyed(FIAccessibilityHelper);
  BarManager := nil;
  while RowCount <> 0 do
  begin
    while Rows[0].ColCount <> 0 do
      Rows[0].DeleteCol(0);
    Rows[0].Free;
    RowList.Delete(0);
  end;
  FreeAndNil(FRowList);
  FreeAndNil(FBackgroundTempBitmap);
  FreeAndNil(FBackgroundBitmap);
  inherited Destroy;
end;

procedure TdxDockControl.BitmapChanged(Sender: TObject);
begin
  Invalidate;
  UpdateDoubleBuffered;
  RepaintBarControls;
end;

function TdxDockControl.GetBars: TdxBars;
begin
  if FBarManager = nil then
    Result := nil
  else
    Result := FBarManager.Bars;
end;

function TdxDockControl.GetDockingStyle: TdxBarDockingStyle;
const
  Styles: array[TAlign] of TdxBarDockingStyle =
    (dsTop, dsTop, dsBottom, dsLeft, dsRight, dsTop{$IFDEF DELPHI6}, dsTop{$ENDIF});
begin
  Result := Styles[Align];
end;

function TdxDockControl.GetHorizontal: Boolean;
begin
  Result := DockingStyle in [dsTop, dsBottom];
end;

function TdxDockControl.GetIAccessibilityHelper: IdxBarAccessibilityHelper;
begin
  if FIAccessibilityHelper = nil then
    FIAccessibilityHelper := GetAccessibilityHelper(GetAccessibilityHelperClass.Create(Self));
  Result := FIAccessibilityHelper;
end;

function TdxDockControl.GetIsDesigning: Boolean;
begin
  Result := csDesigning in ComponentState;
end;

function TdxDockControl.GetIsLoading: Boolean;
begin
  Result := csLoading in ComponentState;
end;

function TdxDockControl.GetMain: Boolean;
begin
  Result := FDockingStyle <> dsNone;
end;

function TdxDockControl.GetRow(Index: Integer): TdxDockRow;
begin
  Result := FRowList[Index];
end;

function TdxDockControl.GetRowCount: Integer;
begin
  Result := FRowList.Count;
end;

function TdxDockControl.GetTopLeft: Boolean;
begin
  Result := DockingStyle in [dsLeft, dsTop];
end;

function TdxDockControl.GetVertical: Boolean;
begin
  Result := DockingStyle in [dsLeft, dsRight];
end;

procedure TdxDockControl.SetBarManager(Value: TdxBarManager);
begin
  if FBarManager <> Value then
  begin
    if FBarManager <> nil then
      FBarManager.RemoveDockControl(Self);
    FBarManager := Value;
    if FBarManager <> nil then
      FBarManager.AddDockControl(Self);
    BarManagerChanged;
  end;
end;

procedure TdxDockControl.SetBackgroundBitmap(Value: TBitmap);
var
  AChanged: Boolean;
begin
  AChanged := not ((Value = nil) and FBackgroundBitmap.Empty);
  FBackgroundBitmap.Assign(Value);
  if AChanged then
    BitmapChanged(nil);
end;

procedure TdxDockControl.WMDestroy(var Message: TMessage);
begin
  if FBarManager <> nil then
    FBarManager.CreateBarRestoringList;
  inherited;
end;

procedure TdxDockControl.WMEraseBkgnd(var Message: TWMEraseBkgnd);
var
  R: TRect;
begin
  R := ClientRect;
  FillBackground(Message.DC, R, R, 0, Color);
  Message.Result := 1;
end;

procedure TdxDockControl.WMGetObject(var Message: TMessage);
begin
//  if CanReturnAccessibleObject(Message) then
//    Message.Result := WMGetObjectResultFromIAccessibilityHelper(Message, IAccessibilityHelper)
//  else
    inherited;
end;

procedure TdxDockControl.WMLButtonDblClk(var Message: TWMLButtonDblClk);
begin
  if (FBarManager <> nil) and FBarManager.CanCustomize then
    FBarManager.Customizing(True);
  Message.Result := 0;
end;

procedure TdxDockControl.WMMouseActivate(var Message: TWMMouseActivate);
begin
  inherited;
  if (FBarManager <> nil) and not IsDesigning and (GetParentPopupWindow(Self, True) = nil) then
  begin
    Message.Result := MA_NOACTIVATE;
    dxSetZOrder(MainForm.Handle, HWND_TOP, True);
  end;
end;

procedure TdxDockControl.WMNCCalcSize(var Message: TWMNCCalcSize);
begin
  inherited;
  if SunkenBorder then
    InflateRect(Message.CalcSize_Params.rgrc[0], -1, -1);
end;

procedure TdxDockControl.WMNCPaint(var Message: TWMNCPaint);
var
  R: TRect;
  DC: HDC;
begin
  inherited;
  if SunkenBorder then
  begin
    R := cxGetWindowRect(Handle);
    OffsetRect(R, -R.Left, -R.Top);
    DC := GetWindowDC(Handle);
    DrawEdge(DC, R, BDR_SUNKENOUTER, BF_RECT);
    ReleaseDC(Handle, DC);
  end;
end;

procedure TdxDockControl.WMSize(var Message: TWMSize);
begin
  ResetBackground;
  inherited;
end;

procedure TdxDockControl.WMRButtonDown(var Message: TWMRButtonDown);
begin
  inherited;
  if (FBarManager <> nil) and not FBarManager.IsCustomizing then
    ShowCustomizePopup;
end;

procedure TdxDockControl.WMWindowPosChanged(var Message: TWMWindowPosChanged);
var
  I, J: Integer;
begin
  inherited;
  if (BarManager <> nil) and
    (Message.WindowPos^.flags and (SWP_NOMOVE or SWP_NOSIZE) <> SWP_NOMOVE or SWP_NOSIZE) then
  begin
    Inc(BarManager.FLockUpdateCount);
    try
      if DockingStyle = dsBottom then
        for I := 0 to RowCount - 1 do
          for J := 0 to Rows[I].ColCount - 1 do
            with Rows[I].Cols[J].BarControl do
              if Bar.IsStatusBar then RebuildBar;
    finally
      Dec(BarManager.FLockUpdateCount);
    end;
    if IsTransparent then
      RepaintBarControls;
  end;
end;

procedure TdxDockControl.CMSysColorChange(var Message: TMessage);
begin
  inherited;
  if IsWin9X and Main and (DockingStyle = dsLeft) then
    BarManager.OwnerWndProc(0, WM_SYSCOLORCHANGE, 0, 0);
end;

procedure TdxDockControl.AlignControls(AControl: TControl; var Rect: TRect);
begin
  if (FBarManager <> nil) and not FBarManager.IsLoading then
    UpdateDock;
end;

procedure TdxDockControl.CreateParams(var Params: TCreateParams);
begin
  inherited CreateParams(Params);
  with Params do
  begin
    Style := WS_CHILD or WS_CLIPCHILDREN or WS_CLIPSIBLINGS;
    ExStyle := 0;
    WindowClass.Style := CS_DBLCLKS;
  end;
end;

procedure TdxDockControl.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = BarManager) then
    BarManager := nil;
end;

procedure TdxDockControl.RequestAlign;
begin
  if not (csDestroyingHandle in ControlState) then
    inherited;
end;

procedure TdxDockControl.AddBarControl(ABarControl: TdxBarControl; APos: TPoint;
  Update: Boolean);
var
  Ins: Boolean;
  ARow, ACol, I: Integer;
  DockRow: TdxDockRow;
  DockCol: TdxDockCol;
begin
  if BarManager = nil then
    Exit;
  Ins := False;
  ARow := 0;

  if ABarControl <> nil then
  begin
    if not ABarControl.InternallyLocked then
      ARow := GetRowAtPos(APos, Ins)
    else
      if ABarControl.Bar <> nil then
      begin
        if IsMultiRow then
          ARow := ABarControl.Bar.Row
        else
          ARow := 0;
        Ins := ABarControl.Bar.OneOnRow;
      end;
    if (ABarControl.Bar <> nil) and ABarControl.Bar.WholeRow then
      Ins := True;
  end;

  if ABarControl.InternallyLocked and (BarManager.BarsLoading or BarManager.IsHandleCreating) and
    (ARow > FRowList.Count - 1) then
    for I := FRowList.Count to ARow do
      FRowList.Insert(I, TdxDockRow.Create(Self))
  else
  begin
    if ARow > FRowList.Count - 1 + Byte(Ins) then
    begin
      //Ins := True;
      ARow := FRowList.Count - Byte(not Ins){!};
    end;
    if ARow < 0 then ARow := 0;
  end;
  if ARow >= FRowList.Count then Ins := True;

  if not Ins then
    for I := 0 to Rows[ARow].ColCount - 1 do
      with Rows[ARow].Cols[I] do
        if BarControl.Bar.WholeRow and (BarControl <> ABarControl) then
        begin
          Ins := True;
          Break;
        end;

//  if (ABarControl <> nil) and (ABarControl.DockControl = Self) and
//    (ABarControl.Bar <> nil) and (ABarControl.Bar.DockRow <> nil) and
//    (RowList.IndexOf(ABarControl.Bar.DockRow) = ARow) then
//      Ins := False;

  if Ins then
  begin
    if ABarControl.InternallyLocked and (BarManager.BarsLoading or BarManager.IsHandleCreating) then
      DockRow := Rows[ARow]
    else
    begin
      DockRow := TdxDockRow.Create(Self);
      FRowList.Insert(ARow, DockRow);
    end;
    DockCol := DockRow.AddCol(ABarControl);
    ABarControl.FBar.SetDockRow(DockRow);
  end
  else
  begin
    DockCol := TdxDockCol.Create(TdxDockRow(FRowList[ARow]), ABarControl);
    ACol := GetColAtPos(ARow, APos);
    GetColAtPos(ARow, APos);
    Rows[ARow].ColList.Insert(ACol, DockCol);
    Rows[ARow].UpdateOneOnRows;
    ABarControl.FBar.SetDockRow(Rows[ARow]);
  end;

  if not ABarControl.InternallyLocked then
  begin
    with Bars, FMovingOffset do
      if FMoving then
      begin
        Dec(APos.X, X);
        Dec(APos.Y, Y);
      end;
    with ABarControl, GetDragPointOffset(DockingStyle) do
    begin
      Dec(APos.X, X);
      Dec(APos.Y, Y);
    end;
  end;

  Windows.ScreenToClient(Handle, APos);
  case Horizontal of
    True:
      if APos.X < 0 then APos.X := 0;
    False:
      if APos.Y < 0 then APos.Y := 0;
  end;

  DockCol.FPos := APos;

  if Update then
  begin
    if not {Bars.}ABarControl.FMoving then
      with ABarControl do
      begin
        Left := APos.X;
        Top := APos.Y;
      end;
    UpdateDock;
    if not BarManager.BarsLoading and not BarManager.IsHandleCreating then
      DockCol.AssignPosition;
  end;
end;

procedure TdxDockControl.DeleteBarControl(ABarControl: TdxBarControl; ADockCol: TObject;
  Update: Boolean);
var
  I, J: Integer;

  procedure DeleteCol;
  begin
    Rows[I].DeleteCol(J);
    if Update then
      UpdateDock;
  end;

var
  ADockRow: TdxDockRow;
begin
  if BarManager = nil then
    Exit;
  for I := 0 to RowCount - 1 do
  begin
    ADockRow := Rows[I];
    if ADockCol <> nil then
    begin
      J := ADockRow.ColList.IndexOf(ADockCol);
      if J > -1 then
      begin
        DeleteCol;
        Exit;
      end;
    end
    else
      for J := 0 to ADockRow.ColCount - 1 do
        if ADockRow.Cols[J].BarControl = ABarControl then
        begin
          DeleteCol;
          Exit;
        end;
  end;
end;

procedure TdxDockControl.MoveBarControl(ABarControl: TdxBarControl; APos: TPoint);
var
  DockCol: Pointer;
begin
  if FBarManager = nil then Exit;
  DockCol := Rows[ABarControl.GetRow].Cols[ABarControl.GetCol];
  DeleteBarControl(ABarControl, DockCol, False);
  AddBarControl(ABarControl, APos, True);
  if IsTransparent then
  begin
    ResetBackground;
    RepaintBarControls;
  end;  
end;

procedure TdxDockControl.AssignPositions;
var
  I, J: Integer;
begin
  for I := 0 to RowCount - 1 do
    with Rows[I] do
      for J := 0 to ColCount - 1 do
        Cols[J].AssignPosition;
end;

procedure TdxDockControl.BarManagerChanged;
begin
  ResetBackground;
end;

procedure TdxDockControl.CalcLayout;
var
  AClientSize, I: Integer;
begin
  if Vertical then
    AClientSize := ClientHeight
  else
    AClientSize := ClientWidth;
  for I := 0 to RowCount - 1 do
    if Rows[I].Visible then
      CalcRowToolbarPositions(I, AClientSize);
end;

procedure TdxDockControl.CalcRowToolbarPositions(ARowIndex: Integer;
  AClientSize: Integer);

  function RotatePoint(const APoint: TPoint): TPoint;
  begin
    Result := Point(APoint.Y, APoint.X);
  end;

  function GetMinSize(ABarControl: TdxBarControl): Integer;
  begin
    if Vertical then
      Result := ABarControl.GetMinHeight(DockingStyle)
    else
      Result := ABarControl.GetMinWidth(DockingStyle);
  end;

  function GetMaxSizeX(ABarControl: TdxBarControl): Integer;
  begin
    if Vertical then
      Result := ABarControl.GetMaxHeight(DockingStyle)
    else
      Result := ABarControl.GetMaxWidth(DockingStyle);
  end;

  function GetMaxSizeY(ABarControl: TdxBarControl): Integer;
  begin
    if Vertical then
      Result := ABarControl.GetMaxWidth(DockingStyle)
    else
      Result := ABarControl.GetMaxHeight(DockingStyle);
  end;

  function NCSizeX(ABarControl: TdxBarControl): Integer;
  begin
    if Vertical then
      Result := ABarControl.Bar.BarNCSizeY(DockingStyle)
    else
      Result := ABarControl.Bar.BarNCSizeX(DockingStyle);
  end;

  function NCSizeY(ABarControl: TdxBarControl): Integer;
  begin
    if Vertical then
      Result := ABarControl.Bar.BarNCSizeX(DockingStyle)
    else
      Result := ABarControl.Bar.BarNCSizeY(DockingStyle);
  end;

  function GetFullSize(ABarControl: TdxBarControl; ASize: Integer): TPoint;
  begin
    Dec(ASize, NCSizeX(ABarControl));
    if not Painter.BarAllowQuickCustomizing then
      Dec(ASize, ABarControl.GetMarkSize);
    if Vertical then
      Result := RotatePoint(ABarControl.GetSizeForHeight(DockingStyle, ASize))
    else
      Result := ABarControl.GetSizeForWidth(DockingStyle, ASize);
  end;

  procedure CalcDefaultParams(ARow: TdxDockRow; out AWidthSum: Integer);
  var
    I: Integer;
    ABarControl: TdxBarControl;
  begin
    AWidthSum := 0;
    for I := 0 to ARow.ColCount - 1 do
    begin
      ABarControl := ARow.Cols[I].BarControl;
      ABarControl.FTruncated := False;
      ABarControl.ItemLinks.RecentItemCount := -1;
      ABarControl.FMinSize := GetMinSize(ABarControl) + NCSizeX(ABarControl);
      ABarControl.FMaxSize := GetMaxSizeX(ABarControl) + NCSizeX(ABarControl);
      if not ABarControl.MarkExists and (ABarControl.FMinSize <> ABarControl.FMaxSize) then
        Inc(ABarControl.FMinSize, ABarControl.MarkSize);
      Inc(AWidthSum, ABarControl.FMaxSize);
    end;
  end;

  procedure CalcNewBoundsForWholeRowBar(ARow: TdxDockRow; const ARowBounds: TRect; ARowWidth: Integer; var AMaxHeight: Integer);
  var
    ABarControl: TdxBarControl;
  begin
    ABarControl := ARow.Cols[0].BarControl;
    ABarControl.NewLeft := ARowBounds.Left;
    ABarControl.NewTop := ARowBounds.Top;
    ABarControl.NewWidth := Max(ARowWidth, ABarControl.FMinSize);
    ABarControl.NewHeight := GetFullSize(ABarControl, ABarControl.NewWidth).Y + NCSizeY(ABarControl);
    ABarControl.FTruncated := not ABarControl.MultiLine and (ABarControl.NewWidth < ABarControl.FMaxSize);
    AMaxHeight := Max(AMaxHeight, ABarControl.NewHeight);
  end;

  procedure CalcNewBoundsForLocatedBars(ARow: TdxDockRow; const ARowBounds: TRect; ARowWidth: Integer; var AMaxHeight: Integer);
  var
    I, J: Integer;
    AMargin, AFixedSize, ANewLeft: Integer;
    ACol: TdxDockCol;
    ABarControl: TdxBarControl;
  begin
    AMargin := ARowWidth;
    for I := ARow.ColCount - 1 downto 0 do
    begin
      ACol := ARow.Cols[I];
      ABarControl := ACol.BarControl;
      ABarControl.NewTop := ARowBounds.Top;
      ABarControl.NewWidth := ABarControl.FMaxSize;
      if ABarControl.MultiLine then
        ABarControl.NewHeight := GetFullSize(ABarControl, ABarControl.NewWidth).Y
      else
        ABarControl.NewHeight := GetMaxSizeY(ABarControl);
      Inc(ABarControl.NewHeight, NCSizeY(ABarControl));
      AMaxHeight := Max(AMaxHeight, ABarControl.NewHeight);

      AFixedSize := 0;
      for J := 0 to I - 1 do
        Inc(AFixedSize, ARow.Cols[J].BarControl.FMaxSize);
      ANewLeft := IfThen(Vertical, ACol.Pos.Y, ACol.Pos.X);
      if ANewLeft + ABarControl.NewWidth > AMargin then
        ANewLeft := AMargin - ABarControl.NewWidth;
      ABarControl.NewLeft := Max(ANewLeft, AFixedSize);
      AMargin := ABarControl.NewLeft;
    end;
  end;

  procedure CalcNewBoundsForNonLocatedBars(ARow: TdxDockRow; const ARowBounds: TRect; ARowWidth: Integer; var AMaxHeight: Integer);
  var
    I, K: Integer;
    ASize, ARestSize, AFixedSize, AMaxFixedSize, AMinSize, AMaxSize: Integer;
    ACol, APrevCol: TdxDockCol;
    ABarControl, APrevBarControl: TdxBarControl;
  begin
    ASize := ARowWidth;
    for I := ARow.ColCount - 1 downto 0 do
    begin
      ACol := ARow.Cols[I];
      ABarControl := ACol.BarControl;
      if Vertical then
        AFixedSize := ACol.Pos.Y
      else
        AFixedSize := ACol.Pos.X;
      AMinSize := 0;
      AMaxSize := 0;
      for K := I - 1 downto 0 do
      begin
        Inc(AMinSize, ARow.Cols[K].BarControl.FMinSize);
        Inc(AMaxSize, ARow.Cols[K].BarControl.FMaxSize);
      end;
      AFixedSize := Min(Max(AFixedSize, AMinSize), AMaxSize);
      if (I > 0) and (ARow.Cols[I - 1].BarControl = Bars.FMovingBarControl) then
      begin
        APrevCol := ARow.Cols[I - 1];
        APrevBarControl := APrevCol.BarControl;
        AMaxFixedSize := IfThen(Vertical, APrevCol.Pos.Y, APrevCol.Pos.X);
        AMaxFixedSize := Max(AMaxFixedSize, AMinSize - APrevBarControl.FMinSize);
        Inc(AMaxFixedSize, APrevBarControl.FMaxSize);
        if AFixedSize > AMaxFixedSize then
        begin
          if Vertical then
            ACol.FPos.Y := AMaxFixedSize
          else
            ACol.FPos.X := AMaxFixedSize;
          AFixedSize := AMaxFixedSize;
        end;
      end;
      ARestSize := ASize - AFixedSize;

      if ARestSize >= ABarControl.FMaxSize then
      begin
        ABarControl.NewWidth := ABarControl.FMaxSize;
        if ABarControl.MultiLine then
          ABarControl.NewHeight := GetFullSize(ABarControl, ABarControl.NewWidth).Y
        else
          ABarControl.NewHeight := GetMaxSizeY(ABarControl);
      end
      else
      begin
        ABarControl.FTruncated := not ABarControl.MultiLine and (ABarControl.FMinSize <> ABarControl.FMaxSize);
        ABarControl.NewWidth := Max(ARestSize, ABarControl.FMinSize);
        ABarControl.NewHeight := GetFullSize(ABarControl, ABarControl.NewWidth).Y;
      end;

      if (I = 0) and (ABarControl.NewWidth < ASize) then
        ABarControl.NewWidth := ASize;
      ABarControl.NewLeft := Min(Max(ASize - ABarControl.NewWidth, AMinSize), AMaxSize);
      ABarControl.NewTop := ARowBounds.Top;
      Inc(ABarControl.NewHeight, NCSizeY(ABarControl));
      AMaxHeight := Max(AMaxHeight, ABarControl.NewHeight);

      Dec(ASize, ABarControl.NewWidth);
    end;
  end;

  procedure CalcNewBoundsForAutoAlignBars(ARow: TdxDockRow);
  var
    I: Integer;
    ABarControl: TdxBarControl;
  begin
    for I := 0 to ARow.ColCount - 1 do
    begin
      ABarControl := ARow.Cols[I].BarControl;
      if ABarControl.Bar.UseRestSpace or BarManager.AutoAlignBars then
      begin
        if I = 0 then
          ABarControl.NewLeft := 0
        else
          ABarControl.NewLeft := ARow.Cols[I - 1].BarControl.NewLeft + ARow.Cols[I - 1].BarControl.NewWidth;
      end;

      if ABarControl.Bar.UseRestSpace then
      begin
        if I = ARow.ColCount - 1 then
          ABarControl.NewWidth := AClientSize - ABarControl.NewLeft
        else
          ABarControl.NewWidth := ARow.Cols[I + 1].BarControl.NewLeft - ABarControl.NewLeft;
        ABarControl.NewWidth := Max(ABarControl.NewWidth, ABarControl.FMinSize);
      end;
    end;
  end;

  procedure SetNewBounds(ARow: TdxDockRow; AMaxHeight: Integer);
  var
    I, ATemp: Integer;
    ABarControl: TdxBarControl;
  begin
    for I := 0 to ARow.ColCount - 1 do
    begin
      ABarControl := ARow.Cols[I].BarControl;
      if ABarControl.FTruncated and (I = ARow.ColCount - 1) then
        ABarControl.NewWidth := Max(AClientSize - ABarControl.NewLeft, ABarControl.FMinSize);
      ABarControl.NewHeight := AMaxHeight;
      // for the RecentItemCount calculating
      GetFullSize(ABarControl, ABarControl.NewWidth);
      if Vertical then
      begin
        ATemp := ABarControl.NewLeft;
        ABarControl.NewLeft := ABarControl.NewTop;
        ABarControl.NewTop := ATemp;
        ATemp := ABarControl.NewWidth;
        ABarControl.NewWidth := ABarControl.NewHeight;
        ABarControl.NewHeight := ATemp;
      end;
      ABarControl.SetNewBounds;

      ABarControl.CalcLayout;
    end;
  end;

var
  AWidthSum, ARowWidth, AMaxHeight: Integer;
  ARow: TdxDockRow;
  R: TRect;
begin
  ARow := Rows[ARowIndex];
  if ARow.ColCount = 0 then
    Exit;
  R := GetRectForRow(ARowIndex);
  if Vertical then
    R.TopLeft := RotatePoint(R.TopLeft);
  ARowWidth := AClientSize;
  AMaxHeight := 0;

  CalcDefaultParams(ARow, AWidthSum);

  if ARow.Cols[0].BarControl.Bar.WholeRow then
    CalcNewBoundsForWholeRowBar(ARow, R, ARowWidth, AMaxHeight)
  else
    if AWidthSum <= ARowWidth then
      CalcNewBoundsForLocatedBars(ARow, R, ARowWidth, AMaxHeight)
    else
      CalcNewBoundsForNonLocatedBars(ARow, R, ARowWidth, AMaxHeight);

  CalcNewBoundsForAutoAlignBars(ARow);

  SetNewBounds(ARow, AMaxHeight);
end;

function TdxDockControl.CanDocking(Bar: TdxBar): Boolean;
begin
  Result := FAllowDocking;
end;

procedure TdxDockControl.ColorChanged;
begin
  if (FBarManager = nil) or FBarManager.AutoDockColor then
    ParentColor := True
  else
    Color := FBarManager.DockColor;
end;

function TdxDockControl.GetDockZoneBounds: TRect;
begin
  Result := BoundsRect;
  InflateRect(Result, Bars.DockingZoneSize, Byte(Horizontal) * Bars.DockingZoneSize);
  MapWindowRect(GetParent(Handle), 0, Result);
end;

procedure TdxDockControl.GetDockZoneMargins(Row, ZoneNumber: Integer; var M1, M2: Integer);
var
  IM1, IM2: Integer;
begin
  M1 := 0;
  M2 := 0;
  if Row = -1 then
    if TopLeft then
    begin
      M1 := -Bars.DockingZoneSize;
      M2 := 0;
    end
    else
    begin
      if DockingStyle = dsRight then
        M1 := ClientWidth
      else
        M1 := ClientHeight;
      M1 := M1 - GetClientSize - Bars.DockingZoneSize;
      M2 := M1 + Bars.DockingZoneSize;
    end
  else
    if Row = FRowList.Count then
      if TopLeft then
      begin
        M1 := GetClientSize;
        M2 := M1 + Bars.DockingZoneSize;
      end
      else
      begin
        if DockingStyle = dsRight then
          M1 := ClientWidth
        else
          M1 := ClientHeight;
        M2 := M1 + Bars.DockingZoneSize;
      end
    else
      with GetRectForRow(Row) do
        if Horizontal then
        begin
          M1 := Top;
          M2 := Bottom;
        end
        else
        begin
          M1 := Left;
          M2 := Right;
        end;
  case DockingStyle of
    dsLeft, dsTop:
      IM1 := M1 + (Bars.DockingZoneSize - InsertZone div 2) div 2;
    dsRight, dsBottom:
      IM1 := M2 - (Bars.DockingZoneSize - InsertZone div 2) div 2 - InsertZone div 2;
    else
      IM1 := 0;
  end;
  IM2 := IM1 + InsertZone div 2;

  case ZoneNumber of
    0: M2 := IM1;
    1: begin
         M1 := IM1;
         M2 := IM2;
       end;
    2: M1 := IM2;
  end;
end;

function TdxDockControl.GetRectForRow(ARow: Integer): TRect;
var
  I: Integer;
  Origin, Size: Integer;

  function GetRowHeight(ARow: Integer): Integer;
  var
    J: Integer;
  begin
    Result := 0;
    if not Rows[ARow].Visible then
      Exit;
    for J := 0 to Rows[ARow].ColCount - 1 do
      with TdxDockCol(Rows[ARow].Cols[J]).BarControl do
        case Self.DockingStyle of
          dsLeft, dsRight: if Result < Width then Result := Width;
          dsTop, dsBottom: if Result < Height then Result := Height;
        end;
    if  ARow < RowCount - 1 then
      Inc(Result, Painter.BarDockedGetRowIndent);
  end;

begin
  SetRectEmpty(Result);
  if (ARow < 0) or (ARow > FRowList.Count - 1) then Exit;
  Size := 0;
  if not Bars.FMoving or (DockingStyle in [dsLeft, dsTop]) then
  begin
    Origin := 0;
    for I := 0 to ARow do
    begin
      Inc(Origin, Size);
      Size := GetRowHeight(I);
    end;
  end
  else
  begin
    if DockingStyle = dsRight then
      Origin := ClientWidth
    else
      Origin := ClientHeight;
    for I := FRowList.Count - 1 downto ARow do
    begin
      Size := GetRowHeight(I);
      Dec(Origin, Size);
    end;
  end;
  case DockingStyle of
    dsLeft, dsRight:
      Result := Bounds(Origin, 0, Size, ClientHeight);
    dsTop, dsBottom:
      Result := Bounds(0, Origin, ClientWidth, Size);
  end;
end;

function TdxDockControl.GetClientSize: Integer;
var
  I: Integer;
  R: TRect;
begin
  Result := 0;
  case DockingStyle of
    dsLeft, dsRight:
      for I := 0 to FRowList.Count - 1 do
      begin
        R := GetRectForRow(I);
        Inc(Result, R.Right - R.Left);
      end;
    dsTop, dsBottom:
      for I := 0 to FRowList.Count - 1 do
      begin
        R := GetRectForRow(I);
        Inc(Result, R.Bottom - R.Top);
      end;
  end;
end;

function TdxDockControl.GetSize: Integer;
begin
  Result := GetClientSize;
  if (Result > 0) and SunkenBorder then Inc(Result, 2);
end;

function TdxDockControl.GetRowAtPos(APos: TPoint; var Insert: Boolean): Integer;
var
  I, J, Z, M1, M2: Integer;
  Found: Boolean;
begin
  if FRowList.Count = 0 then
  begin
    Result := 0;
    Insert := True;
    Exit;
  end;
  
  Result := -1;
  Insert := False;
  Windows.ScreenToClient(Handle, APos);
  if Vertical then
    Z := APos.X
  else
    Z := APos.Y;
  Found := False;
  for I := -1 to FRowList.Count - 1 do
  begin
    for J := 0 to 2 do
    begin
      GetDockZoneMargins(I, J, M1, M2);
      if (M1 <= Z)  and (Z < M2) then
      begin
        Result := I + Byte(J > 0);
        Insert := J = 1;
        Found := True;
        Break;
      end;
    end;
    if Found then Break;
  end;

  if Result = -1 then
  begin
    Insert := True;
    if Z >= GetClientSize then
      Result := FRowList.Count
    else
      Result := 0;
  end
  else
    if Result >= RowCount then Insert := True;
end;

function TdxDockControl.GetColAtPos(ARow: Integer; APos: TPoint): Integer;
var
  I: Integer;
begin
  Result := 0;
  if (FRowList[ARow] = nil) or
    (Rows[ARow].ColCount = 0) then Exit;
  Windows.ScreenToClient(Handle, APos);
  if Bars.FMoving and not Bars.FMovingBarControl.InternallyLocked then
    with Bars.FMovingBarControl.GetDragPointOffset(DockingStyle) do
      case DockingStyle of
        dsLeft, dsRight:
          Dec(APos.Y, Y);
        dsTop, dsBottom:
          Dec(APos.X, X);
      end;
  with Rows[ARow] do
  begin
    for I := 0 to ColCount - 1 do
      with Cols[I], BarControl.Bar do
        case DockingStyle of
          dsLeft, dsRight:
            if APos.Y <= DockedTop then
            begin
              Result := I;
              Exit;
            end;
          dsTop, dsBottom:
            if APos.X <= DockedLeft then
            begin
              Result := I;
              Exit;
            end;
        end;
    Result := ColCount;
  end;
end;

procedure TdxDockControl.GetPosForRow(Row: Integer; OneOnRow: Boolean; var P: TPoint);
var
  M1, M2, Temp: Integer;
begin
  if OneOnRow and (Row = FRowList.Count) then OneOnRow := False;
  if OneOnRow then
    GetDockZoneMargins(Row - 1, 1, M1, M2)
  else
  begin
    GetDockZoneMargins(Row - 1, 2, M1, Temp);
    GetDockZoneMargins(Row, 0, Temp, M2);
    if Temp - M1 > M2 - Temp then M1 := Temp - (M2 - Temp);
  end;
  Temp := (M1 + M2) div 2;
  Windows.ScreenToClient(Handle, P);
  if Vertical then
    P.X := Temp
  else
    P.Y := Temp;
  Windows.ClientToScreen(Handle, P);
end;

function TdxDockControl.GetSunkenBorder: Boolean;
begin
  if BarManager = nil then
    Result := False
  else
    Result := BarManager.SunkenBorder;
end;

function TdxDockControl.GetMainForm: TCustomForm;
begin
  Result := GetControlForm(Self, fkMain);
  if (Result = nil) and (BarManager <> nil) then // Result.HandleAllocated?
    Result := BarManager.GetMainForm;
end;

function TdxDockControl.GetMasterForm: TCustomForm;
begin
  Result := GetControlForm(Self, fkMainOrMDIChild);
  if (Result = nil) and (BarManager <> nil) then // Result.HandleAllocated?
    Result := BarManager.MasterForm;
end;

function TdxDockControl.GetParentForm: TCustomForm;
begin
  Result := GetControlForm(Self, fkAny);
  if (Result = nil) and (BarManager <> nil) then // Result.HandleAllocated?
    Result := BarManager.ParentForm;
end;

function TdxDockControl.IsMultiRow: Boolean;
begin
  Result := True;
end;

procedure TdxDockControl.NCChanged;
var
  I, J: Integer;
begin
  if not HandleAllocated then Exit;
  SetWindowPos(Handle, 0, 0, 0, 0, 0,
    SWP_NOZORDER or SWP_NOMOVE or SWP_NOSIZE or SWP_NOACTIVATE or SWP_FRAMECHANGED);
  for I := 0 to RowCount - 1 do
    for J := 0 to Rows[I].ColCount - 1 do
      Rows[I].Cols[J].BarControl.FrameChanged{RebuildBar};
  UpdateDock;
end;

procedure TdxDockControl.PaintBarControls;
begin
  if (RowList = nil) or (BarManager = nil) or BarManager.BarsLoading or BarManager.IsDestroying then
    Exit;

  if not BarManager.Designing and HandleAllocated then
    dxSetZOrder(Handle, HWND_TOP);

  DisableAlign;
  try
    CalcLayout;
  finally
    EnableAlign;
  end;
  Repaint;
end;

procedure TdxDockControl.SetSize;

  function Appropriate(var Variable; Value: TObject): Boolean;
  begin
    TObject(Variable) := TObject(Value);
    Result := True;
  end;

  function IsCurrentDockControl(AParentBar: TCustomdxBarControl): Boolean;
  begin
    Result := (AParentBar <> nil) and
      not ((AParentBar is TdxBarControl) and (Self is TdxBarDockControl) and
      not (TdxBarControl(AParentBar).DockControl is TdxBarDockControl) or
      (AParentBar.BarManager <> BarManager) and (Forms.GetParentForm(Self) <> nil));
  end;

var
  ASize, PrevSize: Integer;
  AParentBar: TCustomdxBarControl;
begin
  ASize := GetSize;
  PrevSize := 0;
  case DockingStyle of
    dsLeft, dsRight:
      begin
        PrevSize := Width;
        if DockingStyle = dsRight then
        begin
          Parent.DisableAlign;
          Left := Left - (ASize - Width);
        end;
        Width := ASize;
        if DockingStyle = dsRight then Parent.EnableAlign;
      end;
    dsTop, dsBottom:
      begin
        PrevSize := Height;
        if DockingStyle = dsBottom then
        begin
          Parent.DisableAlign;
          Top := Top - (ASize - Height);
        end;
        Height := ASize;
        if DockingStyle = dsBottom then Parent.EnableAlign;
      end;
  end;
  if Visible and (ASize <> PrevSize) and (ActiveBarControl <> nil) and
    Appropriate(AParentBar, GetParentBarForBar(ActiveBarControl)) and
    not (AParentBar is TdxbarQuickControl) and (ActiveBarControl.Handle <> GetCapture) and
    IsCurrentDockControl(AParentBar) then
      ActiveBarControl.HideAll;
end;

procedure TdxDockControl.ShowCustomizePopup;
begin
  BarDesignController.ShowToolbarsPopup(FBarManager, Painter);
end;

procedure TdxDockControl.UpdateDock;
begin
  if (BarManager <> nil) and not BarManager.IsUpdateLocked and not BarManager.IsDestroying then
  begin
    PaintBarControls;
    SetSize;
  end;
end;

function TdxDockControl.GetDockedBarControlClass: TdxBarControlClass;
begin
  Result := TdxBarControl;
end;

function TdxDockControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxDockControlAccessibilityHelper;
end;

function TdxDockControl.GetPainter: TdxBarPainter;
begin
  Result := BarManager.DefaultPainter;
end;

procedure TdxDockControl.FillBackground(DC: HDC; const ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor);
var
  CR: TRect;
begin
  if not BackgroundBitmap.Empty or (BarManager = nil) then
    FillBackgroundRect(DC, ADestR, ASourceR, ABrush, AColor, BackgroundBitmap)
  else
  begin
    if not BarManager.Backgrounds.Bar.Empty then
      FillBackgroundRect(DC, ADestR, ASourceR, ABrush, AColor, BarManager.Backgrounds.Bar)
    else
    begin
      CR := ClientRect;
      if not IsRectEmpty(CR) then
        Painter.DockControlFillBackground(Self, DC, ADestR, ASourceR, CR, ABrush, AColor)
    end;
  end;
end;

function TdxDockControl.IsBackgroundBitmap: Boolean;
begin
  Result := not BackgroundBitmap.Empty;
end;

function TdxDockControl.IsDrawDesignBorder: Boolean;
begin
  Result := IsDesigning;
end;

function TdxDockControl.IsTransparent: Boolean;
begin
  Result := not BackgroundBitmap.Empty or
    ((BarManager <> nil) and (Painter.IsNativeBackground or
      not BarManager.Backgrounds.Bar.Empty));
end;

procedure TdxDockControl.RepaintBarControls;
var
  I, J: Integer;
begin
  for I := 0 to RowCount - 1 do
    for J := 0 to Rows[I].ColCount - 1 do
      Rows[I].Cols[J].BarControl.FullRepaint;
end;

procedure TdxDockControl.ResetBackground;
begin
  FBackgroundTempBitmap.Assign(nil);
end;

procedure TdxDockControl.UpdateDoubleBuffered;
begin
  DoubleBuffered := IsTransparent;
end;

procedure TdxDockControl.InitiateAction;
var
  I: Integer;
begin
  if FBarManager <> nil then
    with FBarManager do
      for I := 0 to Bars.Count - 1 do
        with Bars[I] do
          if Visible then ItemLinks.InitiateActions;
end;

{ TdxBarDockControl }

constructor TdxBarDockControl.Create(AOwner: TComponent);
begin
  inherited;
  Align := dalTop;
end;

function TdxBarDockControl.GetAlign: TdxBarDockAlign;
begin
  Result := TdxBarDockAlign(inherited Align);
end;

function TdxBarDockControl.GetColor: TColor;
begin
  Result := inherited Color;
end;

function TdxBarDockControl.GetIsLoading: Boolean;
begin
  Result := (csLoading in ComponentState) or (BarManager <> nil) and BarManager.BarsLoading;
end;

function TdxBarDockControl.GetParentColor: Boolean;
begin
  Result := inherited ParentColor;
end;

procedure TdxBarDockControl.SetAlign(Value: TdxBarDockAlign);
const
  Styles: array[TdxBarDockAlign] of TdxBarDockingStyle =
    (dsTop, dsTop, dsBottom, dsLeft, dsRight);
var
  I, J: Integer;
begin
  if Align <> Value then
  begin
    if BarManager <> nil then
      BarManager.BeginUpdate;
    try
      for I := 0 to RowCount - 1 do
        for J := 0 to Rows[I].ColCount - 1 do
          Rows[I].Cols[J].BarControl.DockingStyle := Styles[Value];
      inherited Align := TAlign(Value);
    finally
      if BarManager <> nil then
      begin
        BarManager.EndUpdate;
        for I := 0 to RowCount - 1 do
          for J := 0 to Rows[I].ColCount - 1 do
            Rows[I].Cols[J].BarControl.RepaintBar;
        if Parent <> nil then Parent.Invalidate;
      end;
    end;
  end;
end;

procedure TdxBarDockControl.SetAllowZeroSizeInDesignTime(Value: Boolean);
begin
  if FAllowZeroSizeInDesignTime <> Value then
  begin
    FAllowZeroSizeInDesignTime := Value;
    Perform(WM_SIZE, 0, 0);
  end;
end;

procedure TdxBarDockControl.SetColor(Value: TColor);
begin
  if Color <> Value then
  begin
    inherited Color := Value;
    if not IsLoading then UseOwnColor := True;
  end;
end;

procedure TdxBarDockControl.SetParentColor(Value: Boolean);
begin
  if ParentColor <> Value then
  begin
    inherited ParentColor := Value;
    if not IsLoading then UseOwnColor := True;
  end;
end;

procedure TdxBarDockControl.SetSunkenBorder(Value: Boolean);
begin
  if SunkenBorder <> Value then
  begin
    FSunkenBorder := Value;
    FUseOwnSunkenBorder := True;
    NCChanged;
  end;
end;

procedure TdxBarDockControl.SetUseOwnColor(Value: Boolean);
begin
  if FUseOwnColor <> Value then
  begin
    FUseOwnColor := Value;
    if not Value then ColorChanged;
  end;
end;

procedure TdxBarDockControl.SetUseOwnSunkenBorder(Value: Boolean);
var
  PrevSunkenBorder: Boolean;
begin
  if FUseOwnSunkenBorder <> Value then
  begin
    PrevSunkenBorder := SunkenBorder;
    FUseOwnSunkenBorder := Value;
    if Value then
      FSunkenBorder := PrevSunkenBorder
    else
      if SunkenBorder <> PrevSunkenBorder then NCChanged;
  end;
end;

function TdxBarDockControl.IsColorStored: Boolean;
begin
  Result := FUseOwnColor and not ParentColor;
end;

procedure TdxBarDockControl.WMCreate(var Message: TWMCreate);
begin
  inherited;
  if BarManager <> nil then
    BarManager.ShowBarsFromRestoringList(Self);
end;

procedure TdxBarDockControl.WMSize(var Message: TWMSize);
begin
  inherited;
  if not IsLoading and (RowCount = 0) then
    if Horizontal then
      ClientHeight := GetMinSize
    else
      ClientWidth := GetMinSize;
end;

function TdxBarDockControl.AllowUndockWhenLoadFromIni: Boolean;
begin
  Result := True;
end;

procedure TdxBarDockControl.CreateParams(var Params: TCreateParams);
begin
  inherited;
  if IsDesigning then
    with Params do
      WindowClass.Style := WindowClass.Style or CS_HREDRAW or CS_VREDRAW;
end;

procedure TdxBarDockControl.Paint;
begin
  inherited;
  if IsDrawDesignBorder then
  begin
    Canvas.Brush.Style := bsClear;
    Canvas.Pen.Style := psDot;
    Canvas.Rectangle(0, 0, ClientWidth, ClientHeight);
    Canvas.Pen.Style := psSolid;
    Canvas.Brush.Style := bsSolid;
  end;
end;

procedure TdxBarDockControl.BarManagerChanged;
begin
  inherited;
  if not (csDestroying in ComponentState) then
  begin
    ColorChanged;
    NCChanged;
  end;
end;

function TdxBarDockControl.CanDocking(Bar: TdxBar): Boolean;
begin
  Result := inherited CanDocking(Bar) and
    ((Bar.Control = nil) or not HasAsParent(Handle, Bar.Control.Handle));
end;

procedure TdxBarDockControl.ColorChanged;
begin
  if not FUseOwnColor then
  begin
    inherited;
    FUseOwnColor := False;
  end;
end;

function TdxBarDockControl.GetClientSize: Integer;
begin
  if IsLoading then
    if Horizontal then
      Result := ClientHeight
    else
      Result := ClientWidth
  else
  begin
    Result := inherited GetClientSize;
    if Result = 0 then Result := GetMinSize;
  end;
end;

function TdxBarDockControl.GetMinSize: Integer;
begin
  if IsDesigning and not AllowZeroSizeInDesignTime then
    Result := MinDockSize
  else
    Result := 0;
end;

function TdxBarDockControl.GetSunkenBorder: Boolean;
begin
  if FUseOwnSunkenBorder then
    Result := FSunkenBorder
  else
    Result := inherited GetSunkenBorder;
end;

{ TdxBarShadowPart }

constructor TdxBarShadowPart.CreateEx(AOwner: TdxBarShadow;
  AKind: TdxBarShadowPartKind; ACorners: TdxBarShadowCorners);
begin
  Create(nil);
  FOwner := AOwner;
  FKind := AKind;
  FCorners := ACorners;
  FImage := TBitmap.Create;
end;

destructor TdxBarShadowPart.Destroy;
begin
  FreeAndNil(FImage);
  inherited;
end;

function TdxBarShadowPart.GetControl: TWinControl;
begin
  Result := FOwner.Owner;
end;

function TdxBarShadowPart.GetShadowSize: Integer;
begin
  Result := FOwner.ShadowSize;
end;

function TdxBarShadowPart.GetTransparent: Boolean;
begin
  Result := FOwner.Transparent;
end;

procedure TdxBarShadowPart.WMNCHitTest(var Message: TWMNCHitTest);
begin
  inherited;
  Message.Result := HTTRANSPARENT;
end;

function TdxBarShadowPart.CanShow: Boolean;
begin
  Result := (FCorners = []) or (Width >= ShadowSize) and (Height >= ShadowSize);
end;

procedure TdxBarShadowPart.CreateParams(var Params: TCreateParams);
begin
  inherited;
  with Params do
  begin
    Style := WS_POPUP;
    if Transparent then
      ExStyle := WS_EX_LAYERED
    else
      ExStyle := 0;
    if GetWindowLong(Control.Handle, GWL_EXSTYLE) and WS_EX_TOPMOST <> 0 then
      ExStyle := ExStyle or WS_EX_TOPMOST;
    WndParent := Control.Handle;
    WindowClass.style := 0;
  end;
end;

procedure TdxBarShadowPart.Paint;
begin
  with Canvas do
  begin
    Brush.Color := clBtnShadow;
    FillRect(ClientRect);
  end;
end;

procedure TdxBarShadowPart.UpdateImage;
var
  AColors: TRGBColors;

  function GetAlphaIndex(X, Y: Integer): Integer;
  begin
    Result := Y * Width + X;
  end;

  function GetAlpha(X, Y: Integer): Byte;
  begin
    Result := AColors[GetAlphaIndex(X, Y)].rgbReserved;
  end;

  procedure SetAlpha(X, Y: Integer; Value: Byte);
  begin
    AColors[GetAlphaIndex(X, Y)].rgbReserved := Value;
  end;

  procedure ProcessMainContent;
  const
    AlphaStep = 15;
  var
    X, Y: Integer;
  begin
    for X := 0 to Width - 1 do
      for Y := 0 to Height - 1 do
        if FKind = spHorizontal then
          SetAlpha(X, Y, (Height - Y) * AlphaStep)
        else
          SetAlpha(X, Y, (Width - X) * AlphaStep);
  end;

  procedure ProcessCorners;
  type
    TCornerKind = (ckLeft, ckRight, ckTop);

    procedure ProcessCorner(ACornerKind: TCornerKind);
    var
      I, J, X, Y: Integer;

      procedure ConvertCoordinates;
      begin
        case ACornerKind of
          ckLeft:
            begin
              X := I;
              Y := J;
            end;
          ckRight:
            begin
              X := Width - 1 - I;
              Y := J;
            end;
          ckTop:
            begin
              X := J;
              Y := I;
            end;
        end;
      end;

    begin
      for I := 0 to ShadowSize - 1 do
        for J := 0 to ShadowSize - 1 do
        begin
          ConvertCoordinates;
          SetAlpha(X, Y, MulDiv(GetAlpha(X, Y), 1 + I, 1 + ShadowSize));
        end;
    end;

  begin
    if FKind = spHorizontal then
    begin
      if scLeft in FCorners then
        ProcessCorner(ckLeft);
      if scRight in FCorners then
        ProcessCorner(ckRight);
    end
    else
      if scTop in FCorners then
        ProcessCorner(ckTop);
  end;

begin
  if not CanShow then Exit;
  FImage.PixelFormat := pf32bit;
  FImage.Width := Width;
  FImage.Height := Height;
  SetLength(AColors, Width * Height);
  ProcessMainContent;
  ProcessCorners;
  SetBitmapBits(FImage, AColors, True);
end;

procedure TdxBarShadowPart.Hide;
begin
  if HandleAllocated then
    ShowWindow(Handle, SW_HIDE);
  DestroyHandle;
end;

procedure TdxBarShadowPart.Show;

  procedure MakeAlphaBlended;
  var
    ASize: TSize;
    P: TPoint;
    ABlend: TBlendFunction;
  begin
    ASize := TSize(ClientRect.BottomRight);
    P := cxNullPoint;
    with ABlend do
    begin
      BlendOp := AC_SRC_OVER;
      BlendFlags := 0;
      SourceConstantAlpha := 255;
      AlphaFormat := AC_SRC_ALPHA;
    end;
    UpdateLayeredWindow(Handle, 0, nil, @ASize, FImage.Canvas.Handle, @P, 0, @ABlend, LWA_ALPHA);
    FImage.Dormant;
  end;

begin
  if not CanShow then Exit;
  if Transparent then MakeAlphaBlended;
  dxSetZOrder(Handle, Control.Handle, False, SWP_SHOWWINDOW);
end;

procedure TdxBarShadowPart.UpdateBounds(const ABounds: TRect);
begin
  BoundsRect := ABounds;
  UpdateImage;
  if FOwner.Visible then Show;
end;

{ TdxBarShadow }

constructor TdxBarShadow.Create(AOwner: TWinControl);
begin
  inherited Create;
  FOwner := AOwner;
end;

destructor TdxBarShadow.Destroy;
begin
  DestroyParts;
  inherited;
end;

function TdxBarShadow.GetShadowSize: Integer;
begin
  if Transparent then
    Result := dxBarTransparentShadowSize
  else
    Result := dxBarOpaqueShadowSize;
end;

function TdxBarShadow.GetTransparent: Boolean;
begin
  Result := (@UpdateLayeredWindow <> nil) and (BitsPerPixel > 8);
end;

procedure TdxBarShadow.SetVisible(Value: Boolean);
begin
  if FVisible <> Value then
  begin
    FVisible := Value;
    if FVisible then
      Show
    else
      Hide;
  end;
end;

procedure TdxBarShadow.CreateParts;
var
  APartCount: Integer;

  procedure CreatePart(AKind: TdxBarShadowPartKind; ACorners: TdxBarShadowCorners;
    const ABounds: TRect);
  begin
    if IsRectEmpty(ABounds) then Exit;
    FParts[APartCount] := TdxBarShadowPart.CreateEx(Self, AKind, ACorners);
    FParts[APartCount].UpdateBounds(ABounds);
    Inc(APartCount);
  end;

  procedure CreatePartsForHorizontalMode;
  begin
    if not IsRectEmpty(R1) then
      CreatePart(spVertical, [scTop],
        Rect(R1.Right, R1.Top + ShadowSize, R1.Right + ShadowSize, R1.Bottom));
    CreatePart(spHorizontal, [scLeft, scRight],
      Rect(R2.Left + ShadowSize, R2.Bottom, R2.Right + ShadowSize, R2.Bottom + ShadowSize));

    if not IsRectEmpty(R1) then
    begin
      if R1.Left + ShadowSize < R2.Left then
        CreatePart(spHorizontal, [scLeft],
          Rect(R1.Left + ShadowSize, R1.Bottom, R2.Left, R1.Bottom + ShadowSize));
      if R1.Right > R2.Right then
        CreatePart(spHorizontal, [scRight],
          Rect(R2.Right, R1.Bottom, R1.Right + ShadowSize, R1.Bottom + ShadowSize));
    end;

    if IsRectEmpty(R1) or (R1.Right < R2.Right) then
      CreatePart(spVertical, [scTop],
        Rect(R2.Right, R2.Top + ShadowSize, R2.Right + ShadowSize, R2.Bottom))
    else
      CreatePart(spVertical, [],
        Rect(R2.Right, R2.Top, R2.Right + ShadowSize, R2.Bottom));
  end;

  procedure CreatePartsForVerticalMode;
  begin
    CreatePart(spVertical, [scTop],
      Rect(R2.Right, R2.Top + ShadowSize, R2.Right + ShadowSize, R2.Bottom));

    if R1.Top + ShadowSize < R2.Top then
      CreatePart(spVertical, [scTop],
        Rect(R1.Right, R1.Top + ShadowSize, R1.Right + ShadowSize, R2.Top));

    if R1.Bottom > R2.Bottom then
    begin
      CreatePart(spHorizontal, [scLeft, scRight],
        Rect(R1.Left + ShadowSize, R1.Bottom, R1.Right + ShadowSize, R1.Bottom + ShadowSize));
      CreatePart(spVertical, [],
        Rect(R1.Right, R2.Bottom, R1.Right + ShadowSize, R1.Bottom));
    end
    else
      CreatePart(spHorizontal, [scLeft],
        Rect(R1.Left + ShadowSize, R1.Bottom, R1.Right, R1.Bottom + ShadowSize));

    if R1.Bottom >= R2.Bottom then
      CreatePart(spHorizontal, [scRight],
        Rect(R2.Left, R2.Bottom, R2.Right + ShadowSize, R2.Bottom + ShadowSize))
    else
      CreatePart(spHorizontal, [scLeft, scRight],
        Rect(R2.Left + ShadowSize, R2.Bottom, R2.Right + ShadowSize, R2.Bottom + ShadowSize));
  end;

begin
  APartCount := 0;
  if FHorizontal then
    CreatePartsForHorizontalMode
  else
    CreatePartsForVerticalMode;
end;

procedure TdxBarShadow.DestroyParts;
var
  I: Integer;
begin
  for I := Low(FParts) to High(FParts) do
  begin
    FParts[I].Free;
    FParts[I] := nil;
  end;
end;

procedure TdxBarShadow.Hide;
var
  I: Integer;
begin
  for I := Low(FParts) to High(FParts) do
    if FParts[I] <> nil then FParts[I].Hide;
end;

procedure TdxBarShadow.Show;
var
  I: Integer;
begin
  for I := Low(FParts) to High(FParts) do
    if FParts[I] <> nil then FParts[I].Show;
end;

procedure TdxBarShadow.Refresh;
begin
  DestroyParts;
  CreateParts;
end;

procedure TdxBarShadow.SetOwnerBounds(AR1, AR2: TRect);

  procedure SwapRects;
  var
    R: TRect;
  begin
    R := R1;
    R1 := R2;
    R2 := R;
  end;

begin
  R1 := AR1;
  R2 := AR2;
  FHorizontal := IsRectEmpty(R1) or (R1.Bottom = R2.Top) or (R1.Top = R2.Bottom);
  if FHorizontal and (R1.Top = R2.Bottom) or
    not FHorizontal and (R1.Left = R2.Right) then
    SwapRects;
  Refresh;
end;

{ TCustomdxBarControl }

constructor TCustomdxBarControl.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FCanvas := TcxCanvas.Create(inherited Canvas);
  FViewInfo := GetViewInfoClass.Create(Self);
  AddBarControl(Self);
  ControlStyle := ControlStyle - [csCaptureMouse];
  UpdateControlStyle;
  Color := clBtnFace;
  FLastMousePos := cxInvalidPoint;
  FShadow := TdxBarShadow.Create(Self);
  Visible := False;
  SetBounds(100, 100, 30, 50);
  FBackgroundTempBitmap := TBitmap.Create;
  FViewState := bvsNormal;
end;

destructor TCustomdxBarControl.Destroy;
begin
  BarAccessibilityHelperOwnerObjectDestroyed(FIAccessibilityHelper);
  BarManager.EndMouseTracking(Self);
  DoDestroy;
//#DG <BarManager.SelectedItem>
  if (BarManager <> nil) and (BarManager.FSelectedItem <> nil) and
    (BarManager.FSelectedItem.Parent = Self) then
    BarManager.InternalSetSelectedItem(nil);
  if FItemLinks <> nil then FItemLinks.FBarControl := nil;
  if IsCustomizing and (Self is TdxBarSubMenuControl) then
  begin
    SelectedLink := nil;
    with TdxBarSubMenuControl(Self) do
      if FSubItem <> nil then
        with FSubItem do
        begin
          BarManager.InternalSetSelectedItem(FSubItem);
          FIsActive := False;
          Repaint;
        end;
  end;
  RemoveBarControl(Self);
  cxClearObjectLinks(Self);
  FreeAndNil(FShadow);
  FreeAndNil(FBackgroundTempBitmap);
  FreeAndNil(FViewInfo);
  FreeAndNil(FCanvas);
  FreeAndNil(FActiveCanvas);
  inherited Destroy;
end;

procedure TCustomdxBarControl.BarGetFocus(ASelectedItem: TdxBarItemControl);
begin
  DoBarGetFocus(ASelectedItem);
end;

procedure TCustomdxBarControl.BarLostFocus;
begin
  if IsFocused then
    DoBarLostFocus;
end;

procedure TCustomdxBarControl.BeforeDestruction;
begin
  inherited;
  if (ChildBar <> nil) and not ChildBar.IsDestroying then
    FreeAndNil(FChildBar);
  if ParentBar <> nil then
    ParentBar.ChildBar := nil;
end;

procedure TCustomdxBarControl.MouseDownNotifyControls(
  ALinkAtPos: TdxBarItemLink; const AMousePos: TPoint; Button: TMouseButton;
  Shift: TShiftState);
begin
  if GetControlByLink(ALinkAtPos) <> nil then
    GetControlByLink(ALinkAtPos).MouseDown(Button, Shift, AMousePos.X, AMousePos.Y);
end;

procedure TCustomdxBarControl.MouseNotifyControls(ALinkAtPos: TdxBarItemLink;
  const AMousePos: TPoint; Shift: TShiftState);
begin
  if FPrevTrackedLink <> ALinkAtPos then
  begin
    if GetControlByLink(FPrevTrackedLink) <> nil then
      GetControlByLink(FPrevTrackedLink).MouseLeave;
    FPrevTrackedLink := ALinkAtPos;
    if GetControlByLink(ALinkAtPos) <> nil then
      GetControlByLink(ALinkAtPos).MouseEnter(Shift, AMousePos.X, AMousePos.Y);
  end;
  if GetControlByLink(ALinkAtPos) <> nil then
    GetControlByLink(ALinkAtPos).MouseMove(Shift, AMousePos.X, AMousePos.Y);
end;

procedure TCustomdxBarControl.MouseUpNotifyControls(ALinkAtPos: TdxBarItemLink;
  const AMousePos: TPoint; Button: TMouseButton; Shift: TShiftState);
begin
  if GetControlByLink(ALinkAtPos) <> nil then
    GetControlByLink(ALinkAtPos).MouseUp(Button, Shift, AMousePos.X, AMousePos.Y);
end;

function TCustomdxBarControl.GetActiveCanvas: TcxCanvas;
begin
  if HandleAllocated then
  begin
    if FActiveCanvas <> nil then
    begin
      FreeAndNil(FActiveCanvas);
      UpdateCanvasFont;
    end;
    Result := FCanvas;
  end
  else
  begin
    if FActiveCanvas = nil then
    begin
      FActiveCanvas := TcxScreenCanvas.Create;
      UpdateCanvasFont;
    end;
    Result := FActiveCanvas;
  end;
end;

function TCustomdxBarControl.GetBarControlOwnerBrush: HBRUSH;
begin
  Result := Painter.BarControlOwnerBrush(BarManager);
end;

function TCustomdxBarControl.GetBarManager: TdxBarManager;
begin
  Result := Owner as TdxBarManager;
end;

function TCustomdxBarControl.GetCanvas: TcxCanvas;
begin
  Result := ActiveCanvas;
end;

function TCustomdxBarControl.GetFlat: Boolean;
begin
  // TODO: obsolete
  Result := BarManager.Flat;
end;

function TCustomdxBarControl.GetIsDestroying: Boolean;
begin
  Result := csDestroying in ComponentState;
end;

function TCustomdxBarControl.GetOwnerLinkBounds(AOwnerPart: Boolean): TRect;
var
  AOwnerBounds: TRect;
  AFirstCase: Boolean;

  procedure ConvertRects;

    procedure ConvertRect(var R: TRect);

      procedure ConvertPoint(var P: TPoint);
      var
        APrevX: Integer;
      begin
        with P do
        begin
          APrevX := X;
          X := Y;
          Y := APrevX;
        end;
      end;

    begin
      ConvertPoint(R.TopLeft);
      ConvertPoint(R.BottomRight);
    end;

  begin
    if not FShadow.Horizontal then
    begin
      ConvertRect(Result);
      ConvertRect(AOwnerBounds);
    end;
  end;

begin
  if IsRectEmpty(FOwnerBounds) or not IsLinkedToOwner then
    SetRectEmpty(Result)
  else
  begin
    Result := WindowRect;
    AOwnerBounds := FOwnerBounds;
    with Result do
    begin
      OffsetRect(AOwnerBounds, -Left, -Top);
      OffsetRect(Result, -Left, -Top);
      ConvertRects;

      AFirstCase := AOwnerBounds.Bottom = Top;
      if AFirstCase then
        Bottom := Top + 1
      else
        Top := Bottom - 1;
      if AOwnerPart then
        OffsetRect(Result, 0, -(2 * Ord(AFirstCase) - 1));

      if Left < AOwnerBounds.Left + 1 then
        Left := AOwnerBounds.Left + 1
      else
        Inc(Left);
      if Right > AOwnerBounds.Right - 1 then
        Right := AOwnerBounds.Right - 1
      else
        Dec(Right);

      ConvertRects;
    end;
    if AOwnerPart then
      OffsetRect(Result, Left, Top);
  end;
end;

function TCustomdxBarControl.GetPainterClass: TdxBarPainterClass;
begin
  Result := TdxBarPainterClass(Painter.ClassType);
end;

function TCustomdxBarControl.GetSelectedControlAtDesign: TdxBarItemControl;
begin
  if (BarManager.LastSelectedLinkAtDesign <> nil) and (BarManager.LastSelectedLinkAtDesign.BarControl = Self) then
    Result := BarManager.LastSelectedLinkAtDesign.Control
  else
    Result := nil;
end;

function TCustomdxBarControl.GetSelectedControl: TdxBarItemControl;
begin
  Result := GetControlByLink(SelectedLink);
end;

function TCustomdxBarControl.ItemAtMousePos: TdxBarItemControl;
begin
  Result := ItemAtPos(ScreenToClient(GetMouseCursorPos));
end;

procedure TCustomdxBarControl.SetChildBar(Value: TCustomdxBarControl);

  procedure InternalSetParentBar(AParent, AChild: TCustomdxBarControl);
  begin
    if AChild <> nil then
      AChild.ParentBar := AParent;
  end;

//var
//  APrevChildBar: TCustomdxBarControl;
begin

  FChildBar := Value;
  if (Value <> nil) and (Value.ParentBar <> Self) then
    Value.ParentBar := Self;

{
  if FChildBar <> Value then
  begin
    APrevChildBar := FChildBar;
    FChildBar := Value;
    InternalSetParentBar(nil, APrevChildBar);
    InternalSetParentBar(Self, FChildBar);
  end;
}
end;

procedure TCustomdxBarControl.SetDockControl(Value: TdxDockControl);
begin
  FDockControl := Value;
  UpdateDoubleBuffered; //!
end;

procedure TCustomdxBarControl.SetIsActive(Value: Boolean);
begin
  BarManager.HideHint;
  if (FIsActive <> Value) and CanActiveChange or IsCustomizing and not Value then
    DoSetIsActive(Value);
end;

procedure TCustomdxBarControl.SetParentBar(Value: TCustomdxBarControl);

  procedure InternalSetChidBar(AParent, AChild: TCustomdxBarControl);
  begin
    if AParent <> nil then
      AParent.ChildBar := AChild;
  end;

//var
//  APrevParentBar: TCustomdxBarControl;
begin
  FParentBar := Value;
  if (Value <> nil) and (Value.ChildBar <> Self) then
    Value.ChildBar := Self;

{
  if FParentBar <> Value then
  begin
    APrevParentBar := FParentBar;
    FParentBar := Value;
    InternalSetChidBar(APrevParentBar, nil);
    InternalSetChidBar(FParentBar, Self);
  end;
}
end;

procedure TCustomdxBarControl.SetViewState(Value: TdxBarViewState);
var
  APrevViewState: TdxBarViewState;
begin
  if (Value <> FViewState) and not IsCustomizing then
  begin
    APrevViewState := FViewState;
    FViewState := Value;
    ViewStateChanged(APrevViewState);
  end;
end;

procedure TCustomdxBarControl.WMCaptureChanged(var Message: TMessage);
begin
  inherited;
  if FDragDown then
  begin
    BarManager.DraggingItem := nil;
    BarManager.DraggingItemLink := nil;
    FDragDown := False;
  end;
  FClickedControl := nil;
end;

procedure TCustomdxBarControl.WMDestroy(var Message: TMessage);
begin
  if not IsDestroying then
  begin
    MarkState := msNone;
    BeforeDestroyHandle;
  end;
  inherited;
end;

procedure TCustomdxBarControl.WMEraseBkgnd(var Message: TWMEraseBkgnd);
begin
//  if FItemLinks.CanVisibleItemCount = 0 then // else Fill Rgn is called
//    FillBackground(Message.DC, ClientRect, ToolbarBrush, clNone, True);
  Message.Result := 1;
end;

procedure TCustomdxBarControl.WMKeyDown(var Message: TWMKeyDown);

  procedure NavigationHandler;
  var
    AKey: Word;
    AIsTabKey, ADuplicate: Boolean;
    AItemLink: TdxBarItemLink;
    ATabForward: Boolean;
  begin
    AKey := Message.CharCode;

    if IsRealVertical then
    begin
      case AKey of
        VK_LEFT:
          AKey := VK_UP;
        VK_RIGHT:
          AKey := VK_DOWN;
        VK_UP:
          AKey := VK_LEFT;
        VK_DOWN:
          AKey := VK_RIGHT;
      end;
      Message.CharCode := AKey;
    end;

    if Self is TdxBarSubMenuControl then
      case AKey of
        VK_LEFT, VK_RIGHT:
          AKey := 0;
        VK_UP:
          AKey := VK_LEFT;
        VK_DOWN:
          AKey := VK_RIGHT;
      end;
    AIsTabKey := AKey = VK_TAB;
    ATabForward := False;
    if AIsTabKey then
    begin
      if GetKeyState(VK_CONTROL) < 0 then
        ATabForward := not (GetKeyState(VK_SHIFT) < 0)
      else
        if GetKeyState(VK_SHIFT) < 0 then
          AKey := VK_LEFT
        else
          AKey := VK_RIGHT;
    end;

    case AKey of
      VK_TAB: // + Ctrl
        FocusNextBarControl(ATabForward);
      VK_F10, VK_MENU:
        if (AKey = VK_MENU) or BarManager.UseF10ForMenu then
        begin
          Message.CharCode := 0;
          HideAll;
        end;
      VK_LEFT:
        begin
          if SelectedLink = nil then
            AItemLink := ItemLinks.First
          else
            AItemLink := ItemLinks.Prev(SelectedLink);
          if AItemLink <> nil then SetKeySelectedItem(AItemLink.Control);
          if AIsTabKey and SelectedControl.HasWindow then
            SelectedControl.Click(False);
        end;
      VK_RIGHT:
        begin
          if SelectedLink = nil then
            AItemLink := ItemLinks.First
          else
            AItemLink := ItemLinks.Next(SelectedLink);
          if AItemLink <> nil then
          begin
            SetKeySelectedItem(AItemLink.Control);
            if AIsTabKey and SelectedControl.HasWindow then
              SelectedControl.Click(False);
          end;
        end;
      VK_HOME:
        begin
          AItemLink := ItemLinks.First;
          if AItemLink <> nil then SetKeySelectedItem(AItemLink.Control);
        end;
      VK_END:
        begin
          AItemLink := ItemLinks.Last;
          if AItemLink <> nil then SetKeySelectedItem(AItemLink.Control);
        end;
    else
      begin
        if IsTextCharForKeyTip(AKey) then
        begin
          AItemLink := FindLinkWithAccel(AKey, KeyDataToShiftState(Message.KeyData), GetLinkByControl(SelectedControl), ADuplicate);
          if AItemLink <> nil then
            SetAccelSelectedItem(GetControlByLink(AItemLink), ADuplicate);
        end;
      end;
    end;
  end;

var
  ALinkSelf: TcxObjectLink;
begin
  ALinkSelf := cxAddObjectLink(Self);
  try
    inherited;
    if (ALinkSelf.Ref = nil) or (ActiveBarControl = nil) then Exit;
    NavigationHandler;
    if (ALinkSelf.Ref = nil) or (ActiveBarControl = nil) or SelectedItemWantsKey(Message.CharCode) then Exit;
    DoKeyDown(Message);
  finally
    cxRemoveObjectLink(ALinkSelf);
  end;
end;

procedure TCustomdxBarControl.WMLButtonDblClk(var Message: TWMLButtonDblClk);
begin
  if not FIgnoreMouseClick then
    inherited;
end;

procedure TCustomdxBarControl.WMLButtonDown(var Message: TWMLButtonDown);
begin
  if not FIgnoreMouseClick then
    inherited;
end;

procedure TCustomdxBarControl.WMLButtonUp(var Message: TWMLButtonUp);
var
  P: TPoint;
  Item, AClickedControl: TdxBarItemControl;
begin
  if FIgnoreMouseClick then
  begin
    FIgnoreMouseClick := False;
    Exit;
  end;

  inherited;
  if FDragDown then
    ReleaseCapture
  else
  begin
    P.X := Message.XPos;
    P.Y := Message.YPos;
    AClickedControl := FClickedControl;
    if AClickedControl <> nil then ReleaseCapture;
    if PtInRect(ClientRect, P) and IsActive then
    begin
      Item := ItemAtPos(P);
      if not IsCustomizing and (Item <> nil) and Item.HotPartWantMouse then
        if Item.Enabled and (Item = SelectedControl) then
        begin
          if Item.HasWindow then
            TdxBarWinControl(Item).TransferMessage(Handle, TMessage(Message));
          Item.ControlUnclick(True);
        end
        else
          if not Item.Enabled and (Item <> SelectedControl) and (Self is TdxBarControl) and
            not ((SelectedControl is TdxBarButtonControl) and
                 TdxBarButtonControl(SelectedControl).DroppedDown) then
            TdxBarControl(Self).HideAll;//BarLostFocus;
    end;
    if (AClickedControl <> nil) and BarControlExists(Self) then
      HideAll;
  end;
end;

procedure TCustomdxBarControl.WMMouseActivate(var Message: TWMMouseActivate);
begin
  inherited;
  Message.Result := MA_NOACTIVATE;
end;

procedure TCustomdxBarControl.WMMouseMove(var Message: TWMMouseMove);
var
  ALinkSelf: TcxObjectLink;
begin
  ALinkSelf := cxAddObjectLink(Self);
  try
    inherited;
    if ALinkSelf.Ref <> nil then
      AfterMouseMove(KeysToShiftState(Message.Keys), Message.XPos, Message.YPos);
  finally
    cxRemoveObjectLink(ALinkSelf);
  end;
end;

procedure TCustomdxBarControl.WMNCPaint(var Message: TMessage);
var
  ADC: HDC;
begin
  if AllowNCPaint then
  begin
    ADC := GetNCDrawingDC(Message.WParam);
    try
      inherited;
      NCPaint(ADC);
    finally
      ReleaseNCDrawingDC(ADC);
    end;
  end
  else
    inherited;
end;

procedure TCustomdxBarControl.WMPaint(var Message: TWMPaint);
begin
  if not IsDestroying then
    inherited;
end;

procedure TCustomdxBarControl.WMPrint(var Message: TMessage);
begin
  inherited;
  NCPaint(Message.WParam);
end;

procedure TCustomdxBarControl.WMPrintClient(var Message: TMessage);
begin
  inherited;
  PaintWindow(Message.WParam);
end;

procedure TCustomdxBarControl.WMRepaintBar(var Message: TMessage);
begin
  RepaintBar;
end;

procedure TCustomdxBarControl.WMSetCursor(var Message: TWMSetCursor);
begin
  with Message do
    if (HitTest = HTCLIENT) and (CursorWnd = Handle)  then
    begin
      Windows.SetCursor(Screen.Cursors[Cursor]);
      Result := 1;
    end
    else
      inherited;
end;

procedure TCustomdxBarControl.WMSize(var Message: TWMSize);
begin
//  ResetBackground;
  inherited;
end;

procedure TCustomdxBarControl.WMWindowPosChanged(var Message: TWMWindowPosChanged);
begin
  inherited;
  if not IsDestroying then
    WindowPosChanged(Message);
end;

procedure TCustomdxBarControl.AdjustSize;
begin
// do nothing
end;

procedure TCustomdxBarControl.AdjustHintWindowPosition(var APos: TPoint; const ABoundsRect: TRect; AHeight: Integer);
var
  AHintOffset: Integer;
begin
  AHintOffset := WidthToCurrentDpi(HintOffset);
  if APos.Y + AHintOffset + AHeight > GetDesktopWorkArea(APos).Bottom then
    APos.Y := ClientToScreen(cxNullPoint).Y - AHeight
  else
    APos.Y := APos.Y + AHintOffset;
end;

procedure TCustomdxBarControl.AfterControlEscape(AControl: TdxBarItemControl);
begin
  if not (bboAllowSelectWindowItemsWithoutFocusing in BehaviorOptions) then
    HideAllByEscape
  else
    SelectedControl := AControl;
end;

procedure TCustomdxBarControl.AfterMouseMove(Shift: TShiftState; X, Y: Integer);
begin
  if not NotHandleMouseMove then
    FLastMousePos := ClientToScreen(Point(X, Y)) // FLastMousePos := GetMouseCursorPos - incorrect (SC B20836)
  else
    if NotHandleMouseMove(False) then
      MouseLeave;
end;

procedure TCustomdxBarControl.CreateWindowHandle(const Params: TCreateParams);
begin
  inherited;
  CreateControls;
  SetLayeredAttributes;
end;

procedure TCustomdxBarControl.CreateWnd;
begin
  inherited;
  SetFont;
  CalcDrawingConsts;
end;

procedure TCustomdxBarControl.DestroyWindowHandle;
begin
  if WindowHandle <> 0 then
    BeforeDestroyHandle;
  DestroyControls;
  inherited DestroyWindowHandle;
end;

procedure TCustomdxBarControl.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);

  procedure CorrectCurrentMessage;
  begin
    case FCurrentMessage.Msg of
      WM_LBUTTONDBLCLK: FCurrentMessage.Msg := WM_LBUTTONDOWN;
      WM_RBUTTONDBLCLK: FCurrentMessage.Msg := WM_RBUTTONDOWN;
      WM_MBUTTONDBLCLK: FCurrentMessage.Msg := WM_MBUTTONDOWN;
    end;
  end;

var
  P: TPoint;
  AItemControl: TdxBarItemControl;
begin
  inherited;
  P := Point(X, Y);
  AItemControl := ItemAtPos(P);

  if cxPointIsEqual(FLastMousePos, cxInvalidPoint) and not IsCustomizing then
    DoBarMouseEnter(Shift, P, AItemControl);

  if (ssDouble in Shift) and (AItemControl <> nil) and (AItemControl = SelectedControl) and AItemControl.WantsDblClick then
    DblClickOnItem(AItemControl)
  else
  begin
    CorrectCurrentMessage;
    DoBarMouseDown(Button, Shift, P, AItemControl, PtInRect(ClientRect, P));
  end;
end;

procedure TCustomdxBarControl.MouseLeave;
begin
  FLastMousePos := cxInvalidPoint;
  if BarManager.IsMouseTracking(Self) then
  begin
    BarManager.EndMouseTracking(Self);
    DoBarMouseLeave;
  end;
end;

procedure TCustomdxBarControl.MouseMove(Shift: TShiftState; X, Y: Integer);

  function DragAndDrop(const P: TPoint): Boolean;

    function DragRect: TRect;
    begin
      Result := Bounds(0, 0, GetSystemMetrics(SM_CXDRAG), GetSystemMetrics(SM_CYDRAG));
      OffsetRect(Result, FDragPoint.X - Result.Right div 2, FDragPoint.Y - Result.Bottom div 2);
    end;

  begin
    Result := FDragDown and not PtInRect(DragRect, P);
    if Result then
    begin
      FDragDown := False;
      ReleaseCapture;
      with BarManager do
      begin
        DraggingItemLink.Control.ControlInactivate(True);
        DragAndDrop(DraggingItem, DraggingItemLink);
      end;
    end;
  end;

var
  P: TPoint;
  AItemControl: TdxBarItemControl;
begin
  inherited;
  P := Point(X, Y);
  if IsDestroying or DragAndDrop(P) then
    Exit;

  AItemControl := ItemAtPos(P);
  if cxPointIsEqual(FLastMousePos, cxInvalidPoint) and not NotHandleMouseMove then
    DoBarMouseEnter(Shift, P, AItemControl);
  DoBarMouseMove(Shift, P, AItemControl);
end;

procedure TCustomdxBarControl.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  P: TPoint;
  AItemControl: TdxBarItemControl;
begin
  inherited;
  P := Point(X, Y);
  AItemControl := ItemAtPos(P);
  DoBarMouseUp(Button, Shift, P, AItemControl, PtInRect(ClientRect, P));
end;

function TCustomdxBarControl.NeedsMouseWheel: Boolean;
begin
  Result := False;
end;

procedure TCustomdxBarControl.ProcessMouseDownMessageForMeaningParent(AWnd: HWND;
  AMsg: UINT; const AMousePos: TPoint);
begin
end;

function TCustomdxBarControl.PtInCaller(const P: TPoint): Boolean;

   function PtInItemControl: Boolean;
   var
     AItemControl: TdxBarItemControl;
   begin
     AItemControl := ItemAtPos(P);
     Result := AItemControl <> nil;
   end;

begin
  if IsFocused then
    Result := PtInRect(GetMouseTrackingBounds, ClientToScreen(P))
  else
    Result := (WindowFromPointEx(ClientToScreen(P)) = Handle) or PtInItemControl;
end;

procedure TCustomdxBarControl.Resize;
begin
  inherited;
  if IsPopup then
    Painter.SetWindowRgn(Handle, NCRect, True);
end;

procedure TCustomdxBarControl.WindowPosChanged(var Message: TWMWindowPosChanged);
begin
  with Message.WindowPos^ do
    if (flags and SWP_NOSIZE = 0) or (flags and SWP_NOMOVE = 0) then
      ResizeShadow;
  FShadow.Visible := IsShadowVisible;
  ResetBackground;
end;

procedure TCustomdxBarControl.WndProc(var Message: TMessage);

  function FindEditControl(AHandle: HWND): TdxBarEditControl;
  var
    AEditControl: TdxBarEditControl;
    I: Integer;
  begin
    Result := nil;
    for I := 0 to ItemLinks.Count - 1 do
      if ItemLinks[I].Control is TdxBarEditControl then
      begin
        AEditControl := TdxBarEditControl(ItemLinks[I].Control);
        if AEditControl.HandleAllocated and (AEditControl.Handle = AHandle) then
        begin
          Result := AEditControl;
          Break;
        end;
      end;
  end;

var
  ABkColor, ATextColor: COLORREF;
  AEditControl: TdxBarCustomEditControl;
begin
  case Message.Msg of
    WM_CTLCOLOREDIT, WM_CTLCOLORSTATIC: //don't use VCL-like method
      begin
        AEditControl := FindEditControl(Message.LParam);
        if AEditControl = nil then
          inherited
        else
        begin
          Painter.EditGetColors(AEditControl, ATextColor, ABkColor);
          SetBkColor(Message.WParam, ColorToRGB(ABkColor));
          SetTextColor(Message.WParam, ColorToRGB(ATextColor));
          Message.Result := AEditControl.EditBkBrush;
          if IsOnGlass and not AEditControl.InnerControlBufferedPaint then
          begin
            AEditControl.InnerControlBufferedPaint := True;
            PostMessage(Message.LParam, CM_BUFFEREDPAINTONGLASS, 0, 0);
          end;
        end;
      end;
    WM_KILLFOCUS:
      begin
        inherited;
        if Message.wParam = 0 then
          HideAll;
      end;
    WM_NCACTIVATE:
      begin
        if (Message.wParam = Longint(True)) and not BarManager.IsCustomizing then
          SendMessage(GetParent(Handle), WM_NCACTIVATE, Longint(True), 0);
        Message.wParam := Longint(True);
        inherited;
      end;
    WM_SETFOCUS:
      if not (SelectedControl is TdxBarWinControl) then
        DoDropFocus
      else
        inherited;
    WM_MOUSEFIRST..WM_MOUSELAST, WM_NCMOUSEMOVE..WM_NCMBUTTONDBLCLK:
      if CanProcessMouseMessage then
        inherited;
    WM_COMMAND:
      begin
        inherited;
        if (Message.Result = 0) and (HiWord(Message.wParam) = EN_CHANGE) and (Message.lParam <> 0) then
          Message.Result := SendMessage(Message.lParam, Message.Msg, Message.wParam, Message.lParam);
      end;
    else
      inherited;
  end;
end;

function TCustomdxBarControl.CalcChildBarBounds(out ARect: TRect): Boolean;
begin
  Result := False;
end;

procedure TCustomdxBarControl.CalcControlsPositions;
begin
  CalcItemsRect;
end;

procedure TCustomdxBarControl.CalcDragOverParameters(const ACursorPos: TPoint;
  var ADragOverItemLink: TdxBarItemLink;
  var AIsBeginGroup, AIsFirstPart, AIsVerticalDirection: Boolean);
var
  ACalcVerticalDirection: Boolean;
  AControl: TdxBarItemControl;
  AItemRect: TRect;
  ASeparatorIndex, I: Integer;
  ARgn: HRGN;
begin
  AIsVerticalDirection := IsVerticalDirection;

  for I := 0 to FItemLinks.VisibleItemCount - 1 do
  begin
    AControl := FItemLinks.VisibleItems[I].Control;
    if AControl.CanCustomize then
    begin
      ARgn := GetItemRegion(AControl);
      try
        if PtInRegion(ARgn, ACursorPos.X, ACursorPos.Y) then
        begin
          ADragOverItemLink := AControl.ItemLink;
          AItemRect := GetFullItemRect(AControl);

          ACalcVerticalDirection := AIsVerticalDirection;

          if not PtInRect(AItemRect, ACursorPos) and
            ViewInfo.IsAssociatedWithSeparator(AControl, ASeparatorIndex) then
          begin
            AIsBeginGroup := True;
            if ACursorPos.Y < AItemRect.Top then
              ACalcVerticalDirection := True;

            AItemRect := ViewInfo.SeparatorInfos[ASeparatorIndex].Bounds;
          end;
          if ACalcVerticalDirection then
            AIsFirstPart := (ACursorPos.Y - AItemRect.Top) < (AItemRect.Bottom - ACursorPos.Y)
          else
            AIsFirstPart := (ACursorPos.X - AItemRect.Left) < (AItemRect.Right - ACursorPos.X);

          Break;
        end;
      finally
        DeleteObject(ARgn);
      end;
    end;
  end;
end;

procedure TCustomdxBarControl.CalcDrawingConsts;
var
  ASize: TSize;
begin
  FTextSize := GetTextSize;
  FRatio := Max(1, FTextSize / GetNormalItemHeight);

  FMenuArrowHeight := FTextSize div 5;
  if FMenuArrowHeight < 4 then FMenuArrowHeight := 4;

  FIconAreaSize := GetIconAreaSize;

  ASize := cxTextExtent(EditFont, '0');
  FEditTextSize := Painter.EditTextSize(Self, ASize.cy);
  FComboBoxArrowWidth := Painter.ComboBoxArrowWidth(Self, ASize.cx);
end;

procedure TCustomdxBarControl.CalcItemsRect;
begin
  FItemsRect := ClientRect;
end;

procedure TCustomdxBarControl.CalcColumnItemRects(ATopIndex: Integer;
  out ALastItemBottom: Integer);
var
  I: Integer;
  AItemLink: TdxBarItemLink;
  AItemRect: TRect;
begin
  AItemRect := VisibleItemsRect;
  AItemRect.Bottom := AItemRect.Top;
  ALastItemBottom := AItemRect.Bottom;
  for I := ATopIndex to ItemLinks.VisibleItemCount - 1 do
  begin
    AItemLink := ItemLinks.VisibleItems[I];
    AItemRect.Top := AItemRect.Bottom + GetItemControlOffset(AItemLink);
    AItemRect.Bottom := AItemRect.Top + AItemLink.Control.Height;
    if AItemRect.Bottom > VisibleItemsRect.Bottom then
    begin
      if CanDrawClippedItem(AItemRect) then
      begin
        AItemLink.ItemRect := AItemRect;
        ALastItemBottom := VisibleItemsRect.Bottom;
      end
      else
        if I > ATopIndex then
          ALastItemBottom := ItemLinks.VisibleItems[I - 1].ItemRect.Bottom
        else
          ALastItemBottom := AItemRect.Top;
      Break;
    end;
    AItemLink.ItemRect := AItemRect;
    ALastItemBottom := AItemRect.Bottom;
  end;
end;

procedure TCustomdxBarControl.CalcRowItemRects;
begin
// do nothing
end;

procedure TCustomdxBarControl.CalcItemRects(APaintStyle: TdxBarPaintType; ATopIndex: Integer);
var
  ALastItemBottom: Integer;
begin
  FVisibleItemsRect := ItemsRect;
  CorrectVisibleItemsRectTop;

  ItemLinks.EmptyItemRects;
  case APaintStyle of
    ptHorz, ptVert: CalcRowItemRects;
    ptMenu: CalcColumnItemRects(ATopIndex, ALastItemBottom);
  end;

  CorrectVisibleItemsRectBottom;
end;

procedure TCustomdxBarControl.CalcLayout;
begin
  ViewInfo.Calculate;
end;

procedure TCustomdxBarControl.BeforeDestroyHandle;
var
  I: Integer;
begin
  if not IsDestroying then
    MouseLeave;
  for I := 0 to ItemLinks.CanVisibleItemCount - 1 do
    with ItemLinks.CanVisibleItems[I] do
      if Control <> nil then Control.BeforeDestroyParentHandle;
end;

procedure TCustomdxBarControl.CreateControls;
begin
  if ([bsCreatingControls, bsDestroyingControls] * FState <> []) then
    Exit;
  Include(FState, bsCreatingControls);
  try
    DoCreateControls;
  finally
    Exclude(FState, bsCreatingControls);
  end;
end;

procedure TCustomdxBarControl.DestroyControls;
begin
  if ([bsCreatingControls, bsDestroyingControls] * FState <> []) then
    Exit;
  Include(FState, bsDestroyingControls);
  try
    DoDestroyControls;
  finally
    Exclude(FState, bsDestroyingControls);
  end;
end;

procedure TCustomdxBarControl.ExpandContainerItems;
var
  ADoneItems: TList;
  I: Integer;
  AItemLink: TdxBarItemLink;
  AFirstCall, AHideWhenRun: Boolean;
begin
  if FItemLinks <> nil then
  begin
    ADoneItems := TList.Create;
    try
      I := 0;
      while I <= FItemLinks.CanVisibleItemCount - 1 do
      begin
        AItemLink := FItemLinks.CanVisibleItems[I];
        if AItemLink.Item is TCustomdxBarContainerItem then
        begin
          if FExpandedItemLinks = nil then
            FExpandedItemLinks := TList.Create;
          FExpandedItemLinks.Count := AItemLink.Index + 1;
          FExpandedItemLinks[AItemLink.Index] := AItemLink;

          AFirstCall := ADoneItems.IndexOf(AItemLink.Item) = -1;
          if AFirstCall then
            ADoneItems.Add(AItemLink.Item);

          AHideWhenRun := TCustomdxBarContainerItem(AItemLink.Item).HideWhenRun;
          if AHideWhenRun then
            AItemLink.SaveRecentIndex;

          TCustomdxBarContainerItem(AItemLink.Item).AddListedItemLinks(FItemLinks,
            AItemLink.Index + 1, AFirstCall, AItemLink);
          if AHideWhenRun then
          begin
            AItemLink.SendToBottomInRecentList;
            AItemLink.Collection := nil;
            Dec(I);
          end;
        end;
        Inc(I);
      end;
    finally
      ADoneItems.Free;
    end;
  end;
end;

procedure TCustomdxBarControl.CollapseContainerItems;
var
  I: Integer;
  AHideWhenRun: Boolean;
begin
  if FExpandedItemLinks <> nil then
  try
    for I := 0 to FExpandedItemLinks.Count - 1 do
      if FExpandedItemLinks[I] <> nil then
        TCustomdxBarContainerItem(TdxBarItemLink(FExpandedItemLinks[I]).Item).NeedClearItemList;

    for I := FExpandedItemLinks.Count - 1 downto 0 do
      if FExpandedItemLinks[I] <> nil then
        with TdxBarItemLink(FExpandedItemLinks[I]) do
        begin
          AHideWhenRun := TCustomdxBarContainerItem(Item).HideWhenRun;
          TCustomdxBarContainerItem(Item).DeleteListedItemLinks(FItemLinks, I + Byte(not AHideWhenRun));
          if AHideWhenRun then
          begin
            Collection := FItemLinks;
            Index := I;
            RestoreRecentIndex;
          end;
        end;
  finally
    FreeAndNil(FExpandedItemLinks);
  end;
end;

procedure TCustomdxBarControl.LayoutChanged;
begin
// do nothing
end;

procedure TCustomdxBarControl.RecreateControls;
begin
  DestroyControls;
  CreateControls;
  UpdateControlByMouse;
end;

procedure TCustomdxBarControl.UpdateControlByMouse;
var
  AControl: TWinControl;
  P: TPoint;
begin
  P := GetMouseCursorPos;
  AControl := FindControl(WindowFromPointEx(P));
  if AControl is TCustomdxBarControl then
    with TCustomdxBarControl(AControl) do
    begin
      Windows.ScreenToClient(Handle, P);
      FLastMousePos := cxInvalidPoint;
      PostMessage(Handle, WM_MOUSEMOVE, 0, MakeLParam(P.X, P.Y));
    end;
end;

procedure TCustomdxBarControl.DoKeyDown(var Message: TWMKey);

  procedure ClickSelectedControl(ASelectedControl: TdxBarItemControl);
  begin
    if BarNavigationController.IsKeyTipsWaiting or BarNavigationController.KeyTipsHandlingMode then
      BarNavigationController.StopKeyboardHandling;
    ASelectedControl.Click(False);
  end;

begin
  case Message.CharCode of
    VK_RETURN:
      if SelectedControl <> nil then
        ClickSelectedControl(SelectedControl);
  end;
end;

function TCustomdxBarControl.CanActiveChange: Boolean;
begin
  Result := IsApplicationActive or IsWindowEnabled or IsCustomizing;
end;

function TCustomdxBarControl.CanAlignControl(AControl: TdxBarItemControl): Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.CanCallInheritedNCCalcSize: Boolean; // obsolete
begin
  Result := True;
end;

function TCustomdxBarControl.CanControlPaint(AControl: TdxBarItemControl): Boolean;
begin
  Result := not IsDestroying and (AControl <> nil) and (AControl.ItemLink <> nil) and
    (AControl.ItemLink.Control <> nil) and not AControl.ItemLink.Item.IsDestroying and
    not (bsPaintItem in FState) and not CheckLockUpdate and ViewInfo.IsItemControlVisible(AControl);
end;

function TCustomdxBarControl.CanCustomizing: Boolean;
begin
  Result := BarManager.Designing;
end;

function TCustomdxBarControl.CanDeactivate(ABarManager: TdxBarManager; AActiveWindow: HWND): Boolean;
begin
  Result := ABarManager.IsCustomizing and (BarManager.Owner = dxBarCustomizingForm) and (Handle <> AActiveWindow) or
    (SelectedControl = nil) or SelectedControl.CanDeselect(ABarManager);
end;

function TCustomdxBarControl.CanDrawClippedItem(AItemRect: TRect): Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.CanHide: Boolean;
begin
  Result := ((SelectedControl = nil) or (SelectedControl.CanHide)) and
    ((ChildBar = nil) or ChildBar.CanHide);
end;

function TCustomdxBarControl.CanProcessMouseMessage: Boolean;
var
  AControl: TCustomdxBarControl;
begin
  AControl := ActiveBarControl;
  Result := AControl = nil;
  while not Result and (AControl <> nil) do
  begin
    Result := AControl = Self;
    AControl := AControl.GetEquivalentParentBar;
  end;
end;

function TCustomdxBarControl.CanShowPopupMenuOnMouseClick(AMousePressed: Boolean): Boolean;

  function CanShowOnMouseDown: Boolean;
  begin
    Result := (not (bboItemCustomizePopup in BehaviorOptions) and not IsInternal) or IsCustomizing;
  end;

  function CanShowOnMouseUp: Boolean;
  begin
    Result := bboItemCustomizePopup in BehaviorOptions
  end;

begin
  Result := AMousePressed and CanShowOnMouseDown or
    not AMousePressed and CanShowOnMouseUp and not CanShowOnMouseDown;
end;

function TCustomdxBarControl.CanShowHint: Boolean;
begin
  Result := not IsActive;
end;

function TCustomdxBarControl.CheckLockUpdate: Boolean;
begin
  Result := BarManager.IsUpdateLocked;
end;

function TCustomdxBarControl.ChildrenHaveShadows: Boolean;
begin
  Result := Painter.BarChildrenHaveShadows(Self);
end;

procedure TCustomdxBarControl.CorrectVisibleItemsRectTop;
begin
// do nothing
end;

procedure TCustomdxBarControl.CorrectVisibleItemsRectBottom;
begin
// do nothing
end;

procedure TCustomdxBarControl.CustomizePrepare(APoint: TPoint; ASecondClick: Boolean);
begin
  if (SelectedControlAtDesign <> nil) and SelectedControlAtDesign.CanCustomize then
  begin
    FDragPoint := APoint;
    BarManager.DraggingItem := GetItemByControl(SelectedControlAtDesign);
    BarManager.DraggingItemLink := GetLinkByControl(SelectedControlAtDesign);
    FDragDown := True;
    SetCapture(Handle);
  end;
end;

procedure TCustomdxBarControl.DblClickOnItem(AItemControl: TdxBarItemControl);
begin
  if BarManager.Designing then
    AItemControl.Item.ShowDefaultEventHandler
  else
    if AItemControl.IsExpandable then
      with TCustomdxBarSubItem(AItemControl.Item).ItemLinks do
        if (BarControl <> nil) and BarControl.MarkExists then
          BarControl.MarkState := msPressed
        else
    else
      AItemControl.DblClick;
end;

procedure TCustomdxBarControl.DoBarGetFocus(ASelectedItem: TdxBarItemControl);
begin
  SetKeySelectedItem(ASelectedItem);
  IsActive := True;
end;

procedure TCustomdxBarControl.DoBarLostFocus;
begin
  SetKeySelectedItem(nil); //TODO CHECK
  IsActive := False;
end;

procedure TCustomdxBarControl.DoBarMouseEnter(Shift: TShiftState; const APoint: TPoint; AItemControl: TdxBarItemControl);
begin
  BarManager.BeginMouseTracking(Self);
  MouseNotifyControls(GetLinkByControl(AItemControl), APoint, Shift);
  ViewState := bvsHot;
end;

procedure TCustomdxBarControl.DoBarMouseDown(Button: TMouseButton; Shift: TShiftState;
  const APoint: TPoint; AItemControl: TdxBarItemControl; APointInClientRect: Boolean);
var
  APrevSelectedControl: TdxBarItemControl;
begin
  if not NotHandleMouseMove(False) then
    MouseDownNotifyControls(GetLinkByControl(AItemControl), APoint, Button, Shift);
  APrevSelectedControl := SelectedControlAtDesign;
  if IsCustomizing then
    SelectItemControl(AItemControl, Button, Shift);
  case Button of
    mbLeft:
      if IsCustomizing then
        CustomizePrepare(APoint, APrevSelectedControl = SelectedControlAtDesign)
      else
        FocusItemControl(AItemControl);
    mbRight:
      begin
        if SelectedControl <> AItemControl then
          BarLostFocus;
        if CanShowPopupMenuOnMouseClick(True) then
          ShowPopup(AItemControl)
      end;
  end;
end;

procedure TCustomdxBarControl.DoBarMouseLeave;
begin
  ViewState := bvsNormal;

  MouseNotifyControls(nil, cxInvalidPoint, []);

  if MarkState = msSelected then
    MarkState := msNone;

  if (FClickedControl = nil) and (SelectedControl <> nil) and not SelectedControl.IsDroppedDown and not IsCustomizing then
    SetMouseSelectedItem(nil)
end;

procedure TCustomdxBarControl.DoBarMouseMove(Shift: TShiftState; const APoint: TPoint;
  AItemControl: TdxBarItemControl);
var
  FocusedControlExists: Boolean;
begin
  if not NotHandleMouseMove then
  begin
    MouseNotifyControls(GetLinkByControl(AItemControl), APoint, Shift);

  //#DG <BarManager.SelectedItem>
    FocusedControlExists := (BarManager.SelectedItem <> nil) and
      (BarManager.SelectedItem is TdxBarWinControl) and
      TdxBarWinControl(BarManager.SelectedItem).Focused;

{
  //#DG <BarManager.SelectedItem>
    if (ActiveBarControl = nil) or (ActiveBarControl = Self) then
      if (AItemControl is TdxBarWinControl) and
        PtInRect(TdxBarWinControl(AItemControl).WindowRect, APoint) and
        (not FocusedControlExists or (AItemControl = BarManager.SelectedItem)) then
        Cursor := crIBeam
      else
        Cursor := crDefault;
}

    if FocusedControlExists then Exit;

    if (AItemControl <> nil) and not AItemControl.CanMouseSelect then AItemControl := nil;
    if (Self is TdxBarControl) and IsActive and (AItemControl = nil) then Exit;

    if (FClickedControl = nil) and ((AItemControl <> nil) or (ChildBar = nil)) then
      SetMouseSelectedItem(AItemControl);

  {#DG
    // TODO if Item <> nil
    if (SelectedControl <> nil) and SelectedControl.FSelectedByMouse then
      SelectedControl.MouseMove(KeysToShiftState(Message.Keys), P.X, P.Y);
  }
  end;
end;

procedure TCustomdxBarControl.DoBarMouseUp(Button: TMouseButton; Shift: TShiftState;
  const APoint: TPoint; AItemControl: TdxBarItemControl; APointInClientRect: Boolean);
begin
  if not NotHandleMouseMove(False) then
    MouseUpNotifyControls(GetLinkByControl(AItemControl), APoint, Button, Shift);
  if (Button = mbRight) and CanShowPopupMenuOnMouseClick(False) then
    ShowPopup(AItemControl);
end;

procedure TCustomdxBarControl.DoCreateControls;
var
  I: Integer;
begin
  if FItemLinks <> nil then
    for I := 0 to FItemLinks.CanVisibleItemCount - 1 do
      FItemLinks.CanVisibleItems[I].CreateControl;
end;

procedure TCustomdxBarControl.DoDestroy;
begin
//#DG  Destroying;
  CallNotify(OnDestroy, Self);
end;

procedure TCustomdxBarControl.DoDestroyControls;
var
  I: Integer;
//#DG  PrevDestroyFlag: Boolean;
begin
{
  if FItemLinks <> nil then
  begin
    PrevDestroyFlag := FDestroyFlag;
    FDestroyFlag := True;
    for I := 0 to FItemLinks.CanVisibleItemCount - 1 do
      FItemLinks.CanVisibleItems[I].DestroyControl;
    FDestroyFlag := PrevDestroyFlag;
  end;
}
  if FItemLinks <> nil then
    for I := 0 to FItemLinks.CanVisibleItemCount - 1 do
      FItemLinks.CanVisibleItems[I].DestroyControl;
end;

procedure TCustomdxBarControl.DoDropFocus;
begin
  if IsCustomizing and (dxBarCustomizingForm <> nil) then
  begin
    dxSetZOrder(Handle);
    Windows.SetFocus(dxBarCustomizingForm.Handle);
    dxSetZOrder(Handle, HWND_NOTOPMOST);
  end
  else
    if IsControlVisible(BarManager.Owner) then
      Windows.SetFocus(BarManager.Owner.Handle)
    else
      Windows.SetFocus(GetNextWindow(BarManager.Owner.Handle, GW_HWNDNEXT));
end;

procedure TCustomdxBarControl.DoHideAll;
var
  ALinkSelf: TcxObjectLink;
begin
  ALinkSelf := cxAddObjectLink(Self);
  try
    IsActive := False;
    if (ALinkSelf.Ref <> nil) and (ParentBar <> nil) and not ClosedByEscape then
      ParentBar.HideAll;
  finally
    cxRemoveObjectLink(ALinkSelf);
  end;
end;

procedure TCustomdxBarControl.DoPaintItem(AControl: TdxBarItemControl; ACanvas: TcxCanvas; const AItemRect: TRect);
begin
  ACanvas.SaveClipRegion;
  try
    ACanvas.SetClipRegion(TcxRegion.Create(AControl.ViewInfo.Bounds), roSet);
    AControl.Paint(ACanvas, AItemRect, GetPaintType);
  finally
    ACanvas.RestoreClipRegion;
  end;
  DrawSelectedItem(ACanvas.Handle, AControl, AItemRect);
end;

procedure TCustomdxBarControl.DoRepaintBar(ARecreateControls: Boolean);
begin
  if ARecreateControls then
    RecreateControls;
end;

procedure TCustomdxBarControl.DoSetIsActive(AValue: Boolean);
begin
  FIsActive := AValue;
  if FIsActive then
  begin
    if FActiveBarControl = nil then ShowFullMenus := IsCustomizing;
    FPrevActiveBarControl := FActiveBarControl;
    FActiveBarControl := Self;
    if not IsCustomizing then ItemLinks.InitiateActions;
  end
  else
  begin
    if IsCustomizing then
      SelectedLink := nil
    else
      SetKeySelectedItem(nil);
    if FActiveBarControl = Self then
      FActiveBarControl := FPrevActiveBarControl;
    if (FActiveBarControl <> nil) and
      (not BarControlExists(FActiveBarControl) or not FActiveBarControl.IsActive) then
      FActiveBarControl := nil;
  end;
end;

procedure TCustomdxBarControl.DrawItems;
var
  I: Integer;
  AItemControlViewInfo: TdxBarItemControlViewInfo;
begin
  for I := 0 to ViewInfo.ItemControlCount - 1 do
  begin
    AItemControlViewInfo := ViewInfo.ItemControlViewInfos[I];
    if CanControlPaint(AItemControlViewInfo.Control) then
      PaintItem(Canvas, AItemControlViewInfo.Control);
    Canvas.ExcludeClipRect(AItemControlViewInfo.Bounds);
  end;
end;

procedure TCustomdxBarControl.DrawSelectedItem(ADC: HDC; AControl: TdxBarItemControl; const AItemRect: TRect);
var
  ALink: TdxBarItemLink;
begin
  ALink := GetLinkByControl(AControl);
  if (ALink <> nil) and ALink.IsComponentSelected then
  begin
    if BarDesignController.NeedDefaultSelection(ALink) then
      dxBarFrameRect(ADC, AItemRect, COLOR_WINDOWTEXT)
    else
      dxBarFocusRect(ADC, AItemRect);
  end;
end;

procedure TCustomdxBarControl.DragOver(X, Y: Integer; var Accept: Boolean);
begin
// do nothing
end;

function TCustomdxBarControl.DoFindLinkWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink): TdxBarItemLink;
begin
  Result := ItemLinks.FindItemWithAccel(AKey, AShift, ACurrentLink);
end;

function TCustomdxBarControl.FindLinkWithAccel(AKey: Word; AShift: TShiftState; ACurrentLink: TdxBarItemLink; out ADuplicate: Boolean): TdxBarItemLink;
begin
  Result := DoFindLinkWithAccel(AKey, AShift, ACurrentLink);
  if (Result <> nil) and Result.Item.Enabled then
    ADuplicate := DoFindLinkWithAccel(AKey, AShift, Result) <> Result
  else
    Result := nil;
end;

procedure TCustomdxBarControl.FocusItemControl(AItemControl: TdxBarItemControl);
var
  ABarButtonControl: TdxBarButtonControl;
  ALinkSelf: TcxObjectLink;
begin
  if (AItemControl <> nil) and AItemControl.Enabled and AItemControl.HotPartWantMouse then
  begin
    SetKeySelectedItem(AItemControl);
    BarManager.HideHint;
    if SelectedControl is TdxBarButtonLikeControl then
      TdxBarButtonLikeControl(SelectedControl).FShowAnimation := True;
    if SelectedControl.HasWindow then // is focusable
      SetControlVisible(SelectedControl);
    ALinkSelf := cxAddObjectLink(Self);
    try
      AItemControl.ControlClick(True);
      if (ALinkSelf.Ref <> nil) and IsControlExists(AItemControl) then
      begin
        if SelectedControl is TdxBarButtonControl then
        begin
          ABarButtonControl := TdxBarButtonControl(SelectedControl);
          ABarButtonControl.FShowAnimation := False;
          // ***
      //        if (ABarButtonControl.AItemControl.FDropDownMenu <> nil) and
      //          (ABarButtonControl.AItemControl.FDropDownMenu.SubMenuControl <> nil) then
      //          ABarButtonControl.AItemControl.FDropDownMenu.SubMenuControl.ParentBar := Self;
         end;
      end;
    finally
      cxRemoveObjectLink(ALinkSelf);
    end;
  end;
end;

procedure TCustomdxBarControl.FocusNextBarControl(AForward: Boolean);
var
  APrevBarControl: TCustomdxBarControl;
  AIndex, APrevIndex, APrevBarIndex: Integer;
  ABar: TdxBar;
  ABars: TdxBars;
begin
  APrevBarControl := GetParentBarForBar(Self);
  if APrevBarControl is TdxBarControl then
  begin
    ABar := TdxBarControl(APrevBarControl).Bar;
    APrevBarIndex := dxBarManagerList.IndexOf(ABar.Bars.BarManager);
    APrevIndex := ABar.Index;
    repeat
      AIndex := ABar.Index;
      if AForward then
      begin
        Inc(AIndex);
        if AIndex >= ABar.Bars.Count then
        begin
          ABar := dxBarManagerList.NextActive(ABar.Bars.BarManager, True).Bars[0];
          AIndex := 0;
        end;
      end
      else
      begin
        Dec(AIndex);
        if AIndex < 0 then
        begin
          ABars := dxBarManagerList.NextActive(ABar.Bars.BarManager, False).Bars;
          ABar := ABars[ABars.Count - 1];
          AIndex := ABar.Bars.Count - 1;
        end;
      end;
      if (APrevBarIndex = dxBarManagerList.IndexOf(ABar.Bars.BarManager)) and (AIndex = APrevIndex) then
        Break;
      ABar := ABar.Bars[AIndex];
      if (ABar.Control <> nil) and (ABar.ItemLinks.First <> nil) then
      begin
        TdxBarControl(APrevBarControl).BarLostFocus;
        ABar.Control.BarGetFocus(ABar.ItemLinks.First.Control);
        Break;
      end;
    until False;
  end;
end;

function TCustomdxBarControl.GetIAccessibilityHelper: IdxBarAccessibilityHelper;
begin
  if (FIAccessibilityHelper = nil) and (GetAccessibilityHelperClass <> nil) then
    FIAccessibilityHelper := GetAccessibilityHelper(GetAccessibilityHelperClass.Create(Self));
  Result := FIAccessibilityHelper;
end;

function TCustomdxBarControl.GetBehaviorOptions: TdxBarBehaviorOptions;
begin
  if ParentBar <> nil then
    Result := ParentBar.BehaviorOptions
  else
    Result := [bboAllowSelectWindowItemsWithoutFocusing, bboExtendItemWhenAlignedToClient, bboAllowDetach];
end;

function TCustomdxBarControl.GetClientOffset: TPoint;
begin
  with ClientOrigin do
    Result := Point(X - WindowRect.Left, Y - WindowRect.Top);
end;

function TCustomdxBarControl.GetDefaultItemHeight(AItem: TdxBarItemControl): Integer;
begin
  Result := AItem.GetTextSize;
  if Result = 0 then
    Result := TextSize;
end;

function TCustomdxBarControl.GetDefaultItemGlyph: TBitmap;
begin
  Result := nil;
end;

function TCustomdxBarControl.GetEditFont: TFont;
begin
  Result := BarManager.FEditFont;
end;

function TCustomdxBarControl.GetClientBounds: TRect;
begin
  Result := cxRectOffset(ClientRect, cxPointOffset(ClientToScreen(cxNullPoint), cxPointInvert(WindowRect.TopLeft)));
end;

function TCustomdxBarControl.GetMouseTrackingBounds: TRect;
begin
//  Result := GetWindowRect;
  Result := BoundsRect;
end;

function TCustomdxBarControl.GetNCRect: TRect;
begin
  Result := cxRectOffset(WindowRect, cxPointInvert(WindowRect.TopLeft));
end;

function TCustomdxBarControl.GetEditFontHandle: HFONT;
begin
  Result := GetEditFont.Handle;
end;

function TCustomdxBarControl.GetEquivalentParentBar: TCustomdxBarControl;
begin
  if IsInternal and (ParentBar <> nil) and not ParentBar.IsInternal then
    Result := nil
  else
    Result := ParentBar;
end;

function TCustomdxBarControl.GetFader: TdxFader;
begin
  Result := dxFader;
end;

function TCustomdxBarControl.GetFullItemRect(Item: TdxBarItemControl): TRect;
begin
  Result := GetItemRect(Item);
end;

function TCustomdxBarControl.GetIsCustomizing;
begin
  Result := BarManager.IsCustomizing;
end;

function TCustomdxBarControl.GetIsFocused: Boolean;
begin
  Result := BarManager.FocusedBarControl = Self;
end;

function TCustomdxBarControl.GetIsShadowVisible: Boolean;
begin
  Result := HasShadow and IsWindowVisible(Handle);
end;

function TCustomdxBarControl.GetItemControlDefaultViewLevel(
  AItemControl: TdxBarItemControl): TdxBarItemViewLevel;
begin
  Result := ivlDefault;
end;

function TCustomdxBarControl.GetItemControlOffset(AItemLink: TdxBarItemLink): Integer;
begin
  if AItemLink.BeginGroup and (AItemLink.VisibleIndex > 0) then
    Result := BeginGroupSize
  else
    Result := 0;
end;

function TCustomdxBarControl.GetItemRect(Item: TdxBarItemControl): TRect;
begin
  if Item = nil then
    SetRectEmpty(Result)
  else
    Result := Item.ItemBounds;
end;

function TCustomdxBarControl.GetItemRectEx(Item: TdxBarItemControl;
  IsBeginGroup: Boolean): TRect;
begin
  Result := GetItemRect(Item);
end;

function TCustomdxBarControl.GetItemRegion(Item: TdxBarItemControl): HRGN;
begin
  Result := CreateRectRgnIndirect(GetItemRectEx(Item, True));
end;

function TCustomdxBarControl.GetItemScreenRect(Item: TdxBarItemControl): TRect;
begin
  Result := GetItemRect(Item);
  MapWindowRect(Handle, 0, Result);
end;

function TCustomdxBarControl.GetMarkDrawState: TdxBarMarkState;
begin
  Result := MarkState;
end;

function TCustomdxBarControl.GetMarkSize: Integer;
begin
  if MarkExists then
    Result := MarkSize
  else
    Result := 0;
end;

function TCustomdxBarControl.GetNormalItemHeight: Integer;
begin
  // TODO: NormalItemHeight for BarControl
  Result := Painter.SubMenuControlNormalItemHeight;
end;

function TCustomdxBarControl.GetOwnerControl: TWinControl;
begin
  if not IsRectEmpty(FOwnerBounds) then
    Result := FOwnerControl
  else
    Result := nil;
end;

function TCustomdxBarControl.GetPainter: TdxBarPainter;
begin
  if FPainter <> nil then
    Result := FPainter
  else
    if ParentBar <> nil then
      Result := ParentBar.GetPainter
    else
      if DockControl <> nil then
        Result := DockControl.Painter
      else
        Result := BarManager.DefaultPainter;
end;

function TCustomdxBarControl.GetPaintType: TdxBarPaintType;
begin
  if IsVertical then
    Result := ptVert
  else
    Result := ptHorz;
end;

function TCustomdxBarControl.GetSelectableObject: TPersistent;
begin
  Result := nil;
end;

function TCustomdxBarControl.GetSelectionOperation(AButton: TMouseButton;
  AShift: TShiftState; ASelectableItem: IdxBarSelectableItem): TdxBarSelectionOperation;
begin
  if AButton = mbRight then
  begin
    if ASelectableItem.IsComponentSelected and not BarDesignController.IsSelectionComplex(BarManager) then
      Result := soAdd
    else
      Result := soExclusive;
  end
  else
    if ([ssShift, ssCtrl] * AShift = [ssShift]) then
    begin
      if ASelectableItem.IsComponentSelected then
        Result := soExclude
      else
        Result := soAdd;
    end
    else
    { #DG - Mouse click on item must cause exclusive selection
      if ASelectableItem.IsComponentSelected then
        Result := soAdd
      else
     }
        Result := soExclusive;
end;

function TCustomdxBarControl.GetToolbarBrush: HBRUSH;
begin
  Result := Painter.BarToolbarBrush(Self);
end;

function TCustomdxBarControl.GetToolbarDownedBrush: HBRUSH;
begin
  Result := Painter.BarToolbarDownedBrush(Self);
end;

function TCustomdxBarControl.GetToolbarDownedSelBrush: HBRUSH;
begin
  Result := Painter.BarToolbarDownedSelBrush(Self);
end;

function TCustomdxBarControl.GetToolbarSelBrush: HBRUSH;
begin
  Result := Painter.BarToolbarSelBrush(Self);
end;

procedure TCustomdxBarControl.RepaintBarEx(ARecreateControls: Boolean);
var
  APrevSelectedItemLink: TdxBarItemLink;
begin
  if IsDestroying or not HandleAllocated or
    ([bsCreatingControls, bsDestroyingControls, bsRepaintBar] * FState <> []) or
    CheckLockUpdate then
    Exit;

  Include(FState, bsRepaintBar);
  try
    APrevSelectedItemLink := nil;
    if IsCustomizing then
    begin
    //#DG <BarManager.SelectedItem>
      if (BarManager.SelectedItem <> nil) and (BarManager.SelectedItem.Parent = Self) then
      begin
        APrevSelectedItemLink := BarManager.SelectedItem.ItemLink;
        BarManager.InternalSetSelectedItem(nil);
      end;
      SelectedLink := nil;
    end;

    DoRepaintBar(ARecreateControls);

    if APrevSelectedItemLink <> nil then
      SetKeySelectedItem(APrevSelectedItemLink.Control);
  finally
    Exclude(FState, bsRepaintBar);
  end;
end;

procedure TCustomdxBarControl.SetControlVisible(AControl: TdxBarItemControl);
begin
  // do nothing
end;

procedure TCustomdxBarControl.SetItemLinks(Value: TdxBarItemLinks);
begin
  FItemLinks := Value;
end;

function TCustomdxBarControl.GetNCDrawingDC(AUpdatedRgn: HRGN): HDC;
begin
  Result := GetWindowDC(Handle);
end;

procedure TCustomdxBarControl.ReleaseNCDrawingDC(ADC: HDC);
begin
  ReleaseDC(Handle, ADC);
end;

function TCustomdxBarControl.GetBorderSize: Integer;
begin
  Result := Painter.GetBorderSize;
end;

function TCustomdxBarControl.GetIconAreaSize: Integer;
begin
  Result := Painter.GetIconAreaSize(Self);
end;

function TCustomdxBarControl.GetTextSize: Integer;
begin
  Result := Painter.GetDefaultTextSize(Canvas);
end;

function TCustomdxBarControl.GetWindowRect: TRect;
begin
  Result := cxGetWindowRect(Self);
end;

function TCustomdxBarControl.GetWindowPoint(const AClientPoint: TPoint): TPoint;
begin
  Result := AClientPoint;
  Result.X := Result.X + NCOffset.X;
  Result.Y := Result.Y + NCOffset.Y;
end;

function TCustomdxBarControl.HasShadow: Boolean;
begin
  Result := Painter.BarHasShadow(Self);
end;

procedure TCustomdxBarControl.HideAllByEscape;
begin
  ClosedByEscape := True;
  HideAll;
end;

function TCustomdxBarControl.HideOnClick: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.IsChildBar(Value: TCustomdxBarControl): Boolean;
begin
  Result := False;
  while Value.ParentBar <> nil do
  begin
    Value := Value.ParentBar;
    if Self = Value then
    begin
      Result := True;
      Exit;
    end;
  end;
end;

function TCustomdxBarControl.IsChildWindow(AWnd: HWND): Boolean;
begin
  Result := IsChildEx(Handle, AWnd) or
    (SelectedControl <> nil) and SelectedControl.IsChildWindow(AWnd);
end;

function TCustomdxBarControl.IsControlExists(ABarItemControl: TdxBarItemControl): Boolean;
begin
  Result := ItemLinks.IsControlExists(ABarItemControl);
end;

function TCustomdxBarControl.IsLinkedToOwner: Boolean;
var
  R1, R2: TRect;
begin
  R1 := FOwnerBounds;
  R2 := BoundsRect;
  Result :=
    ((R1.Bottom = R2.Top) or (R1.Top = R2.Bottom)) and
    (R1.Left < R2.Right) and (R1.Right > R2.Left) or
    ((R1.Right = R2.Left) or (R1.Left = R2.Right)) and
    (R1.Top < R2.Bottom) and (R1.Bottom > R2.Top);
end;

function TCustomdxBarControl.IsMeaningParent(AWnd: HWND): Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.IsPopup: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.IsVerticalDirection: Boolean;
begin
  Result := IsRealVertical;
end;

function TCustomdxBarControl.IsWindowEnabled: Boolean;
begin
  Result := HandleAllocated and IsWindowEnabledEx(Handle);
//TODO    Windows.IsWindowEnabled(Handle) and Windows.IsWindowEnabled(BarManager.Owner.Handle);//#DG
end;

procedure TCustomdxBarControl.MakeItemControlFullyVisible(
  AItemControl: TdxBarItemControl);
begin
end;

function TCustomdxBarControl.MarkExists: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.MarkRect: TRect;
begin
  Result := cxNullRect;
end;

function TCustomdxBarControl.MouseOnMark(const AMousePos: TPoint): Boolean;
begin
  Result := PtInRect(MarkRect, AMousePos);
end;

function TCustomdxBarControl.MouseOnMark: Boolean;
begin
  Result := MouseOnMark(ScreenToClient(GetMouseCursorPos));
end;

procedure TCustomdxBarControl.ActivateHint(AShow: Boolean; const ACustomHint: string; AHintObject: TObject = nil);
begin
  BarManager.ActivateHint(AShow, ACustomHint, AHintObject);
end;

function TCustomdxBarControl.CreateHintViewInfo(const AHintText, AShortCut: string; AScreenTip: TdxBarScreenTip): TdxBarCustomHintViewInfo;
begin
  Result := Painter.CreateHintViewInfo(BarManager, AHintText, AShortCut, AScreenTip);
end;

function TCustomdxBarControl.GetHintPosition(const AItemBounds: TRect; const ACursorPos: TPoint; AHeight: Integer): TPoint;
begin
  Result := Painter.GetBarItemContolHintPosition(Self, AItemBounds, ACursorPos, AHeight);
end;

function TCustomdxBarControl.NeedShowGlyphAndCheckForItem: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.NotHandleMouseMove
  (ACheckLastMousePos: Boolean = True): Boolean;
begin
  Result := IsCustomizing or
    ACheckLastMousePos and cxPointIsEqual(FLastMousePos, GetMouseCursorPos) or
    not PtInRect(WindowRect, GetMouseCursorPos);
end;

procedure TCustomdxBarControl.PaintItem(ACanvas: TcxCanvas; AControl: TdxBarItemControl);
begin
  Include(FState, bsPaintItem);
  try
    FBkBrush := ToolbarBrush;
    DoPaintItem(AControl, ACanvas, AControl.ItemBounds);
  finally
    Exclude(FState, bsPaintItem);
  end;
end;

procedure TCustomdxBarControl.ResizeShadow;
var
  R: TRect;
begin
  if IsLinkedToOwner and Painter.BarLinkedOwnerHasShadow(Self) then
    R := FOwnerBounds
  else
    SetRectEmpty(R);
  FShadow.SetOwnerBounds(R, BoundsRect);
end;

procedure TCustomdxBarControl.SetCursorForMoving(AMoving: Boolean);
const
  Cursors: array[Boolean] of TCursor = (crDefault, crSizeAll);
begin
  Cursor := Cursors[AMoving];
end;

procedure TCustomdxBarControl.SetDockingStyle(Value: TdxBarDockingStyle);
begin
  if FDockingStyle <> Value then
  begin
    FDockingStyle := Value;
    ResetBackground;
    Perform(CM_FONTCHANGED, 0, 0);
    SetLayeredAttributes;
  end;
end;

procedure TCustomdxBarControl.SetLayeredAttributes;
begin
end;

function TCustomdxBarControl.SelectedItemWantsKey(Key: Word): Boolean;
begin
  Result := (SelectedControl <> nil) and SelectedControl.Enabled and
    SelectedControl.WantsKey(Key);
  if Result then SelectedControl.KeyDown(Key, []);
end;

procedure TCustomdxBarControl.SelectItemControl(AItemControl: TdxBarItemControl; AButton: TMouseButton; AShift: TShiftState);
var
  ASelectableItem: IdxBarSelectableItem;
begin
  if AButton = mbRight then
    AShift := [];
  if (AItemControl = nil) then
    ASelectableItem := GetSelectableItem(GetSelectableObject)
  else
  begin
    BarGetFocus(AItemControl);

    ASelectableItem := GetSelectableItem(AItemControl.GetSelectableObject);

    case AButton of
      mbLeft:
        begin
          if ViewInfo.ItemControlCount = 0 then //#DG ???
            Exit;

          if AItemControl.CanCustomize then {1}
          begin
            if AItemControl = SelectedControl then
            begin
              if AItemControl.IsActive then
                AItemControl.ControlInactivate(True)
              else
                AItemControl.ControlActivate(True);
            //#DG <BarManager.SelectedItem>
              BarManager.SelectedItem := AItemControl;
//#DG To exclude superfluous Repaint             AItemControl.Repaint;
            end;
            SetMouseSelectedItem(AItemControl);
          end;
        end;
      mbRight:
        begin
          if SelectedControl <> nil then
            SelectedControl.ControlInactivate(True);
          if AItemControl = SelectedControl then
          begin
            BarManager.SelectedItem := AItemControl;
//#DG To exclude superfluous Repaint            AItemControl.Repaint;
          end;
          SetKeySelectedItem(AItemControl);
        end;
    end;
  end;
  BarDesignController.SelectItem(ASelectableItem,
    GetSelectionOperation(AButton, AShift, ASelectableItem));
end;

procedure TCustomdxBarControl.SetAccelSelectedItem(AItemControl: TdxBarItemControl; ADuplicate: Boolean);
begin
  SetKeySelectedItem(AItemControl);
  if not ADuplicate then
    SendMessage(Handle, WM_KEYDOWN, VK_RETURN, 0);
end;

procedure TCustomdxBarControl.SetKeySelectedItem(Value: TdxBarItemControl);
var
  ALockedBarManager: TdxBarManager;
begin
  if not HandleAllocated or (csDestroying in ComponentState) then Exit;
  if SelectedControl <> Value then
  begin
    if (SelectedControl <> nil) and (Value <> nil) then
      ALockedBarManager := BarManager
    else
      ALockedBarManager := nil;
    if ALockedBarManager <> nil then
      Inc(ALockedBarManager.FChangingFocusedItemControlLockCount);
    try
      if (SelectedControl <> nil) and SelectedControl.IsActive then
        SelectedControl.ControlInactivate(True);
      if not BarControlExists(Self) then
        Exit;
      if Value is TdxBarSubItemControl then
        TdxBarSubItemControl(Value).FShowAnimation := False;
      if Value <> nil then Value.FSelectedByMouse := False;
      SelectedControl := Value;
    finally
      if ALockedBarManager <> nil then
        Dec(ALockedBarManager.FChangingFocusedItemControlLockCount);
    end;
    if Value <> nil then
      MakeItemControlFullyVisible(Value);
  end;
end;

procedure TCustomdxBarControl.SetMouseSelectedItem(Value: TdxBarItemControl);
var
  AErrorText: string;
  ALockedBarManager: TdxBarManager;
begin
  if not HandleAllocated or (csDestroying in ComponentState) or
    (BarNavigationController.IsNavigationBarControl(Self)) and (bboMouseCantUnselectNavigationItem in BehaviorOptions) then Exit;
  if (SelectedControl <> Value) and not ((SelectedControl <> nil) and
    SelectedControl.HasWindow and TdxBarWinControl(SelectedControl).Focused) then
  begin
    if (SelectedControl <> nil) and (Value <> nil) then
      ALockedBarManager := BarManager
    else
      ALockedBarManager := nil;
    if ALockedBarManager <> nil then
      Inc(ALockedBarManager.FChangingFocusedItemControlLockCount);
    try
      if (SelectedControl <> nil) and SelectedControl.IsActive then
        SelectedControl.ControlInactivate(False);
      if Value <> nil then Value.FSelectedByMouse := True;
      SelectedControl := Value;
    finally
    if ALockedBarManager <> nil then
      Dec(ALockedBarManager.FChangingFocusedItemControlLockCount);
    end;
    if not BarControlExists(Self) then Exit;
    if SelectedControl <> nil then
    begin
      if SelectedControl is TdxBarSubItemControl then
        with TCustomdxBarSubItem(GetItemByLink(SelectedLink)) do
          if BarManager.Dragging and not CanContainItem(BarManager.DraggingItem, AErrorText) then
            Exit
          else
            TdxBarSubItemControl(SelectedControl).FShowAnimation := True;
      SelectedControl.ControlActivate(False);
    end;
  end;
end;

procedure TCustomdxBarControl.SetSelectedControl(Value: TdxBarItemControl);
var
  APrevSelectedLink: TdxBarItemLink;
  AParentBar: TCustomdxBarControl;
  AQuickControl: TdxBarQuickControl;
begin
  if SelectedControl <> Value then
  begin
    if BarDesignController.QuickControl is TdxBarQuickControl then
    begin
      AQuickControl := TdxBarQuickControl(BarDesignController.QuickControl);
      if not AQuickControl.IsActive and (AQuickControl <> Self) and (Value <> nil) then
        AQuickControl.StartHidingTimer;
    end;
    APrevSelectedLink := SelectedLink;
    SelectedLink := GetLinkByControl(Value);
    if bboMouseCantUnselectNavigationItem in BehaviorOptions then
      IsDowned := False;
    if IsCustomizing then
    begin
      BarManager.SelectedItem := Value;
      if not BarControlExists(Self) then Exit;
    end
    else
      if not BarManager.IsCustomizing then
        BarManager.InternalSetSelectedItem(Value);
        
    UpdateItem(GetControlByLink(APrevSelectedLink));
    UpdateItem(SelectedControl);

//#DG    GetCursorPos(FLastMousePos);
    if SelectedControl = nil then
      Cursor := crDefault;
    if (SelectedControl <> nil) or
      (Self is TdxBarSubMenuControl) or (TdxBarControl(Self).MarkState = msNone) then
      BarManager.ActivateHint(True, '', SelectedControl);
    // for Application.Hint:
    if (SelectedControl <> nil) and
      (SelectedControl.Enabled or BarManager.ShowHintForDisabledItems) then
      Hint := GetLongHint(SelectedControl.Hint)
    else
      Hint := '';
    AParentBar := GetParentBarOrSubMenuForBar(Self);
    if (AParentBar is TdxBarSubMenuControl) and
      (AParentBar.ItemLinks.Owner is TdxBarCustomPopupMenu) and
      TdxBarCustomPopupMenu(AParentBar.ItemLinks.Owner).FUseOwnMessageLoop then
      Application.Hint := Hint;
  end;
end;

procedure TCustomdxBarControl.Show;
begin
  ShowWindow(Handle, SW_SHOWNOACTIVATE);
  if SelectedControl <> nil then
    SelectedControl.ParentVisibleChange(True);
end;

procedure TCustomdxBarControl.UpdateCanvasFont;
var
  ALogFont: TLogFont;
begin
  if bsUpdatingCanvasFont in FState then
    Exit;
  Include(FState, bsUpdatingCanvasFont);
  try
    if IsVertical then
    begin
      cxGetFontData(Font.Handle, ALogFont);
      ALogFont.lfEscapement := -900;
      ALogFont.lfOrientation := ALogFont.lfEscapement;
      ALogFont.lfOutPrecision := OUT_TT_ONLY_PRECIS;
      Canvas.Font.Handle := CreateFontIndirect(ALogFont);
    end
    else
      Canvas.Font := Font;
  finally
    Exclude(FState, bsUpdatingCanvasFont);
  end;
end;

procedure TCustomdxBarControl.UpdateControlStyle;
begin
  if (BarManager.GetPaintStyle = bmsStandard) and not IsCustomizing then // ???
    ControlStyle := ControlStyle - [csDoubleClicks]
  else
    ControlStyle := ControlStyle + [csDoubleClicks];
end;

procedure TCustomdxBarControl.ViewStateChanged(APrevValue: TdxBarViewState);
begin
end;

function TCustomdxBarControl.WantMouse: Boolean;
begin
  Result := WindowFromPointEx(GetMouseCursorPos) = Handle;
end;

procedure TCustomdxBarControl.DoShowPopup(ASelectedControl: TdxBarItemControl);
begin
  if (ASelectedControl <> nil) or BarManager.Designing then
    BarDesignController.ShowCustomizePopup(Self, GetLinkByControl(ASelectedControl));
end;

procedure TCustomdxBarControl.InitCustomizationPopup(AItemLinks: TdxBarItemLinks);
begin
// do nothing
end;

procedure TCustomdxBarControl.ShowPopup(AItem: TdxBarItemControl);
begin
  DoShowPopup(SelectedControlAtDesign);
end;

function TCustomdxBarControl.AllowNCPaint: Boolean;
begin
  Result := True;
end;

procedure TCustomdxBarControl.FillBackgroundRgn(DC: HDC; ARgn: HRGN; ABrush: HBRUSH;
  AIsClientArea: Boolean);
var
  AClipRgn: HRGN;
  AClipRgnExists: Boolean;
begin
  SaveClipRgn(DC, AClipRgn, AClipRgnExists);
  ExtSelectClipRgn(DC, ARgn, RGN_AND);
  FillBackground(DC, NCRect, ABrush, clNone, AIsClientArea);
  RestoreClipRgn(DC, AClipRgn, AClipRgnExists);
end;

procedure TCustomdxBarControl.FullInvalidate;
begin
  if HandleAllocated then
    SendMessage(Handle, WM_NCPAINT, 0, 0);
  Invalidate;
end;

procedure TCustomdxBarControl.FullRepaint;
begin
  if HandleAllocated then
    SendMessage(Handle, WM_NCPAINT, 0, 0);
  Repaint;
end;

procedure TCustomdxBarControl.InvalidateNCRect(ARect: TRect);
var
  ARegion: HRGN;
begin
  ARect := cxRectOffset(ARect, WindowRect.TopLeft);
  ARegion := CreateRectRgnIndirect(ARect);
  SendMessage(Handle, WM_NCPAINT, ARegion, 0);
  DeleteObject(ARegion);
end;

function TCustomdxBarControl.IsInternal: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.IsBackgroundBitmap: Boolean;
begin
  Result := (DockControl <> nil) and DockControl.IsBackgroundBitmap;
end;

function TCustomdxBarControl.IsNeedBufferedOnGlass(
  AControl: TdxBarItemControl): Boolean;
begin
  Result := IsOnGlass and not AControl.IsTransparentOnGlass;
end; 

function TCustomdxBarControl.IsTransparent: Boolean;
begin
  Result := (DockControl <> nil) and DockControl.IsTransparent;
end;

function TCustomdxBarControl.NCOffset: TPoint;
begin
  Result.X := 0;
  Result.Y := 0;
end;

procedure TCustomdxBarControl.NCPaint(ADC: HDC);
begin
// do nothing
end;

function TCustomdxBarControl.PointBarToDock(const APoint: TPoint): TPoint;
var
  ABounds: TRect;
begin
  ABounds := BoundsRect;
  Result.X := APoint.X + ABounds.Left;
  Result.Y := APoint.Y + ABounds.Top;
end;

procedure TCustomdxBarControl.ResetBackground;
begin
  FBackgroundTempBitmap.Assign(nil);
end;

procedure TCustomdxBarControl.UpdateDoubleBuffered;
begin
  DoubleBuffered := IsTransparent or BarManager.IsUncustomizable or
    ((Painter <> nil) and Painter.NeedDoubleBuffer);
end;

procedure TCustomdxBarControl.HideAll;
var
  ALinkSelf: TcxObjectLink;
begin
  if bsHideAll in FState then
    Exit;

  ALinkSelf := cxAddObjectLink(Self);
  Include(FState, bsHideAll);
  try
    DoHideAll;
  finally
    if ALinkSelf.Ref <> nil then
      Exclude(FState, bsHideAll);
    cxRemoveObjectLink(ALinkSelf);
  end;
end;

function TCustomdxBarControl.IsOnGlass: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.IsRealVertical: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.IsVertical: Boolean;
begin
  Result := False;
end;

function TCustomdxBarControl.ItemAtPos(const APos: TPoint): TdxBarItemControl;
var
  I: Integer;
begin
  Result := nil;
  if not IsCustomizing or CanCustomizing then
    for I := 0 to ViewInfo.ItemControlCount - 1 do
      if PtInRect(ViewInfo.ItemControlViewInfos[I].Bounds, APos) then
      begin
        Result := ViewInfo.ItemControlViewInfos[I].Control;
        if IsCustomizing and Result.IsHiddenForCustomization then
          Result := nil;
        Break;
      end;
end;

procedure TCustomdxBarControl.RepaintBar;
begin
  RepaintBarEx(True);
end;

{ TdxDockCol }

constructor TdxDockCol.Create(ADockRow: TdxDockRow; ABarControl: TdxBarControl);
begin
  inherited Create;
  FDockRow := ADockRow;
  FBarControl := ABarControl;
end;

procedure TdxDockCol.AssignPosition;
begin
  with FBarControl do
    FPos := Point(Left, Top);
end;

{ TdxDockRow }

constructor TdxDockRow.Create(ADockControl: TdxDockControl);
begin
  inherited Create;
  FDockControl := ADockControl;
  FColList := TList.Create;
  FBars := TList.Create;  
end;

destructor TdxDockRow.Destroy;
var
  I: Integer;
begin
  for I := ColCount - 1 downto 0 do
    Cols[I].Free;
  FreeAndNil(FColList);
  while FBars.Count <> 0 do
    TdxBar(FBars[0]).RemoveFromDockRow(False);
  FreeAndNil(FBars);
  inherited;
end;

function TdxDockRow.AddCol(ABarControl: TdxBarControl): TdxDockCol;
begin
  Result := TdxDockCol.Create(Self, ABarControl);
  ColList.Add(Result);
  UpdateOneOnRows;
end;

procedure TdxDockRow.DeleteCol(ABarControl: TdxBarControl);
var
  I: Integer;
begin
  if FColList = nil then
    Exit;
  for I := 0 to ColCount - 1 do
    if Cols[I].BarControl = ABarControl then
    begin
      DeleteCol(I);
      Break;
    end;
end;

procedure TdxDockRow.DeleteCol(AIndex: Integer);
begin
  Cols[AIndex].Free;
  ColList.Delete(AIndex);
  UpdateOneOnRows;
end;

procedure TdxDockRow.AddBar(ABar: TdxBar);
var
  I: Integer;
  ACol: TdxDockCol;
begin
  FBars.Add(ABar);
  if (FBars.Count > ColCount) and (ABar.Control <> nil) and (ABar.RealDockControl = DockControl) then
  begin
    for I := 0 to ColCount - 1 do
      if TdxDockCol(ColList[I]).BarControl = ABar.Control then Exit;
    ACol := TdxDockCol.Create(Self, ABar.Control);
    ColList.Add(ACol);
    UpdateOneOnRows;
    ACol.Pos := Point(ABar.DockedLeft, ABar.DockedTop);
  end;
end;

procedure TdxDockRow.DeleteBar(ABar: TdxBar; ADestroyEmptyDockRow: Boolean);
begin
  if FBars.IndexOf(ABar) < 0 then
    Exit;
  FBars.Delete(FBars.IndexOf(ABar));
  if ABar.Control <> nil then
    DeleteCol(ABar.Control);
  if (FBars.Count = 0) and ADestroyEmptyDockRow then
  begin
    FDockControl.RowList.Delete(FDockControl.RowList.IndexOf(Self));
    Free;
  end;
end;

function TdxDockRow.GetCol(Index: Integer): TdxDockCol;
begin
  Result := FColList[Index];
end;

function TdxDockRow.GetColCount: Integer;
begin
  Result := FColList.Count;
end;

function TdxDockRow.GetVisible: Boolean;
var
  ABarControl: TdxBarControl;
  I: Integer;
begin
  Result := False;
  for I := 0 to FBars.Count - 1 do
  begin
    ABarControl := TdxBar(FBars[I]).Control;
    if (ABarControl <> nil) and (ABarControl.DockingStyle <> dsNone) then
    begin
      Result := True;
      Break;
    end;
  end;
end;

procedure TdxDockRow.UpdateOneOnRows;
var
  I: Integer;
begin
  for I := 0 to ColCount - 1 do
    Cols[I].BarControl.Bar.OneOnRow := ColCount = 1;
end;

{ TdxBarControlMarkFadingHelper }

constructor TdxBarControlMarkFadingHelper.Create(AOwner: TdxBarControl);
begin
  FOwner := AOwner;
end;

destructor TdxBarControlMarkFadingHelper.Destroy;
var
  AFader: TdxFader;
begin
  AFader := Owner.Fader;
  if AFader <> nil then
    AFader.Remove(Self);
  inherited Destroy;
end;

function TdxBarControlMarkFadingHelper.CanFade: Boolean;
begin
  with Owner do
    Result := IsFadingAvailable and MarkExists and (MarkState <> msPressed);
end;

procedure TdxBarControlMarkFadingHelper.DrawFadeImage;
begin
  Owner.InvalidateMark;
end;

procedure TdxBarControlMarkFadingHelper.GetFadingParams(
  out AFadeOutImage, AFadeInImage: TcxBitmap;
  var AFadeInAnimationFrameCount, AFadeInAnimationFrameDelay: Integer;
  var AFadeOutAnimationFrameCount, AFadeOutAnimationFrameDelay: Integer);
var
  AFadingHelper: IdxFadingPainterHelper;
  R: TRect;
begin
  if Supports(Owner.Painter, IdxFadingPainterHelper, AFadingHelper) then
  begin
    R := Owner.MarkRect;
    OffsetRect(R, -R.Left, -R.Top);
    AFadeInImage := TcxBitmap.CreateSize(R, pf32bit);
    AFadeOutImage := TcxBitmap.CreateSize(R, pf32bit);
    AFadingHelper.DrawBarMarkState(Owner, AFadeOutImage.Canvas.Handle, R, msNone);
    AFadingHelper.DrawBarMarkState(Owner, AFadeInImage.Canvas.Handle, R, msSelected);
    if AFadingHelper.BarMarkIsOpaque then
    begin
      AFadeInImage.MakeOpaque;
      AFadeOutImage.MakeOpaque;
    end;
  end;
end;

{ TdxBarControlMDIButtonFadingHelper }

constructor TdxBarControlMDIButtonFadingHelper.Create(AOwner: TdxBarControl;
  AMDIButton: TdxBarMDIButton);
begin
  FMDIButton := AMDIButton;
  FOwner := AOwner;
end;

destructor TdxBarControlMDIButtonFadingHelper.Destroy;
var
  AFader: TdxFader;
begin
  AFader := Owner.Fader;
  if AFader <> nil then
    AFader.Remove(Self);
  inherited Destroy;
end;

function TdxBarControlMDIButtonFadingHelper.CanFade: Boolean;
begin
  Result := Owner.IsFadingAvailable and Owner.MDIButtonsOnBar;
end;

procedure TdxBarControlMDIButtonFadingHelper.DrawFadeImage;
begin
  if Owner.HandleAllocated then
    cxInvalidateRect(Owner.Handle, Owner.RectMDI(MDIButton));
end;

procedure TdxBarControlMDIButtonFadingHelper.FadeIn;
begin
  if CanFade then
    Owner.Fader.FadeIn(Self);
end;

procedure TdxBarControlMDIButtonFadingHelper.FadeOut;
begin
  if CanFade then
    Owner.Fader.FadeOut(Self);
end;

procedure TdxBarControlMDIButtonFadingHelper.GetFadingParams(
  out AFadeOutImage, AFadeInImage: TcxBitmap;
  var AFadeInAnimationFrameCount, AFadeInAnimationFrameDelay: Integer;
  var AFadeOutAnimationFrameCount, AFadeOutAnimationFrameDelay: Integer);
var
  AFadingHelper: IdxFadingPainterHelper;
  R: TRect;
begin
  if Supports(Owner.Painter, IdxFadingPainterHelper, AFadingHelper) then
  begin
    R := Owner.RectMDI(MDIButton);
    OffsetRect(R, -R.Left, -R.Top);
    AFadeInImage := TcxBitmap.CreateSize(R, pf32bit);
    AFadeOutImage := TcxBitmap.CreateSize(R, pf32bit);
    Owner.Painter.BarDrawMDIButton(Owner, MDIButton, DXBAR_HOT,
      AFadeInImage.Canvas.Handle, R);
    Owner.Painter.BarDrawMDIButton(Owner, MDIButton, DXBAR_NORMAL,
      AFadeOutImage.Canvas.Handle, R);
    if AFadingHelper.BarMarkIsOpaque then
    begin
      AFadeInImage.MakeOpaque;
      AFadeOutImage.MakeOpaque;
    end;
  end;
end;

{ TdxBarControl }

constructor TdxBarControl.Create(AOwner: TComponent);
var
  AButton: TdxBarMDIButton;
begin
  inherited Create(AOwner);
  FMarkFadingHelper := TdxBarControlMarkFadingHelper.Create(Self);
  for AButton := Low(TdxBarMDIButton) to High(TdxBarMDIButton) do
    FMDIButtonFadingHelper[AButton] := TdxBarControlMDIButtonFadingHelper.Create(Self, AButton);
end;

constructor TdxBarControl.CreateEx(AOwner: TComponent; ABar: TdxBar);
begin
  Create(AOwner);
  FBar := ABar;
end;

constructor TdxBarControl.CreateForPopup(AParentBarControl: TdxBarControl;
  ABar: TdxBar);
begin
  CreateEx(ABar.BarManager, ABar);
  FPopupBar := ABar;
  ParentBar := AParentBarControl;
  BarManager.Bars.BeginUpdate;
  try
    Bar := BarManager.Bars.Add;
    Bar.AllowQuickCustomizing := False;
    Bar.Hidden := True;
    Bar.Font := AParentBarControl.Font;
    Bar.UseOwnFont := False;
  finally
    BarManager.Bars.EndUpdate(False);
  end;
  ItemLinks := Bar.ItemLinks;
  ItemLinks.BarControl := Self;
  ItemLinks.Internal := True;
end;

destructor TdxBarControl.Destroy;
var
  AButton: TdxBarMDIButton;
begin
//#DG  Destroying;
  BarAccessibilityHelperOwnerObjectDestroyed(FMarkIAccessibilityHelper);
  if (FBar <> nil) and (FBar.Bars <> nil) and (DockingStyle <> dsNone) then
    FBar.Bars.UnregFromDock(FDockingStyle, FDockControl, Self);

  BarLostFocus; //  HideAll; //#DG TODO: CHECK IT!!!

  if WindowHandle = 0 then
    DestroyControls
  else
    DestroyHandle;
    
  for AButton := Low(TdxBarMDIButton) to High(TdxBarMDIButton) do
    FreeAndNil(FMDIButtonFadingHelper[AButton]);
  FreeAndNil(FMarkFadingHelper);
  inherited Destroy;
  if IsPopup then
    FreeAndNil(FBar);
end;

function TdxBarControl.ClientToScreen(const APoint: TPoint): TPoint;
begin
  Result := APoint;
  Windows.ClientToScreen(Handle, Result);
end;

procedure TdxBarControl.CloseUp;
begin
  ParentBar.MarkState := msNone;
end;

procedure TdxBarControl.Hide;
begin
  SetWindowPos(Handle, 0, 0, 0, 0, 0,
    SWP_NOZORDER or SWP_NOMOVE or SWP_NOSIZE or SWP_HIDEWINDOW or SWP_NOACTIVATE);

  if SelectedControl <> nil then
    SelectedControl.ParentVisibleChange(False);
end;

function TdxBarControl.GetCaptionBkColor: COLORREF;
begin
  Result := Painter.BarCaptionBkColor(Self, BarManager.MainFormActive);
end;

function TdxBarControl.GetCaptionButtons: TdxBarCaptionButtons;
begin
  Result := Bar.CaptionButtons;
end;

function TdxBarControl.GetCaptionColor: COLORREF;
begin
  Result := Painter.BarCaptionColor(Self);
end;

function TdxBarControl.GetHorizontal: Boolean;
begin
  Result := DockingStyle in [dsTop, dsBottom];
end;

function TdxBarControl.GetInternallyLocked: Boolean;
begin
  Result := FInternalLockCount <> 0;
end;

function TdxBarControl.GetIsFadingAvailable: Boolean;
begin
  Result := Painter.IsFadingAvailable and (Fader <> nil);
end;

function TdxBarControl.GetMarkIAccessibilityHelper: IdxBarAccessibilityHelper;
begin
  if FMarkIAccessibilityHelper = nil then
    FMarkIAccessibilityHelper := GetAccessibilityHelper(GetMarkAccessibilityHelperClass.Create(Self));
  Result := FMarkIAccessibilityHelper;
end;

function TdxBarControl.GetVertical: Boolean;
begin
  Result := DockingStyle in [dsLeft, dsRight];
end;

procedure TdxBarControl.SetCloseButtonState(Value: TdxBarMarkState);
var
  DC: HDC;
begin
  if FCloseButtonState <> Value then
  begin
    FCloseButtonState := Value;
    if HandleAllocated then
    begin
      DC := GetWindowDC(Handle);
      DrawCloseButton(DC);
      ReleaseDC(Handle, DC);
    end;
  end;
end;

procedure TdxBarControl.SetNewBounds;
begin
  if (Left <> NewLeft) or (Top <> NewTop) or (Width <> NewWidth) or (Height <> NewHeight) then
    SetWindowPos(Handle, 0, NewLeft, NewTop, NewWidth, NewHeight, SWP_NOZORDER or SWP_NOACTIVATE);
end;

procedure TdxBarControl.SetMoving(Value: Boolean);
var
  I: Integer;
  KillingHandle: HWND;
begin
  if FMoving <> Value then
  begin
    FMovingChanging := True;
    try
      FMoving := Value;
      if Value then
        FBar.Bars.FMovingBarControl := Self
      else
        FBar.Bars.FMovingBarControl := nil;
//      SetCursorForMoving(Value);
      for I := 0 to ItemLinks.CanVisibleItemCount - 1 do
        if ItemLinks.CanVisibleItems[I].Control.HasWindow then
          with TdxBarWinControl(ItemLinks.CanVisibleItems[I].Control) do
            if FMoving then
              DestroyInnerEdit
            else
              CreateInnerEdit;
      if FMoving then
      begin
        if FDockingStyle = dsNone then
        begin
          FFloatingHandle := Handle;
          FDockingStyle := dsLeft;
          FDockControl := FBar.Bars.FDockControls[dsLeft];
          DestroyControls;
          WindowHandle := 0;
          CreateHandle;
          FDockedHandle := Handle;
          WindowHandle := 0;
          FDockingStyle := Bar.DockingStyle;
          FDockControl := nil;
          BeginInternal;
          try
            CreateHandle;
          finally
            EndInternal;
          end;
          Windows.SetParent(FDockedHandle, 0);
        end
        else
        begin
          FDockedHandle := Handle;
          FDockingStyle := dsNone;
          DestroyControls;
          WindowHandle := 0;
          CreateHandle;
          FFloatingHandle := Handle;
          WindowHandle := 0;
          FDockingStyle := Bar.DockingStyle;
          BeginInternal;
          try
            CreateHandle;
          finally
            EndInternal;
          end;
        end;
        // this code creates problems with other relative popups
//        SetWindowPos(FFloatingHandle, HWND_TOPMOST, 0, 0, 0, 0,
//          SWP_NOMOVE or SWP_NOSIZE or SWP_NOACTIVATE);
      end
      else
      begin
        // this code makes top-most windows normal
        //SetWindowPos(FFloatingHandle, HWND_NOTOPMOST, 0, 0, 0, 0,
        //  SWP_NOMOVE or SWP_NOSIZE or SWP_NOACTIVATE);
        if FDockingStyle = dsNone then
          KillingHandle := FDockedHandle
        else
          KillingHandle := FFloatingHandle;
        SetWindowLong(KillingHandle, GWL_WNDPROC, Longint(DefWndProc));
        DestroyWindow(KillingHandle);
        SavePos;
      end;
      SetCursorForMoving(Value);      
      Perform(WM_SIZE, 0, 0);  // to store normal size
      RepaintBar;
    finally
      FMovingChanging := False;
    end;
  end;
end;

procedure TdxBarControl.ChangeStyleWinTo(AStyle: TdxBarDockingStyle;
  ADockControl: TdxDockControl);
begin
  if (FBar = nil) or (FBar.Bars = nil) or IsDestroying then Exit;
  if FMoving then
  begin
    DockControl := ADockControl;
    DockingStyle := AStyle;
    WindowHandle := 0;
    BeginInternal;
    try
      CreateHandle;
    finally
      EndInternal;
    end;
    if FDockingStyle = dsNone then
      Windows.SetParent(FDockedHandle, 0)
    else
      Windows.SetParent(Handle, FDockControl.Handle);
    RepaintBar;
  end
  else
  begin
    BeginInternal;
    try
      DestroyHandle;
    finally
      EndInternal;
    end;
    DockControl := ADockControl;
    DockingStyle := AStyle;
    CreateHandle;
    FrameChanged;
  end;
end;

function TdxBarControl.GetDragPointOffset(Style: TdxBarDockingStyle): TPoint;
begin
  if (Style <> dsNone) and (Self = Bar.Bars.FMovingBarControl) and
    (Style = Bar.Bars.FMovingBarOriginalDockingStyle) then
    with Bar.Bars do
      if Vertical then
        Result := Point(-FMovingOffset.X, FMovingStaticOffset.Y)
      else
        Result := Point(FMovingStaticOffset.X, -FMovingOffset.Y)
  else
    with GetTrackSize(Style) do
    begin
      Result.X := MulDiv(X, RX.X, RX.Y);
      Result.Y := MulDiv(Y, RY.X, RY.Y);
    end;
end;

function TdxBarControl.GetCaptionNCRect: TRect;
begin
  Result := Painter.GetToolbarCaptionRect(NCRect);
end;

procedure TdxBarControl.DrawCloseButton(DC: HDC);
begin
  Painter.BarDrawCloseButton(Self, DC, CloseButtonRectNC);
end;

procedure TdxBarControl.DrawMark(DC: HDC);
begin
  Painter.BarDrawMark(Self, DC, MarkNCRect);
end;

procedure TdxBarControl.DrawMDIButton(AButton: TdxBarMDIButton; ASelected, APressed: Boolean);

  function GetMDIButtonState: Integer;
  begin
    Result := DXBAR_NORMAL;
    if not MDIButtonEnabled(AButton, MF_GRAYED) then
      Result := DXBAR_DISABLED
    else
      if ASelected or APressed then
        if ASelected and APressed then
          Result := DXBAR_PRESSED
        else
          if ASelected then
            Result := DXBAR_HOT
          else
            Result := DXBAR_ACTIVE
  end;

var
  R: TRect;
  DC: HDC;
begin
  R := RectMDI(AButton);
  DC := Canvas.Handle;
  Painter.BarDrawMDIButton(Self, AButton, GetMDIButtonState, DC, R);
end;

function TdxBarControl.GetMDIWidth: Integer;
begin
  if RealMDIButtonsOnBar then
    if IsRealVertical then
      Result := MDIButtonWidth
    else
      Result := 3 * MDIButtonWidth + 2
  else
    Result := MDIButtonWidth;
end;

function TdxBarControl.GetMDIHeight: Integer;
begin
  if RealMDIButtonsOnBar then
    if IsRealVertical then
      Result := 3 * MDIButtonHeight + 2
    else
      Result := MDIButtonHeight
  else
    Result := MDIButtonHeight;
end;

function TdxBarControl.RectMDI(Button: TdxBarMDIButton): TRect;
var
  AVertical: Boolean;
  AWidth, AHeight, W, H, MDISize, Offset: Integer;

  function MDIButtonsHaveOwnRow: Boolean;
  var
    I, L: Integer;
  begin
    Result := False;
    L := ItemLinks.VisibleItemCount - 1;
    for I := L downto 0 do
      with ItemLinks.VisibleItems[I] do
      begin
        if Control.FLastInRow and (I <> L) then
        begin
          Result := True;
          Break;
        end;
        if AVertical then
          if ItemRect.Left < Offset then Break
          else
        else
          if ItemRect.Bottom > Offset then Break;
        if I = 0 then Result := True;
      end;
  end;

begin
  SetRectEmpty(Result);

  AVertical := Vertical;
  if AVertical then
  begin
    AWidth := ClientHeight;
    AHeight := ClientWidth;
    W := MDIButtonHeight;
    H := MDIButtonWidth;
    MDISize := GetMDIHeight;
  end
  else
  begin
    AWidth := ClientWidth;
    AHeight := ClientHeight;
    W := MDIButtonWidth;
    H := MDIButtonHeight;
    MDISize := GetMDIWidth;
  end;
  if DockingStyle <> dsNone then
    Dec(AWidth, GetMarkSize);

  if MultiLine then
  begin
    if AVertical then
      Offset := H
    else
      Offset := AHeight - H;
    if not MDIButtonsHaveOwnRow then
      if ItemLinks.VisibleItemCount = 0 then
        Offset := (AHeight - H) div 2
      else
        Offset := AHeight -
          (ItemLinks.VisibleItems[ItemLinks.VisibleItemCount - 1].RowHeight - H) div 2 - H
    else
      if AVertical then Offset := AHeight - Offset;
  end
  else
    Offset := (AHeight - H) div 2;

  if RealMDIButtonsOnBar then
  begin
    Result := Bounds(AWidth - MDISize + W * Ord(Button), Offset, W, H);
    if Button = mdibClose then OffsetRect(Result, 2, 0);
  end
  else
    Result := Bounds(AWidth - W, Offset, W, H);
  if AVertical then
    with Result do
    begin
      W := Left;
      Left := AHeight - Bottom;
      Bottom := Right;
      Right := AHeight - Top;
      Top := W;
    end;
end;

function TdxBarControl.RealMDIButtonsOnBar: Boolean;
begin
  Result := IsMainMenu and BarManager.IsMDIMaximized and
    (GetSystemMenu(BarManager.ActiveMDIChild, False) <> 0);
end;

function TdxBarControl.MDIButtonsOnBar: Boolean;
begin
  Result := RealMDIButtonsOnBar or IsMainMenu and BarManager.ShowCloseButton;
end;

function TdxBarControl.MDIButtonEnabled(AButton: TdxBarMDIButton; State: Integer): Boolean;
begin
  Result :=
    (AButton = mdibRestore) or
    (AButton = mdibClose) and not RealMDIButtonsOnBar and MDIButtonsOnBar or
    (GetMenuState(GetSystemMenu(BarManager.ActiveMDIChild, False),
     MDIButtonCommands[AButton], MF_BYCOMMAND) and State = 0);
end;

procedure MoreButtonsHintTimerProc(Wnd: HWND; Msg: UINT; idEvent: UINT; Time: DWORD); stdcall;
var
  BarControl: TdxBarControl;
begin
  BarControl := TdxBarControl(FindControl(Wnd));
  with BarControl do
    if not IsWindowVisible(Handle) or not MouseOnMark then
      FinishMoreButtonsHintTimer;
end;

procedure TdxBarControl.StartMoreButtonsHintTimer;
begin
  FMoreButtonsHintTimer := SetTimer(Handle, 1, 50, @MoreButtonsHintTimerProc);
end;

procedure TdxBarControl.FinishMoreButtonsHintTimer;
begin
  if dxKillTimer(0, FMoreButtonsHintTimer) and (MarkState = msSelected) then
    MarkState := msNone;
end;

function TdxBarControl.CanResizeSelectedLink(APoint: TPoint): Boolean;
begin
  Result := (SelectedControlAtDesign <> nil) and SelectedControlAtDesign.CanResize(APoint);
end;

procedure TdxBarControl.WMCaptureChanged(var Message: TMessage);
begin
  inherited;
  if FIsResizing then
  begin
    FIsResizing := False;
    SelectedControl.EndResize(False);
  end;
end;

procedure TdxBarControl.WMDestroy(var Message: TMessage);
var
  ADockControl: TdxDockControl;
begin
  ADockControl := DockControl;
  if ADockControl <> nil then
    ADockControl.IsBarHandleDestroying := True;
  try
    FinishMoreButtonsHintTimer;
    inherited;
    if (FBar <> nil) and not InternallyLocked and not IsInternal and FBar.Visible and
      not BarManager.IsDestroying then
    begin
      BarManager.AddBarToRestoringList(Bar);
      FBar.Visible := False;
    end;
  finally
    if ADockControl <> nil then
      ADockControl.IsBarHandleDestroying := False;
  end;
end;

procedure TdxBarControl.WMGetDlgCode(var Message: TWMGetDlgCode);
begin
  Message.Result := DLGC_WANTALLKEYS or DLGC_WANTARROWS or DLGC_WANTTAB;
end;

procedure TdxBarControl.WMGetMinMaxInfo(var Message: TWMGetMinmaxInfo);
begin
  inherited;
  with Message.MinMaxInfo^ do
  begin
    ptMinTrackSize := Point(10, 10);
    ptMaxTrackSize := Point(30000, 30000);  // because of Win95/98
    ptMaxSize := ptMaxTrackSize;
    ptMaxPosition := ptMaxSize;
  end;
end;

procedure TdxBarControl.WMGetObject(var Message: TMessage);
begin
//  if CanReturnAccessibleObject(Message) then
//    Message.Result := WMGetObjectResultFromIAccessibilityHelper(Message, IAccessibilityHelper)
//  else
    inherited;
end;

procedure TdxBarControl.WMLButtonDblClk(var Message: TWMLButtonDblClk);
begin
  CheckMarkState(Point(Message.XPos, Message.YPos));
  inherited;
end;

procedure TdxBarControl.WMLButtonUp(var Message: TWMLButtonUp);
var
  P: TPoint;
  AButton: TdxBarMDIButton;
begin
  if FIgnoreMouseClick then
  begin
    FIgnoreMouseClick := False;
    Exit;
  end;

  if FIsResizing then
  begin
    FIsResizing := False;
    SelectedControl.EndResize(True);
    ReleaseCapture;
    Exit;
  end;

  P := Point(Message.XPos, Message.YPos);
  if MDIButtonsOnBar and FIsMDIButtonPressed then
  begin
    ReleaseCapture;
    FIsMDIButtonPressed := False;
    FIsMouseOverMDIButton := False;
    RepaintMDIButtons;
    if not RealMDIButtonsOnBar then
    begin
      if PtInRect(RectMDI(mdibClose), P) then
        BarManager.DoCloseButtonClick;
    end
    else
    begin
      for AButton := Low(TdxBarMDIButton) to High(TdxBarMDIButton) do
        if PtInRect(RectMDI(AButton), P) then
        begin
          if AButton = FPressedMDIButton then
            SendMessage(BarManager.ActiveMDIChild, WM_SYSCOMMAND, MDIButtonCommands[AButton], 0);
          Break;
        end;
    end;
  end;
  inherited;
end;

procedure TdxBarControl.WMMouseActivate(var Message: TWMMouseActivate);
begin
  inherited;
  if not IsActive and (DockingStyle = dsNone) then
    dxSetZOrder(Handle, HWND_TOP);
  //ProcessPaintMessages;
end;

procedure TdxBarControl.WMNCCalcSize(var Message: TWMNCCalcSize);
var
  AContentOffsets: TRect;
begin
  if not FMovingChanging then
    FHasSizeGrip := FBar.HasSizeGrip;
  AContentOffsets := Painter.GetToolbarContentOffsets(Bar, DockingStyle, FHasSizeGrip);

  with Message.CalcSize_Params^.rgrc[0] do
  begin
    Inc(Left, AContentOffsets.Left);
    Inc(Top, AContentOffsets.Top);
    Dec(Right, AContentOffsets.Right);
    Dec(Bottom, AContentOffsets.Bottom);
  end;
end;

procedure TdxBarControl.WMNCHitTest(var Message: TWMNCHitTest);
var
  P: TPoint;
  AControl: TdxBarItemControl;

  function MouseAboveMDIButtons: Boolean;
  begin
    Result := MDIButtonsOnBar and
      (RealMDIButtonsOnBar and
       (PtInRect(RectMDI(mdibMinimize), P) or PtInRect(RectMDI(mdibRestore), P)) or
       PtInRect(RectMDI(mdibClose), P));
  end;

  function NoControl: Boolean;
  begin
    Result := (AControl = nil) or not IsCustomizing and not AControl.HotPartWantMouse;
  end;

  procedure CheckResizingHitTest(var AHitTest: Integer; P: TPoint);
  var
    R, RW: TRect;
    ASizingBorders: TSize;
  begin
    if AHitTest = HTNOWHERE then
    begin
      ASizingBorders.cx := Painter.BorderSizeX;
      ASizingBorders.cy := Painter.BorderSizeY;
      RW := WindowRect;
      Dec(P.X, RW.Left);
      Dec(P.Y, RW.Top);
      OffsetRect(RW, -RW.Left, -RW.Top);
      R := RW;
      R.Bottom := R.Top + ASizingBorders.cy;
      if cxRectPtIn(R, P) then
        AHitTest := HTTOP
      else
      begin
        R := RW;
        R.Left := R.Right - ASizingBorders.cx;
        if cxRectPtIn(R, P) then
          AHitTest := HTRIGHT
        else
        begin
          R := RW;
          R.Top := R.Bottom - ASizingBorders.cy;
          if cxRectPtIn(R, P) then
            AHitTest := HTBOTTOM
          else
          begin
            R := RW;
            R.Right := R.Left + ASizingBorders.cx;
            if cxRectPtIn(R, P) then
              AHitTest := HTLEFT;
          end;
        end;
      end;
    end;
  end;

begin
  inherited;
  if bboUnmoved in BehaviorOptions then
  begin
    FHitTest := Message.Result;
    Exit;
  end;
  FHitTest := 0;
  P := SmallPointToPoint(Message.Pos);
  Windows.ScreenToClient(Handle, P);
  with Message do
    if DockingStyle = dsNone then
    begin
      case Result of
        HTCLIENT:
          begin
            AControl := ItemAtPos(P);
            if NoControl and not MouseAboveMDIButtons then
            begin
              FHitTest := HTCAPTION;
              Result := HTCLIENT;
            end;
          end;
        HTNOWHERE:
          begin
            CheckResizingHitTest(Result, GetMouseCursorPos);
            if Result <> HTNOWHERE then
            begin
              FHitTest := Result;
              Exit;
            end;
            if not IsCustomizing and MarkExists and MouseOnMark(P) then
              FHitTest := HTCLIENT
            else
              if PtInRect(CloseButtonRect, P) then
                if not Painter.BarUseSystemClose then
                  FHitTest := HTCLOSE
                else
                begin
                  FHitTest := HTCLIENT;
                  Result := HTCLOSE;
                  Exit;
                end
              else
                FHitTest := HTCAPTION;
            Result := HTCLIENT;
          end;
      else
        FHitTest := Result;
      end
    end
    else  // DockingStyle <> dsNone
    begin
      if Result = HTCLIENT then
        AControl := ItemAtPos(P)
      else
        AControl := nil;
      if (Result = HTCLIENT) and NoControl or (Result = HTNOWHERE) then
      begin
        if not Vertical and (P.X < 0) or Vertical and (P.Y < 0) or
          NoControl and not MouseAboveMDIButtons and
          (not MarkExists or not MouseOnMark(P)) then
            if FHasSizeGrip and PtInRect(SizeGripRect, P) then
            begin
              FHitTest := HTBOTTOMRIGHT;
              Result := HTBOTTOMRIGHT;
            end
            else
            begin
              FHitTest := HTCAPTION;
              Result := HTCLIENT;
            end;
      end
      else
      begin
        FHitTest := Result;
        Result := HTCLIENT;
      end;
    end;
end;

procedure TdxBarControl.WMNCLButtonDown(var Message: TWMNCLButtonDown);

const
  CloseButtonID = -2;
var
  ACloseButtonRectNC: TRect;
  AActiveButtonID: Integer;

  function GetWindowCursorPos: TPoint;
  begin
    Result := cxPointOffset(GetMouseCursorPos, cxPointInvert(WindowRect.TopLeft));
  end;

  function GetButtonID(const APoint: TPoint): Integer;
  begin
    if PtInRect(ACloseButtonRectNC, APoint) then
      Result := CloseButtonID
    else
      Result := CaptionButtons.GetButtonIndex(APoint);
  end;

  procedure UpdateButtonState(AMousePressed: Boolean);
  var
    APoint: TPoint;
  begin
    APoint := GetWindowCursorPos;
    if AActiveButtonID = CloseButtonID then
      if GetButtonID(APoint) = CloseButtonID then
        if AMousePressed then
          CloseButtonState := msPressed
        else
          CloseButtonState := msSelected
      else
        if AMousePressed then
          CloseButtonState := msSelected
        else
          CloseButtonState := msNone
    else
      CaptionButtons.UpdateButtonStates(APoint, AMousePressed);
  end;

  procedure DoClick;
  var
    ABar: TdxBar;
  begin
    if AActiveButtonID = CloseButtonID then
    begin
      ABar := FBar;
      Bar.Visible := False;
      ABar.BarManager.DesignerModified;
      ABar.BarManager.DoBarClose(ABar);
    end
    else
      CaptionButtonClick(AActiveButtonID);
  end;

var
  ASuccessfulDragging: Boolean;
  ACaptureWnd: HWND;
  AMsg: TMsg;
begin
  if NeedHideOnNCMouseClick then
    HideAll;
  if not BarControlExists(Self) then Exit;

  ACloseButtonRectNC := CloseButtonRectNC;

  AActiveButtonID := GetButtonID(GetWindowCursorPos);

  if AActiveButtonID <> -1 then
  begin
    if not BarManager.HideFloatingBarsWhenInactive then
      SetActiveWindow(BarManager.Owner.Handle);

    UpdateButtonState(True);
    ASuccessfulDragging := False;

    ACaptureWnd := Handle;
    SetCapture(ACaptureWnd);
    try
      while GetCapture = ACaptureWnd do
      begin
        case Integer(GetMessage(AMsg, 0, 0, 0)) of
          -1: Break;
          0: begin
              PostQuitMessage(AMsg.wParam);
              Break;
            end;
        end;
        with AMsg do
          case message of
            WM_LBUTTONUP:
              begin
                ASuccessfulDragging := GetButtonID(GetWindowCursorPos) = AActiveButtonID;
                Break;
              end;
            WM_MOUSEMOVE:
              if PtInRect(WindowRect, GetMouseCursorPos) then
              begin
                if cxPointIsEqual(FLastMousePos, cxInvalidPoint) then
                  DoBarMouseEnter([], cxInvalidPoint, nil);
                FLastMousePos := GetMouseCursorPos;

                UpdateButtonState(True);
              end;
          else
            TranslateMessage(AMsg);
            DispatchMessage(AMsg);
          end;
      end;
    finally
      if GetCapture = ACaptureWnd then
        ReleaseCapture;
      UpdateButtonState(False);
//      CloseButtonState := msNone;
      if ASuccessfulDragging then
        DoClick;
    end;
    Exit;
  end;
  inherited;
end;

procedure TdxBarControl.WMSetCursor(var Message: TWMSetCursor);
var
  P: TPoint;
begin
  P := ScreenToClient(GetMouseCursorPos);

  if FIsResizing or CanResizeSelectedLink(P) then
    SetCursor(Screen.Cursors[crdxBarEditSizing])
  else
  begin
    if not Moving and CanMoving then // ---
      SetCursorForMoving(PtInRect(GetSizeAllCursorBounds, P));
    inherited;
  end;
end;

procedure TdxBarControl.WMSize(var Message: TWMSize);
begin
  if IsDestroying then Exit;
  inherited;
  CalcLayout;
end;

procedure TdxBarControl.WMSizing(var Message: TMessage);
var
  Size: TPoint;
  NCSize: Integer;
begin
  inherited; 
  if DockingStyle = dsNone then
    with Message, PRect(lParam)^ do
    begin
      case wParam of
        WMSZ_LEFT, WMSZ_RIGHT:
          begin
            NCSize := Bar.BarNCSizeX(dsNone);
            Size := GetSizeForWidth(DockingStyle, Right - Left - NCSize);
            if wParam = WMSZ_LEFT then
              Left := Right - Size.X - NCSize
            else
              Right := Left + Size.X + NCSize;
            Bottom := Top + Size.Y + Bar.BarNCSizeY(dsNone);
          end;
        WMSZ_TOP, WMSZ_BOTTOM:
          begin
            NCSize := Bar.BarNCSizeY(dsNone);
            Size := GetSizeForHeight(DockingStyle, Bottom - Top - NCSize);
            Right := Left + Size.X + Bar.BarNCSizeX(dsNone);
            if wParam = WMSZ_TOP then
              Top := Bottom - Size.Y - NCSize
            else
              Bottom := Top + Size.Y + NCSize;
          end;
      else
        PRect(lParam)^ := BoundsRect;
        Result := 1;
      end;
      // against windows' bug:
      if Top < -15 then OffsetRect(PRect(lParam)^, 0, -15 - Top);
      Result := 1;
    end;
end;

procedure TdxBarControl.WMWindowPosChanging(var Message: TWMWindowPosChanging);

  procedure CalcCoords(const AWindowPos: TWindowPos; var ALeft, ATop, AWidth, AHeight: Integer);
  begin
    if AWindowPos.flags and SWP_NOMOVE = 0 then
    begin
      ALeft := AWindowPos.x;
      ATop := AWindowPos.y;
    end
    else
    begin
      ALeft := Left;
      ATop := Top;
    end;
    if AWindowPos.flags and SWP_NOSIZE = 0 then
    begin
      AWidth := AWindowPos.cx;
      AHeight := AWindowPos.cy;
    end
    else
    begin
      AWidth := Width;
      AHeight := Height;
    end;
  end;

var
  L, T, W, H: Integer;
  I: Integer;
  AIntersect: Boolean;
  P: TPoint;
  R, ABarRect, ARect: TRect;
begin
  inherited;
  if DockingStyle <> dsNone then Exit;
  if (Message.WindowPos^.flags and SWP_NOMOVE = 0) or
    (Message.WindowPos^.flags and SWP_NOSIZE = 0) then
  begin
    CalcCoords(Message.WindowPos^, L, T, W, H);

    ABarRect := Bounds(L, T, W, H);
    AIntersect := False;
    for I := 0 to Screen.MonitorCount - 1 do
    begin
      // begin BoundsRect
      P := Point(Screen.Monitors[I].Left, Screen.Monitors[I].Top);
      R := GetWorkArea(P);
      // end BoundsRect
      if IntersectRect(ARect, R, ABarRect) then
      begin
        AIntersect := True;
        Break;
      end;
    end;

    if not AIntersect then
    begin
      R := GetWorkArea(GetMouseCursorPos);
      with Message.WindowPos^ do
      begin
        with R do
        begin
          if L + W <= Left then
          begin
            x := Left;
            y := T;
            flags := flags and not SWP_NOMOVE;
          end;
          if T + H <= Top then
          begin
            x := L;
            y := Top;
            flags := flags and not SWP_NOMOVE;
          end;
          if L >= Right then
          begin
            x := Right - W;
            y := T;
            flags := flags and not SWP_NOMOVE;
          end;
          if T >= Bottom then
          begin
            x := L;
            y := Bottom - H;
            flags := flags and not SWP_NOMOVE;
          end;
        end;
      end;
    end;
  end;
end;

procedure TdxBarControl.CMFontChanged(var Message: TMessage);
begin
  UpdateCanvasFont;
  if not HandleAllocated then
    Exit;
  CalcDrawingConsts;
  if not InternallyLocked then
  begin
    SetMouseSelectedItem(nil);
    RepaintBar;
  end;
  inherited;
end;

procedure TdxBarControl.CreateParams(var Params: TCreateParams);
begin
  inherited CreateParams(Params);
  with Params do
  begin
    Style := WS_CLIPCHILDREN or WS_CLIPSIBLINGS;
    WindowClass.Style := CS_DBLCLKS or CS_HREDRAW or CS_VREDRAW;
    ExStyle := 0;
    if DockingStyle = dsNone then
    begin
      Style := (Style or WS_POPUP) and not WS_BORDER;
      WndParent := BarManager.Owner.Handle;
    end
    else
    begin
      Style := Style or WS_CHILD;
      WndParent := FDockControl.Handle;
    end;
  end;
end;

procedure TdxBarControl.CreateWnd;
begin
  if FMoving and InternallyLocked then
    if FDockingStyle = dsNone then
      WindowHandle := FFloatingHandle
    else
      WindowHandle := FDockedHandle
  else
    inherited;
  Text := GetCaption;
  SendMessage(Handle, WM_NCACTIVATE, Longint(True), 0);  // don't remove (AV in ntdll.dll)
end;

procedure TdxBarControl.Paint;
var
  APrevRegion: TcxRegion;
begin
  APrevRegion := Canvas.GetClipRegion;
  try
    inherited;
    DoPaint;
    if BarManager.IsUncustomizable then
    begin
      Canvas.SetClipRegion(APrevRegion, roSet, False);
      DrawDisablingHatch(Canvas.Handle, ClientRect);
    end;
  finally
    APrevRegion.Free;
  end;
end;

procedure TdxBarControl.Resize;
begin
  inherited;
  if HasCaptionButtons then
    UpdateCaptionButton(nil);
end;

procedure TdxBarControl.WindowPosChanged(var Message: TWMWindowPosChanged);
begin
  inherited;
  if (FBar = nil) or InternallyLocked then
    Exit;
  FBar.ChangeDockingStyle(DockingStyle, DockControl);
  SavePos;
  with Message.WindowPos^ do
  begin
    if ((flags and SWP_NOSIZE = 0) or (flags and SWP_NOMOVE = 0)) and
      (FQuickPopup <> nil) then
    begin
      FQuickPopup.OwnerBounds := MarkScreenRect;
      FQuickPopup.ResizeShadow;
      SendMessage(FQuickPopup.Handle, WM_NCPAINT, 0, 0);
    end;
    if (flags and SWP_NOSIZE <> 0) and (flags and SWP_NOMOVE = 0) and
      (FHasSizeGrip <> FBar.HasSizeGrip) then
      RebuildBar;
  end;
  if IsPopup and (Message.WindowPos^.flags and SWP_HIDEWINDOW <> 0) and not IsDestroying then
    CloseUp;  
end;

procedure TdxBarControl.BeginInternal;
begin
  Inc(FInternalLockCount);
end;

procedure TdxBarControl.EndInternal;
begin
  if FInternalLockCount > 0 then
    Dec(FInternalLockCount);
end;

procedure TdxBarControl.LayoutChanged;
begin
  if BarManager.CanShowRecentItems and (DockingStyle <> dsNone) then
    PostMessage(Handle, WM_REPAINTBAR, 0, 0);
end;

procedure TdxBarControl.DoKeyDown(var Message: TWMKey);
begin
  case Message.CharCode of
    VK_ESCAPE:
      begin
        Message.CharCode := 0;
        HideAllByEscape;
      end;
    else
      inherited;
  end;
end;

procedure TdxBarControl.CalcControlsPositions;
begin
  inherited CalcControlsPositions;
  CalcItemRects(GetPaintType);
end;

procedure TdxBarControl.CalcRowItemRects;
var
  FirstInRow, X, Y, ARowHeight, ABeginGroupSize, ASize, VerSize, AWidth, AHeight: Integer;
  AMultiLine, AVertical, ItemControlAlignApplied: Boolean;
  AItemLink: TdxBarItemLink;

  function GetMDIButtonSize(AIsVertical: Boolean): Integer;
  begin
    if not MDIButtonsOnBar then
      Result := 0
    else
      if AIsVertical then
        Result := GetMDIHeight
      else
        Result := GetMDIWidth;
  end;

  procedure InitValues;
  begin
    X := 0;
    Y := 0;
    VerSize := 0;
    AItemLink := nil;
    AMultiLine := MultiLine;
    AVertical := Vertical;
    
    if AVertical then
      ASize := ClientHeight
    else
      ASize := ClientWidth;
    if DockingStyle <> dsNone then
        Dec(ASize, GetMarkSize);

    if AMultiLine then
    begin
      if AVertical then
        VerSize := ClientWidth;
      ARowHeight := 0;
      FirstInRow := 0;
    end
    else
    begin
      if AVertical then
        ARowHeight := ClientWidth
      else
        ARowHeight := ClientHeight;
      Dec(ASize, GetMDIButtonSize(AVertical));
    end;
  end;

  procedure InitItemControlValues;
  begin
    with AItemLink.Control do
    begin
      FLastInRow := False;
      if AVertical then
      begin
        AWidth := Height;
        AHeight := Width;
      end
      else
      begin
        AWidth := Width;
        AHeight := Height;
      end;
    end;
    if AItemLink.BeginGroup and (X > 0) then
      ABeginGroupSize := BeginGroupSize
    else
      ABeginGroupSize := 0;
  end;

  function ItemControlBreaksRow: Boolean;
  begin
    Result :=
      ((X > 0) or not AMultiLine and CanHideAllItemsInSingleLine) and (X + ABeginGroupSize + AWidth > ASize) or
      AMultiLine and AItemLink.Control.FBreakingRow;
  end;

  procedure ArrangeControlsOnRow(const LastInRow: Integer);
  var
    I: Integer;
  begin
    for I := FirstInRow to LastInRow do
      with ItemLinks.VisibleItems[I], ItemRect do
      begin
        if AVertical then
          ItemRect := cxRectOffset(ItemRect, -(ARowHeight - (Right - Left)) div 2, 0)
        else
          ItemRect := cxRectOffset(ItemRect, 0, (ARowHeight - (Bottom - Top)) div 2);
        RowHeight := ARowHeight;
      end;
    FirstInRow := LastInRow + 1;
  end;

  function GetItemControlRect: TRect;

    procedure ApplyAlign;

      procedure CheckSize;
      var
        AMDISize: Integer;
      begin
        if AMultiLine and (AItemLink.Control.Align <> iaLeft) and MDIButtonsOnBar then
        begin
          if AVertical then
            AMDISize := GetMDIHeight
          else
            AMDISize := GetMDIWidth;
          if Result.Right + AMDISize <= ASize then
            Dec(ASize, AMDISize);
        end;
      end;

    begin
      CheckSize;
      ItemControlAlignApplied := True;
      case AItemLink.Control.Align of
        iaLeft:
          ItemControlAlignApplied := False;
        iaCenter:
          if AVertical then
            OffsetRect(Result, 0, (ASize - Result.Bottom) div 2)
          else
            OffsetRect(Result, (ASize - Result.Right) div 2, 0);
        iaRight:
          if AVertical then
            OffsetRect(Result, 0, ASize - Result.Bottom)
          else
            OffsetRect(Result, ASize - Result.Right, 0);
        iaClient:
          with Result do
            if AVertical then
            begin
              Bottom := ASize;
              if Bottom - Top < AItemLink.Control.MinWidth then
                Bottom := Top + AItemLink.Control.MinWidth;
            end
            else
            begin
              Right := ASize;
              if Right - Left < AItemLink.Control.MinWidth then
                Right := Left + AItemLink.Control.MinWidth;
            end;
      end;
    end;

  begin
    if AMultiLine then
      if AVertical then
        Result := Bounds(VerSize - Y - AHeight, X + ABeginGroupSize, AHeight, AWidth)
      else
        Result := Bounds(X + ABeginGroupSize, Y, AWidth, AHeight)
    else
      case DockingStyle of
        dsTop, dsBottom:
          Result :=
            Bounds(X + ABeginGroupSize, (ARowHeight - AHeight) div 2, AWidth, AHeight);
        dsLeft, dsRight:
          Result :=
            Bounds((ARowHeight - AHeight) div 2, X + ABeginGroupSize, AHeight, AWidth);
      end;
    ApplyAlign;
  end;

  procedure CalcX(ALinkIndex: Integer);
  begin
    if ItemControlAlignApplied then
    begin
      X := ASize;
      if ALinkIndex < ItemLinks.VisibleItemCount - 1 then
        FTruncated := True;
    end
    else
      Inc(X, ABeginGroupSize + AWidth);
  end;

var
  I: Integer;
begin
  InitValues;
  for I := 0 to ItemLinks.VisibleItemCount - 1 do
  begin
    AItemLink := ItemLinks.VisibleItems[I];
    if AItemLink.Control = nil then
      AItemLink.CreateControl;
    InitItemControlValues;
    if ItemControlBreaksRow then
      if AMultiLine then
      begin
        ItemLinks.VisibleItems[I - 1].Control.FLastInRow := True;
        ArrangeControlsOnRow(I - 1);
        Inc(Y, ARowHeight + ABeginGroupSize);
        X := 0;
        ABeginGroupSize := 0;
        ARowHeight := 0;
      end
      else
      begin
        if I = 0 then
          AItemLink := nil
        else
          AItemLink := ItemLinks.VisibleItems[I - 1];
        Break;
      end;
    AItemLink.ItemRect := GetItemControlRect;
    AItemLink.RowHeight := ARowHeight;
    CalcX(I);
    if ARowHeight < AHeight then ARowHeight := AHeight;
  end;
  if AItemLink <> nil then
    AItemLink.Control.FLastInRow := True;
  if AMultiLine then
    ArrangeControlsOnRow(ItemLinks.VisibleItemCount - 1);
end;

procedure TdxBarControl.CalcDrawingConsts;
begin
  inherited CalcDrawingConsts;
  FMDIButtonWidth := GetSystemMetrics(SM_CXMENUSIZE) - 2;
  FMDIButtonHeight := GetSystemMetrics(SM_CYMENUSIZE) - 2 * 2;
  FMarkSize := Painter.MarkSizeX(Self);
end;

procedure TdxBarControl.CalcDragOverParameters(const ACursorPos: TPoint;
  var ADragOverItemLink: TdxBarItemLink;
  var AIsBeginGroup, AIsFirstPart, AIsVerticalDirection: Boolean);

  function GetRowLastItemControl(const ACursorPos: TPoint): TdxBarItemControl;
  var
    AControl: TdxBarItemControl;
    AItemRect: TRect;
    AVertical: Boolean;
    I: Integer;
  begin
    Result := nil;
    for I := 0 to ItemLinks.VisibleItemCount - 1 do
    begin
      AControl := ItemLinks.VisibleItems[I].Control;
      if AControl.CanCustomize and AControl.LastInRow then
      begin
        AItemRect := GetItemRect(AControl);
        AVertical := Vertical;
        if AVertical and (AItemRect.Left <= ACursorPos.X) and (ACursorPos.X < AItemRect.Right) or
          not AVertical and (AItemRect.Top <= ACursorPos.Y) and (ACursorPos.Y < AItemRect.Bottom) then
        begin
          Result := AControl;
          Break;
        end;
      end;
    end;
  end;

  function GetRowFirstItemControl(ARowLastItemControl: TdxBarItemControl): TdxBarItemControl;
  var
    AControl: TdxBarItemControl;
    I: Integer;
  begin
    Result := ARowLastItemControl;
    for I := ARowLastItemControl.ItemLink.VisibleIndex - 1 downto 0 do
    begin
      AControl := ItemLinks.VisibleItems[I].Control;
      if AControl.LastInRow then
        Break
      else
        Result := AControl;
    end;
  end;

var
  AControl: TdxBarItemControl;
  AItemRect: TRect;
  AVertical: Boolean;
begin
  inherited CalcDragOverParameters(ACursorPos, ADragOverItemLink,
    AIsBeginGroup, AIsFirstPart, AIsVerticalDirection);
  if (ADragOverItemLink <> nil) or not PtInRect(ClientRect, ACursorPos) then
    Exit;
  AControl := GetRowLastItemControl(ACursorPos);
  if AControl <> nil then
  begin
    AItemRect := GetItemRect(AControl);
    AVertical := Vertical;
    if AVertical and (ACursorPos.Y < AItemRect.Top) or
      not AVertical and (ACursorPos.X < AItemRect.Left) then
    begin
      AIsFirstPart := True;
      if AControl.Align in [iaCenter, iaRight] then
        ADragOverItemLink := AControl.ItemLink
      else
        ADragOverItemLink := GetRowFirstItemControl(AControl).ItemLink;
    end
    else
      ADragOverItemLink := AControl.ItemLink;
  end;
end;

function TdxBarControl.CanAlignControl(AControl: TdxBarItemControl): Boolean;
begin
  with AControl.ItemLink do
    Result := Bar.UseRestSpace and (CanVisibleIndex = Owner.CanVisibleItemCount - 1);
end;

function TdxBarControl.CanCallInheritedNCCalcSize: Boolean; // obsolete
begin
  Result := (DockingStyle <> dsNone) or not Flat;
end;

function TdxBarControl.CanCustomizing: Boolean;
begin
  Result := inherited CanCustomizing or FBar.AllowCustomizing;
end;

function TdxBarControl.CanHideAllItemsInSingleLine: Boolean;
begin
  Result := False;
end;

function TdxBarControl.CanMoving: Boolean;
begin
  Result := Bar.CanMoving;
end;

function TdxBarControl.CanProcessShortCut: Boolean;
begin
  Result := HandleAllocated and IsWindowVisible(Handle);
end;

procedure TdxBarControl.CaptionButtonClick(AIndex: Integer);
var
  AButton: TdxBarCaptionButton;
begin
  if IsPopup then
    AButton := PopupBar.CaptionButtons[AIndex]
  else
    AButton := CaptionButtons[AIndex];
  if not NeedHideOnNCMouseClick then
    CloseUp;
  AButton.Click;
end;

function TdxBarControl.GetCaptionRect: TRect;
begin
  Result := cxRectOffset(GetCaptionNCRect, WindowRect.TopLeft);
  MapWindowRect(0, Handle, Result);
end;

procedure TdxBarControl.CheckMarkState(const P: TPoint);
begin
  if IsMarkAccessible and MouseOnMark(P) then
    if MarkState = msPressed then
      MarkState := msSelected
    else
      MarkState := msPressed;
end;

function TdxBarControl.CloseButtonRect: TRect;
var
  ASize: TSize;
  RW, RH: Integer;
begin
  if HasCloseButton then
  begin
    Result := GetCaptionRect;
    with Result do
      Left := Right - Painter.BarCaptionSize;
    ASize := Painter.BarCloseButtonSize;
    RW := Result.Right - Result.Left;
    if ASize.cx < RW then
    begin
      Result.Left := Result.Left + (RW div 2) - (ASize.cx div 2);
      Result.Right := Result.Left + ASize.cx;
    end;
    RH := Result.Bottom - Result.Top;
    if ASize.cy < RH then
    begin
      Result.Top := Result.Top + (RH div 2) - (ASize.cy div 2);
      Result.Bottom := Result.Top + ASize.cy;
    end;
  end
  else
    Result := cxEmptyRect;
end;

function TdxBarControl.CloseButtonRectNC: TRect;
begin
  Result := CloseButtonRect;
  MapWindowRect(Handle, 0, Result);
  OffsetRect(Result, -WindowRect.Left, -WindowRect.Top);
end;

function TdxBarControl.CheckLockUpdate: Boolean;
begin
  Result := inherited CheckLockUpdate;
  if Result and (Bar <> nil) then
    Bar.DoChanged;
end;

procedure TdxBarControl.CustomizePrepare(APoint: TPoint; ASecondClick: Boolean);
begin
  if ASecondClick and CanResizeSelectedLink(APoint) then
  begin
    FIsResizing := True;
    SelectedControlAtDesign.BeginResize(APoint);
    SetCapture(Handle);
  end
  else
    inherited;
end;

procedure TdxBarControl.DoBarGetFocus(ASelectedItem: TdxBarItemControl);
var
  AControl: TWinControl;
  ItemLink: TdxBarItemLink;
begin
  AControl := FindControl(WindowFromPointEx(GetMouseCursorPos));
  if (AControl is TCustomdxBarControl) and (AControl <> Self) then
    TCustomdxBarControl(AControl).MouseLeave;

  dxBar.SendCancelMode;

  FBeforeBarGetFocusFocusedWnd := GetFocus;

  if not IsCustomizing and
    not (IsPopup and ParentBar.Focused) and (GetParentPopupWindow(Self, True) = nil) then
    dxSetZOrder(MasterForm.Handle, HWND_TOP, True);
 
  if ASelectedItem = nil then
  begin
    ItemLink := nil;
    repeat
      ItemLink := ItemLinks.Next(ItemLink);
    until (ItemLink = nil) or (ItemLink.Control <> nil) and
      not (ItemLink.Control is TSystemMenuSubItemControl); // !!!
    if ItemLink <> nil then
      ASelectedItem := ItemLink.Control;
  end;

  inherited DoBarGetFocus(ASelectedItem);

  if not IsFocused then
  begin
    dxFreeAndNilObjectLink(FPrevFocusedBarControlLink);
    if BarManager.FFocusedBarControl <> nil then
      FPrevFocusedBarControlLink := cxAddObjectLink(BarManager.FFocusedBarControl);
    BarManager.FFocusedBarControl := Self;
  end;
end;

procedure TdxBarControl.DoBarLostFocus;
begin
  if (FPrevFocusedBarControlLink <> nil) and (FPrevFocusedBarControlLink.Ref <> nil) then
  begin
    BarManager.FFocusedBarControl := TCustomdxBarControl(FPrevFocusedBarControlLink.Ref);
    dxFreeAndNilObjectLink(FPrevFocusedBarControlLink);
  end
  else
    BarManager.FFocusedBarControl := nil;

  inherited DoBarLostFocus;
  UpdateControlByMouse;

  if Application.Active and IsFormActive(ParentForm) and  // -> bug with toolbars' hiding (without Application.Active)
    IsWindowVisible(FBeforeBarGetFocusFocusedWnd) then
    Windows.SetFocus(FBeforeBarGetFocusFocusedWnd);
end;

procedure TdxBarControl.DoBarMouseDown(Button: TMouseButton; Shift: TShiftState;
  const APoint: TPoint; AItemControl: TdxBarItemControl; APointInClientRect: Boolean);

  function CheckMDIButton(AButton: TdxBarMDIButton): Boolean;
  begin
    Result := PtInRect(RectMDI(AButton), APoint);
    if Result then
    begin
      FIsMDIButtonPressed := True;
      FIsMouseOverMDIButton := True;
      FPressedMDIButton := AButton;
      FSelectedMDIButton := FPressedMDIButton;
      DrawMDIButtons([AButton]);
      SetCapture(Handle);
    end
  end;

var
  AButton: TdxBarMDIButton;
  R: TRect;
begin
  case Button of
    mbLeft:
      begin
      // !!!
        if not BarManager.HideFloatingBarsWhenInactive and (not IsInternal and (DockingStyle = dsNone)) then
          SetActiveWindow(BarManager.Owner.Handle);
      end;
    mbRight:
      ReleaseCapture;
  end;

  inherited;

  if not BarControlExists(Self) then Exit;

  case Button of
    mbLeft:
      begin
        if MDIButtonsOnBar and not BarManager.IsCustomizing then
          if RealMDIButtonsOnBar then
            for AButton := Low(TdxBarMDIButton) to High(TdxBarMDIButton) do
              if MDIButtonEnabled(AButton, MF_DISABLED or MF_GRAYED) and
                CheckMDIButton(AButton) then Exit
              else
          else
            if CheckMDIButton(mdibClose) then Exit;

        if FHitTest = HTCAPTION then
        begin
          R := WindowRect;
          RX.X := GetMouseCursorPos.X - R.Left;
          RY.X := GetMouseCursorPos.Y - R.Top;
          RX.Y := R.Right - R.Left;
          RY.Y := R.Bottom - R.Top;
          FBar.Bars.Moving(Self);
        end
        else
        begin
          CheckMarkState(APoint);
          if not IsCustomizing and not APointInClientRect then
          begin
            SendMessage(Handle, WM_NCLBUTTONDOWN, FHitTest, LPARAM(PointToSmallPoint(GetMouseCursorPos)));
          end;
        end;
      end;
  end;
end;

procedure TdxBarControl.DoBarMouseLeave;
begin
  inherited;
  UpdateCaptionButtons(cxInvalidPoint);
  if not IsActive then
  begin
//#DG    inherited;
    CloseButtonState := msNone;
    // MDI
    if MDIButtonsOnBar then
    begin
      FIsMouseOverMDIButton := False;
      RepaintMDIButtons;
    end;
  end
  else
    if SelectedControl is TdxBarButtonControl then
      SelectedControl.Repaint;
end;

procedure TdxBarControl.DoBarMouseMove(Shift: TShiftState; const APoint: TPoint;
  AItemControl: TdxBarItemControl);
var
  PrevIsMouseOverMDIButton: Boolean;
  PrevSelectedMDIButton: TdxBarMDIButton;
  AButton: TdxBarMDIButton;
  AButtons: TdxBarMDIButtons;
  AChangeMark: Boolean;
begin
  if FIsMDIButtonPressed then
  begin
    PrevIsMouseOverMDIButton := FIsMouseOverMDIButton;
    FIsMouseOverMDIButton := PtInRect(RectMDI(FPressedMDIButton), APoint);
    if FIsMouseOverMDIButton <> PrevIsMouseOverMDIButton then
      DrawMDIButtons([FPressedMDIButton]);
  end
  else
  begin
    // check MDI
    if MDIButtonsOnBar then
    begin
      PrevIsMouseOverMDIButton := FIsMouseOverMDIButton;
      PrevSelectedMDIButton := FSelectedMDIButton;
      FIsMouseOverMDIButton := False;
      if not RealMDIButtonsOnBar then
      begin
        if MDIButtonEnabled(mdibClose, MF_GRAYED) and
          PtInRect(RectMDI(mdibClose), APoint) then
        begin
          FIsMouseOverMDIButton := True;
          FSelectedMDIButton := mdibClose;
        end
      end
      else
      begin
        for AButton := Low(TdxBarMDIButton) to High(TdxBarMDIButton) do
          if MDIButtonEnabled(AButton, MF_GRAYED) and
            PtInRect(RectMDI(AButton), APoint) then
          begin
            FIsMouseOverMDIButton := True;
            FSelectedMDIButton := AButton;
            Break;
          end;
      end;
      if (FIsMouseOverMDIButton <> PrevIsMouseOverMDIButton) or
        (FSelectedMDIButton <> PrevSelectedMDIButton) then
      begin
        AButtons := [PrevSelectedMDIButton];
        if PrevIsMouseOverMDIButton then
          FMDIButtonFadingHelper[PrevSelectedMDIButton].FadeOut;
        if FIsMouseOverMDIButton then
          FMDIButtonFadingHelper[FSelectedMDIButton].FadeIn;
        if FSelectedMDIButton <> PrevSelectedMDIButton then
          AButtons := AButtons + [FSelectedMDIButton];
        DrawMDIButtons(AButtons);
      end;
    end;

//    if IsCustomizing and FIsResizing and (GetCapture = Handle) then
    if FIsResizing then
      SelectedControlAtDesign.Resizing(APoint); //#DG
//#DG      SelectedItem.Resizing(P);

    AChangeMark := False;
    if not NotHandleMouseMove then
    begin
      UpdateCaptionButtons(cxPointOffset(APoint, NCOffset));
      if ActiveBarControl = nil then
      begin
        if Painter.BarAllowQuickCustomizing and MarkExists and (MarkState <> msPressed) then
          if MouseOnMark(APoint) then
            MarkState := msSelected
          else
            AChangeMark := True;
        if HasCloseButton and Painter.BarAllowHotTrack then
          if PtInRect(CloseButtonRect, APoint) then
            CloseButtonState := msSelected
          else
            CloseButtonState := msNone;
      end;
    end;
    inherited;
    if AChangeMark then MarkState := msNone;
  end;
end;

procedure TdxBarControl.DoHideAll;
var
  ALinkSelf: TcxObjectLink;
  AWasPopup: Boolean;
begin
  ALinkSelf := cxAddObjectLink(Self);
  try
    AWasPopup := IsPopup;
    BarLostFocus;
    inherited;
    if (ALinkSelf.Ref <> nil) and AWasPopup then
    begin
      if LeftButtonPressed and PtInRect(IgnoreClickAreaWhenHidePopup, GetMouseCursorPos) then
        ParentBar.FIgnoreMouseClick := True;
      CloseUp;
    end;
  finally
    cxRemoveObjectLink(ALinkSelf);
  end;
end;

procedure TdxBarControl.DoRepaintBar(ARecreateControls: Boolean);
var
  P: TPoint;
begin
  inherited DoRepaintBar(ARecreateControls);
  if DockingStyle = dsNone then
  begin
    if HandleAllocated then
    begin
      P := GetSizeForWidth(DockingStyle, ClientWidth);
      ClientWidth  := P.X;
      ClientHeight := P.Y;
    end;
    CalcLayout;
  end
  else
    FDockControl.UpdateDock;
  //Repaint;
  Invalidate;
  if BarManager.IsUncustomizable then
    SendMessage(Handle, WM_NCPAINT, 1, 0)
  else
    if IsTransparent then
      SendMessage(Handle, WM_NCPAINT, 0, 0);
end;

procedure TdxBarControl.DoSetIsActive(AValue: Boolean);
begin
  if not AValue then
  begin
    if IsCustomizing and (SelectedControl <> nil) then
      SetMouseSelectedItem(nil);
    if IsActive and (SelectedControl is TdxBarButtonControl) and
      TdxBarButtonControl(SelectedControl).DroppedDown then
      SelectedControl.ControlInactivate(True);
    if IsDowned then
    begin
      IsDowned := False;
      if not IsCustomizing then {HideAll;//}BarLostFocus;
    end;
  end;
  inherited;

  BarLostFocus; // !!!
end;

function TdxBarControl.HasCaptionButtons: Boolean;
begin
  Result := CaptionButtons.Count > 0;
end;

procedure TdxBarControl.FocusItemControl(AItemControl: TdxBarItemControl);
var
  AProcessedByItemControl: Boolean;
  ALinkSelf: TcxObjectLink;
begin
  if (AItemControl <> nil) and AItemControl.Enabled and AItemControl.HotPartWantMouse then
  begin
    AProcessedByItemControl := False;
    ALinkSelf := cxAddObjectLink(Self);
    try
      if IsActive and not ((bboNeedsFocusWhenActive in BehaviorOptions) and not IsFocused) then
        AItemControl.ControlGetFocus(AItemControl = SelectedControl, AProcessedByItemControl)
      else
        BarGetFocus(AItemControl);

      if (ALinkSelf.Ref = nil) or AProcessedByItemControl then
        Exit;
    finally
      cxRemoveObjectLink(ALinkSelf);
    end;

    if IsActive and not AItemControl.HasWindow then
      IsDowned := True;

    if (SelectedControl <> nil) and SelectedControl.NeedCaptureMouse then
    begin
      FClickedControl := AItemControl;
      SetCapture(Handle);
      AItemControl.Repaint;
    end;
  end
  else
    IsActive := False;

  inherited;
end;

function TdxBarControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarControlAccessibilityHelper;
end;

function TdxBarControl.GetAlphaBlendValue: Byte;
begin
  if {not FMovingChanging and }(DockingStyle = dsNone) then
    Result := 200
  else
    Result := 255;
end;

function TdxBarControl.GetBackgroundBitmap: TBitmap;
begin
  Result := Bar.BackgroundBitmap;
end;

function TdxBarControl.GetBeginGroupSize: Integer;
begin
  Result := Painter.BarBeginGroupSize; 
end;

function TdxBarControl.GetCol: Integer;
var
  I, J: Integer;
begin
  Result := 0;
  if (FBar = nil) or (FBar.Bars = nil) or (DockingStyle = dsNone) or
    (FDockControl = nil) then Exit;
  with FDockControl do
    for I := 0 to FRowList.Count - 1 do
      for J := 0 to Rows[I].ColCount - 1 do
        if Rows[I].Cols[J].BarControl = Self then
        begin
          Result := J;
          Exit;
        end;
end;

procedure TdxBarControl.WndProc(var Message: TMessage);
var
  AStyle: TdxBarDockingStyle;
  ADockControl: TdxDockControl;
begin
  FCurrentMessage := Message; //#DG

  if Message.Msg = WM_SETFOCUS then
    Exit;
  if (FIsMDIButtonPressed or FIsMouseOverMDIButton) and (Message.Msg = WM_CANCELMODE) then
  begin
    ReleaseCapture;
    FIsMDIButtonPressed := False;
    FIsMouseOverMDIButton := False;
    RepaintMDIButtons;
  end;
  if (Message.Msg = WM_LBUTTONDBLCLK) and (FHitTest = HTCAPTION) then
  begin
    if not BarManager.Designing then
      with Bar do
      begin
        ADockControl := nil;
        if DockingStyle = dsNone then
          if DockedDockingStyle <> dsNone then
          begin
            AStyle := DockedDockingStyle;
            ADockControl := DockedDockControl;
            if ADockControl = nil then
              ADockControl := Bars.FDockControls[AStyle];
          end
          else
          begin
            AStyle := dsTop;
            ADockControl := Bars.FDockControls[dsTop];
          end
        else
          AStyle := dsNone;
        if BarManager.DoDocking(Bar, AStyle, ADockControl) then
        begin
          Visible := False;
          if DockingStyle = dsNone then
          begin
            ChangeDockingStyle(AStyle, ADockControl);
            if DockedDockingStyle = dsNone then
            begin
              OneOnRow := True;
              Row := ADockControl.RowCount;
            end;
          end
          else
            DockingStyle := dsNone;
          Visible := True;
        end;
      end;
    Exit;
  end;
  inherited;
end;

function TdxBarControl.GetDockCol: TdxDockCol;
var
  I, J: Integer;
begin
  Result := nil;
  if (FBar = nil) or (FBar.Bars = nil) or (DockingStyle = dsNone) or
    (FDockControl = nil) then Exit;
  with FDockControl do
    for I := 0 to RowCount - 1 do
      for J := 0 to Rows[I].ColCount - 1 do
        if Rows[I].Cols[J].BarControl = Self then
        begin
          Result := Rows[I].Cols[J];
          Exit;
        end;
end;

function TdxBarControl.GetIsMainMenu: Boolean;
begin
  Result := (Bar <> nil) and Bar.IsMainMenu;
end;

function TdxBarControl.GetIsStatusBar: Boolean;
begin
  Result := (Bar <> nil) and Bar.IsStatusBar;
end;

function TdxBarControl.GetMarkAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarControlMarkAccessibilityHelper;
end;

function TdxBarControl.GetMarkDrawState: TdxBarMarkState;
begin
  if MarkIAccessibilityHelper.IsSelected then
    Result := msSelected
  else
    Result := inherited GetMarkDrawState;
end;

function TdxBarControl.GetMoreButtonsHint: string;
begin
  Result := cxGetResourceString(@dxSBAR_MOREBUTTONS);
end;

function TdxBarControl.GetMultiLine: Boolean;
begin
  Result := (DockingStyle = dsNone) or FBar.MultiLine;
end;

function TdxBarControl.GetQuickControlClass: TdxBarControlClass;
begin
  Result := TdxBarQuickControl;
end;

function TdxBarControl.GetRow: Integer;
var
  I, J: Integer;
begin
  Result := 0;
  if (FBar = nil) or (FBar.Bars = nil) or (DockingStyle = dsNone) or
    (FDockControl = nil) then Exit;
  with FDockControl do
    for I := 0 to RowCount - 1 do
      for J := 0 to Rows[I].ColCount - 1 do
        if Rows[I].Cols[J].BarControl = Self then
        begin
          Result := I;
          Exit;
        end;
end;

function TdxBarControl.GetViewInfoClass: TCustomdxBarControlViewInfoClass;
begin
  Result := TdxBarControlViewInfo;
end;

function TdxBarControl.GetNCDrawingDC(AUpdatedRgn: HRGN): HDC;
var
  CR: TRect;
begin
  FDrawBitmap := nil;
  FPrevClipRgn := nil;
  if BarManager.IsUncustomizable then
  begin
    if AUpdatedRgn = 1 then
      FPrevClipRgn := TcxRegion.Create(0, 0, Width, Height)
    else
    begin
      FPrevClipRgn := TcxRegion.Create;
      CombineRgn(FPrevClipRgn.Handle, FPrevClipRgn.Handle, AUpdatedRgn, RGN_OR);
      FPrevClipRgn.Offset(-WindowRect.Left, -WindowRect.Top);
      FPrevClipRgn.Combine(TcxRegion.Create(0, 0, Width, Height), roIntersect);
    end;

    CR := cxRectOffset(ClientRect, GetClientOffset);
    FPrevClipRgn.Combine(TcxRegion.Create(CR), roSubtract);

    FDrawBitmap := cxCreateBitmap(Width, Height, pf32bit);
    Result := FDrawBitmap.Canvas.Handle;

    SelectClipRgn(Result, FPrevClipRgn.Handle);
  end
  else
    Result := inherited GetNCDrawingDC(AUpdatedRgn);
end;

procedure TdxBarControl.ReleaseNCDrawingDC(ADC: HDC);
begin
  FreeAndNil(FDrawBitmap);
  FreeAndNil(FPrevClipRgn);
  if not BarManager.IsUncustomizable then
    inherited;
end;

function TdxBarControl.GetMasterForm: TCustomForm;
begin
  if DockControl <> nil then
    Result := DockControl.MasterForm
  else
    Result := BarManager.MasterForm;
end;

function TdxBarControl.GetParentForm: TCustomForm;
begin
  if DockControl <> nil then
    Result := DockControl.ParentForm
  else
    Result := BarManager.ParentForm;
end;

function TdxBarControl.GetSelectableObject: TPersistent;
begin
  Result := Bar;
end;

function TdxBarControl.AllowQuickCustomizing: Boolean;
begin
  Result := Bar.AllowQuickCustomizing;
end;

procedure TdxBarControl.HandleQuickAccessSubItemPopup(Sender: TObject);
begin
  BarDesignController.ClearOwnedItems(TdxBarSubItem(Sender).ItemLinks);
  InitAddRemoveSubItemPopup(TdxBarSubItem(Sender).ItemLinks);
end;

procedure TdxBarControl.InitQuickControl(AQuickControlItemLinks: TdxBarItemLinks);
var
  I: Integer;
  AItemLink: TdxBarItemLink;
begin
  for I := 0 to ItemLinks.CanVisibleItemCount - 1 do
  begin
    AItemLink := ItemLinks.CanVisibleItems[I];
    if (AItemLink.VisibleIndex = -1) or
      (AItemLink.Control <> nil) and IsRectEmpty(AItemLink.ItemRect) then
    begin
      with AQuickControlItemLinks.Add do
      begin
        Assign(AItemLink);
        FOriginalItemLink := AItemLink;
      end;
    end;
  end;

  if AllowQuickCustomizing then
    InitQuickCustomizeItemLinks(AQuickControlItemLinks);
end;

procedure TdxBarControl.InitQuickCustomizeItemLinks(AQuickControlItemLinks: TdxBarItemLinks);
var
  AItemLink: TdxBarItemLink;
  AAddRemoveSubItem: TdxBarSubItem;
begin
  AItemLink := BarDesignController.AddInternalItem(AQuickControlItemLinks, TdxBarQuickAccessItem,
    cxGetResourceString(@dxSBAR_ADDREMOVEBUTTONS));
  AItemLink.BeginGroup := True;
  AAddRemoveSubItem := TdxBarSubItem(AItemLink.Item);
//    AAddRemoveSubItem.Enabled := AllowQuickCustomizing;
  AAddRemoveSubItem.OnPopup := HandleQuickAccessSubItemPopup;
end;

procedure TdxBarControl.InitAddRemoveSubItemPopup(AItemLinks: TdxBarItemLinks);
var
  I: Integer;
  AItemLink: TdxBarItemLink;
  AllowReset: Boolean;
  AQuickCustItem: TdxBarQuickCustItem;
begin
  AQuickCustItem := TdxBarQuickCustItem.Create(BarManager.Owner);//#DG
  BarDesignController.AddInternalItem(AQuickCustItem);

  for I := 0 to ItemLinks.AvailableItemCount - 1 do
  begin
    AItemLink := ItemLinks.AvailableItems[I];
    if (AItemLink.Control = nil) or AItemLink.Control.CanCustomize then
      with AItemLinks.Add do
      begin
        Item := AQuickCustItem;
        Data := Integer(AItemLink);
      end;
  end;
  // add reset button
  AllowReset := BarManager.CanReset and Bar.CanReset;
  if AllowReset then
    BarDesignController.AddInternalItem(AItemLinks, TdxBarQuickCustExtButton,
      cxGetResourceString(@dxSBAR_RESETTOOLBAR), ResetToolbarClick).BeginGroup := True;
  // add customize button
  BarDesignController.AddCustomizeItem(AItemLinks, TdxBarQuickCustExtButton, not AllowReset);
end;

procedure TdxBarControl.ResetToolbarClick(Sender: TObject);
begin
  Bar.ResetWithConfirmation;
end;

function TdxBarControl.GetMinWidth(AStyle: TdxBarDockingStyle): Integer;
var
  I, AWidth: Integer;
begin
  if (AStyle in [dsLeft, dsRight]) or MultiLine then
  begin
    Result := 0;
    if ItemLinks.CanVisibleItemCount <> 0 then
      for I := 0 to ItemLinks.CanVisibleItemCount - 1 do
      begin
        AWidth := ItemLinks.CanVisibleItems[I].Control.Width;
        Result := Max(Result, AWidth);
      end
    else
      if AStyle <> dsNone then
        Result := Painter.GetButtonWidth(BarManager.GlyphSize, TextSize);
    if MDIButtonsOnBar and (Result < GetMDIWidth) then
      Result := GetMDIWidth;
    if AStyle = dsNone then
    begin
     AWidth := GetMarkSize;
     if HasCloseButton then
       Inc(AWidth, Painter.BarCloseButtonSize.cx);
     AWidth := Max(AWidth, dxBarFloatToolbarMinWidth);
     Result := Max(Result, AWidth);
    end;
  end
  else
  begin
    if ItemLinks.CanVisibleItemCount = 0 then
      Result := Painter.GetButtonWidth(BarManager.GlyphSize, TextSize)
    else
    begin
      ItemLinks.RecentItemCount := 1;
      Result := ItemLinks.VisibleItems[0].Control.Width;
      ItemLinks.RestoreRecentItemCount;
    end;
    if MDIButtonsOnBar then
      Inc(Result, GetMDIWidth);
  end;
  if Horizontal then
    Inc(Result, GetMarkSize);
end;

function TdxBarControl.GetMinHeight(AStyle: TdxBarDockingStyle): Integer;
var
  I, AHeight: Integer;
begin
  if (AStyle in [dsTop, dsBottom]) or MultiLine then
  begin
    if ItemLinks.CanVisibleItemCount = 0 then
      Result := Painter.GetButtonHeight(BarManager.GlyphSize, TextSize)
    else
    begin
      Result := 0;
      for I := 0 to ItemLinks.CanVisibleItemCount - 1 do
      begin
        AHeight := ItemLinks.CanVisibleItems[I].Control.Height;
        Result := Max(Result, AHeight);
      end;
    end;
    if MDIButtonsOnBar and (Result < GetMDIHeight) then
      Result := GetMDIHeight;
  end
  else
  begin
    if ItemLinks.CanVisibleItemCount = 0 then
      Result := Painter.GetButtonHeight(BarManager.GlyphSize, TextSize)
    else
    begin
      ItemLinks.RecentItemCount := 1;
      Result := ItemLinks.VisibleItems[0].Control.Height;
      ItemLinks.RestoreRecentItemCount;
    end;
    if MDIButtonsOnBar then
      Inc(Result, GetMDIHeight);
  end;
  if Vertical then
    Inc(Result, GetMarkSize);
end;

function TdxBarControl.GetMaxWidth(AStyle: TdxBarDockingStyle): Integer;
var
  AWidth, I: Integer;
  AItemLink: TdxBarItemLink;
begin
  Result := GetMinWidth(AStyle);
  AWidth := 0;
  if (AStyle in [dsTop, dsBottom]) or MultiLine then
  begin
    ItemLinks.RecentItemCount := -1;
    for I := 0 to ItemLinks.VisibleItemCount - 1 do
    begin
      AItemLink := ItemLinks.VisibleItems[I];
      if AItemLink.BeginGroup then Inc(AWidth, BeginGroupSize);
      Inc(AWidth, AItemLink.Control.Width);
    end;
    ItemLinks.RestoreRecentItemCount;
    if MDIButtonsOnBar then
      Inc(AWidth, GetMDIWidth);
    if Horizontal then
      Inc(AWidth, GetMarkSize);
  end
  else
  begin
    for I := 0 to ItemLinks.CanVisibleItemCount - 1 do
    begin
      AItemLink := ItemLinks.CanVisibleItems[I];
      if AWidth < AItemLink.Control.Width then
        AWidth := AItemLink.Control.Width;
    end;
    if MDIButtonsOnBar and (AWidth < GetMDIWidth) then AWidth := GetMDIWidth;
  end;
  if Result < AWidth then Result := AWidth;
end;

function TdxBarControl.GetMaxHeight(AStyle: TdxBarDockingStyle): Integer;
var
  AHeight, I: Integer;
  AItemLink: TdxBarItemLink;
begin
  Result := GetMinHeight(AStyle);
  AHeight := 0;
  if (AStyle in [dsLeft, dsRight]) or MultiLine then
  begin
    ItemLinks.RecentItemCount := -1;
    for I := 0 to ItemLinks.VisibleItemCount - 1 do
    begin
      AItemLink := ItemLinks.VisibleItems[I];
      if AItemLink.BeginGroup then Inc(AHeight, BeginGroupSize);
      Inc(AHeight, AItemLink.Control.Height);
    end;
    ItemLinks.RestoreRecentItemCount;
    if MDIButtonsOnBar then
      Inc(AHeight, GetMDIHeight);
    if Vertical then
      Inc(AHeight, GetMarkSize);
  end
  else
  begin
    for I := 0 to ItemLinks.CanVisibleItemCount - 1 do
    begin
      AItemLink := ItemLinks.CanVisibleItems[I];
      if AHeight < AItemLink.Control.Height then
        AHeight := AItemLink.Control.Height;
    end;
    if MDIButtonsOnBar and (AHeight < GetMDIHeight) then
      AHeight := GetMDIHeight;
  end;
  if Result < AHeight then Result := AHeight;
end;

procedure TdxBarControl.GetMultiLineBarSize(AStyle: TdxBarDockingStyle;
  ASize: Integer; var Result: TPoint);
var
  ABeginGroupSize, ACount, ACurRowHeight, ACurX, ACurY,
  ALastItemLinkWithBeginGroupCurX, ALastItemLinkWithBeginGroupCurRowHeight,
  AMaxSize, I, H, W: Integer;
  AItemLink, ALastItemLinkWithBeginGroup: TdxBarItemLink;
  ABreakingRow, AEntireRow, AVertical: Boolean;
begin
  AVertical := Vertical;
  if AVertical and (ASize < Result.Y) then
    ASize := Result.Y
  else
    if not AVertical and (ASize < Result.X) then
      ASize := Result.X;
  if AStyle <> dsNone then
    Dec(ASize, GetMarkSize);
  ACurX := 0;
  ACurY := 0;
  ACurRowHeight := 0;
  AMaxSize := 0;
  ALastItemLinkWithBeginGroup := nil;
  ALastItemLinkWithBeginGroupCurX := 0;
  ALastItemLinkWithBeginGroupCurRowHeight := 0;
  ABreakingRow := False;
  AEntireRow := True;

  ACount := ItemLinks.VisibleItemCount;
  I := 0;
  while I < ACount do
  begin
    AItemLink := ItemLinks.VisibleItems[I];
    if AItemLink.BeginGroup and (ACurX > 0) then
    begin
      ABeginGroupSize := BeginGroupSize;
      ALastItemLinkWithBeginGroup := AItemLink;
      ALastItemLinkWithBeginGroupCurX := ACurX;
      ALastItemLinkWithBeginGroupCurRowHeight := ACurRowHeight;
    end
    else
      ABeginGroupSize := 0;

    with AItemLink.Control do
      if AVertical then
      begin
        W := Height;
        H := Width;
      end
      else
      begin
        W := Width;
        H := Height;
      end;

    if (ACurX > 0) and (ACurX + ABeginGroupSize + W > ASize) or
      ABreakingRow or (ABeginGroupSize > 0) and not AEntireRow then
    begin
      AEntireRow := True;
      AItemLink.Control.FBreakingRow := True;
      if ALastItemLinkWithBeginGroup = nil then
        AEntireRow := False
      else
        if ABreakingRow then
        begin
          ALastItemLinkWithBeginGroup := nil;
          ABreakingRow := False;
        end
        else
        begin
          I := ALastItemLinkWithBeginGroup.VisibleIndex;
          ACurX := ALastItemLinkWithBeginGroupCurX;
          ACurRowHeight := ALastItemLinkWithBeginGroupCurRowHeight;
          ABreakingRow := True;
          Continue;
        end;
      Inc(ACurY, ABeginGroupSize + ACurRowHeight);
      ACurRowHeight := 0;
      if AMaxSize < ACurX then AMaxSize := ACurX;
      ACurX := W;
    end
    else
    begin
      AItemLink.Control.FBreakingRow := False;
      Inc(ACurX, ABeginGroupSize + W);
    end;
    if ACurRowHeight < H then ACurRowHeight := H;
    Inc(I);
  end;
  if ItemLinks.VisibleItemCount > 0 then
    if AVertical then
      Result.X := ACurY + ACurRowHeight
    else
      Result.Y := ACurY + ACurRowHeight;
  if MDIButtonsOnBar then
  begin
    if AVertical then
      I := GetMDIHeight
    else
      I := GetMDIWidth;
    if ACurX + I <= ASize then
      Inc(ACurX, I)
    else
      if AVertical then
        Inc(Result.X, GetMDIWidth)
      else
        Inc(Result.Y, GetMDIHeight);
  end;
  if AMaxSize < ACurX then AMaxSize := ACurX;
  if AVertical then
    if Result.Y < AMaxSize then Result.Y := AMaxSize
    else
  else
    if Result.X < AMaxSize then Result.X := AMaxSize;
  CalcLayout;  // because of a FBreakingRow
end;

function TdxBarControl.GetSizeAllCursorBounds: TRect;
begin
  if (DockingStyle = dsNone) or (Bar.BorderStyle = bbsNone) then
    SetRectEmpty(Result)
  else
    if Horizontal then
      Result := Rect(-100, -100, 0, 100)
    else
      Result := Rect(-100, -100, 100, 0);
end;

function TdxBarControl.GetSizeForWidth(AStyle: TdxBarDockingStyle;
  AWidth: Integer): TPoint;
var
  J, ABeginGroupSize: Integer;
  AItemLink: TdxBarItemLink;
  Found: Boolean;
  PrevSize, Size: TPoint;

  function CalcSize(var Size: TPoint): Boolean;
  var
    I: Integer;
  begin
    Result := False;
    Size.X := 0;
    Size.Y := 0;
    for I := 0 to ItemLinks.VisibleItemCount - 1 do
    begin
      AItemLink := ItemLinks.VisibleItems[I];
      if AItemLink.BeginGroup then
        ABeginGroupSize := BeginGroupSize
      else
        ABeginGroupSize := 0;
      with AItemLink.Control do
      begin
        if (Size.X + ABeginGroupSize + Width > AWidth) and (I <> 0) then
        begin
          Result := True;
          Break;
        end;
        Inc(Size.X, ABeginGroupSize + Width);
        if Size.Y < Height then Size.Y := Height;
      end;
    end;
  end;

begin
//  if ItemLinks.RecentItemCount <> -1 then
  begin
    ItemLinks.RecentItemCount := -1;
    CalcLayout;
    ItemLinks.RestoreRecentItemCount;
  end;

  if MultiLine then
    if Vertical then
    begin
      Size := GetSizeForHeight(AStyle, GetMaxHeight(AStyle));
      repeat
        if Size.X >= AWidth then Break;
        PrevSize := Size;
        Dec(Size.Y);
        Size := GetSizeForHeight(AStyle, Size.Y);
      until Size.Y = PrevSize.Y;
      Result := Size;
    end
    else
    begin
      Result := Point(GetMinWidth(AStyle), GetMinHeight(AStyle));
      GetMultiLineBarSize(AStyle, AWidth, Result);
    end
  else
    case AStyle of
      dsTop, dsBottom:
        begin
          Result := Point(GetMinWidth(AStyle), GetMinHeight(AStyle));
          if AWidth < Result.X then AWidth := Result.X;
          if MDIButtonsOnBar then Dec(AWidth, GetMDIWidth);
          ItemLinks.RecentItemCount := -1;
          if ItemLinks.CanVisibleItemCount > 0 then
          begin
            Dec(AWidth, GetMarkSize);
            if ItemLinks.CanUseRecentItems and not BarManager.Designing then
            begin
              PrevSize := Result;
              Dec(PrevSize.X, GetMarkSize);
              Found := False;
              for J := 1 to ItemLinks.CanVisibleItemCount do
              begin
                ItemLinks.RecentItemCount := J;
                Found := CalcSize(Size);
                if Found then
                begin
                  ItemLinks.RecentItemCount := J - 1;
                  Size := PrevSize;
                  Break;
                end;
                PrevSize := Size;
              end;
              if not Found then ItemLinks.RecentItemCount := -1;
            end
            else
              CalcSize(Size);
            Inc(Size.X, GetMarkSize);
            
            if Result.X < Size.X then Result.X := Size.X;
            Result.Y := Size.Y;
            if MDIButtonsOnBar then
            begin
              Inc(Result.X, GetMDIWidth);
              if Result.Y < GetMDIHeight then Result.Y := GetMDIHeight;
            end;
          end;
        end;
      dsLeft, dsRight:
        Result := Point(GetMinWidth(AStyle), GetMaxHeight(AStyle));
    else
      Result := cxNullPoint;
    end;
end;

function TdxBarControl.GetSizeForHeight(AStyle: TdxBarDockingStyle;
  AHeight: Integer): TPoint;
var
  J, ABeginGroupSize: Integer;
  AItemLink: TdxBarItemLink;
  Found: Boolean;
  PrevSize, Size: TPoint;

  function CalcSize(var Size: TPoint): Boolean;
  var
    I: Integer;
  begin
    Result := False;
    Size.X := 0;
    Size.Y := 0;
    for I := 0 to ItemLinks.VisibleItemCount - 1 do
    begin
      AItemLink := ItemLinks.VisibleItems[I];
      if AItemLink.BeginGroup then
        ABeginGroupSize := BeginGroupSize
      else
        ABeginGroupSize := 0;
      with AItemLink.Control do
      begin
        if (Size.Y + ABeginGroupSize + Height > AHeight) and (I <> 0) then
        begin
          Result := True;
          Break;
        end;
        Inc(Size.Y, ABeginGroupSize + Height);
        if Size.X < Width then Size.X := Width;
      end;
    end;
  end;

begin
  if ItemLinks.RecentItemCount <> -1 then
  begin
    ItemLinks.RecentItemCount := -1;
    CalcLayout;
    ItemLinks.RestoreRecentItemCount;
  end;

  if MultiLine then
    if Vertical then
    begin
      Result := Point(GetMinWidth(AStyle), GetMinHeight(AStyle));
      GetMultiLineBarSize(AStyle, AHeight, Result);
    end
    else
    begin
      Size := GetSizeForWidth(AStyle, GetMaxWidth(AStyle));
      repeat
        if Size.Y >= AHeight then Break;
        PrevSize := Size;
        Dec(Size.X);
        Size := GetSizeForWidth(AStyle, Size.X);
      until Size.X = PrevSize.X;
      Result := Size;
    end
  else
    case AStyle of
      dsTop, dsBottom:
        Result := Point(GetMaxWidth(AStyle), GetMinHeight(AStyle));

      dsLeft, dsRight:
        begin
          Result := Point(GetMinWidth(AStyle), GetMinHeight(AStyle));
          if AHeight < Result.Y then AHeight := Result.Y;
          if MDIButtonsOnBar then Dec(AHeight, GetMDIHeight);
          ItemLinks.RecentItemCount := -1;
          if ItemLinks.CanVisibleItemCount > 0 then
          begin
            Dec(AHeight, GetMarkSize);
            if ItemLinks.CanUseRecentItems and not BarManager.Designing then
            begin
              PrevSize := Result;
              Dec(PrevSize.Y, GetMarkSize);
              Found := False;
              for J := 1 to ItemLinks.CanVisibleItemCount do
              begin
                ItemLinks.RecentItemCount := J;
                Found := CalcSize(Size);
                if Found then
                begin
                  ItemLinks.RecentItemCount := J - 1;
                  Size := PrevSize;
                  Break;
                end;
                PrevSize := Size;
              end;
              if not Found then ItemLinks.RecentItemCount := -1;
            end
            else
              CalcSize(Size);
            Inc(Size.Y, GetMarkSize);
            
            if Result.Y < Size.Y then Result.Y := Size.Y;
            Result.X := Size.X;
            if MDIButtonsOnBar then
            begin
              Inc(Result.Y, GetMDIHeight);
              if Result.X < GetMDIWidth then Result.X := GetMDIWidth;
            end;
          end;
        end;
    end;
end;

function TdxBarControl.GetSizeForPopup: TSize;
begin
  Result := cxNullSize;
end;

function TdxBarControl.GetTrackSize(AStyle: TdxBarDockingStyle): TPoint;
var
  PrevRecentItemCount: Integer;
begin
  if bboUnmoved in BehaviorOptions then
    AStyle := dsNone;
  Result.X := 0;
  Result.Y := 0;
  PrevRecentItemCount := ItemLinks.RecentItemCount;
  case AStyle of
    dsNone:
      begin
        Result := GetSizeForWidth(AStyle, Bar.FloatClientWidth);
        Inc(Result.X, Bar.BarNCSizeX(AStyle));
        Inc(Result.Y, Bar.BarNCSizeY(AStyle));
      end;
    dsTop, dsBottom:
      begin
        if (FBar <> nil) and FBar.WholeRow then
          Result.X := FDockControl.ClientWidth - FBar.BarNCSizeX(AStyle)
        else
          Result.X := GetMaxWidth(AStyle);
        Result := GetSizeForWidth(AStyle, Result.X);
        if (FBar <> nil) and FBar.WholeRow then
          Result.X := FDockControl.ClientWidth
        else
          Inc(Result.X, Bar.BarNCSizeX(AStyle));
        Inc(Result.Y, Bar.BarNCSizeY(AStyle));
      end;
    dsLeft, dsRight:
      begin
        if (FBar <> nil) and FBar.WholeRow then
          Result.Y := FDockControl.ClientHeight - FBar.BarNCSizeY(AStyle)
        else
          Result.Y := GetMaxHeight(AStyle);
        Result := GetSizeForHeight(AStyle, Result.Y);
        Inc(Result.X, Bar.BarNCSizeX(AStyle));
        if (FBar <> nil) and FBar.WholeRow then
          Result.Y := FDockControl.ClientHeight
        else
          Inc(Result.Y, Bar.BarNCSizeY(AStyle));
      end;
  end;
  if ItemLinks.RecentItemCount <> PrevRecentItemCount then
  begin
    ItemLinks.RecentItemCount := PrevRecentItemCount;
    CalcLayout;
  end;
end;

function TdxBarControl.HasCaption: Boolean;
begin
  Result := True;
end;

function TdxBarControl.HasCloseButton: Boolean;
begin
  Result := (DockingStyle = dsNone) and Bar.CanClose;
end;

function TdxBarControl.HideOnClick: Boolean;
begin
  Result := IsPopup;
end;

function TdxBarControl.IgnoreClickAreaWhenHidePopup: TRect;
begin
  Result := ParentBar.MarkRect;
  MapWindowRect(ParentBar.Handle, 0, Result);
end;

procedure TdxBarControl.InvalidateMark;
begin
  if HandleAllocated then
    Painter.BarMarkRectInvalidate(Self);
end;

function TdxBarControl.IsMarkAccessible: Boolean;
begin
  Result := Painter.BarAllowQuickCustomizing and MarkExists;
end;

function TdxBarControl.IsInternal: Boolean;
begin
  Result := IsPopup;
end;

function TdxBarControl.GetMouseTrackingBounds: TRect;
begin
  Result := inherited GetMouseTrackingBounds;
  if DockControl <> nil then
  begin
    IntersectRect(Result, DockControl.ClientRect, Result);
    Result := cxRectOffset(Result, DockControl.ClientOrigin);
  end;
end;

function TdxBarControl.MarkExists: Boolean;
begin
  Result := Bar.ShowMark and (FTruncated or
    (Painter.BarAllowQuickCustomizing and Bar.AllowQuickCustomizing));
end;

function TdxBarControl.MarkNCRect: TRect;
begin
  Result := MarkScreenRect;
  OffsetRect(Result, -WindowRect.Left, -WindowRect.Top);
end;

function TdxBarControl.MarkRect: TRect;
begin
  Result := Painter.BarMarkRect(Self);
end;

function TdxBarControl.MarkScreenRect: TRect;
begin
  Result := MarkRect;
  MapWindowRect(Handle, 0, Result);
end;

procedure TdxBarControl.SetMarkState(Value: TdxBarMarkState);
var
  ALinkSelf: TcxObjectLink;
  AOldMarkState: TdxBarMarkState;
begin
  if IsCustomizing then Exit;
  if FMarkState <> Value then
  begin
    AOldMarkState := FMarkState;
    FMarkState := Value;
    FinishMoreButtonsHintTimer;

    if FMarkState = msPressed then
    begin
      //PlaySound(psMenuPopup);
      BarDesignController.ShowQuickControl(Self, MarkScreenRect);
      FQuickPopup := BarDesignController.QuickControl;
    end
    else
    begin
      ALinkSelf := cxAddObjectLink(Self);
      try
        FreeAndNil(FQuickPopup);
        if ALinkSelf.Ref = nil then
          Exit;
      finally
        cxRemoveObjectLink(ALinkSelf);
      end;
      if FMarkState = msSelected then
      begin
        if DockingStyle = dsNone then StartMoreButtonsHintTimer;
        BarManager.ActivateHint(True, GetMoreButtonsHint, Self);
      end
      else
        if SelectedControl = nil then
          BarManager.HideHint;
    end;
    if MarkFadingHelper.CanFade then
    begin
      if AOldMarkState = msSelected then
        Fader.FadeOut(MarkFadingHelper);
      if AOldMarkState = msNone then
        Fader.FadeIn(MarkFadingHelper);
    end;
    InvalidateMark;
  end;
end;

procedure TdxBarControl.SelectItemControl(AItemControl: TdxBarItemControl; AButton: TMouseButton; AShift: TShiftState);
begin
  if (AItemControl = nil) then
    IsActive := False; //#DG first subitem - blue caption
  inherited;
end;

procedure TdxBarControl.ShowPopup(AItem: TdxBarItemControl);
begin
  if not BarManager.IsCustomizing then
    BarDesignController.ShowToolbarsPopup(BarManager, Painter)
  else
    inherited;
end;

function TdxBarControl.SizeGripRect: TRect;
begin
  with Result do
  begin
    Left := ClientWidth;
    Right := Left + Painter.StatusBarGripSize(BarManager).cx;
    Bottom := ClientHeight;
    Top := Bottom - Painter.StatusBarGripSize(BarManager).cy;
  end;
end;

procedure TdxBarControl.UpdateCaptionButton(ACaptionButton: TdxBarCaptionButton);
begin
// do nothing
end;

procedure TdxBarControl.UpdateCaptionButtons(const AMousePos: TPoint;
  AMousePressed: Boolean = False);
begin
  if HasCaptionButtons then
    CaptionButtons.UpdateButtonStates(AMousePos, AMousePressed);
end;

procedure TdxBarControl.UpdateItem(AControl: TdxBarItemControl);
begin
  cxInvalidateRect(Handle, GetItemRect(AControl), False);
end;

function TdxBarControl.AllowNCPaint: Boolean;
begin
  Result := not ((ClientHeight = Height) and (ClientWidth = Width) or IsDestroying);
end;

procedure TdxBarControl.BarManagerStyleChanged;
var
  ABar: TdxBar;
begin
  UpdateControlStyle;
  CalcDrawingConsts;
  if DockingStyle = dsNone then
  begin
    ABar := Bar;
    ABar.Visible := False;
    ABar.Visible := True;
  end
  else
    RebuildBar;
end;

procedure TdxBarControl.CaptionChanged;
begin
  Text := GetCaption;
  SendMessage(Handle, WM_NCPAINT, 0, 0);
end;

procedure TdxBarControl.DoDrawBeginGroup(const ASeparatorRect: TRect; AHorz: Boolean);
begin
  Painter.BarDrawBeginGroup(Self, Canvas.Handle, ASeparatorRect, ToolbarBrush, AHorz);
end;

procedure TdxBarControl.DoNCPaint(DC: HDC);

  procedure DrawStatusBar(const ARect: TRect; AToolbarBrush: HBRUSH);
  begin
    Painter.BarDrawStatusBarBorder(Self, DC, ARect, AToolbarBrush);
    if FHasSizeGrip then
      Painter.BarDrawStatusBarGrip(Self, DC, ARect, AToolbarBrush);
  end;

  procedure DrawBorders;
  var
    AWindowRect, R, CR: TRect;
    Rgn, Rgn1: HRGN;
    AToolbarBrush: HBRUSH;
    BR: TRect;
  begin
    AWindowRect := WindowRect;
    CR := ClientBounds;
    R := NCRect;
    AToolbarBrush := ToolbarBrush;
    if DockingStyle = dsNone then
    begin
      Painter.BarDrawFloatingBarBorder(Self, DC, R, CR, AToolbarBrush);
      R := CR;
      if HasCaption then
      begin
        Dec(R.Left, Painter.BarHorSize);
        Inc(R.Right, Painter.BarHorSize);
        Dec(R.Top, Painter.BarTopSize);
        Inc(R.Bottom, Painter.BarBottomSize);
      end;
      Rgn := CreateRectRgn(R.Left, R.Top, R.Right, R.Bottom);
    end
    else
    begin
      Painter.BarBorderPaintSizes(Self, BR);
      Rgn := CreateRectRgn(R.Left + BR.Left, R.Top + BR.Top, R.Right - BR.Right, R.Bottom - BR.Bottom);
    end;
    Rgn1 := CreateRectRgn(CR.Left, CR.Top, CR.Right, CR.Bottom);
    CombineRgn(Rgn, Rgn1, Rgn, RGN_XOR);
    DeleteObject(Rgn1);

    FillBackgroundRgn(DC, Rgn, AToolbarBrush, False);

    DeleteObject(Rgn);

    if DockingStyle <> dsNone then
      Painter.BarDrawDockedBarBorder(Self, DC, R, AToolbarBrush);
  end;

begin
  if Painter.IsCompoundPainting then
    Painter.DrawToolbarNonContentPart(Self, DC)
  else
    if (DockingStyle <> dsNone) and (FBar.BorderStyle = bbsNone) then
    begin
      if FBar.IsStatusBar then
        DrawStatusBar(NCRect, ToolbarBrush);
    end
    else
    begin
      DrawBorders;
      if (DockingStyle = dsNone) and HasCaption then
        Painter.BarDrawFloatingBarCaption(Self, DC, GetCaptionNCRect, GetCaptionNCRect, ToolbarBrush);
    end;
end;

procedure TdxBarControl.DoPaint;
var
  AButtons: TdxBarMDIButtons;
  AItemLink: TdxBarItemLink;
  I: Integer;
begin
//#DG  if {not IsWindowVisible(BarManager.Owner.Handle) or} FDestroyFlag then Exit;
  if {not IsWindowVisible(BarManager.Owner.Handle) or} IsDestroying then
    Exit;

//  // recalc positions of items
//  CalcLayout;

  // hide invisible items that require that
  if not BarManager.Designing then
    for I := 0 to FItemLinks.CanVisibleItemCount - 1 do
    begin
      AItemLink := FItemLinks.CanVisibleItems[I];
      with AItemLink do
        if Item.NeedToBeHidden and (VisibleIndex = -1) then
          Item.HideControl(Control);
    end;

  Canvas.SaveClipRegion;
  try
    if Painter.IsCompoundPainting then
      DrawContentBackground;

    DrawItems;
    DrawBeginGroups;
    if MDIButtonsOnBar then
    begin
      if RealMDIButtonsOnBar then
        AButtons := [mdibMinimize, mdibRestore, mdibClose]
      else
        AButtons := [mdibClose];
      DrawMDIButtons(AButtons, True);
    end;
    if (DockingStyle <> dsNone) and MarkExists then
      DrawMarks;
    if not Painter.IsCompoundPainting then
      DrawContentBackground;
  finally
    Canvas.RestoreClipRegion;
  end;

  DrawSelection(Canvas.Handle);
end;

procedure TdxBarControl.DrawBeginGroups;
var
  I: Integer;
  ASeparatorRect: TRect;
begin
  for I := 0 to ViewInfo.SeparatorCount - 1 do
  begin
    ASeparatorRect := ViewInfo.SeparatorInfos[I].Bounds;
    DoDrawBeginGroup(ASeparatorRect, ViewInfo.SeparatorInfos[I].Kind = skHorizontal);
    Canvas.ExcludeClipRect(ASeparatorRect);
  end;
end;

procedure TdxBarControl.DrawContentBackground;
begin
  Painter.DrawToolbarContentPart(Self, Canvas);
end;

procedure TdxBarControl.DrawMarks;
var
  AMarkRect: TRect;
begin
  AMarkRect := Painter.BarMarkItemRect(Self);
  Painter.BarDrawMarks(Self, Canvas, AMarkRect, ToolbarBrush);
  Canvas.ExcludeClipRect(AMarkRect);
end;

procedure TdxBarControl.DrawMDIButtons(AButtons: TdxBarMDIButtons;
  AExcludeClipRect: Boolean = False);
var
  AButton: TdxBarMDIButton;
begin
  for AButton := Low(TdxBarMDIButton) to High(TdxBarMDIButton) do
    if AButton in AButtons then
    begin
      if FMDIButtonFadingHelper[AButton].IsEmpty then
        DrawMDIButton(AButton, FIsMouseOverMDIButton and (AButton = FSelectedMDIButton),
          FIsMDIButtonPressed and (AButton = FPressedMDIButton))
      else
        FMDIButtonFadingHelper[AButton].DrawImage(Canvas.Handle, RectMDI(AButton));
      if AExcludeClipRect then
        Canvas.ExcludeClipRect(RectMDI(AButton));
    end;
end;

procedure TdxBarControl.DrawSelection(ADC: HDC);
begin
  if BarManager.Designing and Bar.IsComponentSelected then
  begin
    if BarDesignController.NeedDefaultSelection(Bar) then
      dxBarFrameRect(ADC, ClientRect, COLOR_WINDOWTEXT)
    else
       dxBarFocusRect(ADC, ClientRect);
  end;
end;

procedure TdxBarControl.FillBackground(ADC: HDC; const ARect: TRect; ABrush: HBRUSH;
  AColor: TColor; AIsClientArea: Boolean);
var
  R: TRect;
begin
  // calc rect
  if AIsClientArea then
    R := cxRectOffset(ARect, NCOffset)
  else
    R := ARect;
  Painter.BarDrawBackground(Self, ADC, ARect, R, ABrush, AColor);
end;

procedure TdxBarControl.FrameChanged;
begin
  SetWindowPos(Handle, 0, 0, 0, 0, 0,
    SWP_NOZORDER or SWP_NOMOVE or SWP_NOSIZE or SWP_NOACTIVATE or SWP_FRAMECHANGED);
end;

function TdxBarControl.GetCaption: TCaption;
begin
  Result := Bar.Caption;
end;

function TdxBarControl.GetEditFont: TFont;
begin
  if FBar.UseOwnFont then
    Result := FBar.FEditFont
  else
    Result := inherited GetEditFont;
end;

function TdxBarControl.GetFont: TFont;
begin
  Result := Bar.Font;
end;

function TdxBarControl.GetFullItemRect(Item: TdxBarItemControl): TRect;
begin
  Result := GetItemRect(Item);
  with Item.ItemLink, Result do
    if Vertical then
    begin
      Dec(Left, (RowHeight - (Right - Left)) div 2);
      Right := Left + RowHeight;
    end
    else
    begin
      Dec(Top, (RowHeight - (Bottom - Top)) div 2);
      Bottom := Top + RowHeight;
    end;
end;

function TdxBarControl.GetItemRegion(Item: TdxBarItemControl): HRGN;
var
  Rgn: HRGN;
  ASeparatorIndex: Integer;
begin
  Result := CreateRectRgnIndirect(GetFullItemRect(Item));
  if ViewInfo.IsAssociatedWithSeparator(Item, ASeparatorIndex) then
  begin
    Rgn := CreateRectRgnIndirect(ViewInfo.SeparatorInfos[ASeparatorIndex].Bounds);
    CombineRgn(Result, Result, Rgn, RGN_OR);
    DeleteObject(Rgn);
  end;
end;

function TdxBarControl.GetToolbarBrush: HBRUSH;
begin
  Result := Painter.BarToolbarBrushEx(Self);
end;

procedure TdxBarControl.GlyphChanged;
begin
end;

function TdxBarControl.IsBackgroundBitmap: Boolean;
begin
  Result := inherited IsBackgroundBitmap or
    not Bar.BackgroundBitmap.Empty or
    not BarManager.Backgrounds.Bar.Empty;
end;

function TdxBarControl.IsTransparent: Boolean;
begin
  Result := (Bar.Color <> clDefault) or not Bar.BackgroundBitmap.Empty or
    not BarManager.Backgrounds.Bar.Empty or inherited IsTransparent or
    Painter.IsCompoundPainting;
end;

function TdxBarControl.LockHotTrackWhenPopup: Boolean;
begin
  Result := True;
end;

function TdxBarControl.NCOffset: TPoint;
begin
//  Result := inherited NCOffset;
//  if DockingStyle <> dsNone then
  Result := ClientBounds.TopLeft;
end;

procedure TdxBarControl.NCPaint(ADC: HDC);
var
  ATempDC: HDC;
begin
  DoNCPaint(ADC);
  if BarManager.IsUncustomizable then
  begin
    SelectClipRgn(ADC, FPrevClipRgn.Handle);
    DrawDisablingHatch(ADC, Rect(0, 0, Width, Height));
    ATempDC := GetWindowDC(Handle);
    try
      SelectClipRgn(ATempDC, FPrevClipRgn.Handle);
      BitBlt(ATempDC, 0, 0, Width, Height, ADC, 0, 0, SRCCOPY);
    finally
      ReleaseDC(Handle, ATempDC);
    end;
  end;
end;

function TdxBarControl.NeedHideOnNCMouseClick: Boolean;
begin
  Result := GetParentPopupWindow(Self, True) = nil;
end;

function TdxBarControl.NotHandleMouseMove(ACheckLastMousePos: Boolean = True): Boolean;

  function ControlContainerActive: Boolean;
  begin
    Result := HasAsParent(GetActiveWindow, BarManager.Owner.Handle);
  end;

var
  AQuickControl: TdxBarControl;
begin
  Result := inherited NotHandleMouseMove(ACheckLastMousePos) or
    (DockingStyle <> dsNone) and not IsFormActive(ParentForm) and not ControlContainerActive;
  if not Result then
  begin
    AQuickControl := BarDesignController.QuickControl;
    Result := (AQuickControl <> nil) and AQuickControl.LockHotTrackWhenPopup and
      not ((Self = AQuickControl) or AQuickControl.IsChildBar(Self));
  end;
end;

procedure TdxBarControl.RebuildBar;
begin
  UpdateDoubleBuffered;
  FrameChanged;
  RepaintBar;
end;

procedure TdxBarControl.RefreshShadow;
begin
  FShadow.Refresh;
end;

procedure TdxBarControl.RepaintMDIButtons;
var
  AButtons: TdxBarMDIButtons;
begin
  if RealMDIButtonsOnBar then
    AButtons := [mdibMinimize, mdibRestore, mdibClose]
  else
    AButtons := [mdibClose];
  DrawMDIButtons(AButtons);
end;

procedure TdxBarControl.SavePos;
begin
  if not FBar.Visible or FMoving or BarManager.IsDestroying then
    Exit;
  FPosSaving := True;
  BarManager.LockDesignerModified(True);
  try
    if DockingStyle = dsNone then
    begin
      Bar.FloatLeft := Left;
      Bar.FloatTop := Top;
      Bar.FloatClientWidth := ClientWidth;
      Bar.FloatClientHeight := ClientHeight;
    end
    else
      if (DockControl <> nil) and not DockControl.IsBarHandleDestroying and
        not BarManager.IsHandleCreating then
      begin
        Bar.DockedDockingStyle := DockingStyle;
        if DockControl.Main then
          Bar.DockedDockControl := nil
        else
          Bar.DockedDockControl := TdxBarDockControl(DockControl);
        if GetDockCol <> nil then
        begin
          Bar.OneOnRow := GetDockCol.DockRow.FBars.Count = 1;
//          FBar.Bars.BeginUpdate;
          try
            Bar.DockedLeft := Left;
            Bar.DockedTop := Top;
          finally
//            FBar.Bars.EndUpdate;
          end;
        end;
      end;
  finally
    FPosSaving := False;
    BarManager.LockDesignerModified(False);
  end;
end;

procedure TdxBarControl.SetFont;
begin
  Font := GetFont;
end;

procedure TdxBarControl.SetDockingStyle(Value: TdxBarDockingStyle);
begin
  if DockingStyle <> Value then FTruncated := False;
  inherited;
end;

procedure TdxBarControl.SetKeySelectedItem(Value: TdxBarItemControl);
var
  APrevSelectedControl: TdxBarItemControl;
begin
  APrevSelectedControl := SelectedControl;
  inherited SetKeySelectedItem(Value);
  if (SelectedControl <> APrevSelectedControl) and
    (SelectedControl <> nil) and not SelectedControl.IsActive and not IsCustomizing then
    if SelectedControl is TdxBarSubItemControl then
      SelectedControl.ControlClick(False)
    else
      SelectedControl.ControlActivate(True);
end;

procedure TdxBarControl.SetLayeredAttributes;
var
  AAlphaBlendValue: Byte;
begin
  if FMoving or ((DockingStyle = dsNone) and not IsInternal) then
    AAlphaBlendValue := Bar.AlphaBlendValue
  else
    AAlphaBlendValue := 255;
  if FMoving then
    SetLayeredWndAttributes(FFloatingHandle, AAlphaBlendValue)
  else
    SetLayeredWndAttributes(Handle, AAlphaBlendValue);
end;

function TdxBarControl.IsRealVertical: Boolean;
begin
  Result := Vertical;
end;

function TdxBarControl.IsVertical: Boolean;
begin
  Result := IsRealVertical and Bar.RotateWhenVertical;
end;

function TdxBarControl.Kind: TdxBarKind;
begin
  Result := bkBarControl;
end;

procedure TdxBarControl.Popup(const AOwnerRect: TRect);
begin
  PopupEx(AOwnerRect, xdRight);
end;

procedure TdxBarControl.PopupEx(const AOwnerRect: TRect; APopupDirection: TXDirection);
var
  AWorkArea: TRect;
  ASize: TSize;
  P: TPoint;
begin
  ClosedByEscape := False;
  ASize := GetSizeForPopup;
  if ParentBar.IsRealVertical then
    P := Point(AOwnerRect.Right, AOwnerRect.Top)
  else
    case APopupDirection of
      xdLeft: P := Point(AOwnerRect.Right - ASize.cx, AOwnerRect.Bottom);
      xdRight: P := Point(AOwnerRect.Left, AOwnerRect.Bottom);
    end;
  AWorkArea := GetWorkArea(P);
  if ParentBar.IsRealVertical then
  begin
    if P.X + ASize.cx > AWorkArea.Right then P.X := AOwnerRect.Left - ASize.cx;
    if P.Y < AWorkArea.Top then P.Y := AWorkArea.Top;
    if P.Y + ASize.cy > AWorkArea.Bottom then P.Y := AWorkArea.Bottom - ASize.cy;
  end
  else
  begin
    if P.X < AWorkArea.Left then P.X := AWorkArea.Left;
    if P.X + ASize.cx > AWorkArea.Right then P.X := AWorkArea.Right - ASize.cx;
    if P.Y + ASize.cy > AWorkArea.Bottom then P.Y := AOwnerRect.Top - ASize.cy;
  end;
  if IsWinVista then
  begin
    SetWindowPos(Handle, HWND_TOP, P.X, P.Y, ASize.cx, ASize.cy, SWP_NOACTIVATE);
    ShowWindow(Handle, SW_SHOWNOACTIVATE);
  end
  else
    SetWindowPos(Handle, HWND_TOP, P.X, P.Y, ASize.cx, ASize.cy, SWP_SHOWWINDOW or SWP_NOACTIVATE);
end;

procedure TdxBarControl.Repaint;
begin
  if (Bar <> nil) and Bar.BarManager.IsUpdateLocked then
    Bar.DoChanged
  else
    inherited;
end;

procedure TdxBarControl.UpdateFont;
begin
  Font := GetFont;
  Perform(CM_FONTCHANGED, 0, 0);
end;

procedure TdxBarControlViewInfo.Calculate;
var
  AItemLink: TdxBarItemLink;
  I: Integer;
begin
  BarControl.CalcControlsPositions;
  inherited Calculate;
  for I := 0 to BarControl.ItemLinks.VisibleItemCount - 1 do
  begin
    AItemLink := BarControl.ItemLinks.VisibleItems[I];
    if AItemLink.Control = nil then
      Continue;
    AddItemControlViewInfo(AItemLink.Control.ViewInfo);
    IdxBarItemControlViewInfo(AItemLink.Control.ViewInfo).SetBounds(BarControl.GetItemRect(AItemLink.Control));
    CalcSeparatorInfo(AItemLink);
    if IsLastVisibleItemControl(AItemLink.Control) then
      Break;
  end;
end;

procedure TdxBarControlViewInfo.CalcSeparatorInfo(AItemLink: TdxBarItemLink);
var
  AItemRect: TRect;
begin
  if not CanShowSeparators then Exit;
  AItemRect := AItemLink.Control.ViewInfo.Bounds;
  if AItemLink.BeginGroup and not IsRectEmpty(AItemRect) then
    DoCalcSeparatorInfo(AItemLink, AItemRect);
end;

function TdxBarControlViewInfo.CanShowButtonGroups: Boolean;
begin
  Result := False;
end;

function TdxBarControlViewInfo.CanShowSeparators: Boolean;
begin
  Result := True;
end;

procedure TdxBarControlViewInfo.DoCalcSeparatorInfo(AItemLink: TdxBarItemLink; const AItemRect: TRect);
var
  R: TRect;
  AMarkSize: Integer;
begin
  if BarControl.DockingStyle <> dsNone then
    AMarkSize := BarControl.GetMarkSize
  else
    AMarkSize := 0;
  if not BarControl.Vertical and (AItemRect.Left = 0) and (AItemRect.Top > 0) or
    BarControl.Vertical and (AItemRect.Top > 0) then
  begin  // begin group in vertical direction
    if BarControl.Vertical then
      R := Bounds(AItemRect.Left - (AItemLink.FRowHeight - cxRectWidth(AItemRect)) div 2,
        AItemRect.Top - BarControl.BeginGroupSize, AItemLink.FRowHeight, BarControl.BeginGroupSize)
    else
      R := Bounds(
        0,
        AItemRect.Top - (AItemLink.FRowHeight - cxRectHeight(AItemRect)) div 2 - BarControl.BeginGroupSize,
        BarControl.ClientWidth - AMarkSize,
        BarControl.BeginGroupSize);
    AddSeparatorInfo(R, skHorizontal, AItemLink.Control);
  end
  else
  begin  // begin group in horizontal direction
    if BarControl.Vertical then
      R := Bounds(
        AItemRect.Right + (AItemLink.FRowHeight - cxRectWidth(AItemRect)) div 2, 0,
        BarControl.BeginGroupSize,
        BarControl.ClientHeight - AMarkSize)
    else
      R := Bounds(
        AItemRect.Left - BarControl.BeginGroupSize,
        AItemRect.Top - (AItemLink.FRowHeight - cxRectHeight(AItemRect)) div 2,
        BarControl.BeginGroupSize, AItemLink.FRowHeight);
    AddSeparatorInfo(R, skVertical, AItemLink.Control);
  end;
end;

function TdxBarControlViewInfo.IsLastVisibleItemControl(
  AItemControl: TdxBarItemControl): Boolean;
begin
  Result := False;
end;

function TdxBarControlViewInfo.GetBarControl: TdxBarControl;
begin
  Result := TdxBarControl(FBarControl);
end;

{ TdxBarSubMenuControl }

type
  TdxBarAnimationInfo = record
    AnimationMenu: TdxBarSubMenuControl;
    AnimationType: TdxBarMenuAnimations;
    LeftDirection, TopDirection: Boolean;
    RealLeft, RealTop: Integer;
    RealClientWidth, RealClientHeight: Integer;
    BorderWidth, BorderHeight: Integer;
    FirstValue: Integer;
    Delta: Integer;
    Step: Integer;
    OldClientRect: TRect;
  end;

  TdxBarAnimationThread = class(TThread)
  private
    FAnimationInfo: TdxBarAnimationInfo;
    FPrevGDIObject: HGDIOBJ;
    FCompatibleDC: HDC;
    procedure DoAnimation;
    procedure DoOneStepOfAnimation(AIteration: Integer);
    procedure DoFinishAnimation;
  protected
    procedure DoTerminate; override;
    procedure Execute; override;
  public
    constructor Create(const AAnimationInfo: TdxBarAnimationInfo);
    destructor Destroy; override;
    procedure TerminateAnimation;
  end;

constructor TdxBarAnimationThread.Create(const AAnimationInfo: TdxBarAnimationInfo);
var
  ADC: HDC;
begin
  inherited Create(True);
  FreeOnTerminate := True;
  FAnimationInfo := AAnimationInfo;

  ADC := FAnimationInfo.AnimationMenu.Canvas.Handle;
  FCompatibleDC := CreateCompatibleDC(ADC);
  FPrevGDIObject := SelectObject(FCompatibleDC, CreateCompatibleBitmap(ADC, FAnimationInfo.RealClientWidth, FAnimationInfo.RealClientHeight));
  FAnimationInfo.AnimationMenu.PaintWindow(FCompatibleDC);
end;

destructor TdxBarAnimationThread.Destroy;
begin
  ReverseGDIObject(FCompatibleDC, FPrevGDIObject);
  DeleteDC(FCompatibleDC);
  inherited;
end;

procedure TdxBarAnimationThread.TerminateAnimation;
begin
  FreeOnTerminate := False;
  try
    Terminate;
    WaitFor;
  finally
    Free;
  end;  
end;

procedure TdxBarAnimationThread.DoTerminate;
begin
  inherited;
  Synchronize(DoFinishAnimation);
end;

procedure TdxBarAnimationThread.Execute;
begin
  DoAnimation;
end;

procedure TdxBarAnimationThread.DoAnimation;
var
  AFirstTime: DWORD;
  I: Integer;
begin
  for I := 1 to FAnimationInfo.Delta div FAnimationInfo.Step do
  begin
    if Terminated then
      Break;
    AFirstTime := GetTickCount;
    DoOneStepOfAnimation(I);
    Sleep(1);
    while (GetTickCount - AFirstTime < 1) and not Terminated do {loop};
  end;
end;

procedure TdxBarAnimationThread.DoOneStepOfAnimation(AIteration: Integer);
var
  ANewLeft, ANewTop, ANewClientWidth, ANewClientHeight: Integer;
  R, R1, R2: TRect;
  DC: HDC;
begin
  with FAnimationInfo do
  begin
    if FirstValue >= 0 then
    begin
      ANewClientWidth := Step * AIteration;
      ANewClientHeight := FirstValue + ANewClientWidth;
      if AnimationType = maSlide then
        ANewClientWidth := AnimationMenu.ClientWidth;
    end
    else
    begin
      ANewClientHeight := Step * AIteration;
      ANewClientWidth := Abs(FirstValue) + ANewClientHeight;
    end;

    if LeftDirection then
      ANewLeft := AnimationMenu.Left - (ANewClientWidth - AnimationMenu.ClientWidth)
    else
      ANewLeft := AnimationMenu.Left;
    if TopDirection then
      ANewTop := AnimationMenu.Top - (ANewClientHeight - AnimationMenu.ClientHeight)
    else
      ANewTop := AnimationMenu.Top;

    SetWindowPos(AnimationMenu.Handle, 0, ANewLeft, ANewTop,
      BorderWidth + ANewClientWidth, BorderHeight + ANewClientHeight,
      SWP_NOZORDER or SWP_NOACTIVATE or SWP_SHOWWINDOW);

    DC := GetDC(AnimationMenu.Handle);
    AnimationMenu.PreparePalette(DC);

    R1 := OldClientRect;
    if TopDirection then
    begin
      R := Rect(0, 0, ANewClientWidth, ANewClientHeight);
      OffsetRect(R1, 0, ANewClientHeight - R1.Bottom);
      cxBitBlt(DC, DC, OldClientRect, R1.TopLeft, SRCCOPY);
      R1 := OldClientRect;

      BitBlt(DC, 0, R1.Bottom, AnimationMenu.ClientWidth, AnimationMenu.ClientHeight - R1.Bottom,
        FCompatibleDC, R.Left, R.Top + R1.Bottom, SRCCOPY);
      BitBlt(DC, R1.Right, R1.Top, AnimationMenu.ClientWidth - R1.Right, R1.Bottom - R1.Top,
        FCompatibleDC, R.Left + R1.Right, R.Top, SRCCOPY);
    end
    else
      if LeftDirection then
      begin
        R := Rect(RealClientWidth - AnimationMenu.ClientWidth, RealClientHeight - AnimationMenu.ClientHeight, RealClientWidth, RealClientHeight);
        OffsetRect(R1, AnimationMenu.ClientWidth - R1.Right, 0);
        R2 := R1;
        OffsetRect(R2, 0, AnimationMenu.ClientHeight - R1.Bottom);
        cxBitBlt(DC, DC, R2, R1.TopLeft, SRCCOPY);
        R1 := R2;

        BitBlt(DC, 0, 0, AnimationMenu.ClientWidth, R1.Top, FCompatibleDC, R.Left, R.Top, SRCCOPY);
        BitBlt(DC, 0, R1.Top, R1.Left, AnimationMenu.ClientHeight - R1.Top,
          FCompatibleDC, R.Left, R.Top + R1.Top, SRCCOPY);
      end
      else
      begin
        R := Rect(0, RealClientHeight - AnimationMenu.ClientHeight, AnimationMenu.ClientWidth, RealClientHeight);
        OffsetRect(R1, 0, AnimationMenu.ClientHeight - R1.Bottom);
        cxBitBlt(DC, DC, R1, OldClientRect.TopLeft, SRCCOPY);

        BitBlt(DC, 0, 0, AnimationMenu.ClientWidth, R1.Top, FCompatibleDC, R.Left, R.Top, SRCCOPY);
        BitBlt(DC, R1.Right, R1.Top, AnimationMenu.ClientWidth - R1.Right, AnimationMenu.ClientHeight - R1.Top,
          FCompatibleDC, R.Left + R1.Right, R.Top + R1.Top, SRCCOPY);
      end;
    OldClientRect := AnimationMenu.ClientRect;

    AnimationMenu.UnpreparePalette(DC);
    UpdateColors(DC);
    ReleaseDC(AnimationMenu.Handle, DC);
  end;
end;

procedure TdxBarAnimationThread.DoFinishAnimation;
begin
  with FAnimationInfo do
    if not AnimationMenu.IsDestroying then
    begin
      AnimationMenu.FShowAnimation := False;
      SetWindowPos(AnimationMenu.Handle, 0, RealLeft, RealTop,
        BorderWidth + RealClientWidth,
        BorderHeight + RealClientHeight,
        SWP_NOZORDER or SWP_NOACTIVATE or SWP_SHOWWINDOW or SWP_FRAMECHANGED {to enforce WM_WINDOWPOSCHANGED});
      AnimationMenu.Repaint;
    end;
end;

constructor TdxBarSubMenuControl.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Width := 0;
  FXDirection := xdRight;
  FYDirection := ydBottom;
end;

destructor TdxBarSubMenuControl.Destroy;
begin
  if BarManager.FChangedSubMenuControl = Self then
    BarManager.FChangedSubMenuControl := nil;
  IsActive := False;
  inherited Destroy;
end;

function TdxBarSubMenuControl.GetBandSize: Integer;
begin
  Result := Painter.SubMenuControlGetBandSize(Self);
end;

function TdxBarSubMenuControl.GetBarSize: Integer;
begin
  if GetSubMenuOwner <> nil then
    Result := GetSubMenuOwner.GetBarSize
  else
    Result := 0;
end;

function TdxBarSubMenuControl.GetBarRect: TRect;
begin
  Result := Rect(ItemsRect.Left - BarSize, ItemsRect.Top, ItemsRect.Left, ItemsRect.Bottom);
end;

function TdxBarSubMenuControl.GetBottomVisibleItemIndex: Integer;
var
  AMaxVisibleItemCount: Integer;
begin
   AMaxVisibleItemCount := Max(GetMaxVisibleCount, 1);
   Result := TopIndex + AMaxVisibleItemCount - 1;
   if not UseScrollButtons and DownArrowExists then
     Dec(Result);
end;

function TdxBarSubMenuControl.GetBorderSize: Integer;
begin
  Result := Painter.SubMenuControlBorderSize;
end;

function TdxBarSubMenuControl.GetContentRect: TRect;
begin
  Result := cxRectContent(ClientRect, Painter.SubMenuControlContentRectOffset(Self));
end;

function TdxBarSubMenuControl.GetDetachCaptionSize: Integer;
begin
  Result := Canvas.TextHeight('Qq') div 2;
  if not Odd(Result) then Inc(Result);
end;

function TdxBarSubMenuControl.GetMaxVisibleCount: Integer;
var
  I: Integer;
begin
  for I := TopIndex to ItemLinks.VisibleItemCount - 1 do
    if ItemLinks.VisibleItems[I].ItemRect.Bottom = 0 then
    begin
      Result := I - TopIndex;
      Exit;
    end;
  Result := ItemLinks.VisibleItemCount - TopIndex;
end;

function TdxBarSubMenuControl.GetParentItemControl: TdxBarItemControl;
begin
  if FDropDownButton <> nil then
    Result := FDropDownButton
  else
    Result := FSubItem;
end;

function TdxBarSubMenuControl.GetSubMenuOwner: IdxBarSubMenuOwner;
begin
  Supports(TObject(ItemLinks.Owner), IdxBarSubMenuOwner, Result);
end;

function TdxBarSubMenuControl.GetToolbarItemsBrush: HBRUSH;
begin
  Result := Painter.SubMenuControlToolbarItemsBrush(Self);
end;

function TdxBarSubMenuControl.GetTopVisibleItemIndex: Integer;
begin
  Result := TopIndex;
  if not UseScrollButtons and UpArrowExists then
    Inc(Result);
end;

procedure TdxBarSubMenuControl.SetDetachCaptionSelected(AValue: Boolean);
begin
  if IsCustomizing or (GetCapture <> 0) then Exit;
  if FDetachCaptionSelected <> AValue then
  begin
    FDetachCaptionSelected := AValue;
    InvalidateDetachCaption;
    SetCursorForMoving(AValue);
    if AValue then
      BarManager.ActivateHint(True, cxGetResourceString(@dxSBAR_DRAGTOMAKEMENUFLOAT), Self)
    else
      if SelectedControl = nil then
        BarManager.HideHint;
  end;
end;

procedure TdxBarSubMenuControl.SetTopIndex(AValue: Integer);
begin
  if AValue < 0 then AValue := 0;
  if FTopIndex <> AValue then
  begin
    FTopIndex := AValue;
    InvalidateItemsRect;
  end;
end;

procedure TdxBarSubMenuControl.CalcBounds(out ASize: TSize);

  procedure CalcItemSizeParams;
  var
    ARecentItemCount: Integer;
    AExtendedView: Boolean;
    ALastWasRecentItem: Boolean;
    I: Integer;
    AItemLink: TdxBarItemLink;
  begin
    ARecentItemCount := ItemLinks.MostRecentItemCount;
    if ARecentItemCount = -1 then
      ARecentItemCount := ItemLinks.CanVisibleItemCount;
    AExtendedView := ExtendedView;

    ALastWasRecentItem := True;
    for I := TopIndex to ItemLinks.VisibleItemCount - 1 do
    begin
      AItemLink := ItemLinks.VisibleItems[I];
      AItemLink.Control.FNonRecent := AExtendedView and (AItemLink.RecentIndex >= ARecentItemCount);
      AItemLink.Control.FChangeRecentGroup := AExtendedView and
        ((I > TopIndex) or Detachable) and (AItemLink.Control.FNonRecent = ALastWasRecentItem);
      ALastWasRecentItem := not AItemLink.Control.FNonRecent;
    end;
  end;

begin
  CalcItemSizeParams;
  CalcSize(ASize);
end;

procedure TdxBarSubMenuControl.CalcSize(out ASize: TSize);
begin
  DoCalcSize(ASize);

  if ASize.cx = 0 then
    ASize.cx := dxBarEmptySubMenuControlContentWidth;
  if ASize.cy <= 2 then
    Inc(ASize.cy, TextSize);
  if MarkExists then
    Inc(ASize.cy, MarkSize);

  DoCorrectSize(ASize);
end;

procedure TdxBarSubMenuControl.CreateLightBrush;
var
  Color: COLORREF;
  R, G, B: Integer;
  DC: HDC;
  LogPalette: TLogPalette;
begin
  Color := GetSysColor(COLOR_BTNFACE);
  R := Min(255, GetRValue(Color) + dxBarNonrecentlyUsedItemsColorDelta);
  G := Min(255, GetGValue(Color) + dxBarNonrecentlyUsedItemsColorDelta);
  B := Min(255, GetBValue(Color) + dxBarNonrecentlyUsedItemsColorDelta);

  DC := GetDC(0);
  if BarManager.ShowRecentItemsFirst and (GetDeviceCaps(DC, BITSPIXEL) <= 8) then
  begin
    with LogPalette do
    begin
      palVersion := $0300;
      palNumEntries := 1;
      with palPalEntry[0] do
      begin
        peRed := R;
        peGreen := G;
        peBlue := B;
        peFlags := 0;
      end;
    end;
    FLightPalette := CreatePalette(LogPalette);
    FLightBrush := CreateSolidBrush(PaletteIndex(0));
  end
  else
  begin
    Color := RGB(R, G, B);
    FLightBrush := CreateSolidBrush(Color);
  end;
  ReleaseDC(0, DC);
end;

procedure TdxBarSubMenuControl.DestroyLightBrush;
begin
  DeleteGDIObject(FLightBrush);
  DeleteGDIObject(FLightPalette);
end;

procedure TdxBarSubMenuControl.PreparePalette(DC: HDC);
begin
  if FLightPalette <> 0 then
  begin
    SelectPalette(DC, FLightPalette, True);
    RealizePalette(DC);
  end;
end;

procedure TdxBarSubMenuControl.UnpreparePalette(DC: HDC);
begin
  if FLightPalette <> 0 then
  begin
    SelectPalette(DC, GetStockObject(DEFAULT_PALETTE), True);
    RealizePalette(DC);
  end;  
end;

procedure TdxBarSubMenuControl.ExpandMenu;
begin
  if MarkExists then
  begin
    ShowFullMenus := True;
    FShowAnimation := True;
    FExpandingMenu := True;
    try
      DestroyWnd;
    finally
      FExpandingMenu := False;
    end;
    Left := FOnShowLeft;
    Top := FOnShowTop;
    Show;
  end;  
end;

function TdxBarSubMenuControl.ExtendedView: Boolean;
begin
  Result := BarManager.ShowRecentItemsFirst and ShowFullMenus;
end;

procedure TdxBarSubMenuControl.InvalidateItemsRect;
begin
  cxInvalidateRect(Handle, ItemsRect, False);
end;

procedure TdxBarSubMenuControl.InvalidateDetachCaption;
var
  DC: HDC;
begin
  DC := GetWindowDC(Handle);
  Painter.SubMenuControlDrawDetachCaption(Self, DC, DetachCaptionRect);
  ReleaseDC(Handle, DC);
end;

function TdxBarSubMenuControl.MouseOnArrow(AArrowDirection: TcxArrowDirection): Boolean;
begin
  Result := PtInRect(Painter.SubMenuControlGetScrollBandBounds(Self, AArrowDirection), ScreenToClient(GetMouseCursorPos));
end;

function TdxBarSubMenuControl.MouseOnUpArrow: Boolean;
begin
  Result := MouseOnArrow(adUp);
end;

function TdxBarSubMenuControl.MouseOnDownArrow: Boolean;
begin
  Result := MouseOnArrow(adDown);
end;

procedure ExpandMenuTimerProc(Wnd: HWND; Msg: UINT; idEvent: UINT; Time: DWORD); stdcall;
begin
  with TdxBarSubMenuControl(FindControl(Wnd)) do
  begin
    KillExpandMenuTimer;
    if idEvent = 3 then
      MarkState := msPressed
    else
      if ChildBar = nil then
        MarkState := msSelected;
  end;
end;

procedure TdxBarSubMenuControl.SetExpandMenuTimer(Time: UINT; ExpandAfterDelay: Boolean);
begin
  FExpandMenuTimer := SetTimer(Handle, 2 + Byte(ExpandAfterDelay), Time, @ExpandMenuTimerProc);
end;

procedure TdxBarSubMenuControl.KillExpandMenuTimer;
begin
  if FExpandMenuTimer <> 0 then
    dxKillTimer(Handle, FExpandMenuTimer);
end;

procedure TdxBarSubMenuControl.KillScrollTimer;
begin
  if FScrollTimerID <> 0 then
    dxKillTimer(Handle, FScrollTimerID);
end;

function TdxBarSubMenuControl.IsAnimationRunning: Boolean;
begin
  Result := (FAnimationThread <> nil) and not FAnimationThread.Suspended;
end;

procedure TdxBarSubMenuControl.OnTerminateAnimation(Sender: TObject);
begin
  FAnimationThread := nil;
end;

procedure TdxBarSubMenuControl.WMGetDlgCode;
begin
  Message.Result := DLGC_WANTALLKEYS or DLGC_WANTARROWS or DLGC_WANTTAB;
end;

procedure TdxBarSubMenuControl.WMKeyDown(var Message: TWMKeyDown);
var
  Shift: TShiftState;
begin
  TerminateAnimation;

  Shift := KeyDataToShiftState(Message.KeyData);
  if (Message.CharCode in [VK_DOWN, VK_TAB]) and MarkExists then
    if (Message.CharCode = VK_DOWN) and (Shift = [ssCtrl]) then
    begin
      MarkState := msPressed;
      Exit;
    end
    else
      if (Shift = []) and (SelectedControl <> nil) then
        with SelectedControl.ItemLink do
          if VisibleIndex = Owner.VisibleItemCount - 1 then
          begin
            MarkState := msPressed;
            SendMessage(Handle, WM_KEYDOWN, Message.CharCode, 1);
            Exit;
          end;
          
  inherited;
end;

procedure TdxBarSubMenuControl.WMLButtonDown(var Message: TWMLButtonDown);
begin
  if FScrollTimerId <> 0 then Exit;
  inherited;
  if not BarControlExists(Self) then Exit;
  if FIgnoreMouseClick then Exit;
  TerminateAnimation;
  if DetachCaptionSelected then
    DoDetachMenu
  else
    if MarkExists and MouseOnMark then
      if MarkState = msNone then
      begin
        SetKeySelectedItem(nil);
        MarkState := msSelected;
      end
      else
      begin
        FIgnoreMouseClick := True;
        MarkState := msPressed;
      end;
end;

procedure TdxBarSubMenuControl.WMNCCalcSize(var Message: TWMNCCalcSize);
begin
  inherited;
  with Message.CalcSize_Params^ do
    rgrc[0] := cxRectContent(rgrc[0], GetClientOffset);
end;

procedure TdxBarSubMenuControl.WMNCHitTest(var Message: TWMNCHitTest);
var
  ADetachCaptionRect: TRect;
begin
  if Detachable then
  begin
    ADetachCaptionRect := cxRectOffset(DetachCaptionRect, Left, Top);
    if PtInRect(ADetachCaptionRect, SmallPointToPoint(Message.Pos)) then
      Message.Result := HTCLIENT
    else
      inherited;
  end
  else
    inherited;
end;

procedure TdxBarSubMenuControl.WMPrint(var Message: TMessage);
begin
  inherited;
  NCPaint(Message.WParam);
end;

procedure TdxBarSubMenuControl.WMPrintClient(var Message: TMessage);
begin
  inherited;
  PaintWindow(Message.WParam);
end;

procedure TdxBarSubMenuControl.WMRButtonDown(var Message: TWMRButtonUp);
begin
  inherited;
  if IsContextMenu then
    with TMessage(Message) do
      SendMessage(Handle, WM_LBUTTONDOWN, WParam, LParam);
end;

procedure TdxBarSubMenuControl.WMRButtonUp(var Message: TWMRButtonUp);
begin
  inherited;
  if IsContextMenu then
    with TMessage(Message) do
      SendMessage(Handle, WM_LBUTTONUP, WParam, LParam);
end;

procedure TdxBarSubMenuControl.WMTimer(var Message: TWMTimer);

  procedure EndScrollingSubMenu;
  var
    P: TPoint;
  begin
    KillScrollTimer;
    FLastMousePos := cxInvalidPoint;
    P := GetMouseCursorPos;
    if BarManager.Dragging then
    begin
      Windows.ScreenToClient(BarManager.Owner.Handle, P); //#DG
      PostMessage(BarManager.Owner.Handle, WM_MOUSEMOVE, 0, MakeLParam(P.X, P.Y)); //#DG
    end
    else
    begin
      Windows.ScreenToClient(Handle, P);
      SendMessage(Handle, WM_MOUSEMOVE, 0, MakeLParam(P.X, P.Y));
    end;
  end;

begin
  if UpArrowExists and MouseOnUpArrow then
      TopIndex := TopIndex - 1
  else
    if DownArrowExists and MouseOnDownArrow then
      TopIndex := TopIndex + 1
    else
      EndScrollingSubMenu;
end;

procedure TdxBarSubMenuControl.CMFontChanged(var Message: TMessage);
begin
  inherited;
  Canvas.Font := Font;
  CalcDrawingConsts;
end;

procedure TdxBarSubMenuControl.CreateParams(var Params: TCreateParams);
begin
  inherited CreateParams(Params);
  with Params do
  begin
    Style := WS_CLIPCHILDREN or WS_CLIPSIBLINGS or WS_POPUP;
    ExStyle := ExStyle or WS_EX_TOPMOST;
    WindowClass.Style :=
      CS_DBLCLKS or CS_HREDRAW or CS_VREDRAW or CS_OWNDC or CS_SAVEBITS;
    if FParentWnd > 0 then
      WndParent := FParentWnd
    else
      WndParent := BarManager.Owner.Handle;
  end;
end;

procedure TdxBarSubMenuControl.CreateWnd;
var
  AChangeXDirection, AChangeYDirection: Boolean;
  AAnimationInfo: TdxBarAnimationInfo;
begin
  //ProcessPaintMessages; - destroys submenu because of PeekMessage
  CreateLightBrush;
  inherited CreateWnd;
  FOnShowLeft := Left;
  FOnShowTop := Top;
  IsActive := True;
  SetRecentItemCount;
  FTopIndex := -1;
  TopIndex := 0;
  SetSizeAndCheckBounds(cxNullSize, AChangeXDirection, AChangeYDirection);
//  PlaySound(psMenuPopup);
  if FShowAnimation then
    with AAnimationInfo do
    begin
      RealLeft := Left;
      RealTop := Top;
      RealClientWidth := ClientWidth;
      RealClientHeight := ClientHeight;
      BorderWidth := Width - ClientWidth;
      BorderHeight := Height - ClientHeight;
      LeftDirection := ((FXDirection = xdLeft) and not AChangeXDirection) or
        ((FXDirection = xdRight) and AChangeXDirection);
      TopDirection := ((FYDirection = ydTop) and not AChangeYDirection) or
        ((FYDirection = ydBottom) and AChangeYDirection);
      AnimationType := FMenuAnimations;
      case AnimationType of
        maUnfold:
          begin
            FirstValue := ClientHeight - ClientWidth;
            if FirstValue > 0 then
            begin
              OldClientRect := Rect(0, 0, 0, FirstValue);
              Delta := ClientWidth;
            end
            else
            begin
              OldClientRect := Rect(0, 0, -FirstValue, 0);
              Delta := ClientHeight;
            end;
            Step := 8;
          end;
        maSlide:
          begin
            FirstValue := 0;
            OldClientRect := Rect(0, 0, ClientWidth, 0);
            Delta := ClientHeight;
            Step := 17;
          end;
      else
        begin
          FirstValue := 0;
          Delta := 128;
          Step := 1;
        end;
      end;
      AnimationMenu := Self;

      FAnimationThread := TdxBarAnimationThread.Create(AAnimationInfo);
      FAnimationThread.OnTerminate := OnTerminateAnimation;
      FAnimationThread.Resume;
    end;

  PlaySound(psMenuPopup);
end;

procedure TdxBarSubMenuControl.DestroyWindowHandle;
begin
  if BarManager.Dragging and (BarManager.DraggingItemLink <> nil) and
    (ItemLinks.IndexOf(BarManager.DraggingItemLink) > -1) and
    (BarManager.DragInfo.DraggingItemLinkParentHandle = 0) then
  begin
    BarManager.DragInfo.DraggingItemLinkParentHandle := WindowHandle;
    Perform(WM_DESTROY, 0, 0);
    SetWindowLong(WindowHandle, GWL_WNDPROC, Longint(DefWndProc));
    ShowWindow(WindowHandle, SW_HIDE);
    DestroyControls;
    WindowHandle := 0;
  end
  else inherited;
end;

procedure TdxBarSubMenuControl.DestroyWnd;
begin
  if not HandleAllocated or (bsDestroyingWindow in FState) then
    Exit;
  Include(FState, bsDestroyingWindow);
  try
    TerminateAnimation;
    KillScrollTimer;
    KillExpandMenuTimer;
  //#DG  if (ChildBar <> nil) and not ChildBar.FDestroyFlag and
    if ChildBar <> nil then
      ChildBar.DestroyWnd;
    if not FExpandingMenu then
      IsActive := False;
    inherited DestroyWnd;
  //  ProcessPaintMessages;
    DoCloseUp;
    DestroyLightBrush;
  finally
    Exclude(FState, bsDestroyingWindow);
  end;
end;

procedure TdxBarSubMenuControl.DoCloseUp;
begin
  CallNotify(FOnCloseUp, Self);
end;

procedure TdxBarSubMenuControl.DoPopup;
begin
  CallNotify(FOnPopup, Self);
end;

procedure TdxBarSubMenuControl.Paint;
begin
  if IsAnimationRunning or IsDestroying then
    Exit;

  Canvas.SaveClipRegion;
  try
    SelectClipRgn(Canvas.Handle, 0); // because of CS_OWNDC
    Painter.SubMenuControlDrawClientBorder(Self, Canvas.Handle, ClientRect, ToolbarBrush);
    DrawContent;
    DrawBar;
  finally
    Canvas.RestoreClipRegion;
  end;
end;

procedure TdxBarSubMenuControl.NCPaint(ADC: HDC);
begin
  DoNCPaint(ADC, NCRect);
end;

procedure TdxBarSubMenuControl.DoKeyDown(var Message: TWMKey);
var
  AParentBarControl: TCustomdxBarControl;
begin
  case Message.CharCode of
    VK_ESCAPE:
      if (ParentBar <> nil) and (ParentBar.SelectedControl <> nil) then
      begin
        ClosedByEscape := True;
        AParentBarControl := ParentBar;
        AParentBarControl.SelectedControl.ControlInactivate(True);
        AParentBarControl.IsDowned := False;
      end
      else
        HideByEscape;
    VK_LEFT:
      begin
        AParentBarControl := ParentBar;
        if (AParentBarControl <> nil) and (AParentBarControl.SelectedControl <> nil) then
          if AParentBarControl is TdxBarSubMenuControl then
            AParentBarControl.SelectedControl.ControlInactivate(True)
          else
          begin
            AParentBarControl := GetParentBarForBar(Self);
            if AParentBarControl <> nil then
              if AParentBarControl.IsRealVertical then
                Message.Result := SendMessage(Handle, WM_KEYDOWN, VK_ESCAPE, 0)
              else
                Message.Result := SendMessage(AParentBarControl.Handle, WM_KEYDOWN, VK_LEFT, 0);
          end;
      end;
    VK_RIGHT:
      begin
        AParentBarControl := GetParentBarForBar(Self);
        if AParentBarControl <> nil then
          Message.Result := SendMessage(AParentBarControl.Handle, WM_KEYDOWN, VK_RIGHT, 0);
      end;
  else
    inherited;
  end;
end;

procedure TdxBarSubMenuControl.CalcControlsPositions;
begin
  inherited;
  CalcItemRects(ptMenu, TopIndex);
  CalcLayout;
end;

procedure TdxBarSubMenuControl.CalcDrawingConsts;
begin
  inherited CalcDrawingConsts;
  Painter.SubMenuControlCalcDrawingConsts(Canvas, FTextSize, FMenuArrowWidth, FMarkSize);
end;

procedure TdxBarSubMenuControl.CalcDragOverParameters(const ACursorPos: TPoint;
  var ADragOverItemLink: TdxBarItemLink;
  var AIsBeginGroup, AIsFirstPart, AIsVerticalDirection: Boolean);
begin
  if not (UpArrowExists and MouseOnUpArrow or
      DownArrowExists and MouseOnDownArrow or
      MarkExists and MouseOnMark) then
    inherited CalcDragOverParameters(ACursorPos, ADragOverItemLink, AIsBeginGroup, AIsFirstPart, AIsVerticalDirection);
end;

procedure TdxBarSubMenuControl.CalcItemsRect;
var
  AOffset: TRect;
begin
  AOffset := GetItemsRectOffset;
  FItemsRect := Rect(
    AOffset.Left,
    AOffset.Top,
    ClientWidth - AOffset.Right,
    ClientHeight - AOffset.Bottom - GetMarkSize);
end;

function TdxBarSubMenuControl.CanActiveChange: Boolean;
begin
  Result := True;
end;

function TdxBarSubMenuControl.CanCustomizing: Boolean;
begin
  Result := inherited CanCustomizing or
    (ItemLinks.Owner is TdxBarSubItem) and TdxBarSubItem(ItemLinks.Owner).AllowCustomizing or
    (ItemLinks.Owner is TdxBarCustomPopupMenu);
end;

function TdxBarSubMenuControl.CanDrawClippedItem(AItemRect: TRect): Boolean;
begin
  Result := AItemRect.Top < Painter.SubMenuControlGetScrollBandBounds(Self, adDown).Top;
end;

function TdxBarSubMenuControl.CanShowHint: Boolean;
begin
   Result := bboAllowShowHints in BehaviorOptions;
end;

function TdxBarSubMenuControl.CheckLockUpdate: Boolean;
begin
  Result := inherited CheckLockUpdate;
  if Result and
    ((BarManager.FChangedSubMenuControl = nil) or IsChildBar(BarManager.FChangedSubMenuControl)) then
    BarManager.FChangedSubMenuControl := Self;
end;

function TdxBarSubMenuControl.ChildrenHaveShadows: Boolean;
begin
  Result := False;
end;

procedure TdxBarSubMenuControl.CorrectVisibleItemsRectBottom;
begin
  if UseScrollButtons and DownArrowExists then
    Dec(FVisibleItemsRect.Bottom, Painter.SubMenuControlGetScrollBandSize(Self));
end;

procedure TdxBarSubMenuControl.CorrectVisibleItemsRectTop;
begin
  if UseScrollButtons and UpArrowExists then
    Inc(FVisibleItemsRect.Top, Painter.SubMenuControlGetScrollBandSize(Self));
end;

procedure TdxBarSubMenuControl.DoCreateControls;
begin
  if not IsCustomizing then
    ExpandContainerItems;
  inherited DoCreateControls;
end;

procedure TdxBarSubMenuControl.DoDestroyControls;
begin
  inherited DoDestroyControls;
  if not IsCustomizing then
    CollapseContainerItems;
end;

procedure TdxBarSubMenuControl.DoBarMouseLeave;
begin
  DetachCaptionSelected := False;
  if UpArrowExists or DownArrowExists then
    DrawScrollArea;
  inherited;
end;

procedure TdxBarSubMenuControl.DoBarMouseMove(Shift: TShiftState; const APoint: TPoint;
  AItemControl: TdxBarItemControl);
begin
  if not NotHandleMouseMove then
  begin
    TerminateAnimation;
    if not BarControlExists(Self) then Exit;
  end
  else
    if IsAnimationRunning then
      Exit;

  if WantMouse and (ParentBar <> nil) and (ParentItemControl <> nil) then
    ParentBar.SetMouseSelectedItem(ParentItemControl);

  if MarkExists then
    if MouseOnMark then
      MarkState := msSelected
    else
      MarkState := msNone;
  if UpArrowExists and MouseOnUpArrow or DownArrowExists and MouseOnDownArrow then
  begin
    if (FScrollTimerId = 0) and not cxPointIsEqual(FLastMousePos, ClientToScreen(APoint)) then
    begin
    //#DG <BarManager.SelectedItem>
      if SelectedControl = BarManager.SelectedItem then
        BarManager.InternalSetSelectedItem(nil);  // otherwise BarManager will hide all
      SetKeySelectedItem(nil);
      FScrollTimerId := SetTimer(Handle, 1, GetScrollTime, nil);
    end;
  end
  else
  begin
    if (FScrollTimerId <> 0) and dxKillTimer(Handle, FScrollTimerId) then
    begin
      FLastMousePos := cxInvalidPoint;
      DrawScrollArea;
    end;
    inherited;
    if BarManager.IsHintActive and not cxPointIsEqual(ClientToScreen(APoint), FLastMousePos) then
      BarManager.HideHint;
  end;

  if Detachable then
    DetachCaptionSelected := MouseOnDetachCaption;
end;

procedure TdxBarSubMenuControl.DoDropFocus;
begin
  if FParentWnd <> 0 then
    Windows.SetFocus(FParentWnd)
  else
    inherited;
end;

procedure TdxBarSubMenuControl.DoNCPaint(DC: HDC; const ARect: TRect);
begin
  Painter.SubMenuControlDrawBorder(Self, DC, ARect);
end;

procedure TdxBarSubMenuControl.DoHideAll;
begin
  if ParentBar = nil then
  begin
    ChildBar := nil;
    Hide;
    ProcessPaintMessages;
  end
  else
    inherited;
end;

procedure TdxBarSubMenuControl.DoPaintItem(AControl: TdxBarItemControl; ACanvas: TcxCanvas; const AItemRect: TRect);
var
  ASeparatorIndex: Integer;
  ANonRecent: Boolean;
begin
  if IsRectEmpty(AItemRect) then
    Exit;
  ANonRecent := not Painter.IgnoreNonRecentColor and AControl.FNonRecent;
  if ANonRecent then
  begin
    PreparePalette(ACanvas.Handle);
    FBkBrush := FLightBrush;
  end
  else
    Painter.SubMenuControlPrepareBkBrush(Self, FBkBrush);

  if ViewInfo.IsAssociatedWithSeparator(AControl, ASeparatorIndex) then
    Painter.SubMenuControlDrawBeginGroup(Self, AControl, ACanvas,
      ViewInfo.SeparatorInfos[ASeparatorIndex].Bounds);

  Painter.SubMenuControlDrawItemFrame(Self, AControl, ACanvas.Handle, AItemRect, AControl.ItemLink.VisibleIndex);

  inherited DoPaintItem(AControl, ACanvas, AItemRect);

  if ANonRecent then
    UnpreparePalette(ACanvas.Handle);
end;

procedure TdxBarSubMenuControl.DoRepaintBar(ARecreateControls: Boolean);
var
  AWasVisible, AChangeXDirection, AChangeYDirection, NeedRepaint: Boolean;
  PrevTopIndex: Integer;
begin
  AWasVisible := IsWindowVisible(Handle);

  inherited DoRepaintBar(ARecreateControls);

  SetRecentItemCount;
  if (Left <> FOnShowLeft) or (Top <> FOnShowTop) then
  begin
    ShowWindow(Handle, SW_HIDE);
    Left := FOnShowLeft;
    Top := FOnShowTop;
    NeedRepaint := False;
  end
  else
    NeedRepaint := True;
  SetSizeAndCheckBounds(cxNullSize, AChangeXDirection, AChangeYDirection);
  CalcControlsPositions;

  if UpArrowExists and not DownArrowExists then
  begin
    PrevTopIndex := FTopIndex;
    repeat
      Dec(FTopIndex);
      CalcControlsPositions;
    until DownArrowExists or (FTopIndex = 0);
    if DownArrowExists then Inc(FTopIndex);
    NeedRepaint := NeedRepaint or (FTopIndex <> PrevTopIndex);
  end;

  if AWasVisible then Show;
  if NeedRepaint then
  begin
    CalcControlsPositions;
    Invalidate;
  end;
end;

procedure TdxBarSubMenuControl.DoSetIsActive(AValue: Boolean);
begin
  inherited;
  if not BarControlExists(Self) then Exit;
  if IsActive and
    BarManager.ShowRecentItemsFirst and not ShowFullMenus and
    BarManager.ShowFullMenusAfterDelay then
    SetExpandMenuTimer(dxBarSlowExpandMenuTime, True);
end;

procedure TdxBarSubMenuControl.DragOver(X, Y: Integer; var Accept: Boolean);
begin
  SendMessage(Handle, WM_MOUSEMOVE, 0, MakeLParam(X, Y));
  if FScrollTimerID > 0 then
    Accept := False;
end;

function TdxBarSubMenuControl.ChangeSizeByChildItemControl(
  out ASize: TSize): Boolean;
begin
  ASize := cxNullSize;
  Result := False;
end;

function TdxBarSubMenuControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarSubMenuControlAccessibilityHelper;
end;

function TdxBarSubMenuControl.GetBeginGroupSize: Integer;
begin
  Result := Painter.SubMenuControlBeginGroupSize;
end;

function TdxBarSubMenuControl.GetBehaviorOptions: TdxBarBehaviorOptions;
begin
  Result := inherited GetBehaviorOptions +
    [bboAllowSelectWindowItemsWithoutFocusing, bboExtendItemWhenAlignedToClient] -
    [bboMouseCantUnselectNavigationItem, bboSubMenuCaptureMouse];
end;

function TdxBarSubMenuControl.GetBottomItemControl: TdxBarItemControl;
begin
   Result := ItemLinks.VisibleItems[TopIndex + Max(MaxVisibleCount, 1) - 1].Control;
end;

function TdxBarSubMenuControl.GetDefaultItemHeight(AItem: TdxBarItemControl): Integer;
var
  AItemHeight: Integer;
begin
  AItemHeight := inherited GetDefaultItemHeight(AItem);
  case AItem.MenuItemSize of
    misNormal: Result := AItemHeight;
  else {misLarge}
      if ItemLinks.ItemShowDescriptions then
        Result := Trunc(AItemHeight * 2.5)
//        Result := Round(AItemHeight * 2.35)
      else
        Result := AItemHeight * 2;
  end;
end;

function TdxBarSubMenuControl.GetEditFont: TFont;
begin
  if ParentBar = nil then
    if (ItemLinks.Owner is TdxBarCustomPopupMenu) and
      TdxBarCustomPopupMenu(ItemLinks.Owner).UseOwnFont then
      Result := TdxBarCustomPopupMenu(ItemLinks.Owner).FEditFont
    else
      Result := inherited GetEditFont
  else
    Result := ParentBar.GetEditFont;
end;

function TdxBarSubMenuControl.GetIsContextMenu: Boolean;
begin
  Result :=
    (OwnerWidth = 0) and (OwnerHeight = 0) or
    (ParentBar is TdxBarSubMenuControl) and TdxBarSubMenuControl(ParentBar).IsContextMenu;
end;

function TdxBarSubMenuControl.GetIsCustomizing: Boolean;
begin
  if IsInternal or
    (GetItemByControl(FSubItem) is TdxBarSubItem) and TdxBarSubItem(GetItemByControl(FSubItem)).IsInternal then
    Result := False
  else
    Result := inherited GetIsCustomizing;
end;

function TdxBarSubMenuControl.GetIsMainMenu: Boolean;
begin
  Result := False;
end;

function TdxBarSubMenuControl.GetIsStatusBar: Boolean;
begin
  Result := False;
end;

function TdxBarSubMenuControl.GetIsShadowVisible: Boolean;
begin
  Result := inherited GetIsShadowVisible and not FShowAnimation;
end;

function TdxBarSubMenuControl.GetItemControlOffset(AItemLink: TdxBarItemLink): Integer;
begin
  Result := 0;
  if AItemLink.Control.FChangeRecentGroup and Painter.SubMenuControlIsOffsetRecentGroupNeeded then
    Inc(Result);
  if AItemLink.BeginGroup and
    not ((AItemLink.VisibleIndex = TopIndex) or UpArrowExists and (AItemLink.VisibleIndex = TopIndex + 1)) then
    Inc(Result, BeginGroupSize);
end;

function TdxBarSubMenuControl.GetItemRectEx(Item: TdxBarItemControl;
  IsBeginGroup: Boolean): TRect;
var
  AIndex: Integer;
begin
  Result := inherited GetItemRectEx(Item, IsBeginGroup);
  if Item <> nil then
  begin
    if Item.FChangeRecentGroup and
      Painter.SubMenuControlIsOffsetRecentGroupNeeded then
      Dec(Result.Top);
    if IsBeginGroup and Item.ItemLink.BeginGroup then
    begin
      AIndex := Item.ItemLink.VisibleIndex;
      if (AIndex > TopIndex) and not (UpArrowExists and (AIndex = TopIndex + 1)) then
        Dec(Result.Top, BeginGroupSize);
    end;
  end;
end;

function TdxBarSubMenuControl.GetItemsPaneSize: TSize;
var
  I: Integer;
  AItemLink: TdxBarItemLink;
begin
  Result := Size(0, 0);
  for I := TopIndex to ItemLinks.VisibleItemCount - 1 do
  begin
    AItemLink := ItemLinks.VisibleItems[I];
    Result.cx := Max(Result.cx, AItemLink.Control.Width);
    Result.cy := Result.cy + GetItemControlOffset(AItemLink) + AItemLink.Control.Height;
  end;
  if UseScrollButtons and UpArrowExists then
    Inc(Result.cy, Painter.SubMenuControlGetScrollBandSize(Self));
end;

function TdxBarSubMenuControl.GetPaintType: TdxBarPaintType;
begin
  Result := ptMenu;
end;

function TdxBarSubMenuControl.GetSelectableObject: TPersistent;
begin
  if (ParentBar <> nil) and (ParentBar.SelectedControl <> nil) then
    Result := ParentBar.SelectedControl.ItemLink
  else
    Result := ItemLinks.Owner;
end;

function TdxBarSubMenuControl.GetTextSize: Integer;
begin
  Result := Painter.SubMenuControlTextSize(Canvas);
end;

function TdxBarSubMenuControl.GetTopItemControl: TdxBarItemControl;
begin
  Result := ItemLinks.VisibleItems[TopIndex].Control;
end;

function TdxBarSubMenuControl.GetViewInfoClass: TCustomdxBarControlViewInfoClass;
begin
  Result := TdxBarSubMenuControlViewInfo;
end;

procedure TdxBarSubMenuControl.HideByEscape;
begin
  ClosedByEscape := True;
  Hide;
end;

function TdxBarSubMenuControl.HideOnClick: Boolean;
begin
  Result := True;
end;

function TdxBarSubMenuControl.IsInternal: Boolean;
begin
  Result := (ParentBar <> nil) and (ParentBar.IsInternal); //#DG
end;

function TdxBarSubMenuControl.IsMeaningParent(AWnd: HWND): Boolean;
begin
  Result := (FOwnerControl <> nil) and (FOwnerControl.HandleAllocated) and
    (AWnd = FOwnerControl.Handle); 
end;

function TdxBarSubMenuControl.IsPopup: Boolean;
begin
  Result := True;
end;

function TdxBarSubMenuControl.IsVerticalDirection: Boolean;
begin
  Result := True;
end;

function TdxBarSubMenuControl.MustFitInWorkAreaWidth: Boolean;
begin
  Result := False;
end;

function TdxBarSubMenuControl.NeedBufferedRepaint: Boolean;
begin
  Result := Painter.IsNativeBackground;
end;

function TdxBarSubMenuControl.NeedsSelectFirstItemOnDropDownByKey: Boolean;
begin
  Result := True;
end;

procedure TdxBarSubMenuControl.SetFont;
begin
  if ParentBar = nil then
    if ItemLinks.Owner is TdxBarCustomPopupMenu then
      Font := TdxBarCustomPopupMenu(ItemLinks.Owner).Font
    else
      Font := BarManager.Font
  else
    Font := ParentBar.Font;
end;

procedure TdxBarSubMenuControl.SetRecentItemCount;
begin
  with ItemLinks do
    if BarManager.ShowRecentItemsFirst and not ShowFullMenus then
      RecentItemCount := MostRecentItemCount
    else
      RecentItemCount := -1;
end;

procedure TdxBarSubMenuControl.SetAccelSelectedItem(AItemControl: TdxBarItemControl; ADuplicate: Boolean);
var
  AHidden: Boolean;
begin
  AHidden := AItemControl.ItemLink.VisibleIndex = -1;
  if (BarManager.GetPaintStyle <> bmsStandard) and
    AHidden and (ADuplicate or not AItemControl.IsDestroyOnClick) then
    MarkState := msPressed;
  inherited;
end;

procedure TdxBarSubMenuControl.SetControlVisible(AControl: TdxBarItemControl);

  function ScrollNeeded(AScrollDirection: TcxArrowDirection): Boolean;
  var
    AIndex: Integer;
  begin
    AIndex := AControl.ItemLink.VisibleIndex;
    case AScrollDirection of
      adUp:
        Result := (AIndex < TopVisibleItemIndex) or
          (not IsRectEmpty(AControl.ItemBounds) and (AControl.ItemBounds.Top < VisibleItemsRect.Top));
    else {adDown}
      Result := (AIndex > BottomVisibleItemIndex) or
        (TopIndex < ItemLinks.VisibleItemCount - 1) and
        (not IsRectEmpty(AControl.ItemBounds) and (AControl.ItemBounds.Bottom > VisibleItemsRect.Bottom));
    end;
  end;

  procedure Scroll(AScrollDirection: TcxArrowDirection);
  const
    AStep: array [TcxArrowDirection] of Integer = (-1, 1, 0, 0);
  begin
    repeat
      FTopIndex := Max(FTopIndex + AStep[AScrollDirection], 0);
      CalcControlsPositions;
    until not ScrollNeeded(AScrollDirection);
    InvalidateItemsRect;
  end;

begin
  if UpArrowExists and ScrollNeeded(adUp) then
    Scroll(adUp)
  else
    if DownArrowExists and ScrollNeeded(adDown) then
      Scroll(adDown);
end;

procedure TdxBarSubMenuControl.SetSelectedControl(Value: TdxBarItemControl);
begin
  if MarkState = msNone then
  begin
    KillExpandMenuTimer;
    if IsActive and BarManager.ShowRecentItemsFirst and
      not ShowFullMenus and BarManager.ShowFullMenusAfterDelay then
      SetExpandMenuTimer(dxBarSlowExpandMenuTime, False);
  end;
  if (Value <> nil) and not Value.FSelectedByMouse then
    SetControlVisible(Value);
  inherited SetSelectedControl(Value);
end;

procedure TdxBarSubMenuControl.SetSizeAndCheckBounds(
  const APredefinedSize: TSize;
  out AChangeXDirection, AChangeYDirection: Boolean);
var
  ASize: TSize;
  AWorkArea, ABounds: TRect;
  AReturnedChangeXDirection, AReturnedChangeYDirection: Boolean;
begin
  if (ParentBar = nil) or not ParentBar.CalcChildBarBounds(ABounds) then
  begin
    if cxSizeIsEqual(APredefinedSize, cxNullSize) then
      CalcBounds(ASize)
    else
      ASize := APredefinedSize;

    AWorkArea := GetWorkArea(Point(Left, Top));
    AChangeXDirection := False;
    AChangeYDirection := False;

    if Left + ASize.cx > AWorkArea.Right then
      if OwnerWidth = 0 then
        if (OwnerHeight = 0) and (Left - ASize.cx >= AWorkArea.Left) then
        begin
          Left := Left - ASize.cx;  // for popupmenu
          AChangeXDirection := True;
        end
        else
          Left := AWorkArea.Right - ASize.cx
      else
        if Left - OwnerWidth - AWorkArea.Left > AWorkArea.Right - Left then
        begin
          Left := Left - OwnerWidth - ASize.cx;
          AChangeXDirection := True;
        end;
    if Left < AWorkArea.Left then
      if OwnerWidth = 0 then
        Left := AWorkArea.Left
      else
        if (FXDirection = xdLeft) and
          (AWorkArea.Right - (Left + ASize.cx + OwnerWidth) > Left + ASize.cx - AWorkArea.Left) then
        begin
          Left := Left + ASize.cx + OwnerWidth;
          AChangeXDirection := True;
        end;
    if Left + ASize.cx > AWorkArea.Right then Left := AWorkArea.Right - ASize.cx;
    if Left < AWorkArea.Left then Left := AWorkArea.Left;
    if MustFitInWorkAreaWidth and (Left + ASize.cx > AWorkArea.Right) then
      ASize.cx := AWorkArea.Right - Left;

    if Top + ASize.cy > AWorkArea.Bottom then
      if OwnerHeight = 0 then
        if (OwnerWidth = 0) and (Top - ASize.cy >= AWorkArea.Top) then  // for popupmenu
        begin
          Top := Top - ASize.cy;
          AChangeYDirection := True;
        end
        else
          Top := AWorkArea.Bottom - ASize.cy
      else
        if Top - OwnerHeight - AWorkArea.Top > AWorkArea.Bottom - Top then
        begin
          Top := Top - OwnerHeight - ASize.cy;
          AChangeYDirection := True;
        end
        else
          ASize.cy := AWorkArea.Bottom - Top;
    if Top < AWorkArea.Top then
      if FYDirection = ydBottom then
        if AChangeYDirection and (OwnerHeight <> 0) then
        begin
          ASize.cy := ASize.cy - (AWorkArea.Top - Top);
          Top := AWorkArea.Top;
        end
        else
        begin
          Top := AWorkArea.Top;
          if Top + ASize.cy > AWorkArea.Bottom then
            ASize.cy := AWorkArea.Bottom - Top;
        end
      else
        if (OwnerHeight <> 0) and
          (AWorkArea.Bottom - (Top + ASize.cy + OwnerHeight) > Top + ASize.cy - AWorkArea.Top) then
        begin
          Top := Top + ASize.cy + OwnerHeight;
          if Top + ASize.cy > AWorkArea.Bottom then ASize.cy := AWorkArea.Bottom - Top;
          AChangeYDirection := True;
        end;
    ABounds := cxRectBounds(Left, Top, ASize.cx, ASize.cy);
  end;
  SetBounds(ABounds.Left, ABounds.Top, cxRectWidth(ABounds), cxRectHeight(ABounds));
  if not FLockChangeSizeByChildItemControl and
    ChangeSizeByChildItemControl(ASize) then
  begin
    FLockChangeSizeByChildItemControl := True;
    try
      SetSizeAndCheckBounds(ASize, AReturnedChangeXDirection,
        AReturnedChangeYDirection);
      AChangeXDirection := AChangeXDirection xor AReturnedChangeXDirection;
      AChangeYDirection := AChangeYDirection xor AReturnedChangeYDirection;
    finally
      FLockChangeSizeByChildItemControl := False;
    end;
  end;
end;

procedure TdxBarSubMenuControl.ShowPopup(AItem: TdxBarItemControl);
begin
  if not BarManager.IsCustomizing and (GetLinkByControl(AItem) <> nil) then
    BarDesignController.ShowCustomCustomizePopup(BarManager, InitCustomizationPopup, Painter, Self, GetLinkByControl(AItem))
  else
    if (ItemLinks.Count = 0) and (ParentBar <> nil) then
      DoShowPopup(ParentBar.SelectedControlAtDesign)
    else
      inherited;
end;

procedure TdxBarSubMenuControl.TerminateAnimation;
begin
  if FAnimationThread <> nil then
    TdxBarAnimationThread(FAnimationThread).TerminateAnimation;
end;

procedure TdxBarSubMenuControl.UpdateItem(AControl: TdxBarItemControl);

  function GetSeparatorBounds: TRect;
  var
    ASeparatorIndex: Integer;
  begin
    if ViewInfo.IsAssociatedWithSeparator(AControl, ASeparatorIndex) then
      Result := ViewInfo.SeparatorInfos[ASeparatorIndex].Bounds
    else
      Result := cxEmptyRect;
  end;

var
  ABitmapRect: TRect;
  ACanvas: TcxCanvas;
  ATempCanvas: TCanvas;
begin
  if CanControlPaint(AControl) then
  begin
    if NeedBufferedRepaint then
    begin
      ABitmapRect := cxRectUnion(AControl.ViewInfo.Bounds, GetSeparatorBounds);
      BackgroundTempBitmap.Width := cxRectWidth(ABitmapRect);
      BackgroundTempBitmap.Height := cxRectHeight(ABitmapRect);
      ATempCanvas := BackgroundTempBitmap.Canvas;
    end
    else
      ATempCanvas := Canvas.Canvas;

    ACanvas := TcxCanvas.Create(ATempCanvas);
    try
      if NeedBufferedRepaint then
        ACanvas.WindowOrg := ABitmapRect.TopLeft;
      PaintItem(ACanvas, AControl);
      if NeedBufferedRepaint then
      begin
        Canvas.SaveClipRegion;
        Canvas.ExcludeClipRect(AControl.GetNonBufferedRect);
        cxBitBlt(Canvas.Handle, ACanvas.Handle, ABitmapRect, ABitmapRect.TopLeft, SRCCOPY);
        Canvas.RestoreClipRegion;
      end;
    finally
      ACanvas.Free;
    end;
  end;
end;

procedure TdxBarSubMenuControl.InitCustomizationPopup(AItemLinks: TdxBarItemLinks);
begin
  if ParentBar <> nil then
    ParentBar.InitCustomizationPopup(AItemLinks);
end;

function TdxBarSubMenuControl.CanDetach: Boolean;
begin
  Result := Detachable and
    (FSubItem.Item.GetDetachingBar <> nil) and
    ((GetParentBarForBar(FSubItem.Parent) = nil) or
     (GetParentBarForBar(FSubItem.Parent) <> FSubItem.Item.GetDetachingBar.Control));
end;

function TdxBarSubMenuControl.Detachable: Boolean;
begin
  Result := (bboAllowDetach in BehaviorOptions) and (FSubItem <> nil) and FSubItem.Item.Detachable;
end;

function TdxBarSubMenuControl.DetachCaptionAreaSize: Integer;
begin
  Result := Painter.SubMenuControlDetachCaptionAreaSize(Self);
end;

function TdxBarSubMenuControl.DetachCaptionRect: TRect;
begin
  Result := NCRect;
  Painter.SubMenuControlOffsetDetachCaptionRect(Self, Result);
  with Result do
    Bottom := Top + DetachCaptionSize;
end;

function TdxBarSubMenuControl.MouseOnDetachCaption: Boolean;
begin
  Result := PtInRect(DetachCaptionRect, cxPointOffset(GetMouseCursorPos, -Left, -Top));
end;

procedure TdxBarSubMenuControl.DoDetachMenu;
var
  ADetachingBar: TdxBar;
  ASubItem: TdxBarSubItemControl;
  NonDetachableArea: TRect;
  Success, Started: Boolean;
  PrevP, P: TPoint;
  CaptureWnd: HWND;
  Msg: TMsg;
  ABarCaptionAriaSize: Integer;
begin
  FSubItem.Item.DoDetaching;
  if not CanDetach then Exit;
  ADetachingBar := FSubItem.Item.GetDetachingBar;
  ASubItem := FSubItem;

  NonDetachableArea := DetachCaptionRect;
  OffsetRect(NonDetachableArea, Left, Top);
  InflateRect(NonDetachableArea, DetachAreaDelta, DetachAreaDelta);

  Success := False;
  Started := False;
  PrevP := GetMouseCursorPos;
  ABarCaptionAriaSize := Painter.BarCaptionAreaSize;

  Include(BarDesignController.FDesignStates, dsKeyAlreadyProcessed);
  CaptureWnd := ParentBar.Handle;
  SetCapture(CaptureWnd);
  try
    while GetCapture = CaptureWnd do
    begin
      case Integer(GetMessage(Msg, 0, 0, 0)) of
        -1: Break;
        0: begin
            PostQuitMessage(Msg.wParam);
            Break;
          end;
      end;
      case Msg.message of
        WM_KEYDOWN, WM_KEYUP:
          if Msg.wParam = VK_ESCAPE then
          begin
            ASubItem.ControlActivate(True);
            Break;
          end;
        WM_MOUSEMOVE:
          begin
            P := SmallPointToPoint(TSmallPoint(Msg.lParam));
            Windows.ClientToScreen(Msg.hwnd, P);
            if (P.X <> PrevP.X) or (P.Y <> PrevP.Y) then
            begin
              if not Started and not PtInRect(NonDetachableArea, P) then
              begin
                ASubItem.ControlInactivate(True);
                if ADetachingBar.DockingStyle <> dsNone then
                begin
                  ADetachingBar.Visible := False;
                  ADetachingBar.DockingStyle := dsNone;
                end;
                if not ADetachingBar.Visible then
                begin
                  ADetachingBar.FloatLeft := P.X - 100;
                  ADetachingBar.FloatTop := P.Y - ABarCaptionAriaSize div 2;
                  ADetachingBar.Visible := True;
                end;
                Started := True;
              end;
              if Started then
                if PtInRect(NonDetachableArea, P) then
                begin
                  ADetachingBar.Visible := False;
                  ASubItem.ControlActivate(True);
                  Break;
                end
                else
                  with ADetachingBar.Control do
                    SetWindowPos(Handle,
                      0, P.X - Width div 2, P.Y - Painter.BarCaptionAreaSize div 2, 0, 0,
                      SWP_NOZORDER or SWP_NOSIZE or SWP_NOACTIVATE);
              PrevP := P;
            end;
          end;
        WM_LBUTTONUP:
          begin
            Success := True;
            Break;
          end;
      else
        TranslateMessage(Msg);
        DispatchMessage(Msg);
      end;
    end;
  finally
    if GetCapture = CaptureWnd then ReleaseCapture;
    if Started then
      if Success then
        ADetachingBar.BarManager.HideAll
      else
        ADetachingBar.Visible := False;
    Exclude(BarDesignController.FDesignStates, dsKeyAlreadyProcessed);
  end;
end;

function TdxBarSubMenuControl.MarkArrowSize: Integer;
begin
  Result := Painter.SubMenuControlMarkArrowSize(MarkSize);
end;

function TdxBarSubMenuControl.MarkExists: Boolean;
begin
  Result := BarManager.ShowRecentItemsFirst and
    (ItemLinks.VisibleItemCount < ItemLinks.CanVisibleItemCount);
end;

function TdxBarSubMenuControl.MarkRect: TRect;
var
  AOffset: Integer;
begin
  Result := ClientRect;
  AOffset := Painter.SubMenuControlClientBorderSize;
  with Result do
  begin
    Inc(Left, AOffset + BarSize);
    Dec(Right, AOffset);
    Dec(Bottom, AOffset);
    Top := Bottom - MarkSize;
  end;
end;

procedure TdxBarSubMenuControl.SetMarkState(Value: TdxBarMarkState);
begin
  if IsCustomizing or not BarManager.ShowRecentItemsFirst then Exit;
  if (Value = msSelected) and (SelectedControl is TdxBarWinControl) and
    TdxBarWinControl(SelectedControl).Focused then Value := msNone;
  if FMarkState <> Value then
  begin
    FMarkState := Value;
    if Value = msPressed then
      ExpandMenu
    else
      cxInvalidateRect(Handle, MarkRect, False);
    if BarManager.ShowFullMenusAfterDelay then
    begin
      KillExpandMenuTimer;
      if (FMarkState = msSelected) and MouseOnMark then
        SetExpandMenuTimer(FHintWindow.ShowHintTime, True);
    end
    else
      if FMarkState = msSelected then
        BarManager.ActivateHint(True, cxGetResourceString(@dxSBAR_EXPAND), Self)
      else
        BarManager.HideHint;
  end;
end;

function TdxBarSubMenuControl.DownArrowExists: Boolean;
begin
  Result := (ItemLinks.VisibleItemCount - TopIndex > MaxVisibleCount) or
    (TopIndex < ItemLinks.VisibleItemCount - 1) and
    (ItemLinks.VisibleItemCount > 0) and
    (ItemLinks.VisibleItems[ItemLinks.VisibleItemCount - 1].ItemRect.Bottom > ItemsRect.Bottom);
end;

function TdxBarSubMenuControl.GetScrollTime: Integer;
begin
  if UseScrollButtons then
    Result := dxBarSmoothScrollMenuTime
  else
    Result := dxBarScrollMenuTime;
end;

function TdxBarSubMenuControl.UpArrowExists: Boolean;
begin
  Result := TopIndex > 0;
end;

function TdxBarSubMenuControl.UseScrollButtons: Boolean;
begin
  Result := Painter.SubMenuControlUseScrollButtons;
end;

procedure TdxBarSubMenuControl.DoCalcSize(out ASize: TSize);
begin
  ASize := GetItemsPaneSize;
end;

procedure TdxBarSubMenuControl.DoCorrectSize(var ASize: TSize);

  procedure IncByOffset(const AOffset: TRect);
  begin
    Inc(ASize.cx, AOffset.Left + AOffset.Right);
    Inc(ASize.cy, AOffset.Top + AOffset.Bottom);
  end;

begin
  IncByOffset(GetClientOffset);
  IncByOffset(GetItemsRectOffset);
end;

procedure TdxBarSubMenuControl.DoShow;
const
  Shows: array[Boolean] of Integer = (0, SWP_SHOWWINDOW);
begin
  if (FMenuAnimations = maFade) and Assigned(AnimateWindowProc) and not IsWin9X then
  begin
    ProcessPaintMessages;
    AnimateWindowProc(Handle, 150, AW_BLEND);
  end
  else
  begin
    SetWindowPos(Handle, 0, 0, 0, 0, 0,
      SWP_NOZORDER or SWP_NOMOVE or SWP_NOSIZE or SWP_NOACTIVATE or
      Shows[not FShowAnimation]);
    ProcessPaintMessages;
  end;
end;

procedure TdxBarSubMenuControl.DrawBar;
begin
  if BarManager.Designing then
    FillGradientRect(Canvas.Handle, BarRect, 0, clBlue, False)
  else
    if GetSubMenuOwner <> nil then
      GetSubMenuOwner.DoPaintBar(Canvas.Canvas, BarRect)
end;

procedure TdxBarSubMenuControl.DrawContent;
begin
  CalcControlsPositions;

  if (ItemLinks.CanVisibleItemCount > 0) or (ViewInfo.ItemControlCount > 0) then
  begin
    DrawScrollArea;
    DrawItems;
  end
  else
    FillBackground(Canvas.Handle, FItemsRect, ToolbarBrush, clNone, True);
end;

procedure TdxBarSubMenuControl.DrawItems;
var
  I: Integer;
  AControl: TdxBarItemControl;
begin
  for I := 0 to ItemLinks.VisibleItemCount - 1 do
  begin
    AControl := ItemLinks.VisibleItems[I].Control;
    AControl.RealVisibleChanging(ViewInfo.IsItemControlVisible(AControl));
  end;

  for I := 0 to ViewInfo.ItemControlCount - 1 do
    ViewInfo.ItemControlViewInfos[I].Control.FLastInRow := False;

  inherited;

  if ViewInfo.ItemControlCount > 0 then
    ViewInfo.ItemControlViewInfos[ViewInfo.ItemControlCount - 1].Control.FLastInRow := True;
end;

procedure TdxBarSubMenuControl.DrawScrollArea;

  procedure DrawBottomAreaBackground;
  var
    R: TRect;
    AControl: TdxBarItemControl;
  begin
    AControl := BottomItemControl;
    R := GetItemRectEx(AControl, True);
    R.Top := R.Bottom;
    R.Bottom := ItemsRect.Bottom;
    FillBackground(Canvas.Handle, R, ToolbarItemsBrush, clNone, True);
  end;

begin
  Canvas.SaveClipRegion;
  try
    if UpArrowExists then
      Painter.SubMenuControlDrawScrollBand(Self, Canvas, adUp);

    if DownArrowExists then
      Painter.SubMenuControlDrawScrollBand(Self, Canvas, adDown);

    if MarkExists then
      Painter.SubMenuControlDrawMarkBand(Self, MarkRect, MarkDrawState = msSelected);

    if ItemLinks.VisibleItemCount > 0 then
      DrawBottomAreaBackground;
  finally
    Canvas.RestoreClipRegion;
  end;
end;

procedure TdxBarSubMenuControl.FillBackground(DC: HDC; const ARect: TRect;
  ABrush: HBRUSH; AColor: TColor; AIsClientArea: Boolean);
begin
  BarCanvas.BeginPaint(DC);
  try
    FillBackgroundEx(BarCanvas, ARect, ABrush, AColor, AIsClientArea);
  finally
    BarCanvas.EndPaint;
  end;
end;

procedure TdxBarSubMenuControl.DoFillBackgroundEx(ACanvas: TcxCanvas;
  const ARect: TRect; ABrush: HBRUSH; AColor: TColor; AIsClientArea: Boolean);
begin
  Painter.SubMenuControlDrawBackground(Self, ACanvas, ARect, ABrush, AColor);
end;

procedure TdxBarSubMenuControl.FillBackgroundEx(ACanvas: TcxCanvas;
  const ARect: TRect; ABrush: HBRUSH; AColor: TColor; AIsClientArea: Boolean);
begin
  ACanvas.SaveClipRegion;
  try
    ACanvas.SetClipRegion(TcxRegion.Create(ARect), roIntersect);
    DoFillBackgroundEx(ACanvas, ARect, ABrush, AColor, AIsClientArea);
  finally
    ACanvas.RestoreClipRegion;
  end;
end;

function TdxBarSubMenuControl.GetBackgroundBitmap: TBitmap;
begin
  Result := BarManager.Backgrounds.SubMenu;
  if (ItemLinks.Owner is TdxBarCustomPopupMenu) and
    not TdxBarCustomPopupMenu(ItemLinks.Owner).BackgroundBitmap.Empty then
    Result := TdxBarCustomPopupMenu(ItemLinks.Owner).BackgroundBitmap;
end;

function TdxBarSubMenuControl.GetClientOffset(
  AIncludeDetachCaption: Boolean = True): TRect;
var
  AOffset: Integer;
begin
  AOffset := Painter.SubMenuControlNCBorderSize;
  Result := Rect(AOffset, AOffset, AOffset, AOffset);
  if AIncludeDetachCaption and Detachable then
    Result.Top := Result.Top + DetachCaptionAreaSize;
end;

function TdxBarSubMenuControl.GetIndent1: Integer;
begin
  // WARNING: sync with TdxBarButtonControl.GetDefaultHeight
  Result := Painter.SubMenuControlGetControlContentIndent(Self);
end;

function TdxBarSubMenuControl.GetIndent2: Integer;
begin
  // WARNING: sync with TdxBarButtonControl.GetDefaultHeight
  if NeedShowGlyphAndCheckForItem then
  begin
    Result := TextSize;
    Painter.CorrectButtonControlDefaultHeight(Result);
  end
  else
    Result := 0;
end;

function TdxBarSubMenuControl.GetItemsRectOffset: TRect;
begin
  Result := Painter.SubMenuControlContentRectOffset(Self);
  Result.Left := Result.Left + BarSize;
end;

function TdxBarSubMenuControl.IsTransparent: Boolean;
begin
  Result := (ItemLinks.Owner is TdxBarCustomPopupMenu) and
    not TdxBarCustomPopupMenu(ItemLinks.Owner).BackgroundBitmap.Empty or
    not BarManager.Backgrounds.SubMenu.Empty or Painter.IsCompoundPainting;
end;

function TdxBarSubMenuControl.GetMouseTrackingBounds: TRect;
begin
  Result := inherited GetMouseTrackingBounds;
  ExtendRect(Result, GetClientOffset(False));
end;

procedure TdxBarSubMenuControl.Hide;
begin
  if not IsDestroying then
  begin
    Include(FState, bsHideAll);
//#DG    Destroying;
    DestroyWnd;
    Free;
  end;
end;

function TdxBarSubMenuControl.Kind: TdxBarKind;
begin
  Result := bkSubMenu;
end;

procedure TdxBarSubMenuControl.Show;
var
  AParentBar: TCustomdxBarControl;
  ARandom: Double;
begin
  ClosedByEscape := False;
  DoPopup;
  AParentBar := GetParentBarForBar(Self);
  if AParentBar <> nil then
    FMenuAnimations := AParentBar.BarManager.MenuAnimations
  else
    FMenuAnimations := BarManager.MenuAnimations;
  // prepare AMenuAnimations
  if FMenuAnimations = maRandom then
  begin
    ARandom := Random(100);
    if ARandom < 33 then
      FMenuAnimations := maUnfold
    else
      if ARandom < 66 then
        FMenuAnimations := maSlide
      else
        FMenuAnimations := maFade;
  end;
  FShowAnimation := FShowAnimation and not (FMenuAnimations in [maNone, maFade]) and
    not ((ItemLinks.CanVisibleItemCount = 0) or BarManager.IsCustomizing);
  DoShow;
end;

procedure TdxBarSubMenuControlViewInfo.Calculate;

  procedure CalcSeparatorInfo(AIndex: Integer);
  var
    AItemLink: TdxBarItemLink;
    AItemRect: TRect;
  begin
    AItemLink := BarControl.ItemLinks.VisibleItems[AIndex];
    AItemRect := AItemLink.Control.ViewInfo.Bounds;
    if not IsRectEmpty(AItemRect) and AItemLink.BeginGroup and
      (AIndex > BarControl.TopIndex) and not (BarControl.UpArrowExists and (AIndex = BarControl.TopIndex + 1)) then
        AddSeparatorInfo(BarControl.Painter.SubMenuControlBeginGroupRect(BarControl, AItemLink.Control, AItemRect), skHorizontal, AItemLink.Control);
  end;

var
  AItemLink: TdxBarItemLink;
  I: Integer;
  AVisibleItemRect: TRect;
begin
  inherited Calculate;
  if BarControl.ItemLinks.CanVisibleItemCount > 0 then
  begin
    for I := BarControl.TopVisibleItemIndex to BarControl.BottomVisibleItemIndex do
    begin
      AItemLink := BarControl.ItemLinks.VisibleItems[I];
      AddItemControlViewInfo(AItemLink.Control.ViewInfo);
      AVisibleItemRect := BarControl.GetItemRect(AItemLink.Control);
      AVisibleItemRect.Bottom := Min(BarControl.VisibleItemsRect.Bottom, AVisibleItemRect.Bottom);
      IdxBarItemControlViewInfo(AItemLink.Control.ViewInfo).SetBounds(AVisibleItemRect);
      CalcSeparatorInfo(I);
    end;
  end;
end;

function TdxBarSubMenuControlViewInfo.GetBarControl: TdxBarSubMenuControl;
begin
  Result := TdxBarSubMenuControl(FBarControl);
end;

{ TdxBarInternalSubMenuControl }

constructor TdxBarInternalSubMenuControl.Create(AOwner: TComponent);
begin
  inherited;
  FItemLinks := TdxBarSubMenuControlItemLinks.Create(BarManager, Self);
  FItemLinks.Internal := True;
  FItemLinks.FBarControl := Self;
end;

destructor TdxBarInternalSubMenuControl.Destroy;
begin
  FreeAndNil(FItemLinks);
  inherited Destroy;
end;

function TdxBarInternalSubMenuControl.GetIsCustomizing: Boolean;
begin
  Result := False;
end;

function TdxBarInternalSubMenuControl.IsInternal: Boolean;
begin
  Result := True;
end;

// IdxBarLinksOwner
function TdxBarInternalSubMenuControl.CanContainItem(AItem: TdxBarItem;
  out AErrorText: string): Boolean;
begin
  Result := True;
end;

function TdxBarInternalSubMenuControl.CreateBarControl: TCustomdxBarControl;
begin
  Result := Self;
end;

function TdxBarInternalSubMenuControl.GetInstance: TComponent;
begin
  Result := Self;
end;

function TdxBarInternalSubMenuControl.GetItemLinks: TdxBarItemLinks;
begin
  Result := FItemLinks;
end;

{ TdxBarCustomizingPopup }
// TODO: remove to designer

constructor TdxBarCustomizingPopup.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FShowAnimation := False;
end;

procedure TdxBarCustomizingPopup.DoShowCustomizingPopup;
begin
  BarManager.DoShowCustomizingPopup(FItemLinks)
end;

{ TdxBarItemActionLink }

procedure TdxBarItemActionLink.AssignClient(AClient: TObject);
begin
  FClient := AClient as TdxBarItem;
end;

function TdxBarItemActionLink.IsCaptionLinked: Boolean;
begin
  Result := inherited IsCaptionLinked and
    (FClient.Caption = (Action as TCustomAction).Caption);
end;

function TdxBarItemActionLink.IsCheckedLinked: Boolean;
begin
  Result := inherited IsCheckedLinked and (FClient is TdxBarButton) and
    (TdxBarButton(FClient).Down = (Action as TCustomAction).Checked);
end;

function TdxBarItemActionLink.IsEnabledLinked: Boolean;
begin
  Result := inherited IsEnabledLinked and
    (FClient.Enabled = (Action as TCustomAction).Enabled);
end;

function TdxBarItemActionLink.IsHelpContextLinked: Boolean;
begin
  Result := inherited IsHelpContextLinked and
    (FClient.HelpContext = (Action as TCustomAction).HelpContext);
end;

function TdxBarItemActionLink.IsHintLinked: Boolean;
begin
  Result := inherited IsHintLinked and
    ((FClient.Hint = (Action as TCustomAction).Hint) or FClient.IsHintFromCaption);
end;

function TdxBarItemActionLink.IsImageIndexLinked: Boolean;
begin
  Result := inherited IsImageIndexLinked and
    (FClient.ActionImageIndex = (Action as TCustomAction).ImageIndex);
end;

function TdxBarItemActionLink.IsShortCutLinked: Boolean;
begin
  Result := inherited IsShortCutLinked and
    (FClient.ShortCut = (Action as TCustomAction).ShortCut);
end;

function TdxBarItemActionLink.IsVisibleLinked: Boolean;

  function GetClientVisible: TdxBarItemVisible;
  begin
    if FClient.IsLoading then
      Result := FClient.FLoadedVisible
    else
      Result := FClient.Visible;
  end;

begin
  Result := inherited IsVisibleLinked and
    (GetClientVisible = VisibleTodxBarVisible((Action as TCustomAction).Visible));
end;

function TdxBarItemActionLink.IsOnExecuteLinked: Boolean;
begin
  Result := inherited IsOnExecuteLinked and
    (@FClient.OnClick = @Action.OnExecute);
end;

procedure TdxBarItemActionLink.SetCaption(const Value: string);
begin
  if IsCaptionLinked then FClient.Caption := Value;
end;

procedure TdxBarItemActionLink.SetChecked(Value: Boolean);
begin
  if IsCheckedLinked and (FClient is TdxBarButton) then
    TdxBarButton(FClient).Down := Value;
end;

procedure TdxBarItemActionLink.SetEnabled(Value: Boolean);
begin
  if IsEnabledLinked then FClient.Enabled := Value;
end;

procedure TdxBarItemActionLink.SetHelpContext(Value: THelpContext);
begin
  if IsHelpContextLinked then FClient.HelpContext := Value;
end;

procedure TdxBarItemActionLink.SetHint(const Value: string);
begin
  if IsHintLinked then FClient.Hint := Value;
end;

procedure TdxBarItemActionLink.SetImageIndex(Value: Integer);
begin
  if IsImageIndexLinked then FClient.ActionImageIndex := Value;
end;

procedure TdxBarItemActionLink.SetShortCut(Value: TShortCut);
begin
  if IsShortCutLinked then FClient.ShortCut := Value;
end;

procedure TdxBarItemActionLink.SetVisible(Value: Boolean);
begin
  if IsVisibleLinked then FClient.Visible := VisibleTodxBarVisible(Value);
end;

procedure TdxBarItemActionLink.SetOnExecute(Value: TNotifyEvent);
begin
  if IsOnExecuteLinked then FClient.OnClick := Value;
end;

{ TdxBarItemStylesData }

constructor TdxBarItemStylesData.Create(AStyleCount: Integer);
var
  I: Integer;
begin
  inherited Create(nil);
  FStyleCount := AStyleCount;
  SetLength(FStylesData, AStyleCount);
  for I := 0 to AStyleCount - 1 do
  begin
    FStylesData[I].AssignedValues := [];
    FStylesData[I].Style := nil;
  end;
end;

destructor TdxBarItemStylesData.Destroy;
var
  I: Integer;
begin
  FIsDestroying := True;
  for I := 0 to StyleCount - 1 do
    Styles[I] := nil;
  inherited Destroy;
end;

procedure TdxBarItemStylesData.StyleChanged(AStyle: TcxCustomStyle);
begin
  InternalStyleChanged(TcxStyle(AStyle));
end;

procedure TdxBarItemStylesData.StyleRemoved(AStyle: TcxCustomStyle);
begin
  InternalStyleRemoved(TcxStyle(AStyle));
end;

procedure TdxBarItemStylesData.DoChange(AChangeKind: TdxBarItemStyleChangeKind);
begin
  if IsChangeEventLocked then
  begin
    if (AChangeKind <> FChangeKind) and (FChangeKind in [sckNone, sckDrawing]) then
      FChangeKind := AChangeKind;
  end
  else
    if Assigned(FOnChange) then
      FOnChange(AChangeKind);
end;

function TdxBarItemStylesData.GetStyle(AIndex: Integer): TcxStyle;
begin
  Result := FStylesData[AIndex].Style;
end;

function TdxBarItemStylesData.GetStyleReferenceCount(AStyle: TcxStyle): Integer;
var
  I: Integer;
begin
  Result := 0;
  for I := 0 to StyleCount - 1 do
    if Styles[I] = AStyle then
      Inc(Result);
end;

procedure TdxBarItemStylesData.InternalSetStyle(AIndex: Integer; Value: TcxStyle);
begin
  FStylesData[AIndex].Style := Value;
end;

procedure TdxBarItemStylesData.InternalStyleChanged(AIndex: Integer);

  procedure GetFontData(AFont: TFont; out AFontData: TFontData);
  begin
    AFontData.Height := AFont.Height;
  {$IFDEF DELPHI9}
    AFontData.Orientation := AFont.Orientation;
  {$ENDIF}
    AFontData.Pitch := AFont.Pitch;
    AFontData.Style := AFont.Style;
    AFontData.Charset := AFont.Charset;
    AFontData.Name := dxStringToShortString(AFont.Name);
  end;

  function IsFontChanged(const APrevFontData: TFontData; AFont: TFont): Boolean;
  begin
    Result := (APrevFontData.Height <> AFont.Height){$IFDEF DELPHI9} or
      (APrevFontData.Orientation <> AFont.Orientation){$ENDIF} or
      (APrevFontData.Pitch <> AFont.Pitch) or
      (APrevFontData.Style <> AFont.Style) or
      (APrevFontData.Charset <> AFont.Charset) or
      (dxShortStringToString(APrevFontData.Name) <> AFont.Name);
  end;

var
  AAssignedValues1, AAssignedValues2: TcxStyleValues;
  AColorChanged, AFontChanged, ATextColorChanged: Boolean;
  AStyle: TcxStyle;
begin
  if IsDestroying then
    Exit;

  AStyle := Styles[AIndex];
  AAssignedValues1 := FStylesData[AIndex].AssignedValues;
  AAssignedValues2 := [];
  if AStyle <> nil then
    AAssignedValues2 := AStyle.AssignedValues;

  AColorChanged := not (not (svColor in AAssignedValues1) and not (svColor in AAssignedValues2));
  if AColorChanged and (svColor in AAssignedValues1) and (svColor in AAssignedValues2) then
    AColorChanged := ColorToRGB(FStylesData[AIndex].Color) <> ColorToRGB(AStyle.Color);

  AFontChanged := not (not (svFont in AAssignedValues1) and not (svFont in AAssignedValues2));
  if AFontChanged and (svFont in AAssignedValues1) and (svFont in AAssignedValues2) then
    AFontChanged := IsFontChanged(FStylesData[AIndex].FontData, AStyle.Font);

  ATextColorChanged := not (not (svTextColor in AAssignedValues1) and not (svTextColor in AAssignedValues2));
  if ATextColorChanged and (svTextColor in AAssignedValues1) and (svTextColor in AAssignedValues2) then
    ATextColorChanged := ColorToRGB(FStylesData[AIndex].TextColor) <> ColorToRGB(AStyle.TextColor);

  FStylesData[AIndex].AssignedValues := AAssignedValues2;
  if svColor in AAssignedValues2 then
    FStylesData[AIndex].Color := AStyle.Color;
  if svFont in AAssignedValues2 then
    GetFontData(AStyle.Font, FStylesData[AIndex].FontData);
  if svTextColor in AAssignedValues2 then
    FStylesData[AIndex].TextColor := AStyle.TextColor;

  if AFontChanged then
    DoChange(sckStructure)
  else
    if AColorChanged or ATextColorChanged then
      DoChange(sckDrawing);
end;

procedure TdxBarItemStylesData.InternalStyleChanged(AStyle: TcxStyle);
var
  I: Integer;
begin
  LockChangeEvent(True);
  try
    for I := 0 to StyleCount - 1 do
      if Styles[I] = AStyle then
        InternalStyleChanged(I);
  finally
    LockChangeEvent(False);
  end;
end;

procedure TdxBarItemStylesData.InternalStyleRemoved(AStyle: TcxStyle);
var
  I: Integer;
begin
  LockChangeEvent(True);
  try
    for I := 0 to StyleCount - 1 do
      if Styles[I] = AStyle then
        Styles[I] := nil;
  finally
    LockChangeEvent(False);
  end;
end;

function TdxBarItemStylesData.IsChangeEventLocked: Boolean;
begin
  Result := FChangeEventLockCount > 0;
end;

procedure TdxBarItemStylesData.LockChangeEvent(ALock: Boolean);
begin
  if ALock then
  begin
    if FChangeEventLockCount = 0 then
      FChangeKind := sckNone;
    Inc(FChangeEventLockCount);
  end
  else
  begin
    Dec(FChangeEventLockCount);
    if (FChangeEventLockCount = 0) and (FChangeKind <> sckNone) then
      DoChange(FChangeKind);
  end;
end;

procedure TdxBarItemStylesData.SetStyle(AIndex: Integer; Value: TcxStyle);
var
  AStyleValue: TcxStyle;
begin
  AStyleValue := Styles[AIndex];
  if Value <> AStyleValue then
  begin
    InternalSetStyle(AIndex, Value);
    if (AStyleValue <> nil) and (GetStyleReferenceCount(AStyleValue) = 0) then
      AStyleValue.RemoveListener(Self);
    if (Value <> nil) and (GetStyleReferenceCount(Value) = 1) then
      Value.AddListener(Self);
    InternalStyleChanged(AIndex);
  end;
end;

{ TdxBarCustomScreenTipBand }

constructor TdxBarCustomScreenTipBand.Create(ABandType: TdxBarScreenTipBandType);
begin
  inherited Create;
  FBandType := ABandType;
  FGlyph := TBitmap.Create;
  FGlyph.Transparent := True;
  FTextAlign := stbtaRight;
end;

destructor TdxBarCustomScreenTipBand.Destroy;
begin
  FreeAndNil(FGlyph);
  inherited Destroy;
end;

procedure TdxBarCustomScreenTipBand.Assign(Source: TPersistent);
begin
  if Source is TdxBarScreenTipBand then
  begin
    Text := TdxBarScreenTipBand(Source).Text;
    TextAlign := TdxBarScreenTipBand(Source).TextAlign;
    Glyph := TdxBarScreenTipBand(Source).Glyph;
  end
  else
    inherited;
end;

procedure TdxBarCustomScreenTipBand.Changed;
begin
  if Assigned(FOnChange) then
    FOnChange(Self);
end;

function TdxBarCustomScreenTipBand.IsVisible(const AHintText: string): Boolean;
begin
  Result := (Text <> '') or not Glyph.Empty;
  if not Result and (BandType = stbHeader) then
    Result := AHintText <> '';
end;

procedure TdxBarCustomScreenTipBand.SetGlyph(Value: TBitmap);
begin
  FGlyph.Assign(Value);
  Changed;
end;

procedure TdxBarCustomScreenTipBand.SetText(const Value: string);
begin
  if FText <> Value then
  begin
    FText := Value;
    Changed;
  end;
end;

procedure TdxBarCustomScreenTipBand.SetTextAlign(Value: TdxBarScreenTipBandTextAlign);
begin
  if FTextAlign <> Value then
  begin
    FTextAlign := Value;
    Changed;
  end;
end;

{ TdxBarScreenTipBand }

constructor TdxBarScreenTipBand.Create(AScreenTip: TdxBarScreenTip;
  ABandType: TdxBarScreenTipBandType);
begin
  inherited Create(ABandType);
  FScreenTip := AScreenTip;
end;

function TdxBarScreenTipBand.GetFont: TFont;
begin
  Result := ScreenTip.Collection.Repository.GetBandFont(BandType);
end;

{ TdxBarScreenTipFooterBand }

constructor TdxBarScreenTipFooterBand.Create(
  ARepository: TdxBarScreenTipRepository);
begin
  inherited Create(stbFooter);
  FRepository := ARepository;
end;

function TdxBarScreenTipFooterBand.GetFont: TFont;
begin
  Result := Repository.GetBandFont(BandType);
end;

{ TdxBarScreenTip }

constructor TdxBarScreenTip.Create(AOwner: TComponent);
var
  I: TdxBarScreenTipBandType;
begin
  inherited Create(AOwner);
  for I := Low(TdxBarScreenTipBandType) to High(TdxBarScreenTipBandType) do
    FBands[I] := TdxBarScreenTipBand.Create(Self, I); 
end;

destructor TdxBarScreenTip.Destroy;
var
  I: TdxBarScreenTipBandType;
begin
  for I := Low(TdxBarScreenTipBandType) to High(TdxBarScreenTipBandType) do
    FreeAndNil(FBands[I]);
  inherited Destroy;
end;

procedure TdxBarScreenTip.Assign(Source: TPersistent);
begin
  if Source is TdxBarScreenTip then
  begin
    Header := TdxBarScreenTip(Source).Header;
    Description := TdxBarScreenTip(Source).Description;
    Footer := TdxBarScreenTip(Source).Footer;
    UseHintAsHeader := TdxBarScreenTip(Source).UseHintAsHeader;
    UseStandardFooter := TdxBarScreenTip(Source).UseStandardFooter;
    Width := TdxBarScreenTip(Source).Width;
  end
  else
    inherited;
end;

function TdxBarScreenTip.GetCollectionFromParent(AParent: TComponent): TcxComponentCollection;
begin
  Result := (AParent as TdxBarScreenTipRepository).Items;
end;

function TdxBarScreenTip.GetDisplayName: string;
begin
  Result := Format('%s - ''%s''', [Name, Header.Text]);
end;

function TdxBarScreenTip.GetWidth: Integer;
begin
  Result := Width;
  if Result = 0 then
  begin
    if not Description.Glyph.Empty then
      Result := WidthToCurrentDpi(318)
    else
      Result := WidthToCurrentDpi(210);
  end;
end;

procedure TdxBarScreenTip.SetName(const Value: TComponentName);
var
  AChangeText: Boolean;
begin
  AChangeText := not (csLoading in ComponentState) and (Name = Header.Text) and
    ((Owner = nil) or not (Owner is TControl) or
    not (csLoading in TControl(Owner).ComponentState));
  inherited SetName(Value);
  if AChangeText then
    Header.Text := Value;
end;

function TdxBarScreenTip.GetBandForCalculation(
  Index: TdxBarScreenTipBandType): TdxBarCustomScreenTipBand;
begin
  if FUseStandardFooter and (Index = stbFooter) then
    Result := Collection.Repository.StandardFooter
  else
    Result := GetBand(Ord(Index));
end; 

function TdxBarScreenTip.GetCollection: TdxBarScreenTipCollection;
begin
  Result := TdxBarScreenTipCollection(inherited Collection);
end;

function TdxBarScreenTip.GetBand(Index: Integer): TdxBarScreenTipBand;
begin
  Result := FBands[TdxBarScreenTipBandType(Index)];
end;

procedure TdxBarScreenTip.SetBand(Index: Integer; Value: TdxBarScreenTipBand);
begin
  FBands[TdxBarScreenTipBandType(Index)].Assign(Value);
end;

{ TdxBarScreenTipCollection }

constructor TdxBarScreenTipCollection.Create(AParentComponent: TComponent; AItemClass: TcxComponentCollectionItemClass);
begin
  inherited Create(AParentComponent, AItemClass);
  FRepository := TdxBarScreenTipRepository(AParentComponent);
end;

function TdxBarScreenTipCollection.Add: TdxBarScreenTip;
begin
  Result := TdxBarScreenTip(inherited Add);
end;

procedure TdxBarScreenTipCollection.SetItemName(AItem: TcxComponentCollectionItem);
begin
  AItem.Name := CreateUniqueName(ParentComponent.Owner, ParentComponent, AItem,
    'TdxBar', '');
end;

procedure TdxBarScreenTipCollection.UpdateFonts;
begin
  //FHeaderFont.Assign(FBarManager.Font);
 // FDescriptionFont.Assign(FBarManager.Font);
 // FFooterFont.Assign(FBarManager.Font);
end;

function TdxBarScreenTipCollection.GetItem(Index: Integer): TdxBarScreenTip;
begin
  Result := TdxBarScreenTip(inherited Items[Index]);
end;

procedure TdxBarScreenTipCollection.SetItem(Index: Integer; Value: TdxBarScreenTip);
begin
  Items[Index].Assign(Value);
end;

{ TdxBarScreenTipRepository }

constructor TdxBarScreenTipRepository.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  CreateFonts;
  FStandardFooter := TdxBarScreenTipFooterBand.Create(Self);
  FItems := CreateScreenTips;
  FShowDescription := True;
end;

destructor TdxBarScreenTipRepository.Destroy;
var
  I: TdxBarScreenTipBandType;
begin
  FreeAndNil(FItems);
  FreeAndNil(FStandardFooter);
  for I := Low(TdxBarScreenTipBandType) to High(TdxBarScreenTipBandType) do
    FreeAndNil(FFonts[I]);
  FreeAndNil(FSystemFont);
  inherited Destroy;
end;

procedure TdxBarScreenTipRepository.Assign(Source: TPersistent);
begin
  if Source is TdxBarScreenTipRepository then
  begin
    Items := TdxBarScreenTipRepository(Source).Items;
    StandardFooter := TdxBarScreenTipRepository(Source).StandardFooter;
    DescriptionFont := TdxBarScreenTipRepository(Source).DescriptionFont;
    FooterFont := TdxBarScreenTipRepository(Source).FooterFont;
    HeaderFont := TdxBarScreenTipRepository(Source).HeaderFont;
    FAssignedFonts := TdxBarScreenTipRepository(Source).AssignedFonts;
    ShowDescription := TdxBarScreenTipRepository(Source).ShowDescription;
  end
  else
    inherited Assign(Source);
end;

function TdxBarScreenTipRepository.CreateScreenTips: TdxBarScreenTipCollection;
begin
  Result := TdxBarScreenTipCollection.Create(Self, TdxBarScreenTip);
end;

function TdxBarScreenTipRepository.GetBandFont(ABandType: TdxBarScreenTipBandType): TFont;
begin
  if ABandType in AssignedFonts then
  begin
    case ABandType of
      stbHeader: Result := HeaderFont;
      stbDescription: Result := DescriptionFont;
    else {stbFooter}
      Result := FooterFont;
    end;
  end
  else
    Result := GetSystemFont(ABandType);
end;

procedure TdxBarScreenTipRepository.GetChildren(Proc: TGetChildProc; Root: TComponent);
var
  I: Integer;
begin
  for I := 0 to Items.Count - 1 do
    if Items[I].Owner = Root then Proc(Items[I]);
end;

function TdxBarScreenTipRepository.GetFont(Index: Integer): TFont;
begin
  Result := FFonts[TdxBarScreenTipBandType(Index)];
end;

function TdxBarScreenTipRepository.GetSystemFont(ABandType: TdxBarScreenTipBandType): TFont;
begin
  Result := FSystemFont;
  Result.Assign(Screen.HintFont);
  Result.Color := dxBarScreenTipFontColor;
  if ABandType in [stbHeader, stbFooter] then
    Result.Style := Result.Style + [fsBold];
end;

function TdxBarScreenTipRepository.IsFontStored(Index: Integer): Boolean;
begin
  Result := TdxBarScreenTipBandType(Index) in AssignedFonts;
end;

procedure TdxBarScreenTipRepository.CreateFonts;

  function CreateFont(ABandType: TdxBarScreenTipBandType): TFont;
  begin
    Result := TFont.Create;
    Result.Assign(Screen.HintFont);
    Result.Color := dxBarScreenTipFontColor;
    if ABandType in [stbHeader, stbFooter] then
      Result.Style := Result.Style + [fsBold];
    Result.OnChange := FontChanged;
  end;

var
  I: TdxBarScreenTipBandType;
begin
  FSystemFont := TFont.Create;
  for I := Low(TdxBarScreenTipBandType) to High(TdxBarScreenTipBandType) do
    FFonts[I] := CreateFont(I);
end;

procedure TdxBarScreenTipRepository.FontChanged(Sender: TObject);
var
  I: TdxBarScreenTipBandType;
begin
  if csLoading in ComponentState then Exit;
  for I := Low(TdxBarScreenTipBandType) to High(TdxBarScreenTipBandType) do
    if FFonts[I] = Sender then
      Include(FAssignedFonts, I);
end;

procedure TdxBarScreenTipRepository.SetFont(Index: Integer; Value: TFont);
begin
  FFonts[TdxBarScreenTipBandType(Index)].Assign(Value);
end;

procedure TdxBarScreenTipRepository.SetItems(AValue: TdxBarScreenTipCollection);
begin
  FItems.Assign(AValue);
end;

procedure TdxBarScreenTipRepository.SetStandardFooter(Value: TdxBarScreenTipFooterBand);
begin
  FStandardFooter.Assign(Value);
end;

{ TdxBarCustomHintViewInfo }

constructor TdxBarCustomHintViewInfo.Create(ABarManager: TdxBarManager);
begin
  inherited Create;
  FBarManager := ABarManager;
end;

function TdxBarCustomHintViewInfo.IsScreenTip: Boolean;
begin
  Result := False;
end;

procedure TdxBarCustomHintViewInfo.SetWindowDrawParams(AWindow: TdxBarHintWindow);
begin
  AWindow.IsScreenTipWindow := IsScreenTip;
  AWindow.HandleNeeded;
end;

{ TdxBarHintViewInfo }

constructor TdxBarHintViewInfo.Create(ABarManager: TdxBarManager; const AHint, AShortCut: string; const ACursorPos: TPoint);
begin
  inherited Create(ABarManager);
  if AHint <> '' then
    FText := AHint + AShortCut;
  FPos := ACursorPos;
end;

procedure TdxBarHintViewInfo.Calculate(ACanvas: TCanvas);
var
  ASize: TSize;
begin
  if FText <> '' then
  begin
    ASize := CalculateMinSize(ACanvas);
    CorrectMinSize(ASize);
    BoundsRect := cxRectBounds(0, 0, ASize.cx, ASize.cy);
  end
  else
    BoundsRect := cxEmptyRect;
end;

procedure TdxBarHintViewInfo.Paint(ACanvas: TCanvas);
var
  R: TRect;
begin
  R := BoundsRect;
  DrawEdge(ACanvas.Handle, R, BDR_RAISEDOUTER, BF_RECT);
  DrawText(ACanvas);
end;

procedure TdxBarHintViewInfo.CorrectMinSize(var ASize: TSize);
begin
  Inc(ASize.cx, 2 * (1 + 2));
  Inc(ASize.cy, 2 * (1 + 2));
end;

function TdxBarHintViewInfo.GetTextRect: TRect;
begin
  Result := cxRectInflate(BoundsRect, -3, -3, -1, -1);
end;

procedure TdxBarHintViewInfo.DrawText(ACanvas: TCanvas);
var
  R: TRect;
begin
  R := GetTextRect;
  cxDrawText(ACanvas.Handle, FText, R, DT_LEFT or DT_NOCLIP or DT_NOPREFIX or DT_WORDBREAK);
end;

procedure TdxBarHintViewInfo.SetWindowDrawParams(AWindow: TdxBarHintWindow);
begin
  inherited SetWindowDrawParams(AWindow);
  AWindow.Caption := FText;
  SetWindowFont(AWindow);
  AWindow.Color := Application.HintColor;
end;

procedure TdxBarHintViewInfo.SetWindowFont(AWindow: TdxBarHintWindow);
var
  NonClientMetrics: TNonClientMetrics;
begin
  if (BarManager <> nil) and not BarManager.UseSystemFont then
    AWindow.Canvas.Font := BarManager.Font
  else
  begin
    NonClientMetrics.cbSize := SizeOf(NonClientMetrics);
    if SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, @NonClientMetrics, 0) then
      AWindow.Canvas.Font.Handle := CreateFontIndirect(NonClientMetrics.lfStatusFont)
    else
      AWindow.Canvas.Font.Size := 8;
  end;
{$IFNDEF DELPHI6}
  AWindow.Canvas.Font.Color := clInfoText;
{$ELSE}
  AWindow.Canvas.Font.Color := Screen.HintFont.Color;
{$ENDIF}
end;

function TdxBarHintViewInfo.CalculateMinSize(ACanvas: TCanvas): TSize;
var
  R: TRect;
  AWidth: Integer;
begin
  AWidth := cxRectWidth(GetWorkArea(GetMouseCursorPos));
  R := Rect(0, 0, AWidth, 0);
  cxDrawText(ACanvas.Handle, FText, R, DT_CALCRECT or DT_LEFT or DT_NOPREFIX or DT_WORDBREAK);
  Result := cxSize(R.Right, R.Bottom);
end;

{ TdxBarLikeHintScreenTipViewInfo }

procedure TdxBarLikeHintScreenTipViewInfo.CorrectMinSize(var ASize: TSize);
begin
  inherited CorrectMinSize(ASize);
  Inc(ASize.cx, 5);
  Inc(ASize.cy, 5);
end;

function TdxBarLikeHintScreenTipViewInfo.GetTextRect: TRect;
begin
  Result := cxRectInflate(BoundsRect, -5, -6, -6, -5);
end;

function TdxBarLikeHintScreenTipViewInfo.IsScreenTip: Boolean;
begin
  Result := True;
end;

constructor TdxBarLikeHintScreenTipViewInfo.Create(ABarManager: TdxBarManager; APainter: TdxBarPainter;
  const AHint, AShortCut: string; const ACursorPos: TPoint);
begin
  inherited Create(ABarManager, AHint, AShortCut, ACursorPos);
  FPainter := APainter;
end;

procedure TdxBarLikeHintScreenTipViewInfo.Paint(ACanvas: TCanvas);
begin
  BarCanvas.BeginPaint(ACanvas);
  try
    FPainter.ScreenTipDrawBackground(BarCanvas, BoundsRect);
    DrawText(ACanvas);
  finally
    BarCanvas.EndPaint;
  end;
end;

{ TdxBarScreenTipBandViewInfo }

constructor TdxBarScreenTipBandViewInfo.Create(ABand: TdxBarCustomScreenTipBand;
  const AHintText, AShortCut: string);
begin
  inherited Create;
  FBand := ABand;
  FHintText := AHintText;
  FShortCut := AShortCut;
end;

procedure TdxBarScreenTipBandViewInfo.Calculate(AWidth: Integer; var ATop: Integer; AHeight: Integer; APainter: TdxBarPainter);
begin
  FTop := ATop;
  FWidth := AWidth;
  if HasText then
  begin
    FTextBounds.Top := ATop + GetVertIndent(APainter);
    FTextBounds.Bottom := FTextBounds.Top + FTextSize.cy;
    FTextBounds.Left := GetHorzIndent;
    if Band.TextAlign = stbtaRight then
    begin
      if HasGlyph then
        Inc(FTextBounds.Left, GetAvailGlyphWidth + GetHorzIndent);
       FTextBounds.Right := AWidth - GetHorzIndent;
    end
    else
      FTextBounds.Right := FTextBounds.Left + FTextSize.cx;
  end;
  if HasGlyph then
  begin
    if FBand.BandType = stbDescription then
      FGlyphBounds.Top := ATop + GetVertIndent(APainter)
    else
      FGlyphBounds.Top := ATop + (AHeight - FGlyphSize.cy) div 2;
    FGlyphBounds.Bottom := FGlyphBounds.Top + FGlyphSize.cy;
    if Band.TextAlign = stbtaRight then
    begin
      FGlyphBounds.Left := GetHorzIndent + (GetAvailGlyphWidth - FGlyphSize.cx) div 2;
      FGlyphBounds.Right := FGlyphBounds.Left + FGlyphSize.cx;
    end
    else
    begin
      FGlyphBounds.Right := Width - (GetHorzIndent + (GetAvailGlyphWidth - FGlyphSize.cx) div 2);
      FGlyphBounds.Left :=  FGlyphBounds.Right - FGlyphSize.cx;
    end;
  end;
end;

function TdxBarScreenTipBandViewInfo.GetHeight(ACanvas: TCanvas; const AWidth: Integer; APainter: TdxBarPainter): Integer;

  function GetTextFlags: Integer;
  begin
    Result := DT_CALCRECT or DT_LEFT or DT_NOPREFIX;
    if Band.BandType = stbDescription then
      Result := Result or DT_WORDBREAK or DT_EDITCONTROL;
  end;

var
  AvailWidth: Integer;
  R: TRect;
begin
  Result := 0;
  if not (HasGlyph or HasText) then Exit;
  if HasGlyph then
  begin
    AvailWidth := GetAvailGlyphWidth;
    if Band.Glyph.Width < AvailWidth then
    begin
      Result := Band.Glyph.Height;
      FGlyphSize.cx := Band.Glyph.Width;
    end
    else
    begin
      Result := Round(AvailWidth * Band.Glyph.Height / Band.Glyph.Width);
      FGlyphSize.cx := AvailWidth;
    end;
    FGlyphSize.cy := Result;
  end
  else
    FGlyphSize := cxNullSize;
  if HasText then
  begin
    AvailWidth := AWidth;
    Dec(AvailWidth, 2 * GetHorzIndent);
    if HasGlyph then
      Dec(AvailWidth, GetAvailGlyphWidth + GetHorzIndent);
    ACanvas.Font.Assign(Band.Font);
    R := cxRectBounds(0, 0, AvailWidth, 0);
    cxDrawText(ACanvas.Handle, GetText, R, GetTextFlags);
    FTextSize.cx := R.Right;
    FTextSize.cy := R.Bottom;
  end
  else
    FTextSize  := cxNullSize;
  Result := Max(FGlyphSize.cy, FTextSize.cy);
  Inc(Result, 2 * GetVertIndent(APainter));
end;

function TdxBarScreenTipBandViewInfo.IsVisible: Boolean;
begin
  Result := HasText or HasGlyph;
end;

function TdxBarScreenTipBandViewInfo.GetAvailGlyphWidth: Integer;
begin
  if Band.BandType = stbDescription then
    Result := WidthToCurrentDpi(108) - GetHorzIndent
  else
    Result := WidthToCurrentDpi(16);
end;

function TdxBarScreenTipBandViewInfo.GetHorzIndent: Integer;
begin
  if Band.BandType = stbDescription then
    Result := WidthToCurrentDpi(14)
  else
    Result := WidthToCurrentDpi(6);
end;

function TdxBarScreenTipBandViewInfo.GetVertIndent(APainter: TdxBarPainter): Integer;
begin
  Result := 6;
  if FBand.BandType = stbFooter then
    Inc(Result, APainter.ScreenTipGetFooterLineSize);
  Result := WidthToCurrentDpi(Result);
end;

function TdxBarScreenTipBandViewInfo.GetText: string;
begin
  Result := Band.Text;
  if Band.BandType = stbHeader then
  begin
    if FHintText <> '' then
      Result := FHintText;
    Result := Result + FShortCut;
  end;
end;

function TdxBarScreenTipBandViewInfo.HasGlyph: Boolean;
begin
  Result := not FBand.FGlyph.Empty;
end;

function TdxBarScreenTipBandViewInfo.HasText: Boolean;
begin
  Result := GetText <> '';
end;

function TdxBarScreenTipBandViewInfo.HeightToCurrentDpi(AValue: Integer): Integer;
begin
  Result := Round(AValue * VertPixelsPerInch / 96);
end;

function TdxBarScreenTipBandViewInfo.WidthToCurrentDpi(AValue: Integer): Integer;
begin
  Result := Round(AValue * HorzPixelsPerInch / 96);
end;

function TdxBarScreenTipBandViewInfo.HorzPixelsPerInch: Integer;
begin
  Result := cxGetScreenPixelsPerInch(True);
end;

function TdxBarScreenTipBandViewInfo.VertPixelsPerInch: Integer;
begin
  Result := Screen.PixelsPerInch;
end;

procedure TdxBarScreenTipBandViewInfo.Paint(ACanvas: TcxCanvas; APainter: TdxBarPainter);

  procedure DrawTextField(const AText: string; ARect: TRect);
  begin
    cxDrawText(ACanvas.Handle, AText, ARect, DT_LEFT {or DT_NOCLIP} or DT_NOPREFIX or DT_WORDBREAK or DT_EDITCONTROL);
  end;

var
  AColor: TColor;
begin
  if HasText then
  begin
    ACanvas.Font.Assign(Band.Font);
    if Band.BandType = stbDescription then
      AColor := APainter.ScreenTipGetDescriptionTextColor
    else
      AColor := APainter.ScreenTipGetTitleTextColor;
    if AColor <> clDefault then
      ACanvas.Font.Color := AColor;
    DrawTextField(GetText, TextBounds);
  end;
  if HasGlyph then
    TransparentDraw(ACanvas.Handle, GlyphBounds, Band.Glyph);
  if Band.BandType = stbFooter then
    APainter.ScreenTipDrawFooterLine(ACanvas, cxRect(5, Top, Width - 5, Top + APainter.ScreenTipGetFooterLineSize));
end;

{ TdxBarScreenTipViewInfo }

constructor TdxBarScreenTipViewInfo.Create(AScreenTip: TdxBarScreenTip;
  APainter: TdxBarPainter; const AHintText: string; AShortCut: string = '');
begin
  inherited Create(BarManager);
  FScreenTip := AScreenTip;
  FPainter := APainter;
  if (FScreenTip <> nil) and FScreenTip.UseHintAsHeader then
    FHintText := AHintText;
  FShortCut := AShortCut;
end;

destructor TdxBarScreenTipViewInfo.Destroy;
begin
  DestroyBandViewInfos;
  inherited Destroy;
end;

procedure TdxBarScreenTipViewInfo.Calculate(ACanvas: TCanvas);
var
  AHeight, ATop, AMinHeaderWidth: Integer;
  ABand: TdxBarCustomScreenTipBand;
  ABandViewInfo: TdxBarScreenTipBandViewInfo;
  I: TdxBarScreenTipBandType;
begin
  ATop := 0;
  FWidth := FScreenTip.GetWidth;
  DestroyBandViewInfos;
  for I := Low(TdxBarScreenTipBandType) to High(TdxBarScreenTipBandType) do
  begin
    ABand := FScreenTip.GetBandForCalculation(I);
    if ABand.IsVisible(FHintText) then
    begin
      ABandViewInfo := CreateBandViewInfo(ABand);
      AHeight := ABandViewInfo.GetHeight(ACanvas, FWidth, FPainter);
      if I = stbHeader then
      begin
        AMinHeaderWidth := 0;
        if ABandViewInfo.HasText then
          Inc(AMinHeaderWidth, ABandViewInfo.GetHorzIndent * 2 + ABandViewInfo.TextSize.cx);
        if ABandViewInfo.HasGlyph then
          Inc(AMinHeaderWidth, ABandViewInfo.GetHorzIndent);
        FWidth := Max(FWidth, AMinHeaderWidth);
      end;
      ABandViewInfo.Calculate(FWidth, ATop, AHeight, FPainter);
      Inc(ATop, AHeight);
      SetLength(FBandViewInfos, Length(FBandViewInfos) + 1);
      FBandViewInfos[Length(FBandViewInfos) - 1] := ABandViewInfo;
    end;
  end;
  FBoundsRect := Rect(0, 0, FWidth, ATop);
end;

procedure TdxBarScreenTipViewInfo.Paint(ACanvas: TCanvas);
var
  I: Integer;
begin
  BarCanvas.BeginPaint(ACanvas);
  try
    FPainter.ScreenTipDrawBackground(BarCanvas, BoundsRect);
    for I := 0 to BandViewInfosCount - 1 do
      FBandViewInfos[I].Paint(BarCanvas, FPainter);
  finally
    BarCanvas.EndPaint;
  end;
end;

procedure TdxBarScreenTipViewInfo.DestroyBandViewInfos;
var
  I: Integer;
begin
  for I := 0 to BandViewInfosCount - 1 do
    FreeAndNil(FBandViewInfos[I]);
  FBandViewInfos := nil;
end;

function TdxBarScreenTipViewInfo.CreateBandViewInfo(
  ABand: TdxBarCustomScreenTipBand): TdxBarScreenTipBandViewInfo;
begin
  Result := TdxBarScreenTipBandViewInfo.Create(ABand, FHintText, FShortCut);
end;

function TdxBarScreenTipViewInfo.IsScreenTip: Boolean;
begin
  Result := True;
end;

function TdxBarScreenTipViewInfo.GetBandViewInfos(Index: Integer): TdxBarScreenTipBandViewInfo;
begin
  if Index < BandViewInfosCount then
    Result := FBandViewInfos[Index]
  else
    Result := nil;
end;

function TdxBarScreenTipViewInfo.GetBandViewInfosCount: Integer;
begin
  Result := Length(FBandViewInfos);
end;

{ TdxBarHintWindow }

constructor TdxBarHintWindow.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Color := clInfoBk;
  NeedEraseBackground := True;
  AnimationStyle := cxhaNone;
end;

destructor TdxBarHintWindow.Destroy;
begin
  FreeAndNil(FViewInfo);
  inherited Destroy;
end;

function TdxBarHintWindow.GetHintObject(ABarManager: TdxBarManager): IdxBarHintKeeper;
begin
  Supports(ABarManager.FHintObject, IdxBarHintKeeper, Result)
end;

function TdxBarHintWindow.GetHideHintTime: Integer;
begin
  if FIsScreenTipWindow then
    Result := 200000
  else
    Result := dxBarWaitForHideHintTime;
end;

function TdxBarHintWindow.GetShowHintTime: Integer;
begin
  if FIsScreenTipWindow then
    Result := 900
  else
    Result := dxBarWaitForShowHintTime;
end;

procedure TdxBarHintWindow.Paint;
begin
  ClientWidth := cxRectWidth(FViewInfo.BoundsRect);
  ClientHeight := cxRectHeight(FViewInfo.BoundsRect);
  FViewInfo.Paint(Canvas);
end;

procedure TdxBarHintWindow.RecreateWindow;
var
  AParams: TCreateParams;
  ATempClass: TWndClass;
  AClassRegistered: Boolean;
begin
  if not IsWinXP then
    RecreateWnd
  else
  begin
    DestroyHandle;
    CreateParams(AParams);
    with AParams do
    begin
      AClassRegistered := Windows.GetClassInfo(WindowClass.hInstance, WinClassName, ATempClass);
      if AClassRegistered then
        Windows.UnregisterClass(WinClassName, HInstance);
    end;
    HandleNeeded;
  end;
end;

function TdxBarHintWindow.ActivateHint(ABarManager: TdxBarManager; const AHintText, AShortCut: string): Boolean;
var
  P: TPoint;
  AHintKeeper: IdxBarHintKeeper;
  ABarControl: TCustomdxBarControl;
begin
  FreeAndNil(FViewInfo);
  ABarControl := nil;
  AHintKeeper := GetHintObject(ABarManager);
  if (AHintKeeper = nil) and (ABarManager.FHintObject is TCustomdxBarControl) then
    ABarControl := TCustomdxBarControl(ABarManager.FHintObject);

  if AHintKeeper <> nil then
    FViewInfo := AHintKeeper.CreateHintViewInfo(AHintText, AShortCut)
  else
    if ABarControl <> nil then
      FViewInfo := ABarControl.Painter.CreateHintViewInfo(ABarManager, AHintText, AShortCut, nil)
    else
      FViewInfo := TdxBarHintViewInfo.Create(ABarManager, AHintText, AShortCut, GetMouseCursorPos);
  FViewInfo.SetWindowDrawParams(Self);
  FViewInfo.Calculate(Canvas);

  Result := not IsRectEmpty(FViewInfo.BoundsRect);
  if Result then
  begin
    if AHintKeeper <> nil then
      P := AHintKeeper.GetHintPosition(GetMouseCursorPos, Height)
    else
      if ABarControl <> nil then
        P := ABarControl.Painter.GetBarItemContolHintPosition(ABarControl, ABarControl.MarkRect,
          GetMouseCursorPos, Height)
      else
        P := GetMouseCursorPos;
    dxSetZOrder(Handle);
    inherited ActivateHint(cxRectBounds(P.X, P.Y, cxRectWidth(FViewInfo.BoundsRect), cxRectHeight(FViewInfo.BoundsRect)), AHintText);
  end;
end;

procedure TdxBarHintWindow.SetIsScreenTipWindow(Value: Boolean);
begin
  if IsScreenTipWindow <> Value then
  begin
    Visible := False;
    FIsScreenTipWindow := Value;
    DoubleBuffered := Value;
    RecreateWindow;
  end;
end;

procedure TdxBarHintWindow.WMShowWindow(var Message: TWMShowWindow);
begin
  if not Message.Show then
    FreeAndNil(FViewInfo);
end;

procedure TdxBarHintWindow.WMSize(var Message: TWMSize);
begin
  inherited;
  if FIsScreenTipWindow then
    SetWindowRgn(Handle, CreateRoundRectRgn(0, 0, Message.Width + 1, Message.Height + 1, 2, 2), True);
end;

{ TdxBarItem }

constructor TdxBarItem.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FBarManager := GetBarManagerByComponent(AOwner);
  if (FBarManager = nil) and (dxBarManagerList.Count > 0) then
    FBarManager := TdxBarManager(dxBarManagerList[0]);
  if BarManager <> nil then BarManager.FItems.Add(Self);
  FLinks := TList.Create;
  FStylesData := TdxBarItemStylesData.Create(GetStyleCount);
  FStylesData.OnChange := InternalStyleChanged;
  FEnabled := True;

  FGlyph := dxBarCreateBitmap(OnGlyphChanged);
  FLargeGlyph := dxBarCreateBitmap(OnLargeGlyphChanged);
  FImageIndex := -1;
  FLargeImageIndex := -1;

  FGlyphLayout := glTop;
  FCanSelect := True;
  FCategory := -1;
  FLoadedVisible := ivAlways;
  FMergeKind := mkAdd;
  FVisible := ivAlways;
end;

destructor TdxBarItem.Destroy;
begin
//#DG  BarDesignController.DeselectIfSelected(Self);
  FreeAndNil(FStylesData);
  FreeAndNil(FLinks);
  FreeAndNil(FActionLink);
  FreeAndNil(FLargeGlyph);
  FreeAndNil(FGlyph);
  cxClearObjectLinks(Self);
  inherited Destroy;
end;

procedure TdxBarItem.Assign(Source: TPersistent);
var
  AItem: TdxBarItem;
begin
  if Source is TdxBarItem then
  begin
    AItem := TdxBarItem(Source);
    Action := AItem.Action;
    Align := AItem.Align;
    Caption := AItem.Caption;
    Category := AItem.Category;
    Description := AItem.Description;
    Enabled := AItem.Enabled;
    HelpContext := AItem.HelpContext;
    Hint := AItem.Hint;
    KeyTip := AItem.KeyTip;
    MergeKind := AItem.MergeKind;
    MergeOrder := AItem.MergeOrder;
    Style := AItem.Style;
    ScreenTip := AItem.ScreenTip;
    Visible := AItem.Visible;

    Data := AItem.Data;
    Glyph := AItem.Glyph;
    ImageIndex := AItem.ImageIndex;
    LargeGlyph := AItem.LargeGlyph;
    LargeImageIndex := AItem.LargeImageIndex;
    ShortCut := AItem.ShortCut;
    OnClick := AItem.OnClick;
  end
  else
    inherited;
end;

procedure TdxBarItem.BeforeDestruction;
begin
  inherited;
  CallNotify(FOnDestroy, Self);
  DestroyLinks;
end;

function TdxBarItem.GetAction: TBasicAction;
begin
  if FActionLink = nil then
    Result := nil
  else
    Result := FActionLink.Action;
end;

function TdxBarItem.GetActiveLink: TdxBarItemLink;
begin
  if GetItemByLink(BarManager.LastSelectedLinkAtDesign) = Self then
    Result := BarManager.LastSelectedLinkAtDesign
  else
    if LinkCount > 0 then
      Result := Links[0]
    else
      Result := nil;
end;

function TdxBarItem.GetActuallyVisible: Boolean;
begin
  Result :=
    ((Visible = ivAlways) and (InternalActuallyVisible or BarManager.IsCustomizing) or
     (Visible = ivInCustomizing) and BarManager.IsCustomizing);
end;

function TdxBarItem.GetCurItemLink: TdxBarItemLink;
var
  I: Integer;
begin
  Result := nil;
  for I := 0 to LinkCount - 1 do
    if (Links[I].Control <> nil) and Links[I].Control.IsActive then
    begin
      Result := Links[I];
      Break;
    end;
end;

function TdxBarItem.GetFlat: Boolean;
begin
  // TODO: obsolete
  Result := BarManager.Flat;
end;

function TdxBarItem.GetIndex: Integer;
begin
  Result := BarManager.FItems.IndexOf(Self);
end;

function TdxBarItem.GetIsDesigning: Boolean;
begin
  Result := csDesigning in ComponentState;
end;

function TdxBarItem.GetIsDestroying: Boolean;
begin
  Result := csDestroying in ComponentState;
end;

function TdxBarItem.GetIsLoading: Boolean;
begin
  Result := csLoading in ComponentState;
end;

function TdxBarItem.GetLinkCount: Integer;
begin
  Result := FLinks.Count;
end;

function TdxBarItem.GetLinks(Index: Integer): TdxBarItemLink;
begin
  Result := nil;
  if (Index > -1) and (Index < LinkCount) then
    Result := TdxBarItemLink(FLinks[Index]);
end;

function TdxBarItem.GetPainterClass: TdxBarPainterClass;
begin
  Result := BarManager.PainterClass;
end;

function TdxBarItem.GetVisibleForUser: Boolean;
var
  I: Integer;
begin
  Result := True;
  for I := 0 to LinkCount - 1 do
    if Links[I].CanVisibleIndex <> -1 then Exit;
  Result := False;
end;

procedure TdxBarItem.SetAction(Value: TBasicAction);
begin
  if Action <> Value then
    if Value = nil then
      FreeAndNil(FActionLink)
    else
    begin
      if csLoading in Value.ComponentState then
        BarManager.LockDesignerModified(True);
      try
        if FActionLink = nil then
          FActionLink := GetActionLinkClass.Create(Self);
        FActionLink.Action := Value;
        FActionLink.OnChange := DoActionChange;
        ActionChange(Value, csLoading in Value.ComponentState);
        Value.FreeNotification(Self);
      finally
        if csLoading in Value.ComponentState then
          BarManager.LockDesignerModified(False, False);
      end;
    end;
end;

procedure TdxBarItem.SetAlign(Value: TdxBarItemAlign);
begin
  if FAlign <> Value then
  begin
    FAlign := Value;
    UpdateEx;
  end;
end;

procedure TdxBarItem.SetCategory(Value: Integer);

  procedure Rank;
  var
    AList: TList;
    ANewIndex: Integer;
  begin
    AList := TList.Create;
    try
      BarManager.GetAllItemsByCategory(Value, AList);
      if AList.Count > 0 then
      begin
        if Index <= TdxBarItem(AList.Last).Index then
          ANewIndex := TdxBarItem(AList.Last).Index
        else
          ANewIndex := TdxBarItem(AList.Last).Index + 1;
        BarManager.MoveItem(Index, ANewIndex);
      end;
    finally
      AList.Free;
    end;
  end;

begin
  if IsLoading then
    FCategory := Value
  else
    if (BarManager <> nil) and TdxBarManagerCategories(BarManager.Categories).IsIndexValid(Value) then
    begin
      Rank;
      FCategory := Value;
      Changed(True);
    end;
end;

procedure TdxBarItem.SetDescription(Value: string);
begin
  if FDescription <> Value then
  begin
    FDescription := Value;
    Changed;
  end;
end;

procedure TdxBarItem.SetGlyph(Value: TBitmap);
begin
  FGlyph.Assign(Value);
end;

procedure TdxBarItem.SetGlyphLayout(Value: TdxBarGlyphLayout);
begin
  if FGlyphLayout <> Value then
  begin
    FGlyphLayout := Value;
    UpdateEx;
  end;
end;

procedure TdxBarItem.SetIndex(Value: Integer);
begin
  if Index <> Value then
    BarManager.ItemList.Move(Index, Value);
end;

procedure TdxBarItem.SetLargeGlyph(Value: TBitmap);
begin
  FLargeGlyph.Assign(Value);
end;

procedure TdxBarItem.SetMergeOrder(Value: Integer);
begin
  FMergeOrder := Max(Value, 0);
end;

procedure TdxBarItem.SetPaintStyle(Value: TdxBarPaintStyle);
begin
  if FPaintStyle <> Value then
  begin
    FPaintStyle := Value;
    if not IsLoading then PaintStyleChanged;
  end;
end;

procedure TdxBarItem.SetScreenTip(Value: TdxBarScreenTip);
begin
  if FScreenTip <> Value then
  begin
    if FScreenTip <> nil then
      FScreenTip.RemoveFreeNotification(Self);
    FScreenTip := Value;
    if FScreenTip <> nil then
      FScreenTip.FreeNotification(Self);
  end;
end;

procedure TdxBarItem.SetShowCaption(Value: Boolean);
begin
  if FShowCaption <> Value then
  begin
    FShowCaption := Value;
    if not IsLoading then UpdateEx;
  end;
end;

procedure TdxBarItem.SetShortCut(Value: TShortCut);
begin
  if FShortCut <> Value then
  begin
    FShortCut := Value;
    if not IsLoading then ShortCutChanged;
  end;
end;

procedure TdxBarItem.DestroyLinks;

  function HasItemLinkOnUnlockedBar: Boolean;
  var
    I: Integer;
  begin
    Result := False;
    for I := 0 to LinkCount - 1 do
      if (Links[I].BarControl is TdxBarControl) and
        not TdxBarControl(Links[I].BarControl).Bar.BarManager.IsUpdateLocked then
      begin
        Result := True;
        Break;
      end;
  end;

var
  Item: TdxBarItemLink;
  ALock: Boolean;
begin
  ALock := not BarManager.IsDestroying and HasItemLinkOnUnlockedBar;
  if ALock then
    BarManager.BeginUpdate;
  try
    while LinkCount > 0 do
    begin
      Item := TdxBarItemLink(FLinks.Last);
      FLinks.Remove(Item);
      Item.Free;
    end;
  finally
    if ALock then
      BarManager.EndUpdate;
  end;
end;

procedure TdxBarItem.DoActionChange(Sender: TObject);
begin
  if Sender = Action then ActionChange(Sender, False);
end;

function TdxBarItem.IsEnabledStored: Boolean;
begin
  Result := (FActionLink = nil) or not FActionLink.IsEnabledLinked;
end;

function TdxBarItem.IsHelpContextStored: Boolean;
begin
  Result := (ActionLink = nil) or not FActionLink.IsHelpContextLinked;
end;

function TdxBarItem.IsHintStored: Boolean;
begin
  Result := (FActionLink = nil) or not FActionLink.IsHintLinked;
end;

function TdxBarItem.IsImageIndexStored: Boolean;
begin
  Result := (FActionLink = nil) or not FActionLink.IsImageIndexLinked;
end;

function TdxBarItem.IsShortCutStored: Boolean;
begin
  Result := (FActionLink = nil) or not FActionLink.IsShortCutLinked;
end;

function TdxBarItem.IsVisibleStored: Boolean;
begin
  Result := (FActionLink = nil) or not FActionLink.IsVisibleLinked;
end;

function TdxBarItem.IsOnClickStored: Boolean;
begin
  Result := (FActionLink = nil) or not FActionLink.IsOnExecuteLinked;
end;

function TdxBarItem.GetHintFromCaption: string;
var
  P: Integer;
begin
  Result := Caption;
  P := Pos('&', Result);
  if P > 0 then Delete(Result, P, 1);
  P := Pos('...', Result);
  if P > 0 then Delete(Result, P, 3);
end;

procedure TdxBarItem.OnGlyphChanged(Sender: TObject);
begin
  GlyphChanged;
end;

procedure TdxBarItem.OnLargeGlyphChanged(Sender: TObject);
begin
  LargeGlyphChanged;
end;

procedure TdxBarItem.AssignTo(Dest: TPersistent);
begin
  if Dest is TCustomAction then
    with TCustomAction(Dest) do
    begin
      Caption := Self.Caption;
      if Self is TdxBarButton then
        Checked := TdxBarButton(Self).Down;
      Enabled := Self.Enabled;
      HelpContext := Self.HelpContext;
      Hint := Self.Hint;
      ImageIndex := Self.ImageIndex;
      ShortCut := Self.ShortCut;
      case Self.Visible of
        ivNever: Visible := False;
        ivAlways: Visible := True;
      end;
      OnExecute := Self.OnClick;
    end
  else inherited AssignTo(Dest);
end;

function TdxBarItem.GetEnabled: Boolean;
begin
  if not BarManager.Designing and BarManager.IsCustomizing and (Category > -1) then
    Result := True
  else
    Result := FEnabled;
end;

function TdxBarItem.GetWidth: Integer;
begin
  Result := FWidth;
end;

procedure TdxBarItem.Loaded;
begin
  inherited;
  if Action <> nil then ActionChange(Action, True);
  CallNotify(FOnCreate, Self);
end;

procedure TdxBarItem.Notification(AComponent: TComponent; Operation: TOperation);
begin
  inherited Notification(AComponent, Operation);
  if Operation = opRemove then
  begin
    if AComponent = Action then
      Action := nil;
    if AComponent = FScreenTip then
      FScreenTip := nil;
  end;
end;

procedure TdxBarItem.ReadState(Reader: TReader);
begin
  inherited ReadState(Reader);
  if Reader.Parent is TdxBarManager then
  begin
    FBarManager := TdxBarManager(Reader.Parent);
    BarManagerChanged;
  end;
end;

procedure TdxBarItem.SelectionChanged;
var
  I: Integer;
begin
  BarDesignController.SynchronizeLastSelectedItem;
  for I := 0 to LinkCount - 1 do
    RepaintItemControl(Links[I].Control);
end;

procedure TdxBarItem.SetName(const NewName: TComponentName);
begin
  inherited;
  if not ((csDesigning in ComponentState) and (NewName = '')) then
    Changed;
end;

procedure TdxBarItem.SetEnabled(Value: Boolean);
begin
  if FEnabled <> Value then
  begin
    FEnabled := Value;
    if not IsLoading then EnabledChanged;
  end;
end;

procedure TdxBarItem.SetVisible(Value: TdxBarItemVisible);
begin
  if IsLoading then
    FLoadedVisible := Value
  else
    if FVisible <> Value then
    begin
      FVisible := Value;
      if not IsDesigning then
        VisibleChanged;
    end;
end;

procedure TdxBarItem.SetWidth(Value: Integer);
begin
  if (FWidth <> Value) and (Value >= 0) then
  begin
    FWidth := Value;
    WidthChanged;
  end;
end;

procedure TdxBarItem.Invalidate;
begin
  Update;
end;

function TdxBarItem.IsComplex: Boolean;
begin
  Result := LinkCount > 1;
end;

function TdxBarItem.CanDelete(ADestruction: Boolean = False): Boolean;
begin
  Result := ((LinkCount > 0) and not ADestruction) or
    BarManager.CanDeleteComponent(Self);
end;

procedure TdxBarItem.ExecuteCustomizationAction(ABasicAction: TdxBarCustomizationAction);
begin
  if (LinkCount = 1) and (GetSelectableItem(Links[0]) <> BarDesignController.LastSelectedItem) then
    Links[0].ExecuteCustomizationAction(ABasicAction);
end;

procedure TdxBarItem.GetMasterObjects(AList: TdxObjectList);
begin
  AList.Add(BarManager.Owner);
end;

function TdxBarItem.GetNextSelectableItem: IdxBarSelectableItem;

  function GetNextLink(AItemLink: TdxBarItemLink): TdxBarItemLink;
  begin
    if AItemLink <> nil then
      Result := AItemLink.GetNext
    else
      Result := nil;
  end;

  function GetNextItem(AItemLink: TdxBarItemLink): TdxBarItem;
  var
    ANext: TdxBarItemLink;
  begin
    Result := nil;
    ANext := AItemLink;
    repeat
      ANext := GetNextLink(ANext);
      if GetItemByLink(ANext) <> Self then
      begin
        Result := GetItemByLink(ANext);
        Break;
      end;
    until (ANext = nil) or (ANext = AItemLink);
  end;

begin
  Result := GetNextItem(GetActiveLink);
end;

function TdxBarItem.GetSelectableParent: TPersistent;
begin
  if GetActiveLink <> nil then
    Result := GetActiveLink.GetSelectableParent
  else
    Result := nil;
end;

function TdxBarItem.GetSupportedActions: TdxBarCustomizationActions;
begin
  if BarManager.Designing then
  begin
    if BarDesignController.IsItemLinkCustomized then
      Result := [caReset, caDelete, caDeleteItem, caDeleteLink,
        caChangeCaption, caChangePosition, caChangeViewLevels,
        caChangeBeginGroup, caChangeVisible, caChangeRecentList, caChangeDistributed]
    else
      Result := [caDelete];
  end
  else
    Result := [caReset, caDeleteLink, caChangeCaption, caChangeBeginGroup];
end;

procedure TdxBarItem.DeleteSelection(var AReference: IdxBarSelectableItem; ADestruction: Boolean);
begin
  if ADestruction or (LinkCount = 0) then
    inherited
  else
    DestroyLinks;
end;

function TdxBarItem.SelectParentComponent: Boolean;
begin
  if GetActiveLink <> nil then
    Result := GetActiveLink.SelectParentComponent
  else
    Result := False;
end;

procedure TdxBarItem.ActionChange(Sender: TObject; CheckDefaults: Boolean);
begin
  if Action is TCustomAction then
    with TCustomAction(Sender) do
    begin
      FCheckDefaults := CheckDefaults;
      try
        if not CheckDefaults or (Self.Caption = '') then
          Self.Caption := Caption;
      finally
        FCheckDefaults := False;
      end;
      if (Self is TdxBarButton) and
        (not CheckDefaults or (TdxBarButton(Self).Down = False)) then
        TdxBarButton(Self).Down := Checked;
      if not CheckDefaults or (Self.Enabled = True) then
        Self.Enabled := Enabled;
      if not CheckDefaults or (Self.HelpContext = 0) then
        Self.HelpContext := HelpContext;
      if not CheckDefaults or (Self.Hint = '') then
        Self.Hint := Hint;
      if not CheckDefaults or (Self.ActionImageIndex = -1) then
        Self.ActionImageIndex := ImageIndex;
      if not CheckDefaults or (Self.ShortCut = scNone) then
        Self.ShortCut := ShortCut;
      if not CheckDefaults or (Self.Visible = ivAlways) then
        Self.Visible := VisibleTodxBarVisible(Visible);
      if not CheckDefaults or not Assigned(Self.OnClick) then
        Self.OnClick := OnExecute;
    end;
end;

procedure TdxBarItem.BarManagerChanged;
begin
end;

function TdxBarItem.CanBePlacedOn(AParentKind: TdxBarItemControlParentKind;
  AToolbar: TdxBar; out AErrorText: string): Boolean;
begin
  Result := True;
end;

function TdxBarItem.CanChangePaintStyle: Boolean;
begin
  Result := False;
end;

function TdxBarItem.CanClicked: Boolean;
begin
  Result := True;
end;

function TdxBarItem.CanMergeWith(AItem: TdxBarItem): Boolean;
begin
  Result := InternalCanMergeWith(AItem) and AItem.InternalCanMergeWith(Self);
end;

function TdxBarItem.CurImageIndexLinked: Boolean;
begin
  Result := IsImageIndexLinked(GetCurImages, ImageIndex)
end;

procedure TdxBarItem.DrawCustomizingImage(ACanvas: TCanvas;
  const ARect: TRect; AState: TOwnerDrawState);
begin
  dxBarCustomizingForm.PainterClass.DrawButtonOrSubItem(ACanvas, ARect, Self,
    GetTextOf(Caption), odSelected in AState);
end;

procedure TdxBarItem.DrawCustomizingImageContent(ACanvas: TCanvas;
  const ARect: TRect; ASelected: Boolean);
begin
  ACanvas.Brush.Color := clWindow;
  ACanvas.FillRect(ARect);
end;

function TdxBarItem.GetActionLinkClass: TdxBarItemActionLinkClass;
begin
  Result := TdxBarItemActionLink;
end;

function TdxBarItem.GetActionImageIndex: Integer;
begin
  Result := ImageIndex;
end;

procedure TdxBarItem.SetActionImageIndex(Value: Integer);
begin
  ImageIndex := Value;
end;

function TdxBarItem.GetControlClass(AIsVertical: Boolean): TdxBarItemControlClass;
var
  I: Integer;
begin
  Result := nil;
  for I := 0 to RegdxItemList.Count - 1 do
    if ClassInfo = RegdxItemList.Items[I].FItemClass.ClassInfo then
    begin
      Result := RegdxItemList.Items[I].FItemControlClass;
      Break;
    end;
end;

function TdxBarItem.GetHidden: Boolean;
begin
  Result := False;
end;

function TdxBarItem.GetItemLinks: TdxBarItemLinks;
begin
  Result := nil;
end;

class function TdxBarItem.GetStyleCount: Integer;
begin
  Result := 1;
end;

function TdxBarItem.GetStyleValue(AIndex: Integer): TcxStyle;
begin
  Result := StylesData.Styles[AIndex];
end;

function TdxBarItem.HasAccel(AItemLink: TdxBarItemLink): Boolean;
begin
  Result := Enabled;//True
end;

function TdxBarItem.HasControls: Boolean;
var
  I: Integer;
begin
  Result := True;
  for I := 0 to LinkCount - 1 do
    if Links[I].Control <> nil then Exit;
  Result := False;
end;

procedure TdxBarItem.HideControl(AControl: TdxBarItemControl);
begin
end;

function TdxBarItem.InternalActuallyVisible: Boolean;
begin
  Result := True;
end;

function TdxBarItem.InternalCanMergeWith(AItem: TdxBarItem): Boolean;
begin
  Result := False;
end;

function TdxBarItem.IsHintFromCaption: Boolean;
begin
  Result := GetShortHint(Hint) = GetHintFromCaption;
end;

function TdxBarItem.IsImageIndexLinked(AImageList: TCustomImageList; AImageIndex: Integer): Boolean;
begin
  Result := IsImageAssigned(AImageList, AImageIndex);
end;

function TdxBarItem.IsShortCut(AShortCut: TShortCut): Boolean;
begin
  Result := False;
  if Enabled then
  begin
    if CanClicked then
      Result := ShortCut = AShortCut;
    if Result then
      Click
    else
      if GetItemLinks <> nil then
        Result := GetItemLinks.IsShortCut(AShortCut);
  end;
end;

function TdxBarItem.IsStyleColorSupported: Boolean;
begin
  Result := False;
end;

function TdxBarItem.NeedToBeHidden: Boolean;
begin
  Result := False;
end;

procedure TdxBarItem.ObjectNotification(AOperation: TOperation; AObject: TObject);
begin
end;

procedure TdxBarItem.Recalculate;
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    if Links[I].Control <> nil then
      with Links[I].Control do
        PartsChanged;
end;

procedure TdxBarItem.SetImageIndex(Value: Integer);
begin
  if FImageIndex <> Value then
  begin
    FImageIndex := Value;
    GlyphChanged;
  end;
end;

procedure TdxBarItem.SetLargeImageIndex(Value: Integer);
begin
  if FLargeImageIndex <> Value then
  begin
    FLargeImageIndex := Value;
    LargeGlyphChanged;
  end;
end;

procedure TdxBarItem.SetStyleValue(AIndex: Integer; Value: TcxStyle);
begin
  StylesData.Styles[AIndex] := Value;
end;

procedure TdxBarItem.ShowDefaultEventHandler;
begin
  BarManager.ShowDefaultEventHandler(Self);
end;

procedure TdxBarItem.Update;
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    if Links[I].Control <> nil then
      with Links[I].Control do
        if not IsSelected or not Parent.IsActive then
          Repaint;
end;

procedure TdxBarItem.UpdateEx(AParentKinds: TdxBarKinds = dxBarKindAny);
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    if Links[I].Control <> nil then
      with Links[I].Control do
        if (Parent.Kind in AParentKinds) and (not IsSelected or not Parent.IsActive) then
          Parent.RepaintBar;
end;

function TdxBarItem.UseHotImages: Boolean;
begin
  Result := False;
end;

function TdxBarItem.UseLargeImages: Boolean;
begin
  Result := (ImageIndex > -1) or (LargeImageIndex > -1);
end;

procedure TdxBarItem.CaptionChanged;
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    if not (udCaption in Links[I].UserDefine) and (Links[I].Control <> nil) then
      Links[I].Control.CaptionChanged;
  Changed;
end;

procedure TdxBarItem.EnabledChanged;
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    if Links[I].Control <> nil then
    begin
      Links[I].Control.ResetCachedValues(False);
      Links[I].Control.EnabledChanged;
    end;
end;

procedure TdxBarItem.GlyphChanged;
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    if not (udGlyph in Links[I].UserDefine) and (Links[I].Control <> nil) then
      Links[I].Control.ResetCachedValues(True);
  for I := 0 to LinkCount - 1 do
    if not (udGlyph in Links[I].UserDefine) and (Links[I].Control <> nil) then
      Links[I].Control.GlyphChanged;
  Changed;
end;

procedure TdxBarItem.HotGlyphChanged;
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    if Links[I].Control <> nil then
    begin
      Links[I].Control.ResetCachedValues(False);
      Links[I].Control.HotGlyphChanged;
    end;
end;

procedure TdxBarItem.InternalStyleChanged(AChangeKind: TdxBarItemStyleChangeKind);

  procedure DoItemLinkChange(ALink: TdxBarItemLink);
  begin
    if AChangeKind = sckDrawing then
      ALink.Control.CalcDrawingConsts
    else
      ALink.RecreateControl;
  end;

  procedure DoItemChange;
  begin
    if AChangeKind = sckDrawing then
      Update
    else
      UpdateEx;
  end;

var
  I: Integer;
begin
  if not (csDestroying in ComponentState) then
  begin
    for I := 0 to LinkCount - 1 do
      if Links[I].Control <> nil then
         DoItemLinkChange(Links[I]);
    DoItemChange;
  end;
end;

procedure TdxBarItem.LargeGlyphChanged;
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    if Links[I].Control <> nil then
      Links[I].Control.ResetCachedValues(True);

  for I := 0 to LinkCount - 1 do
    if Links[I].Control <> nil then
      Links[I].Control.LargeGlyphChanged;
  Changed;
end;

procedure TdxBarItem.PaintStyleChanged;
begin
// do nothing
end;

procedure TdxBarItem.ShortCutChanged;
begin
  UpdateEx([bkSubMenu]);
  Changed;
end;

procedure TdxBarItem.VisibleChanged;
var
  I: Integer;
begin
  BarManager.BeginUpdate;
  try
    for I := 0 to LinkCount - 1 do
      Links[I].VisibleChanged;
  finally
    BarManager.EndUpdate;
    Changed;
  end;
end;

procedure TdxBarItem.WidthChanged;
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    if not (udWidth in Links[I].UserDefine) and (Links[I].Control <> nil) then
      Links[I].Control.WidthChanged;
end;

function TdxBarItem.GetCaption: string;
begin
  Result := FCaption;
end;

function TdxBarItem.IsCaptionStored: Boolean;
begin
  Result := (FActionLink = nil) or not FActionLink.IsCaptionLinked;
end;

procedure TdxBarItem.SetCaption(const Value: string);
var
  AMakeHint: Boolean;
  S: string;
begin
  if FCaption <> Value then
  begin
    AMakeHint := not FCheckDefaults and not (Self is TCustomdxBarSubItem) and
      ((Hint = '') or IsHintFromCaption);
    FCaption := Value;
    if not IsLoading then
    begin
      if AMakeHint then
      begin
        S := GetHintFromCaption;
        if Pos('|', Hint) = 0 then
          Hint := S
        else
          Hint := S + '|' + GetLongHint(Hint);
      end;
      CaptionChanged;
    end;
  end;
end;

procedure TdxBarItem.CheckLinks(ASource: TCustomIniFile; const ABaseSection: string);
begin
// do nothing
end;

procedure TdxBarItem.LoadFromIni(ASource: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind);
begin
// do nothing
end;

procedure TdxBarItem.LoadUsageData(ASource: TCustomIniFile; const ABaseSection: string);
begin
// do nothing
end;

procedure TdxBarItem.SaveToIni(ADestination: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind);
begin
// do nothing
end;

procedure TdxBarItem.GetTextViewParams(out AViewParams: TcxViewParams);
begin
  GetViewParams(Style, AViewParams);
end;

procedure TdxBarItem.GetViewParams(AStyle: TcxStyle; out AViewParams: TcxViewParams);
begin
  AViewParams := DefaultViewParams;
  if AStyle <> nil then
  begin
    if svBitmap in AStyle.AssignedValues then
      AViewParams.Bitmap := AStyle.Bitmap;
    if svColor in AStyle.AssignedValues then
      AViewParams.Color := AStyle.Color;
    if svFont in AStyle.AssignedValues then
      AViewParams.Font := AStyle.Font;
    if svTextColor in AStyle.AssignedValues then
      AViewParams.TextColor := AStyle.TextColor;
  end;
end;

class function TdxBarItem.GetNewCaption: string;
begin
  Result := dxSBAR_NEWITEMCAPTION;
end;

procedure TdxBarItem.Click;
begin
  if CanClicked then DirectClick;
end;

procedure TdxBarItem.DirectClick;
begin
  if Enabled then
    try
      BarManager.DoClickItem(Self);
      DoClick;
    except
      Application.HandleException(Self);
    end;
end;

procedure TdxBarItem.DoClick;
begin
  if Assigned(FOnClick) and ((Action = nil) or (@FOnClick <> @Action.OnExecute)) then
    FOnClick(Self)
  else
    if not IsDesigning and (FActionLink <> nil) then
      FActionLink.Execute{$IFDEF DELPHI6}(Self){$ENDIF};
end;

function TdxBarItem.GetAddMessageName: string;
begin
  Result := '';
end;

function TdxBarItem.GetCurImages: TCustomImageList;
begin
  Result := BarManager.Images;
end;

function TdxBarItem.GetParentComponent: TComponent;
begin
  if HasParent then Result := FBarManager
  else Result := nil;
end;

function TdxBarItem.HasParent: Boolean;
begin
  Result := FCategory > -1;
end;

procedure TdxBarItem.SetParentComponent(AParent: TComponent);
begin
  if not IsLoading then
  begin
    FBarManager := AParent as TdxBarManager;
    BarManagerChanged;
  end;
end;

{ TdxBarLabel }

constructor TdxBarLabel.Create(AOwner: TComponent);
begin
  inherited;
  FShowCaption := True;
end;

{ TdxBarSeparator }

function TdxBarSeparator.CanBePlacedOn(AParentKind: TdxBarItemControlParentKind;
  AToolbar: TdxBar; out AErrorText: string): Boolean;
begin
  Result := AParentKind = pkSubItemOrPopupMenu;
  if not Result then
    AErrorText := dxSBAR_CANTPLACESEPARATOR;
end;

class function TdxBarSeparator.GetNewCaption: string;
begin
  Result := dxSBAR_NEWSEPARATORCAPTION;
end;

function TdxBarSeparator.GetSupportedActions: TdxBarCustomizationActions;
begin
  Result := inherited GetSupportedActions - [caChangeRecentList];
end;

{ TdxBarWindowItem }

function TdxBarWindowItem.GetCurText: string;
begin
  if CurItemLink = nil then Result := Text
  else
    if CurItemLink.Control is TdxBarWinControl then
      Result := TdxBarWinControl(CurItemLink.Control).Text;
end;

function TdxBarWindowItem.GetFocusedItemLink: TdxBarItemLink;
begin
  if (CurItemLink <> nil) and (CurItemLink.Control is TdxBarWinControl) and
    TdxBarWinControl(CurItemLink.Control).Focused then
    Result := CurItemLink
  else
    Result := nil;
end;

procedure TdxBarWindowItem.SetCurText(Value: string);
begin
  if CurItemLink = nil then Text := Value
  else
    if CurItemLink.Control is TdxBarWinControl then
      TdxBarWinControl(CurItemLink.Control).Text := Value;
end;

function TdxBarWindowItem.CanClicked: Boolean;
begin
  Result := False;
end;

procedure TdxBarWindowItem.Change;
begin
  if not IsLoading and Assigned(FOnChange) then FOnChange(Self);
end;

procedure TdxBarWindowItem.CurChange;
begin
  CallNotify(FOnCurChange, Self);
end;

procedure TdxBarWindowItem.DoEnter;
begin
  CallNotify(FOnEnter, Self);
end;

procedure TdxBarWindowItem.DoExit;
begin
  CallNotify(FOnExit, Self);
end;

function TdxBarWindowItem.GetControlClass(AIsVertical: Boolean): TdxBarItemControlClass;
begin
  if AIsVertical then
    Result := TdxBarButtonControl
  else
    Result := inherited GetControlClass(AIsVertical);
end;

function TdxBarWindowItem.GetText: string;
begin
  Result := FText;
end;

procedure TdxBarWindowItem.KeyDown(var Key: Word; Shift: TShiftState);
begin
  if Assigned(FOnKeyDown) then FOnKeyDown(Self, Key, Shift);
end;

procedure TdxBarWindowItem.KeyPress(var Key: Char);
begin
  if Assigned(FOnKeyPress) then FOnKeyPress(Self, Key);
end;

procedure TdxBarWindowItem.KeyUp(var Key: Word; Shift: TShiftState);
begin
  if Assigned(FOnKeyUp) then FOnKeyUp(Self, Key, Shift);
end;

procedure TdxBarWindowItem.SetText(Value: string);
begin
  if FText <> Value then
  begin
    FText := Value;
{    if (CurItemLink <> nil) and (CurItemLink.Control is TdxBarWinControl) then
      TdxBarWinControl(CurItemLink.Control).Text := FText;}
    Update;
    Change;
    Update;
  end;
end;

procedure TdxBarWindowItem.SetFocus(ACheckBarControlVisibility: Boolean = False);
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    with Links[I] do
      if Control is TdxBarWinControl and
        (not ACheckBarControlVisibility or IsControlVisible(BarControl)) then
      begin
        (BarControl as TdxBarControl).BarGetFocus(Control);
        Control.Click(False);
        Break;
      end;
end;

{ TdxBarButton }

var
  ABarActivationDropDownControl: TdxBarButtonLikeControl;
  ABarActivationDropDownControlTimerID: UINT;

  ABarDeActivationDropDownControl: TdxBarButtonLikeControl;
  ABarDeActivationDropDownControlTimerID: UINT;

constructor TdxBarButton.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FCloseSubMenuOnClick := True;
  FDropDownEnabled := True;
  FUnclickAfterDoing := True;
end;

function  TdxBarButton.GetButtonStyle: TdxBarButtonStyle;
begin
  if FInternalStates = [] then
    Result := bsDefault
  else
    if FInternalStates = [bstChecked] then
      Result := bsChecked
    else
      if FInternalStates = [bstDropDown] then
        Result := bsDropDown
      else
        Result := bsCheckedDropDown;
end;

procedure TdxBarButton.SetAllowAllUp(Value: Boolean);
var
  I: Integer;
begin
  if FAllowAllUp <> Value then
  begin
    FAllowAllUp := Value;
    if GroupIndex <> 0 then
      with BarManager do
        for I := 0 to ItemCount - 1 do
          if (Items[I] is TdxBarButton) and (TdxBarButton(Items[I]).GroupIndex = GroupIndex) then
            TdxBarButton(Items[I]).FAllowAllUp := FAllowAllUp;
  end;
end;

procedure TdxBarButton.SetButtonStyle(Value: TdxBarButtonStyle);
begin
  if ButtonStyle <> Value then
  begin
    case Value of
      bsDefault: FInternalStates := [];
      bsChecked: FInternalStates := [bstChecked];
      bsDropDown: FInternalStates := [bstDropDown];
      bsCheckedDropDown: FInternalStates := [bstChecked, bstDropDown];
    end;
    Down := False;
    if not IsLoading then
      UpdateEx;
    Changed;
  end;
end;

procedure TdxBarButton.SetDown;
var
  DownedButton: TdxBarButton;

  function GetDownedButton: TdxBarButton;
  var
    I: Integer;
  begin
    with BarManager do
      for I := 0 to ItemCount - 1 do
        if Items[I] is TdxBarButton then
        begin
          Result := TdxBarButton(Items[I]);
          with Result do
            if (bstChecked in FInternalStates) and (GroupIndex = Self.GroupIndex) and Down then
              Exit;
        end;
    Result := nil;
  end;

  function AnotherDownedButtonExists: Boolean;
  var
    I: Integer;
  begin
    Result := True;
    with BarManager do
      for I := 0 to ItemCount - 1 do
        if (Items[I] <> Self) and (Items[I] is TdxBarButton) then
          with TdxBarButton(Items[I]) do
            if (bstChecked in FInternalStates) and (GroupIndex = Self.GroupIndex) and Down then
              Exit;
    Result := False;
  end;

begin
  if (FDown <> Value) and ((bstChecked in FInternalStates) or not Value) then
  begin
    if not IsLoading and (bstChecked in FInternalStates) and (GroupIndex <> 0) then
      if Value then
        DownedButton := GetDownedButton
      else
        if not AllowAllUp and not AnotherDownedButtonExists then
          Exit
        else
          DownedButton := nil
    else
      DownedButton := nil;
    FDown := Value;
    if not IsLoading then
    begin
      Update;
      if DownedButton <> nil then DownedButton.Down := False;
    end;
  end;
end;

procedure TdxBarButton.SetDropDownEnabled(Value: Boolean);
begin
  if FDropDownEnabled <> Value then
  begin
    FDropDownEnabled := Value;
    if not IsLoading then Update;
  end;
end;

procedure TdxBarButton.SetDropDownMenu(Value: TdxBarPopupMenu);
begin
  if Value <> FDropDownMenu then
  begin
    if (Value <> nil) and Value.GetItemLinks.IsReferencedBy(Self) then
      raise EdxException.Create(cxGetResourceString(@dxSBAR_RECURSIVEMENUS))
    else
    begin
      FDropDownMenu := Value;
      if Value <> nil then Value.FreeNotification(Self);
    end;
  end;
end;

procedure TdxBarButton.SetGroupIndex(Value: Integer);
begin
  if FGroupIndex <> Value then
  begin
    if not (bstChecked in FInternalStates) then
      Value := 0;
    FGroupIndex := Value;
    Down := False;
  end;
end;

procedure TdxBarButton.SetLowered(Value: Boolean);
begin
  if FLowered <> Value then
  begin
    FLowered := Value;
    if not IsLoading then UpdateEx;
  end;
end;

function TdxBarButton.IsDownStored: Boolean;
begin
  Result := (FActionLink = nil) or not FActionLink.IsCheckedLinked;
end;

function TdxBarButton.CanChangePaintStyle: Boolean;
begin
  Result := True;
end;

procedure TdxBarButton.DoDropDown(AControl: TdxBarButtonControl; X, Y: Integer;
  ByMouse: Boolean);
var
  R: TRect;
begin
  if FDropDownMenu <> nil then
  begin
    if AControl.HasShadow then
      R := AControl.Parent.GetItemScreenRect(AControl)
    else
      R := Rect(0, 0, 0, 0);
    FDropDownMenu.FOwnerItemControl := AControl;
    try
      with AControl, ItemBounds do
        if (Parent.Kind = bkSubMenu) or Parent.IsRealVertical then
          FDropDownMenu.PopupEx(X, Y, Right - Left, 0, FShowAnimation, @R, False, AControl.Parent)
        else
          FDropDownMenu.PopupEx(X, Y, 0, Bottom - Top, FShowAnimation, @R, False, AControl.Parent);
    finally
      FDropDownMenu.FOwnerItemControl := nil;
    end;
    with FDropDownMenu.SubMenuControl do
    begin
      FDropDownButton := AControl;
      if not ByMouse and (ItemLinks.First <> nil) then
        SetKeySelectedItem(ItemLinks.First.Control);
    end;
    if AControl.Parent.Kind = bkSubMenu then
      AControl.Parent.ChildBar := FDropDownMenu.SubMenuControl;
  end;
end;

function TdxBarButton.HasAccel(AItemLink: TdxBarItemLink): Boolean;
begin
  Result := inherited HasAccel(AItemLink) and
    (not (AItemLink.Owner.Owner is TdxBar) or
     (AItemLink.PaintStyle in [psCaption, psCaptionGlyph]) or
     (AItemLink.Control <> nil) and
       (TdxBarButtonControl(AItemLink.Control).PaintStyle in [psCaption, psCaptionGlyph]));
end;

procedure TdxBarButton.Notification(AComponent: TComponent; Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = DropDownMenu) then
    DropDownMenu := nil;
end;

procedure TdxBarButton.PaintStyleChanged;
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    if not (udPaintStyle in Links[I].UserDefine) and (Links[I].Control <> nil) then
      TdxBarButtonControl(Links[I].Control).PaintStyleChanged;
end;

// IdxBarLinksOwner
function TdxBarButton.CanContainItem(AItem: TdxBarItem;
  out AErrorText: string): Boolean;
begin
  Result := (DropDownMenu <> nil) and DropDownMenu.CanContainItem(AItem, AErrorText);
end;

function TdxBarButton.CreateBarControl: TCustomdxBarControl;
begin
  if DropDownMenu <> nil then
    Result := DropDownMenu.CreateBarControl
  else
    Result := nil;
end;

function TdxBarButton.GetItemLinks: TdxBarItemLinks;
begin
  if DropDownMenu <> nil then
    Result := DropDownMenu.ItemLinks
  else
    Result := inherited GetItemLinks;
end;

function TdxBarButton.GetSupportedActions: TdxBarCustomizationActions;
begin
  Result := inherited GetSupportedActions + [caChangeButtonPaintStyle];
  if BarManager.Designing then
    Include(Result, caChangeButtonGroup);
end;

class function TdxBarButton.GetNewCaption: string;
begin
  Result := dxSBAR_NEWBUTTONCAPTION;
end;

procedure TdxBarButton.Click;
begin
  if Enabled and (bstChecked in FInternalStates) then
    Down := not Down;
  inherited Click;
end;

{ TcxCustomBarEdit }

constructor TdxCustomBarEdit.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FWidth := 100;
end;

procedure TdxCustomBarEdit.ReadState(Reader: TReader);
begin
  if not FGlyphLoaded then // the same as in cxButtonEdit
  begin
    Glyph := nil;
    FGlyphLoaded := True;
  end;
  inherited;
end;

procedure TdxCustomBarEdit.DrawCustomizingImage(ACanvas: TCanvas;
  const ARect: TRect; AState: TOwnerDrawState);
begin
  dxBarCustomizingForm.PainterClass.DrawEdit(ACanvas, ARect, Self,
    odSelected in AState, False);
end;

procedure TdxCustomBarEdit.GetEditViewParams(out AViewParams: TcxViewParams);
begin
  GetViewParams(StyleEdit, AViewParams);
end;

class function TdxCustomBarEdit.GetStyleCount: Integer;
begin
  Result := 2;
end;

function TdxCustomBarEdit.HasAccel(AItemLink: TdxBarItemLink): Boolean;
begin
  Result := inherited HasAccel(AItemLink) and
    (FShowCaption or not (AItemLink.Owner.Owner is TdxBar));
end;

procedure TdxCustomBarEdit.SetWidth(Value: Integer);
begin
  if (FWidth <> Value) and (Value > 0) then
  begin
    FWidth := Value;
    if not IsLoading then
      WidthChanged;
  end;
end;

{ TdxBarEdit }

procedure TdxBarEdit.SetMaxLength(Value: Integer);
begin
  FMaxLength := Value;
  if FMaxLength <= 0 then FMaxLength := 0;
end;

procedure TdxBarEdit.DrawInterior(ABarEditControl: TdxBarEditControl; ACanvas: TCanvas;
  R: TRect; ItemLink: TdxBarItemLink);
begin
  ABarEditControl.Painter.EditDrawInterior(ABarEditControl, Self, ACanvas, R, ItemLink);
end;

{ TCustomdxBarCombo }

function TCustomdxBarCombo.GetDroppedDown: Boolean;
begin
  if CurItemLink = nil then
    Result := False
  else
    if CurItemLink.Control is TCustomdxBarComboControl then
      Result := TCustomdxBarComboControl(CurItemLink.Control).DroppedDown
    else
      Result := False;
end;

function TCustomdxBarCombo.GetShowEditor: Boolean;
begin
  Result := not EmptyWindow;
end;

procedure TCustomdxBarCombo.SetDroppedDown(Value: Boolean);
begin
  if (CurItemLink <> nil) and (CurItemLink.Control is TCustomdxBarComboControl) then
    TCustomdxBarComboControl(CurItemLink.Control).DroppedDown := Value;
end;

procedure TCustomdxBarCombo.SetShowEditor(Value: Boolean);
begin
  EmptyWindow := not Value;
end;

procedure TCustomdxBarCombo.AfterDropDown;
begin
end;

procedure TCustomdxBarCombo.CheckDropDownPoint(var X, Y: Integer);
var
  R: TRect;
  AControlWidth, AControlHeight, ADropDownWindowWidth, ADropDownWindowHeight: Integer;
begin
  if DropDownWindow > 0 then
  begin
    AControlWidth := cxRectWidth(CurItemLink.ItemRect);
    AControlHeight := cxRectHeight(CurItemLink.ItemRect);
    R := cxGetWindowRect(DropDownWindow);
    ADropDownWindowWidth := cxRectWidth(R);
    ADropDownWindowHeight := cxRectHeight(R);
    R := GetWorkArea(Point(X, Y));
    if (CurItemLink.BarControl is TdxBarSubMenuControl) or CurItemLink.BarControl.IsRealVertical then
    begin
      if (X + ADropDownWindowWidth > R.Right) and (X - AControlWidth - R.Left > R.Right - X) then
        Dec(X, AControlWidth + ADropDownWindowWidth);
      Y := Min(Y, R.Bottom - ADropDownWindowHeight);
    end
    else
    begin
      X := Min(X, R.Right - ADropDownWindowWidth);
      if (Y + ADropDownWindowHeight > R.Bottom) and (Y - AControlHeight - R.Top > R.Bottom - Y) then
        Dec(Y, AControlHeight + ADropDownWindowHeight);
    end;
    X := Max(X, R.Left);
    Y := Max(Y, R.Top);
  end;
end;

function TCustomdxBarCombo.CheckKeyForDropDownWindow(Key: Word;
  Shift: TShiftState): Boolean;
begin
  Result := (Key <> VK_ESCAPE) and (Key <> VK_RETURN) and (Key <> VK_TAB);
  if Assigned(FOnCheckKeyForDropDownWindow) then
    FOnCheckKeyForDropDownWindow(Self, Key, Shift, Result);
end;

procedure TCustomdxBarCombo.CloseUp;
begin
  if DropDownWindow <> 0 then
    ShowWindow(DropDownWindow, SW_HIDE);
  CallNotify(FOnCloseUp, Self);
end;

procedure TCustomdxBarCombo.DrawCustomizingImage(ACanvas: TCanvas;
  const ARect: TRect; AState: TOwnerDrawState);
begin
  dxBarCustomizingForm.PainterClass.DrawEdit(ACanvas, ARect, Self,
    odSelected in AState, True);
end;

procedure TCustomdxBarCombo.DropDown(X, Y: Integer);
begin
  CallNotify(FOnDropDown, Self);
  if DropDownWindow <> 0 then
  begin
    InitDropDownWindow;
    CheckDropDownPoint(X, Y);
    SetWindowPos(DropDownWindow, 0, X, Y, 0, 0, SWP_NOZORDER or SWP_NOSIZE or SWP_NOACTIVATE);
    dxSetZOrder(DropDownWindow, HWND_TOP, False, SWP_FRAMECHANGED or SWP_SHOWWINDOW);
    AfterDropDown;
  end;
end;

function TCustomdxBarCombo.GetDropDownWindow: HWND;
begin
  Result := 0;
  if Assigned(FOnGetDropDownWindow) then
    FOnGetDropDownWindow(Self, Result);
end;

procedure TCustomdxBarCombo.InitDropDownWindow;
begin
end;

procedure TCustomdxBarCombo.InternalInitDropDownWindow(ADropDownWindow: TWinControl);
var
  ABkColor, ATextColor: COLORREF;
  AEditControl: TdxBarCustomEditControl;
begin
  AEditControl := TdxBarCustomEditControl(CurItemLink.Control);
  TControlAccess(ADropDownWindow).Font := AEditControl.EditFont;
  AEditControl.Painter.EditGetColors(AEditControl, ATextColor, ABkColor);
  TControlAccess(ADropDownWindow).Color := ABkColor;
  TControlAccess(ADropDownWindow).Font.Color := ATextColor;
end;

{ TdxBarCustomCombo }
                              
constructor TdxBarCustomCombo.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FDropDownCount := 8;
  FItemIndex := -1;
  FItems := TStringList.Create;
  TStringList(FItems).OnChange := ItemsChanged;
  FListBox := TdxBarDropDownListBox.Create(Self);
  with TdxBarDropDownListBox(FListBox) do
  begin
    FCombo := Self;
    OnDrawItem := ListBoxDrawItem;
    OnMeasureItem := ListBoxMeasureItem;
  end;
end;

destructor TdxBarCustomCombo.Destroy;
begin
  FreeAndNil(FListBox);
  FreeAndNil(FItems);
  inherited Destroy;
end;

function TdxBarCustomCombo.GetCurItemIndex: Integer;
begin
  if FocusedItemLink = nil then
    Result := ItemIndex
  else
    Result := TdxBarComboControl(FocusedItemLink.Control).LocalItemIndex;
end;

function TdxBarCustomCombo.GetItemsHeight(Index: Integer): Integer;
begin
  MeasureItem(Index, Result);
end;

procedure TdxBarCustomCombo.SetCurItemIndex(Value: Integer);
begin
  if FocusedItemLink = nil then
    ItemIndex := Value
  else
    TdxBarComboControl(FocusedItemLink.Control).LocalItemIndex := Value;
end;

procedure TdxBarCustomCombo.SetItemIndex(Value: Integer);
var
  AText: string;
begin
  if FItemIndex <> Value then
  begin
    FItemIndex := Value;
    if (FItemIndex < 0) or (FItemIndex > Items.Count - 1) then
      FItemIndex := -1;
    if FItemIndex = -1 then
      AText := ''
    else
      AText := Items[FItemIndex];
    if Text = AText then
    begin
      Update;
      Change;
      Update;
    end
    else
      Text := AText;
  end;
end;

procedure TdxBarCustomCombo.SetItems(Value: TStrings);
begin
  FItems.Assign(Value);
end;

procedure TdxBarCustomCombo.SetSorted(Value: Boolean);
begin
  if FSorted <> Value then
  begin
    FSorted := Value;
    TStringList(FItems).Sorted := FSorted;
    FItemIndex := FItems.IndexOf(Text);
  end;
end;

procedure TdxBarCustomCombo.CheckLocalPos;
var
  AText: string;
  AItemIndex: Integer;
begin
  if (CurItemLink = nil) or not (CurItemLink.Control is TdxBarComboControl) then
    Exit;
  AText := TdxBarComboControl(CurItemLink.Control).Text;
  AItemIndex := TdxBarComboControl(CurItemLink.Control).LocalItemIndex;
  if not ((0 <= AItemIndex) and (AItemIndex < Items.Count) and (Items[AItemIndex] = AText)) then
    AItemIndex := GetNearestItemIndex(AText);
  TdxBarComboControl(CurItemLink.Control).FLocalItemIndex := AItemIndex;
  if DroppedDown then
    if (AItemIndex > -1) and (AnsiCompareText(AText, Items[AItemIndex]) = 0) then
      ListBox.ItemIndex := AItemIndex
    else
    begin
      ListBox.ItemIndex := -1;
      ListBox.TopIndex := AItemIndex;
    end;
end;

procedure TdxBarCustomCombo.ItemsChanged(Sender: TObject);
begin
  if ItemIndex > Items.Count - 1 then
    ItemIndex := -1
  else
    Update;
end;

procedure TdxBarCustomCombo.ListBoxDrawItem(Control: TWinControl; Index: Integer;
  Rect: TRect; State: TOwnerDrawState);
begin
  DrawItem(CurItemLink.Control.Painter, Index, Rect, State);
end;

procedure TdxBarCustomCombo.ListBoxMeasureItem(Control: TWinControl; Index: Integer;
  var Height: Integer);
begin
  MeasureItem(Index, Height);
end;

procedure TdxBarCustomCombo.AfterDropDown;
begin
  with TdxBarDropDownListBox(ListBox) do
    if LeftButtonPressed then
    begin
      SetCapture(Handle);
      WaitForCapture := True;
    end
    else
      WaitForCapture := False;
end;

function TdxBarCustomCombo.CheckKeyForDropDownWindow(Key: Word;
  Shift: TShiftState): Boolean;
begin
  Result := (Shift = []) and
    ((Key = VK_UP) or (Key = VK_DOWN) or (Key = VK_PRIOR) or (Key = VK_NEXT));
end;

procedure TdxBarCustomCombo.CloseUp;
begin
  inherited;
  FListBox.Parent := nil;
end;

procedure TdxBarCustomCombo.CurChange;
begin
  inherited;
  CheckLocalPos;
end;

procedure TdxBarCustomCombo.DrawInterior(ABarEditControl: TdxBarEditControl; ACanvas: TCanvas;
  R: TRect; ItemLink: TdxBarItemLink);
var
  AIndex: Integer;
begin
  FCanvas := ACanvas;
  try
    if FocusedItemLink = ItemLink then
      AIndex := TdxBarComboControl(CurItemLink.Control).LocalItemIndex
    else
      AIndex := ItemIndex;
    FInteriorIsDrawing := True;
    try
      DrawItem(ABarEditControl.Painter, AIndex, R, []);
    finally
      FInteriorIsDrawing := False;
    end;
  finally
    FCanvas := nil;
  end;  
end;

procedure TdxBarCustomCombo.DrawItem(APainter: TdxBarPainter;
  AIndex: Integer; ARect: TRect; AState: TOwnerDrawState);
begin
  if Assigned(FOnDrawItem) then
    FOnDrawItem(Self, AIndex, ARect, AState)
  else
    APainter.CustomComboDrawItem(Self, Canvas, AIndex, ARect, AState, FInteriorIsDrawing);
  if odFocused in AState then DrawFocusRect(Canvas.Handle, ARect); // for hiding focus rect
end;

procedure TdxBarCustomCombo.DropDown(X, Y: Integer);
begin
  FListBox.Parent := CurItemLink.Control.Parent;  //BarManager.MainForm;
  inherited;
  CheckLocalPos;
end;

function TdxBarCustomCombo.GetCanvas: TCanvas;
begin
  if FCanvas <> nil then
    Result := FCanvas
  else
    Result := FListBox.Canvas;
end;

function TdxBarCustomCombo.GetDropDownWidth: Integer;
var
  I, ItemWidth: Integer;
begin
  Result := DropDownWidth;
  if Result <= 0 then
  begin
    if CurItemLink <> nil then
      Result := cxRectWidth(TdxBarComboControl(CurItemLink.Control).GetEditRect) - 2 * 2;
    if DropDownCount < Items.Count then
      Dec(Result, GetSystemMetrics(SM_CXVSCROLL));
    for I := 0 to Items.Count - 1 do
    begin
      MeasureItemWidth(I, ItemWidth);
      if ItemWidth > Result then Result := ItemWidth;
    end;
  end;
  Inc(Result, 2 + 2);
  if DropDownCount < Items.Count then
    Inc(Result, GetSystemMetrics(SM_CXVSCROLL));
end;

function TdxBarCustomCombo.GetDropDownWindow: HWND;
begin
  Result := inherited GetDropDownWindow;
  if Result = 0 then Result := FListBox.Handle;
end;

function TdxBarCustomCombo.GetNearestItemIndex(AText: string): Integer;
var
  AItem: string;
  FoundChars, I, J: Integer;
begin
  AText := AnsiUpperCase(AText);
  FoundChars := 0;
  Result := -1;
  for I := 0 to Items.Count - 1 do
  begin
    AItem := AnsiUpperCase(Items[I]);
    if Copy(AItem, 1, FoundChars) = Copy(AText, 1, FoundChars) then
      for J := FoundChars + 1 to Length(AText) do
        if (J <= Length(AItem)) and (AItem[J] = AText[J]) then
        begin
          FoundChars := J;
          Result := I;
          if J = Length(AText) then Exit;
        end
        else Break;
  end;
end;

procedure TdxBarCustomCombo.InitDropDownWindow;
var
  AWidth, AHeight, I: Integer;
begin
  InternalInitDropDownWindow(FListBox);
  FListBox.Canvas.Font := TdxBarDropDownListBox(FListBox).Font;
  FListBox.Items.Assign(Items);
  
  AWidth := GetDropDownWidth;
  if DropDownCount > Items.Count then
    I := Items.Count
  else
    I := DropDownCount;
  AHeight := 2 * 2;
  for I := 0 to I - 1 do Inc(AHeight, ItemsHeight[I]);
  
  SetWindowPos(FListBox.Handle, 0, 0, 0, AWidth, AHeight,
    SWP_NOZORDER or SWP_NOMOVE or SWP_NOACTIVATE);
end;

procedure TdxBarCustomCombo.MeasureItem(AIndex: Integer; var AHeight: Integer);
begin
  if ItemHeight <= 0 then AHeight := Canvas.TextHeight('Qq')
  else AHeight := ItemHeight;
  if Assigned(FOnMeasureItem) then FOnMeasureItem(Self, AIndex, AHeight);
end;

procedure TdxBarCustomCombo.MeasureItemWidth(AIndex: Integer; var AWidth: Integer);
begin
  AWidth := 1 + Canvas.TextWidth(Items[AIndex]) + 1;
end;

procedure TdxBarCustomCombo.SetText(Value: string);
begin
  if (FItemIndex = -1) or (Items[FItemIndex] <> Value) then
    FItemIndex := Items.IndexOf(Value);
  inherited;
end;

{ TCustomdxBarSubItem }

constructor TCustomdxBarSubItem.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FItemLinks := TdxBarSubMenuControlItemLinks.Create(BarManager, Self);
  FShowCaption := True;
end;

destructor TCustomdxBarSubItem.Destroy;
begin
  DetachingBar := -1;
  FreeAndNil(FItemLinks);
  inherited Destroy;
end;

function TCustomdxBarSubItem.GetDetachingBarIndex: Integer;
begin
  if FDetachingBar = nil then
    Result := -1
  else
    Result := FDetachingBar.Index;
end;

function TCustomdxBarSubItem.GetItemOptions: TdxBarItemOptions;
begin
  Result := FItemLinks.ItemOptions;
end;

procedure TCustomdxBarSubItem.SetBarSize(Value: Integer);
begin
  if Value < 0 then Value := 0;
  FBarSize := Value;
end;

procedure TCustomdxBarSubItem.SetDetachingBar(Value: Integer);
begin
  if (BarManager.Bars = nil) or
    (Value < -1) or (Value > BarManager.Bars.Count - 1) then Value := -1;
  if DetachingBar <> Value then
  begin
    if FDetachingBar <> nil then
      FDetachingBar.RemoveFreeNotification(Self);
    if Value = -1 then
      FDetachingBar := nil
    else
      FDetachingBar := BarManager.Bars[Value];
    if FDetachingBar <> nil then
      FDetachingBar.AddFreeNotification(Self);
  end;
end;

procedure TCustomdxBarSubItem.SetIsInternal(Value: Boolean);
begin
  if FIsInternal <> Value then
  begin
    FIsInternal := Value;
    FItemLinks.Internal := Value;
  end;
end;

procedure TCustomdxBarSubItem.SetItemLinks(Value: TdxBarItemLinks);
begin
  FItemLinks.Assign(Value);
end;

procedure TCustomdxBarSubItem.SetItemOptions(Value: TdxBarItemOptions);
begin
  FItemLinks.ItemOptions := Value;
end;

procedure TCustomdxBarSubItem.BarManagerChanged;
begin
  if FItemLinks <> nil then
    FItemLinks.FBarManager := BarManager;
end;

function TCustomdxBarSubItem.CanClicked: Boolean;
begin
  Result := False;
end;

procedure TCustomdxBarSubItem.DoCloseUp;
begin
  CallNotify(FOnCloseUp, Self);
end;

procedure TCustomdxBarSubItem.DoDetaching;
begin
  CallNotify(FOnDetaching, Self);
end;

procedure TCustomdxBarSubItem.DoPopup;
begin
  CallNotify(FOnPopup, Self);
end;

procedure TCustomdxBarSubItem.InternalDropDown(
  AItemControl: TdxBarSubItemControl; AByMouse: Boolean);
begin
  if AByMouse then
    AItemControl.Parent.SetMouseSelectedItem(AItemControl);
  AItemControl.Parent.BarGetFocus(AItemControl);
  AItemControl.DropDown(AByMouse);
end;

procedure TCustomdxBarSubItem.ObjectNotification(AOperation: TOperation;
  AObject: TObject);
begin
  inherited;
  if (AOperation = opRemove) and (AObject = FDetachingBar) then
    DetachingBar := -1;
end;

procedure TCustomdxBarSubItem.CheckLinks(ASource: TCustomIniFile; const ABaseSection: string);
begin
  LoadFromIni(ASource, ABaseSection, skIni);
  LoadUsageData(ASource, ABaseSection);
  ItemLinks.CheckLinks(ASource, ABaseSection);
end;

function TCustomdxBarSubItem.GetIniSection(const ABaseSection: string): string;
begin
  Result := ABaseSection + 'SubItem_' + Name;
end;

procedure TCustomdxBarSubItem.LoadFromIni(ASource: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind);
begin
  if (Name <> '') and (ASource.ReadInteger(GetIniSection(ABaseSection), 'ItemLinkCount', -1) > -1) then
    ItemLinks.LoadFromIni(ASource, GetIniSection(ABaseSection), AStoringKind);
end;

procedure TCustomdxBarSubItem.LoadUsageData(ASource: TCustomIniFile; const ABaseSection: string);
begin
  ItemLinks.LoadUsageData(ASource, GetIniSection(ABaseSection));
end;

procedure TCustomdxBarSubItem.SaveToIni(ADestination: TCustomIniFile; const ABaseSection: string; AStoringKind: TdxBarStoringKind);
begin
  if Name <> '' then
    ItemLinks.SaveToIni(ADestination, GetIniSection(ABaseSection), AStoringKind);
end;

// IdxBarLinksOwner
function TCustomdxBarSubItem.CanContainItem(AItem: TdxBarItem; out AErrorText: string): Boolean;
begin
  Result := AItem.CanBePlacedOn(pkSubItemOrPopupMenu, nil, AErrorText);
  if Result then
  begin
    Result := (GetOwnedLinks(AItem) = nil) or not GetOwnedLinks(AItem).IsReferencedBy(Self);
    if not Result then
      AErrorText := cxGetResourceString(@dxSBAR_RECURSIVEMENUS);
  end;
end;

function TCustomdxBarSubItem.CreateBarControl: TCustomdxBarControl;
begin
  if CurItemLink <> nil then
  begin
    Result := TdxBarSubMenuControl.Create(CurItemLink.BarManager);
    TdxBarSubMenuControl(Result).FParentWnd := CurItemLink.BarControl.Handle;
  end
  else
    Result := TdxBarSubMenuControl.Create(BarManager);
end;

function TCustomdxBarSubItem.GetItemLinks: TdxBarItemLinks;
begin
  Result := FItemLinks;
end;

// IdxBarSelectableItem
function TCustomdxBarSubItem.GetSupportedActions: TdxBarCustomizationActions;
begin
  Result := inherited GetSupportedActions;
  if BarManager.Designing then
    Include(Result, caChangeButtonGroup);
end;

// IdxBarSubMenuOwner
function TCustomdxBarSubItem.GetBarSize: Integer;
begin
  Result := FBarSize;
end;

procedure TCustomdxBarSubItem.DoPaintBar(Canvas: TCanvas; const R: TRect);
begin
  if Assigned(FOnPaintBar) then FOnPaintBar(Self, Canvas, R);
end;

function TCustomdxBarSubItem.GetDetachingBar: TdxBar;
begin
  Result := FDetachingBar;
end;

procedure TCustomdxBarSubItem.DropDown(AByMouse: Boolean = False);
var
  I: Integer;
begin
  for I := 0 to LinkCount - 1 do
    with Links[I] do
      if Control is TdxBarSubItemControl and IsControlVisible(BarControl) then
      begin
        InternalDropDown(TdxBarSubItemControl(Control), AByMouse);
        Break;
      end;
end;

{ TdxBarSubItem }

constructor TdxBarSubItem.Create(AOwner: TComponent);
begin
  inherited;
  FAllowCustomizing := True;
end;

class function TdxBarSubItem.GetNewCaption: string;
begin
  Result := dxSBAR_NEWSUBITEMCAPTION;
end;

function TdxBarSubItem.InternalCanMergeWith(AItem: TdxBarItem): Boolean;
begin
  Result := AItem is TdxBarSubItem;
end;

{ TCustomdxBarContainerItem }

procedure TCustomdxBarContainerItem.AddListedItemLinks(AItemLinks: TdxBarItemLinks;
  AIndex: Integer; FirstCall: Boolean; CallingItemLink: TdxBarItemLink);
begin
  if FNeedClearItemList then
    ClearItemList;
  if FirstCall and Assigned(FOnGetData) then
  begin
    FInOnGetData := True;
    try
      FOnGetData(Self);
    finally
      FInOnGetData := False;
    end;
  end;
end;

procedure TCustomdxBarContainerItem.DeleteListedItemLinks(AItemLinks: TdxBarItemLinks;
  AIndex: Integer);
begin
end;

procedure TCustomdxBarContainerItem.ClearItemList;
begin
  FNeedClearItemList := False;
end;

function TCustomdxBarContainerItem.HideWhenRun: Boolean;
begin
  Result := True;
end;

function TCustomdxBarContainerItem.InternalActuallyVisible: Boolean;
begin
  Result := Assigned(FOnGetData);
end;

procedure TCustomdxBarContainerItem.ItemsChanged(AItemLinks: TObject);
begin
  if not FInOnGetData and not ResettingToolbar then
    VisibleChanged;
end;

procedure TCustomdxBarContainerItem.NeedClearItemList;
begin
  FNeedClearItemList := True;
end;

{ TdxBarListItem }

constructor TdxBarListItem.Create(AOwner: TComponent);
begin
  inherited;
  FItems := TStringList.Create;
  TStringList(FItems).OnChange := ItemsChanged;
  FItemIndex := -1;
  FItemList := TComponentList.Create;
  FShowNumbers := True;
end;

destructor TdxBarListItem.Destroy;
begin
  FreeAndNil(FItemList);
  FreeAndNil(FItems);
  inherited;
end;

function TdxBarListItem.GetDataIndex: Integer;
var
  I: Integer;
begin
  Result := -1;
  if (0 <= FItemIndex) and (FItemIndex < Items.Count) then
    for I := 0 to FItemIndex do
      if Items[I] <> ListItemSeparator then Inc(Result);
end;

function TdxBarListItem.GetItemList: TList;
begin
  Result := FItemList;
end;

procedure TdxBarListItem.SetDataIndex(Value: Integer);
var
  J, I: Integer;
begin
  if Items.Count = 0 then
    I := -1
  else
  begin
    J := -1;
    for I := 0 to Items.Count - 1 do
    begin
      if Items[I] <> ListItemSeparator then
        Inc(J);
      if J = Value then Break;
    end;
  end;  
  ItemIndex := I;
end;

procedure TdxBarListItem.SetItems(Value: TStrings);
begin
  FItems.Assign(Value);
end;

procedure TdxBarListItem.ClickItem(Sender: TObject);
begin
  FItemIndex := TComponent(Sender).Tag;
  DirectClick;
end;

procedure TdxBarListItem.AddListedItemLinks(AItemLinks: TdxBarItemLinks;
  AIndex: Integer; FirstCall: Boolean; CallingItemLink: TdxBarItemLink);
var
  I, ACurIndex: Integer;
  IsBeginGroup, ItemListExists: Boolean;
  AButton: TdxBarButton;
begin
  inherited;
  IsBeginGroup := False;
  ItemListExists := FItemList.Count > 0;
  ACurIndex := 0;
  for I := 0 to Items.Count - 1 do
    if Items[I] = ListItemSeparator then
      IsBeginGroup := True
    else
    begin
      if not ItemListExists then
      begin
        AButton := TdxBarButton.Create(BarManager.Owner);
        BarDesignController.AddInternalItem(AButton, FItemList);
        with AButton do
        begin
          Action := Self.Action;
          if ShowCheck and (I{ACurIndex} = FItemIndex) then
          begin
            ButtonStyle := bsChecked;
            Down := True;
          end;
          if FShowNumbers then
          begin
            if ACurIndex < 9 then
              FCaption := IntToStr(ACurIndex + 1)
            else
              FCaption := Chr(Ord('A') + ACurIndex - 9);
            FCaption := '&' + FCaption + ' ';
          end
          else
            FCaption := '';
          FCaption := FCaption + GetDisplayText(I);
          Hint := GetDisplayHint(Items[I]);
          Tag := I;  //ACurIndex;
          OnClick := ClickItem;
          Enabled := Self.Enabled;
        end;
      end;
      with AItemLinks.Add do
      begin
        FOriginalItemLink := CallingItemLink;
        Index := AIndex + ACurIndex;
        Item := TdxBarItem(FItemList[ACurIndex]);
        if (ACurIndex = 0) or IsBeginGroup then
          BeginGroup := True;
        Synchronize(CallingItemLink);
      end;
      IsBeginGroup := False;
      Inc(ACurIndex);
    end;
end;

procedure TdxBarListItem.ClearItemList;

  function IsAnotherInstanceOpen: Boolean;
  begin
    Result := (FItemList.Count > 0) and (TdxBarItem(FItemList.First).LinkCount > 0);
  end;

begin
  if not IsAnotherInstanceOpen then
    FItemList.Clear;
  inherited;
end;

procedure TdxBarListItem.DeleteListedItemLinks(AItemLinks: TdxBarItemLinks;
  AIndex: Integer);
var
  I: Integer;
begin
  inherited;
  for I := 0 to Items.Count - 1 do
    if Items[I] <> ListItemSeparator then
      AItemLinks[AIndex].Free;
end;

function TdxBarListItem.GetDisplayHint(const AText: string): string;
begin
  Result := '';
end;

function TdxBarListItem.GetDisplayText(const AText: string): string;
begin
  Result := AText;
end;

function TdxBarListItem.GetDisplayText(AItemIndex: Integer): string;
begin
  Result := GetDisplayText(Items[AItemIndex]);
end;

function TdxBarListItem.InternalActuallyVisible: Boolean;
begin
  Result := inherited InternalActuallyVisible or (Items.Count > 0);
end;

procedure TdxBarListItem.DirectClick;
begin
  if CurItemLink = nil then
    inherited;
end;

{ TdxBarContainerItem }

constructor TdxBarContainerItem.Create(AOwner: TComponent);
begin
  inherited;
  FItemLinks.OnChange := ItemsChanged;
end;

procedure TdxBarContainerItem.AddListedItemLinks(AItemLinks: TdxBarItemLinks;
  AIndex: Integer; FirstCall: Boolean; CallingItemLink: TdxBarItemLink);
var
  I: Integer;
begin
  inherited;
  if AItemLinks = ItemLinks then Exit;
  AItemLinks.BeginUpdate;
  try
    for I := 0 to FItemLinks.CanVisibleItemCount - 1 do
      with AItemLinks.Add do
      begin
        FOriginalItemLink := CallingItemLink;
        Assign(FItemLinks.CanVisibleItems[I]);
        Index := AIndex + I;
        if (I = 0) and HideWhenRun then BeginGroup := True;
        Synchronize(FOriginalItemLink);
      end;
  finally
    AItemLinks.EndUpdate;
  end;  
end;

procedure TdxBarContainerItem.DeleteListedItemLinks(AItemLinks: TdxBarItemLinks;
  AIndex: Integer);
var
  I: Integer;
begin
  inherited;
  if AItemLinks = ItemLinks then Exit;
  for I := 0 to FItemLinks.CanVisibleItemCount - 1 do
    AItemLinks[AIndex].Free;
end;

function TdxBarContainerItem.InternalActuallyVisible: Boolean;
begin
  Result := inherited InternalActuallyVisible or IsItemsExist;
end;

function TdxBarContainerItem.InternalCanMergeWith(AItem: TdxBarItem): Boolean;
begin
  Result := AItem is TdxBarContainerItem;
end;

function TdxBarContainerItem.IsItemsExist: Boolean;
var
  I: Integer;
  AItemExists: Boolean;
begin
  Result := ItemLinks.Count > 0;
  if Result then // check empty items
  begin
    AItemExists := False;
    for I := 0 to ItemLinks.Count - 1 do
      if ItemLinks[I].Item <> nil then
      begin
        AItemExists := True;
        Break;
      end;
    if AItemExists then
    begin
      Result := False;
      for I := 0 to ItemLinks.Count - 1 do
        if (ItemLinks[I].Item <> nil) and
          ItemLinks[I].Item.ActuallyVisible then
        begin
          Result := True;
          Break;
        end;
    end;
  end;
end;

{ TdxBarExtraPaneListItem }

procedure TdxBarExtraPaneListItem.AddListedItemLinks(AItemLinks: TdxBarItemLinks;
  AIndex: Integer; FirstCall: Boolean; CallingItemLink: TdxBarItemLink);

  procedure UpdateListedItemLinks;
  var
    I: Integer;
    APaintStyle: TdxBarPaintStyle;
  begin
    APaintStyle := psStandard;
    for I := 0 to Items.Count - 1 do
      if ExtraPaneItem[I].ImageIndex <> -1 then
      begin
        TdxBarButton(FItemList[I]).ImageIndex := ExtraPaneItem[I].ImageIndex;
        APaintStyle := psCaptionGlyph;
      end;
    for I := 0 to Items.Count - 1 do
      TdxBarButton(FItemList[I]).PaintStyle := APaintStyle;
  end;

var
  AHeader: TdxBarItem;
begin
  inherited;

  UpdateListedItemLinks;

  AHeader := TdxBarLabel.Create(BarManager.Owner);
  FItemList.Add(AHeader);
  AHeader.Caption := Caption;
  with AItemLinks.Add do
  begin
    FOriginalItemLink := CallingItemLink;
    Index := AIndex;
    Item := AHeader;
    Synchronize(CallingItemLink);
  end;
end;

function TdxBarExtraPaneListItem.GetDisplayHint(const AText: string): string;
begin
  Result := AText;
end;

function TdxBarExtraPaneListItem.GetDisplayText(AItemIndex: Integer): string;
begin
  Result := ExtraPaneItem[AItemIndex].DisplayText;
  if Assigned(OnGetDisplayText) then
    FOnGetDisplayText(Self, AItemIndex, Result);
  if Result = '' then
    Result := ChangeFileExt(ExtractFileName(ExtraPaneItem[AItemIndex].Text), '');
end;

function TdxBarExtraPaneListItem.InternalActuallyVisible: Boolean;
begin
  Result := inherited InternalActuallyVisible or (Caption <> '');
end;

function TdxBarExtraPaneListItem.GetExtraPaneItem(AIndex: Integer): TdxBarExtraPaneItem;
begin
  Result := TdxBarExtraPaneItem(Items.Objects[AIndex]);
end;

{ TdxBarItemControlDrawParams }

constructor TdxBarItemControlDrawParams.Create(ABarItemControl: TdxBarItemControl);
begin
  inherited Create;
  FBarItemControl := ABarItemControl;
end;

procedure TdxBarItemControlDrawParams.SetViewSize(Value: TdxBarItemControlViewSize);
begin
  if FViewSize <> Value then
  begin
    FViewSize := Value;
    if FBarItemControl <> nil then
      FBarItemControl.ResetCachedValues(False);
  end;
end;

{ TdxBarEditLikeControlDrawParams }

function TdxBarEditLikeControlDrawParams.GetBarEditControl: TdxBarEditControl;
begin
  Result := TdxBarEditControl(BarItemControl);
end;

{ TdxBarStaticLikeControlDrawParams }

function TdxBarStaticLikeControlDrawParams.GetBarStaticControl: TdxBarCustomStaticControl;
begin
  Result := TdxBarCustomStaticControl(BarItemControl);
end;

{ TdxBarItemControlViewInfo }

constructor TdxBarItemControlViewInfo.Create(AControl: TdxBarItemControl);
begin
  inherited Create(nil);
  FControl := AControl;
  FAllowedViewLevels := Control.ViewLevels;
  FMinPossibleViewLevel := GetMinViewLevel(Control.PossibleViewLevels);
  FViewLevelForButtonGroup := GetMinViewLevel(FAllowedViewLevels);
  if FViewLevelForButtonGroup = ivlLargeIconWithText then
    FViewLevelForButtonGroup := FMinPossibleViewLevel;
  ResetCachedValues;
end;

destructor TdxBarItemControlViewInfo.Destroy;
begin
  if not Control.Parent.IsDestroying then
    Control.Parent.ViewInfo.RemoveItemControlViewInfo(Self);
  inherited Destroy;
end;

procedure TdxBarItemControlViewInfo.ResetCachedValues;
var
  AViewLevel: TdxBarItemRealViewLevel;
begin
  for AViewLevel := Low(TdxBarItemRealViewLevel) to High(TdxBarItemRealViewLevel) do
    FViewLevelInfos[AViewLevel].Calculated := False;
end;

// IdxBarItemControlViewInfo
procedure TdxBarItemControlViewInfo.CalculateFinalize;
begin
  BoundsCalculated;
end;

function TdxBarItemControlViewInfo.GetAlign: TdxBarItemAlign;
begin
  Result := Control.Item.Align;
end;

function TdxBarItemControlViewInfo.GetAllowedViewLevels: TdxBarItemViewLevels;
begin
  Result := FAllowedViewLevels;
end;

function TdxBarItemControlViewInfo.GetBounds: TRect;
begin
  Result := FBounds;
end;

function TdxBarItemControlViewInfo.GetColumnRowCount: Integer;
begin
  Result := FColumnRowCount;
end;

function TdxBarItemControlViewInfo.GetDistributed: Boolean;
begin
  Result := Control.ItemLink.Distributed;
end;

function TdxBarItemControlViewInfo.GetPosition: TdxBarItemPosition;
begin
  Result := Control.ItemLink.Position;
end;

function TdxBarItemControlViewInfo.GetPositionInButtonGroup: TdxBarButtonGroupPosition;
begin
  if Control.CanBePartOfButtonGroup then
    Result := Control.ItemLink.ButtonGroup
  else
    Result := bgpNone;
end;

function TdxBarItemControlViewInfo.GetRealPositionInButtonGroup: TdxBarButtonGroupRealPosition;
begin
  Result := FRealPositionInButtonGroup;
end;

function TdxBarItemControlViewInfo.GetRow: Integer;
begin
  Result := FRow;
end;

function TdxBarItemControlViewInfo.GetViewLevel: TdxBarItemViewLevel;
begin
  Result := FViewLevel;
end;

function TdxBarItemControlViewInfo.GetViewLevelForButtonGroup: TdxBarItemRealViewLevel;
begin
  Result := FViewLevelForButtonGroup;
end;

function TdxBarItemControlViewInfo.GetWidth(
  AViewLevel: TdxBarItemRealViewLevel): Integer;
var
  AMultiColumnItemControlViewInfo: IdxBarMultiColumnItemControlViewInfo;
begin
  if IsMultiColumnItemControl(True, AMultiColumnItemControlViewInfo) then
  begin
    Result := AMultiColumnItemControlViewInfo.GetWidthForColumnCount(AMultiColumnItemControlViewInfo.GetColumnCount);
    Exit;
  end;
  if not (AViewLevel in GetAllowedViewLevels) then
    raise EdxException.Create('Testing! The level is not allowed');
  if not FViewLevelInfos[AViewLevel].Calculated then
  begin
    FViewLevelInfos[AViewLevel].Width := Control.GetWidthByViewLevel(AViewLevel);
    FViewLevelInfos[AViewLevel].Calculated := True;
  end;
  Result := FViewLevelInfos[AViewLevel].Width;
end;

function TdxBarItemControlViewInfo.HasSeparator: Boolean;
begin
  Result := Control.ItemLink.BeginGroup; // TODO check
end;

function TdxBarItemControlViewInfo.IsPrimaryForDistribution: Boolean;
begin
  Result := Control.ItemLink.IsPrimaryForDistribution;
end;

function TdxBarItemControlViewInfo.IsMultiColumnItemControl(ACheckCollapsed: Boolean;
  out AIMultiColumnItemControlViewInfo: IdxBarMultiColumnItemControlViewInfo): Boolean;
begin
  Result := Supports(TObject(Self), IdxBarMultiColumnItemControlViewInfo,
    AIMultiColumnItemControlViewInfo) and (not ACheckCollapsed or not AIMultiColumnItemControlViewInfo.GetCollapsed);
end;

procedure TdxBarItemControlViewInfo.SetBounds(const Value: TRect);
begin
  FBounds := Value;
end;

procedure TdxBarItemControlViewInfo.SetColumnRowCount(Value: Integer);
begin
  FColumnRowCount := Value;
end;

procedure TdxBarItemControlViewInfo.SetDistributed(Value: Boolean);
begin
  Control.ItemLink.SetDistributedByPrimaryLink(Value);
end;

procedure TdxBarItemControlViewInfo.SetRealPositionInButtonGroup(
  Value: TdxBarButtonGroupRealPosition);
begin
  FRealPositionInButtonGroup := Value;
end;

procedure TdxBarItemControlViewInfo.SetRow(Value: Integer);
begin
  FRow := Value;
end;

procedure TdxBarItemControlViewInfo.SetViewLevel(
  Value: TdxBarItemViewLevel);
begin
  FViewLevel := Value;
end;

procedure TdxBarItemControlViewInfo.BoundsCalculated;
begin
end;

{ TdxCachedImageOptions }

constructor TdxCachedImageOptions.Create;
begin
  inherited;
  FGlyph := TcxBitmap.Create;
end;

destructor TdxCachedImageOptions.Destroy;
begin
  FreeAndNil(FGlyph);
  inherited;
end;

procedure TdxCachedImageOptions.Cache(const ARect: TRect; AGlyph: TBitmap;
  AImages: TCustomImageList; AImageIndex: Integer; ADrawMode: TcxImageDrawMode;
  ATransparentColor: TColor; ASmoothImage, AUseLeftBottomPixelAsTransparent: Boolean);
var
  AClientRect: TRect;
begin
  AClientRect := cxRect(0, 0, cxRectWidth(ARect), cxRectHeight(ARect));
  FGlyph.SetSize(AClientRect.Right, AClientRect.Bottom);
  cxDrawImage(FGlyph.Canvas.Handle,
    AClientRect, AClientRect, AGlyph, AImages, AImageIndex, ADrawMode,
    ASmoothImage, 0, ATransparentColor, AUseLeftBottomPixelAsTransparent);
  FCachedDrawMode := ADrawMode;
  FCachedImages := AImages;
  FCachedGlyph := AGlyph;
  FCached := True;
end;

function TdxCachedImageOptions.IsCached(ADrawMode: TcxImageDrawMode; AGlyph: TBitmap; AImages: TCustomImageList): Boolean;
begin
  Result := FCached and (FCachedDrawMode = ADrawMode) and
    ((AGlyph <> nil) and (FCachedGlyph = AGlyph) or (AGlyph = nil) and (FCachedImages = AImages)) and
    not FGlyph.Empty;
end;

{ TdxBarItemControl }

constructor TdxBarItemControl.Create(AItemLink: TdxBarItemLink);
begin
  inherited Create;
  FItemLink := AItemLink;
  FParent := AItemLink.BarControl;
  FDrawParams := GetDrawParamsClass.Create(Self);
  FCachedImageOptions := TdxCachedImageOptions.Create;

  FViewInfo := GetViewInfoClass.Create(Self);
  CalcDrawingConsts;

  FHotPartIndex := icpNone;
  CalcDrawParams;
  IdxBarItemControlViewInfo(ViewInfo).SetViewLevel(Parent.GetItemControlDefaultViewLevel(Self));
end;

destructor TdxBarItemControl.Destroy;
begin
  BarAccessibilityHelperOwnerObjectDestroyed(FIAccessibilityHelper);
  if Fader <> nil then
    Fader.Remove(Self);

//#DG <BarManager.SelectedItem>
  if (BarManager <> nil) and (BarManager.FSelectedItem = Self) then
    BarManager.InternalSetSelectedItem(nil);
  if FItemLink <> nil then FItemLink.FControl := nil;
  if (FParent <> nil) and not BarManager.IsDestroying and
    (FParent.SelectedControl = Self) and not BarManager.IsCustomizing then
    if (FItemLink <> nil) and (FItemLink.VisibleIndex <> -1) then
      FParent.SetMouseSelectedItem(nil)
    else
      FParent.SelectedLink := nil;
  DeleteGDIObject(FBkBrush);
  cxClearObjectLinks(Self);
  FreeAndNil(FViewInfo);
  FreeAndNil(FCachedImageOptions);
  FreeAndNil(FDrawParams);
  inherited Destroy;
end;

procedure TdxBarItemControl.DoCalculateParts;
begin
  CalcDrawParams(False);
  CalcParts;
end;

function TdxBarItemControl.FindPartAtPos(APoint: TPoint): Integer;
var
  I: Integer;
begin
  if not PtInRect(ItemBounds, APoint) then
    Result := icpNone
  else
  begin
    Result := icpNonClient;
    for I := Low(FParts) to High(FParts) do
      if PtInRect(FParts[I], APoint) then
      begin
        Result := I;
        Break;
      end;
  end;
end;

function TdxBarItemControl.GetAlign: TdxBarItemAlign;
begin
  Result := Item.Align;
  if (Result <> iaLeft) and not Parent.CanAlignControl(Self) then
    Result := iaLeft;
end;

function TdxBarItemControl.GetBarManager: TdxBarManager;
begin
  if FItemLink <> nil then
    Result := FItemLink.BarManager
  else
    Result := nil;
end;

function TdxBarItemControl.GetBkBrush: HBRUSH;
begin
  Result := FBkBrush;
  if Result = 0 then
    Result := Parent.BkBrush;
end;

function TdxBarItemControl.GetCanvas: TcxCanvas;
begin
  if FActiveCanvas <> nil then
    Result := FActiveCanvas
  else
    Result := Parent.Canvas;
end;

function TdxBarItemControl.GetFlat: Boolean;
begin
  // TODO: obsolete
  Result := Parent.Flat;
end;

function TdxBarItemControl.GetIAccessibilityHelper: IdxBarAccessibilityHelper;
begin
  if FIAccessibilityHelper = nil then
    FIAccessibilityHelper := GetAccessibilityHelper(GetAccessibilityHelperClass.Create(Self));
  Result := FIAccessibilityHelper;
end;

function TdxBarItemControl.GetIsFadingAvailable: Boolean;
begin
  Result := (Fader <> nil) and Painter.IsFadingAvailable;
end;

function TdxBarItemControl.GetIsSelected: Boolean;
begin
  Result := (FParent <> nil) and (FParent.SelectedControl = Self) and
    (Enabled or not FSelectedByMouse);
end;

function TdxBarItemControl.GetItem: TdxBarItem;
begin
  Result := GetItemByLink(FItemLink);
end;

function TdxBarItemControl.GetItemBarManager: TdxBarManager;
begin
  Result := Item.BarManager;
end;

function TdxBarItemControl.GetItemBounds: TRect;
begin
  Result := ItemLink.ItemRect;
end;

function TdxBarItemControl.GetPainterClass: TdxBarPainterClass;
begin
  Result := TdxBarPainterClass(Painter.ClassType);
end;

function TdxBarItemControl.GetRealHeight: Integer;
var
  ASavedFont: TdxBarSavedFont;
begin
  PrepareCanvasFont(0, Item.Style, ASavedFont);
  try
    Result := GetHeight;
    if (Align = iaClient) and Parent.IsRealVertical then
      if Parent.IsVertical then
        Result := MinWidth
      else
        Result := MinHeight;
  finally
    RestoreCanvasFont(ASavedFont);
  end;
end;

function TdxBarItemControl.GetRealWidth: Integer;
var
  ASavedFont: TdxBarSavedFont;
begin
  PrepareCanvasFont(0, Item.Style, ASavedFont);
  try
    Result := GetWidth;
    if (Align = iaClient) and (bboExtendItemWhenAlignedToClient in Parent.BehaviorOptions) and
      not Parent.IsRealVertical or (Result < MinWidth) then
      Result := MinWidth;
  finally
    RestoreCanvasFont(ASavedFont);
  end;
end;

function TdxBarItemControl.GetShowDescription: Boolean;
begin
  Result := (ItemLink.Owner.ItemSize = misLarge) and ItemLink.Owner.ItemShowDescriptions;
end;

function TdxBarItemControl.GetSubMenuParent: TdxBarSubMenuControl;
begin
  Result := Parent as TdxBarSubMenuControl;
end;

function TdxBarItemControl.GetUnclickAfterDoing: Boolean;
begin
  if Item is TdxBarButton then
    Result := Item.UnclickAfterDoing
  else
    Result := True;
end;

function TdxBarItemControl.InternalGetPossibleViewLevels: TdxBarItemViewLevels;
begin
  Result := GetPossibleViewLevels;
  if Result = [] then
    raise EdxException.Create(ClassName + '.GetPossibleViewLevels = []');
end;

procedure TdxBarItemControl.SetPressed(Value: Boolean);
begin
  if FPressed <> Value then
  begin
    FPressed := Value;
    PressedChanged;
  end;
end;

//IdxFadingObject
function TdxBarItemControl.CanFade: Boolean;
begin
  Result := False;
end;

procedure TdxBarItemControl.DrawFadeImage;
begin
  Repaint;
end;

procedure TdxBarItemControl.FadingBegin(AData: IdxFadingElementData);
begin
  FFadingElementData := AData;
end;

procedure TdxBarItemControl.FadingEnd;
begin
  FFadingElementData := nil;  
end;

procedure TdxBarItemControl.GetFadingParams(
  out AFadeOutImage, AFadeInImage: TcxBitmap;
  var AFadeInAnimationFrameCount, AFadeInAnimationFrameDelay: Integer;
  var AFadeOutAnimationFrameCount, AFadeOutAnimationFrameDelay: Integer);
begin

end;

function TdxBarItemControl.GetFader: TdxFader;
begin
  Result := Parent.GetFader;
end;

// IdxBarHintKeeper
function TdxBarItemControl.DoHint(var ANeedDeactivate: Boolean; out AHintText: string; out AShortCut: string): Boolean;
var
  Action: TBasicAction;
begin
  Result := False;
  ANeedDeactivate := False;
  AShortCut := '';
  AHintText := '';

  if (Parent <> nil) and Parent.CanShowHint and (Parent.ItemAtMousePos = Self) then
  begin
    AHintText := GetShortHint(Hint);
    AShortCut := GetShortCutToHint(ShortCut);
    Action := Item.Action;
    if Action is TCustomAction then
      if not TCustomAction(Action).DoHint(AHintText) then
      begin
        ANeedDeactivate := True;
        Exit;
      end;
    Result := True;
  end;
end;

function TdxBarItemControl.CreateHintViewInfo(const AHintText, AShortCut: string): TdxBarCustomHintViewInfo;
begin
  Result := Parent.CreateHintViewInfo(AHintText, AShortCut, Item.ScreenTip);
end;

function TdxBarItemControl.GetEnabled: Boolean;
begin
  if Item <> nil then
    Result := Item.Enabled
  else
    Result := False;
end;

function TdxBarItemControl.GetHintPosition(const ACursorPos: TPoint; AHeight: Integer): TPoint;
begin
  Result := Parent.GetHintPosition(ViewInfo.Bounds, ACursorPos, AHeight);
end;

procedure TdxBarItemControl.BeginGroupChanged;
begin
  FParent.RepaintBar;
end;

procedure TdxBarItemControl.CaptionChanged;
begin
  if (Align = iaClient) and (bboExtendItemWhenAlignedToClient in Parent.BehaviorOptions) then
    Repaint
  else
    FParent.RepaintBar;
end;

procedure TdxBarItemControl.EnabledChanged;
begin
  Parent.UpdateControlByMouse;
  if not Enabled and (Parent.SelectedControl = Self) then
    Parent.SelectedLink := nil;
  Repaint;
end;

procedure TdxBarItemControl.GlyphChanged;

  function GlyphAreaWidthChanged: Boolean;
  begin
    Result := (IdxBarItemControlViewInfo(ViewInfo).GetAllowedViewLevels <> ViewLevels) or
      ((cpIcon in FDrawParams.ViewStructure) <> (cpIcon in GetViewStructure));
  end;

begin
  if GlyphAreaWidthChanged then
    Parent.RepaintBar
  else
    Repaint;
end;

procedure TdxBarItemControl.HotGlyphChanged;
begin
// do nothing
end;

procedure TdxBarItemControl.LargeGlyphChanged;
begin
  if FDrawParams.ViewSize <> cvsSmall then
    if FDrawParams.PaintType <> ptMenu then
      Parent.RepaintBar
    else
      Repaint;
end;

procedure TdxBarItemControl.PartsChanged;
begin
  DoCalculateParts;
  Repaint;
end;

procedure TdxBarItemControl.PaintStyleChanged;
begin
// do nothing
end;

procedure TdxBarItemControl.ParentVisibleChange(AIsShowing: Boolean);
begin
// do nothing
end;

procedure TdxBarItemControl.PressedChanged;
begin
  if not FPressed then Repaint;
end;

procedure TdxBarItemControl.RealVisibleChanging(AVisible: Boolean);
begin
end;

procedure TdxBarItemControl.VisibleChanged;
begin
  FParent.RepaintBar;
end;

procedure TdxBarItemControl.WidthChanged;
begin
  if Parent is TdxBarControl then
    Parent.RepaintBar;
end;

procedure TdxBarItemControl.ResetCachedValues(AFull: Boolean);
begin
  if AFull then
    ViewInfo.ResetCachedValues;
  FCachedImageOptions.Cached := False;
end;

function TdxBarItemControl.UseLargeGlyph(AViewSize: TdxBarItemControlViewSize): Boolean;
begin
  Result := IsGlyphAssigned(Item.LargeGlyph) and
    UseLargeImageSource(AViewSize);
end;

function TdxBarItemControl.UseLargeIcons: Boolean;
begin
  Result := BarManager.LargeIcons and Painter.AllowLargeIcons;
end;

function TdxBarItemControl.UseLargeImageSource(AViewSize: TdxBarItemControlViewSize): Boolean;
begin
  Result := (AViewSize = cvsLarge) or
    (GetPaintType <> ptMenu) and UseLargeIcons and BarManager.UseLargeImagesForLargeIcons;
end;

function TdxBarItemControl.UseLargeImageList(AViewSize: TdxBarItemControlViewSize): Boolean;
begin
  Result := UseLargeImageSource(AViewSize) and
    Item.IsImageIndexLinked(LargeImages, GetCurrentImageIndex(AViewSize));
end;

procedure TdxBarItemControl.BeforeDestroyParentHandle;
begin
end;

function TdxBarItemControl.CanBePartOfButtonGroup: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.CanClicked: Boolean;
begin
  Result := True;
end;

function TdxBarItemControl.CanCustomize: Boolean;
begin
  Result := (BarManager = GetItemBarManager) or
    (csAncestor in BarManager.ComponentState);
end;

function TdxBarItemControl.CanDeselect(ABarManager: TdxBarManager): Boolean;
begin
  Result := CanHide;
end;

function TdxBarItemControl.CanHide: Boolean;
begin
  Result := True;
end;

function TdxBarItemControl.CanMouseSelect: Boolean;
begin
  Result := CanSelect;
end;

function TdxBarItemControl.CanSelect: Boolean;
begin
  Result := not IsSelectionForbidden;
end;

function TdxBarItemControl.CanShowShortCut: Boolean;
begin
  Result := ItemLink.Owner.ItemShowShortCuts;
end;

function TdxBarItemControl.CanVisuallyPressed: Boolean;
begin
  Result := not Parent.HideOnClick;
end;

procedure TdxBarItemControl.CheckHotTrack(APoint: TPoint);
var
  ACurrentHotPart: Integer;
  AOldHotPart: Integer;
begin
  if Enabled then
  begin
    ACurrentHotPart := FindPartAtPos(APoint);
    if ACurrentHotPart <> FHotPartIndex then
    begin
      AOldHotPart := FHotPartIndex;
      FHotPartIndex := ACurrentHotPart;
      if CanFade then
      begin
        if AOldHotPart = icpNone then
          Fader.FadeIn(Self);
        if FHotPartIndex = icpNone then
          Fader.FadeOut(Self);
      end;
      Repaint;
    end;
  end
  else
    FHotPartIndex := icpNone;
end;

procedure TdxBarItemControl.Click(AByMouse: Boolean; AKey: Char = #0);
var
  AParent: TCustomdxBarControl;
begin
  if Enabled then
  begin
    AParent := Parent;
    ControlClick(AByMouse, AKey);
    if BarControlExists(AParent) and AParent.IsControlExists(Self) then
      ControlUnclick(AByMouse);
  end;
end;

procedure TdxBarItemControl.ControlActivate(Immediately: Boolean);
begin
  FIsActive := True;
end;

procedure TdxBarItemControl.ControlInactivate(Immediately: Boolean);
begin
  FIsActive := False;
end;

procedure TdxBarItemControl.ControlClick(AByMouse: Boolean; AKey: Char = #0);
begin
end;

procedure TdxBarItemControl.ControlUnclick(ByMouse: Boolean);
var
  AItem: TdxBarItem;
  AItemLink: TdxBarItemLink;
  AllowClick, AIsDestroyOnClick, AllowPressed: Boolean;
//  AParent: TCustomdxBarControl;
  ALinkSelf, ALinkItem: TcxObjectLink;
begin
  if (Self is TdxBarButtonControl) and (Parent.Kind = bkSubMenu) then
    PlaySound(psMenuCommand);
  AItemLink := FItemLink.RealItemLink;
  AItem := FItemLink.Item;
  AllowClick := CanClicked;
  AIsDestroyOnClick := IsDestroyOnClick;
//  AParent := Parent;
  try
    if AIsDestroyOnClick then
    begin
      AItemLink.BringToTopInRecentList(True);
      // for TCustomdxBarContainerItem:
      if AItemLink <> FItemLink then FItemLink.BringToTopInRecentList(True);
    end;
  except
  end;

  ALinkSelf := cxAddObjectLink(Self);
  AllowPressed :=
    UnclickAfterDoing and (not AIsDestroyOnClick or CanVisuallyPressed);
  if AllowPressed then Pressed := True;
  try
    if AIsDestroyOnClick then
      Parent.HideAll
    else
      if AItemLink = nil then AItemLink := FItemLink;
    if AllowClick then
    begin
      ALinkItem := cxAddObjectLink(AItem);
      AItem.FClickItemLink := AItemLink;
      try
        AItem.DirectClick;
      finally
        if ALinkItem.Ref <> nil then
          AItem.FClickItemLink := nil;
        cxRemoveObjectLink(ALinkItem);
      end;
    end;
  finally
    if (ALinkSelf.Ref <> nil) and AllowPressed {and BarControlExists(AParent)} then
      Pressed := False;
    cxRemoveObjectLink(ALinkSelf);
  end;
end;

procedure TdxBarItemControl.ControlGetFocus(AIsSelected: Boolean; var AProcessed: Boolean);
begin
  Parent.IsDowned := False;
  Parent.SetKeySelectedItem(Self);
end;

procedure TdxBarItemControl.DblClick;
begin
end;

function TdxBarItemControl.DrawSelected: Boolean;
begin
  Result := IsSelected;
end;

function TdxBarItemControl.GetSelectableObject: TPersistent;
begin
  Result := ItemLink;
end;

function TdxBarItemControl.WantsDblClick: Boolean;
begin
  Result := BarManager.Designing or IsExpandable;
end;

procedure TdxBarItemControl.KeyDown(var Key: Word; Shift: TShiftState);
begin
end;

procedure TdxBarItemControl.KeyUp(var Key: Word; Shift: TShiftState);
begin
end;

procedure TdxBarItemControl.KeyPress(var Key: Char);
begin
end;

procedure TdxBarItemControl.MouseDown(Button: TMouseButton; Shift: TShiftState;
  X, Y: Integer);
begin
// do nothing;
end;

procedure TdxBarItemControl.MouseEnter(Shift: TShiftState; X, Y: Integer);
begin
  CheckHotTrack(Point(X, Y));
end;

procedure TdxBarItemControl.MouseLeave;
begin
  CheckHotTrack(Point(-1, -1));
end;

procedure TdxBarItemControl.MouseMove(Shift: TShiftState; X, Y: Integer);
begin
  CheckHotTrack(Point(X, Y));
end;

procedure TdxBarItemControl.MouseUp(Button: TMouseButton; Shift: TShiftState;
  X, Y: Integer);
begin
// do nothing;
end;

function TdxBarItemControl.WantsKey(Key: Word): Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarItemControlAccessibilityHelper;
end;

function TdxBarItemControl.GetPossibleViewLevels: TdxBarItemViewLevels;
begin
  Result := [ivlSmallIconWithText];
  if IconAssigned(cvsSmall) then
    Include(Result, ivlSmallIcon);
end;

function TdxBarItemControl.GetViewLevels: TdxBarItemViewLevels;
begin
  Result := PossibleViewLevels;
  if Result * ItemLink.GetAllowedViewLevels <> [] then
    Result := Result * ItemLink.GetAllowedViewLevels;
end;

function TdxBarItemControl.GetViewStructure: TdxBarItemControlViewStructure;
begin
  case ViewInfo.ViewLevel of
    ivlLargeIconWithText, ivlSmallIconWithText:
      begin
        Result := [cpText];
        if IconAssigned(GetViewSize) then
          Include(Result, cpIcon);
      end;
    ivlSmallIcon:
      if IconAssigned(GetViewSize) then
        Result := [cpIcon]
      else
        Result := [];
    ivlControlOnly: Result := [];
    ivlDefault: Result := GetDefaultViewStructure;
  end;
end;

function TdxBarItemControl.GetDefaultViewStructure: TdxBarItemControlViewStructure;
begin
  Result := [];
end;

function TdxBarItemControl.GetViewSize: TdxBarItemControlViewSize;
begin
  case ViewInfo.ViewLevel of
    ivlLargeIconWithText: Result := cvsLarge;
    ivlSmallIconWithText, ivlSmallIcon: Result := cvsSmall;
  else
    Result := GetDefaultViewSize;
  end;
end;

function TdxBarItemControl.GetDefaultViewSize: TdxBarItemControlViewSize;
begin
  if MenuItemSize = misLarge then
    Result := cvsLarge
  else
    if UseLargeIcons then
      Result := cvsMedium
    else
      Result := cvsSmall;
end;

function TdxBarItemControl.GetPaintType: TdxBarPaintType;
begin
  Result := Parent.GetPaintType;
end;

function TdxBarItemControl.GetPartCount: Integer;
begin
  Result := 1;
end;

function TdxBarItemControl.GetViewInfoClass: TdxBarItemControlViewInfoClass;
begin
  Result := TdxBarItemControlViewInfo;
end;

function TdxBarItemControl.GrayScale: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.HasIcon(AViewSize: TdxBarItemControlViewSize; AViewStructure: TdxBarItemControlViewStructure): Boolean;
begin
   Result := IconAssigned(AViewSize) and (cpIcon in AViewStructure);
end;

function TdxBarItemControl.IconAssigned(AViewSize: TdxBarItemControlViewSize): Boolean;
var
  ACurrentGlyph: TBitmap;
  ACurrentImageIndex: Integer;
  ACurrentImages: TCustomImageList;
begin
  Result := GetCurrentImage(AViewSize, False, ACurrentGlyph, ACurrentImages, ACurrentImageIndex);
end;

procedure TdxBarItemControl.FrameAndFillRect(DC: HDC; var R: TRect;
  Enabled, Selected, Pressed: Boolean);
begin
  Painter.FrameAndFillRect(Self, DC, R, Enabled, Selected, Pressed);
end;

function TdxBarItemControl.GetCaption: string;
begin
  if FItemLink <> nil then
    Result := FItemLink.Caption
  else
    Result := '';
end;

function TdxBarItemControl.GetControl: TControl;
begin
  Result := nil;
end;

function TdxBarItemControl.GetDrawParamsClass: TdxBarItemControlDrawParamsClass;
begin
  Result := TdxBarItemControlDrawParams;
end;

function TdxBarItemControl.GetGlyph: TBitmap;
begin
  if FItemLink <> nil then
    Result := FItemLink.Glyph
  else
    Result := nil;
end;

function TdxBarItemControl.GetImageEnabled(APaintType: TdxBarPaintType): Boolean;
var
  ACurrentGlyph: TBitmap;
  ACurrentImages: TCustomImageList;
  ACurrentImageIndex: Integer;
begin
  GetCurrentImage(FDrawParams.ViewSize, False, ACurrentGlyph, ACurrentImages, ACurrentImageIndex);
  Result := Enabled or
    not IsGlyphAssigned(ACurrentGlyph) and
    (not UseLargeImageList(FDrawParams.ViewSize) and (GetItemBarManager.DisabledImages <> nil) or
    UseLargeImageList(FDrawParams.ViewSize) and (GetItemBarManager.DisabledLargeImages <> nil));
end;

function TdxBarItemControl.GetImageIndex: Integer;
begin
  Result := Item.ImageIndex;
end;

function TdxBarItemControl.GetImageList(AViewSize: TdxBarItemControlViewSize): TCustomImageList;
begin
  if UseLargeImageList(AViewSize) then
    Result := LargeImages
  else
    Result := Images;
end;

function TdxBarItemControl.GetImages: TCustomImageList;
begin
  if not Enabled and (GetItemBarManager.DisabledImages <> nil) then
    Result := GetItemBarManager.DisabledImages
  else
    Result := GetItemBarManager.Images;
end;

function TdxBarItemControl.GetHint;
begin
  if Item <> nil then
    Result := Item.Hint
  else
    Result := '';
end;

function TdxBarItemControl.GetHotImages: TCustomImageList;
begin
  Result := GetItemBarManager.HotImages;
end;

function TdxBarItemControl.GetLargeGlyph: TBitmap;
begin
  Result := Item.LargeGlyph;
end;

function TdxBarItemControl.GetLargeImageIndex: Integer;
begin
  Result := Item.LargeImageIndex;
end;

function TdxBarItemControl.GetLargeImages: TCustomImageList;
begin
  if not Enabled and (GetItemBarManager.DisabledLargeImages <> nil) then
    Result := GetItemBarManager.DisabledLargeImages
  else
    Result := GetItemBarManager.LargeImages;
end;

function TdxBarItemControl.GetMenuItemSize: TdxBarMenuItemSize;
begin
  Result := ItemLink.Owner.ItemSize;
end;

function TdxBarItemControl.GetPainter: TdxBarPainter;
begin
  Result := Parent.Painter;
end;

function TdxBarItemControl.GetShortCut;
begin
  if Item <> nil then
    Result := Item.ShortCut
  else
    Result := 0;
end;

function TdxBarItemControl.GetTextAreaOffset: Integer;
begin
  Result := Painter.TextAreaOffset(Self);
end;

procedure TdxBarItemControl.CalcDrawParams(AFull: Boolean = True);
begin
  if AFull then
  begin
    FDrawParams.Caption := Caption;
    FDrawParams.Description := Item.Description;
    FDrawParams.ShortCut := '';
    FDrawParams.PaintType := GetPaintType;
    FDrawParams.Enabled := Enabled;
    FDrawParams.CanSelect := CanSelect;
    FDrawParams.DrawSelected := DrawSelected;
    FDrawParams.IsDropDown := IsDropDown;
    FDrawParams.HotPartIndex := FHotPartIndex;
    FDrawParams.IsCustomizing := FParent.IsCustomizing;
    FDrawParams.SelectedByKey := DrawSelected and not FSelectedByMouse;
  end;
  FDrawParams.Canvas := Canvas;
  FDrawParams.ViewSize := GetViewSize;
  FDrawParams.ViewStructure := GetViewStructure;
  FDrawParams.DefaultButtonSize := Painter.GetButtonSize(BarManager.GlyphSize, GetTextSize);
end;

procedure TdxBarItemControl.CalcParts;
var
  I: Integer;
begin
  SetLength(FParts, GetPartCount);
  for I := Low(FParts) to High(FParts) do
    FParts[I] := ItemBounds;
end;

procedure TdxBarItemControl.CalcDrawingConsts;
var
  ASavedFont: TdxBarSavedFont;
begin
  PrepareCanvasFont(0, Item.Style, ASavedFont);
  try
    DoCalcDrawingConsts;
  finally
    RestoreCanvasFont(ASavedFont);
  end;
end;

procedure TdxBarItemControl.DoCalcDrawingConsts;
var
  ATextViewParams: TcxViewParams;
begin
  DeleteGDIObject(FBkBrush);
  if Item.IsStyleColorSupported then
  begin
    Item.GetTextViewParams(ATextViewParams);
    if ATextViewParams.Color <> clDefault then
      FBkBrush := CreateSolidBrush(ColorToRGB(ATextViewParams.Color));
  end;
  FTextSize := Parent.GetTextSize;
end;

procedure TdxBarItemControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
begin
// do nothing
end;

function TdxBarItemControl.IsTransparentOnGlass: Boolean;
begin
  Result := True;
end;

procedure TdxBarItemControl.Paint(ACanvas: TcxCanvas; ARect: TRect;
  PaintType: TdxBarPaintType);
var
  ASavedFont: TdxBarSavedFont;
begin
  if not IsRectEmpty(ARect) then
  begin
    ACanvas.SaveState;
    try
      if ACanvas <> Canvas then
        ACanvas.Font := Canvas.Font;
      FActiveCanvas := ACanvas;
      try
        PrepareCanvasFont(0, Item.Style, ASavedFont);
        try
          CalcDrawParams;
          DoPaint(ARect, PaintType)
        finally
          RestoreCanvasFont(ASavedFont);
        end;
      finally
        FActiveCanvas := nil;
        CalcDrawParams(False);
      end;
    finally
      ACanvas.RestoreState;
    end;
  end;
end;

procedure TdxBarItemControl.PrepareCanvasFont(ABaseFont: HFONT;
  AStyle: TcxStyle; out ASavedFont: TdxBarSavedFont);
var
  ABaseLogFont, ALogFont: TLogFont;
begin
  ASavedFont.Saved := (AStyle <> nil) and (svFont in AStyle.AssignedValues) or
    (ABaseFont <> 0);
  if ASavedFont.Saved then
  begin
    cxGetFontData(Canvas.Font.Handle, ASavedFont.LogFont);
    if ABaseFont <> 0 then
      cxGetFontData(ABaseFont, ABaseLogFont)
    else
      ABaseLogFont := ASavedFont.LogFont;
    if (AStyle <> nil) and (svFont in AStyle.AssignedValues) then
    begin
      cxGetFontData(AStyle.Font.Handle, ALogFont);
      ALogFont.lfEscapement := ABaseLogFont.lfEscapement;
      ALogFont.lfOrientation := ALogFont.lfEscapement;
      ALogFont.lfOutPrecision := ABaseLogFont.lfOutPrecision;
      Canvas.Font.Handle := CreateFontIndirect(ALogFont);
    end
    else
      Canvas.Font.Handle := CreateFontIndirect(ABaseLogFont);
  end;
end;

procedure TdxBarItemControl.RestoreCanvasFont(const ASavedFont: TdxBarSavedFont);
begin
  if ASavedFont.Saved then
  begin
    Canvas.Font.Handle := CreateFontIndirect(ASavedFont.LogFont);
    Canvas.Handle; // RequiredState(csAllValid)
  end;
end;

function TdxBarItemControl.GetOwnedBarControl: TCustomdxBarControl;
begin
  Result := nil;
end;

function TdxBarItemControl.GetNonBufferedRect: TRect;
begin
  Result := cxEmptyRect;
end;

function TdxBarItemControl.GetCaptionWidth: Integer;
var
  ASavedFont: TdxBarSavedFont;
begin
  PrepareCanvasFont(0, Item.Style, ASavedFont);
  try
    Result := cxRectWidth(Painter.GetControlCaptionRect(FDrawParams));
  finally
    RestoreCanvasFont(ASavedFont);
  end;
end;

function TdxBarItemControl.GetCurrentImage(AViewSize: TdxBarItemControlViewSize; ASelected: Boolean;
  out ACurrentGlyph: TBitmap; out ACurrentImages: TCustomImageList; out ACurrentImageIndex: Integer): Boolean;
begin
  ACurrentImages := GetImageList(AViewSize);
  ACurrentImageIndex := GetCurrentImageIndex(AViewSize);

  if UseLargeGlyph(AViewSize) then
    ACurrentGlyph := Item.LargeGlyph
  else
    if not UseLargeImageList(AViewSize) then
      ACurrentGlyph := Glyph
    else
      ACurrentGlyph := nil;
  if not IsGlyphAssigned(ACurrentGlyph) then
    ACurrentGlyph := nil;

  Result := IsGlyphAssigned(ACurrentGlyph) or Item.IsImageIndexLinked(ACurrentImages, ACurrentImageIndex);
  if not Result then
  begin
    ACurrentGlyph := Parent.GetDefaultItemGlyph;
    Result := IsGlyphAssigned(ACurrentGlyph);
  end;
end;

function TdxBarItemControl.GetCurrentImageIndex(AViewSize: TdxBarItemControlViewSize): Integer;
begin
  if UseLargeImageSource(AViewSize) and (LargeImages <> nil) and (LargeImageIndex <> -1) then
    Result := LargeImageIndex
  else
    Result := ImageIndex;
end;

function TdxBarItemControl.GetGlyphSize(AViewSize: TdxBarItemControlViewSize; ASelected: Boolean = False): TSize;
var
  ACurrentGlyph: TBitmap;
  ACurrentImages: TCustomImageList;
  ACurrentImageIndex: Integer;
begin
  if not GetCurrentImage(AViewSize, ASelected, ACurrentGlyph, ACurrentImages, ACurrentImageIndex) then
  begin
    if AViewSize = cvsLarge then
      Result := cxSize(20, 20)
    else
      Result := cxSize(BarManager.GlyphSize, BarManager.GlyphSize);
  end
  else
    if ACurrentGlyph = nil then
      Result := cxSize(ACurrentImages.Width, ACurrentImages.Height)
    else
      Result := cxSize(ACurrentGlyph.Width, ACurrentGlyph.Height);
end;

function TdxBarItemControl.GetIndents(ADrawAreaType: TdxBarItemControlPart): TRect;
begin
  Result := Painter.ItemControlGetIndents(FDrawParams, ADrawAreaType);
end;

function TdxBarItemControl.GetRotationDependentHeight(ASourceSize: TSize): Integer;
begin
  if IsRotated then
    Result := ASourceSize.cx
  else
    Result := ASourceSize.cy;
end;

function TdxBarItemControl.GetRotationDependentWidth(ASourceSize: TSize): Integer;
begin
  if IsRotated then
    Result := ASourceSize.cy
  else
    Result := ASourceSize.cx;
end;

function TdxBarItemControl.GetTextExtent(const AText: string): TSize;
var
  ASavedFont: TdxBarSavedFont;
begin
  PrepareCanvasFont(0, Item.Style, ASavedFont);
  try
    Result := Canvas.TextExtent(AText);
  finally
    RestoreCanvasFont(ASavedFont);
  end;
end;

function TdxBarItemControl.GetTextHeight: Integer;
begin
  Result := GetTextExtent('Qq').cy;
end;

function TdxBarItemControl.GetTextSize: Integer;
begin
  if (Item.Style <> nil) and (svFont in Item.Style.AssignedValues) then
    Result := FTextSize
  else
    Result := Parent.TextSize;
end;

function TdxBarItemControl.GetTextWidth(const AText: string): Integer;
begin
  Result := GetTextExtent(AText).cx;
end;

function TdxBarItemControl.GetCaptionAreaWidth: Integer;

  function GetTailAreaSize: Integer;
  begin
    Result := Painter.GetTailAreaSize(FDrawParams);
  end;

  function GetShortCutAreaSize: Integer;
  begin
    if CanShowShortCut and (ShortCut <> 0) then
      Result := Parent.TextSize - 6 + GetTextWidth(FDrawParams.ShortCut)
    else
      Result := 0;
  end;

var
  ADescriptionWidth: Integer;
begin
  if cpText in FDrawParams.ViewStructure then
  begin
    if FDrawParams.PaintType = ptMenu then
    begin
      Result := GetCaptionWidth + GetShortCutAreaSize;
      if (MenuItemSize = misLarge) and ShowDescription and (FDrawParams.Description <> '') then
      begin
        ADescriptionWidth := cxRectWidth(cxGetTextRect(Canvas.Handle, FDrawParams.Description, 2));
        Result := Max(Result, ADescriptionWidth);
      end;
      Inc(Result, GetIndents(cpText).Left + GetIndents(cpText).Right);
      Inc(Result, GetTailAreaSize);
    end
    else
    begin
      Result := GetCaptionWidth;
      if cpIcon in FDrawParams.ViewStructure then
        Inc(Result, Painter.GetControlTextIndents.Left)
      else
        Inc(Result, GetControlCaptionOffset * 2);
    end
  end
  else
    Result := 0;
end;

function TdxBarItemControl.GetControlAreaWidth: Integer;
begin
  Result := 0;
end;

function TdxBarItemControl.GetGlyphAreaWidth: Integer;
begin
  if FDrawParams.PaintType = ptMenu then
    Result := Parent.IconAreaSize
  else
    if cpIcon in FDrawParams.ViewStructure then
      Result := GetRotationDependentWidth(FDrawParams.DefaultButtonSize)
    else
      Result := 0;
end;

function TdxBarItemControl.GetControlCaptionOffset: Integer;
begin
  Result := Parent.Font.Size div 2;
end;

function TdxBarItemControl.GetDefaultHeight: Integer;
begin
  if Parent.Kind = bkSubMenu then
    Result := GetDefaultHeightInSubMenu
  else
    if IsRotated then
      Result := InternalGetDefaultWidth
    else
      Result := InternalGetDefaultHeight;
end;

function TdxBarItemControl.GetDefaultWidth: Integer;
begin
  if FDrawParams.PaintType = ptMenu then
    Result := GetDefaultWidthInSubMenu
  else
    if IsRotated then
      Result := InternalGetDefaultHeight
    else
      Result := InternalGetDefaultWidth;
end;

function TdxBarItemControl.GetDefaultWidthHorzLayout: Integer;
begin
  Result := GetGlyphAreaWidth + GetCaptionAreaWidth + GetControlAreaWidth;
end;

function TdxBarItemControl.GetDefaultWidthVertLayout: Integer;
var
  W: Integer;
begin
  Result := GetRotationDependentWidth(GetGlyphSize(cvsLarge));

  if cpText in FDrawParams.ViewStructure then
  begin
    W := 3 + GetCaptionWidth + 3;
    if Item.GlyphLayout in [glLeft, glRight] then
      Inc(Result, W)
    else
      Result := Max(Result, W);
  end;
  Inc(Result, 1 + 4 + 4 + 1);
end;

function TdxBarItemControl.GetDefaultHeightInSubMenu: Integer;
begin
  Result := Parent.GetDefaultItemHeight(Self);
  Painter.CorrectButtonControlDefaultHeight(Result);
end;

function TdxBarItemControl.GetDefaultWidthInSubMenu: Integer;
begin
  Result := GetDefaultWidthHorzLayout;
  Painter.CorrectButtonControlDefaultWidth(Result);
end;

function TdxBarItemControl.GetMinHeight: Integer;
begin
  Result := 1;
end;

function TdxBarItemControl.GetMinWidth: Integer;
begin
  Result := 1;
end;

function TdxBarItemControl.GetHeight: Integer;
begin
  CalcDrawParams(False);
  Result := GetDefaultHeight;
end;

function TdxBarItemControl.GetWidth: Integer;
begin
  CalcDrawParams(False);
  Result := GetDefaultWidth;
end;

function TdxBarItemControl.GetWidthByViewLevel(
  AViewLevel: TdxBarItemRealViewLevel): Integer;
var
  APrevViewLevel: TdxBarItemViewLevel;
begin
  APrevViewLevel := ViewInfo.ViewLevel;
  try
    IdxBarItemControlViewInfo(ViewInfo).SetViewLevel(AViewLevel);
    Result := Width;
  finally
    IdxBarItemControlViewInfo(ViewInfo).SetViewLevel(APrevViewLevel);
  end;
end;

function TdxBarItemControl.InternalGetDefaultHeight: Integer;
begin
  if FDrawParams.ViewSize = cvsLarge then
    Result := GetLargeHeight
  else
    Result := GetSmallHeight;
end;

function TdxBarItemControl.GetLargeHeight: Integer;
var
  H: Integer;
begin
  Result := GetRotationDependentHeight(GetGlyphSize(cvsLarge));

  if cpText in FDrawParams.ViewStructure then
  begin
    H := GetTextHeight;
    if Item.GlyphLayout in [glTop, glBottom] then
      Inc(Result, H + 1)
    else
      Result := Max(Result, H);
  end;
  Inc(Result, 1 + 2 + 2 + 1);
end;

function TdxBarItemControl.GetSmallHeight: Integer;
begin
  Result := 0;
  if cpText in FDrawParams.ViewStructure then
    Result := Max(Result, GetTextSize);
  if cpIcon in FDrawParams.ViewStructure then
    Result := Max(Result, GetRotationDependentHeight(FDrawParams.DefaultButtonSize));
end;

function TdxBarItemControl.InternalGetDefaultWidth: Integer;
begin
  if FDrawParams.ViewSize = cvsLarge then
    Result := GetDefaultWidthVertLayout
  else
    Result := GetDefaultWidthHorzLayout;
end;

function TdxBarItemControl.HasHint: Boolean;
begin
  Result := (Hint <> '') and (Parent is TdxBarControl);
end;

function TdxBarItemControl.HasShadow: Boolean;
begin
  Result := FParent.ChildrenHaveShadows;
end;

function TdxBarItemControl.HotPartWantMouse: Boolean;
begin
  Result := WantMouse;
end;

function TdxBarItemControl.IsBkColorAssigned: Boolean;
begin
  Result := FBkBrush <> 0;
end;

function TdxBarItemControl.IsChildWindow(AWnd: HWND): Boolean;
begin
  Result := IsChildEx(Parent.Handle, AWnd);
end;

function TdxBarItemControl.IsDestroyOnClick: Boolean;
begin
  Result := True;
end;

function TdxBarItemControl.IsDropDown: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.IsEditTransparent: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.IsExpandable: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.IsHiddenForCustomization: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.IsInvertTextColor: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.IsMenuItem: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.IsRotated: Boolean;
begin
  Result := Parent.IsVertical;
end;

function TdxBarItemControl.IsSelectionForbidden: Boolean;
begin
  Result := (Parent.IsCustomizing and (BarManager <> GetItemBarManager) and
      not (csAncestor in BarManager.ComponentState));
end;

function TdxBarItemControl.MousePressed: Boolean;
var
  R: TRect;
  P: TPoint;
begin
  R := Parent.GetItemRect(Self);
  P := Parent.ScreenToClient(GetMouseCursorPos);
  Result := Enabled and PtInRect(R, P);
  if Result then
    if InMouseHook then
      Result := LeftButtonPressed
    else
      Result := GetKeyState(VK_LBUTTON) < 0;
end;

function TdxBarItemControl.NeedCaptureMouse: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.WantMouse: Boolean;
begin
  Result := CanSelect or CanClicked;
end;

procedure TdxBarItemControl.CheckNonRecent;
begin
  if Parent.Kind = bkSubMenu then
    SubMenuParent.FNonRecent := FNonRecent;
end;

procedure TdxBarItemControl.UncheckNonRecent;
begin
  if Parent.Kind = bkSubMenu then
    SubMenuParent.FNonRecent := False;
end;

procedure TdxBarItemControl.BeginResize(APoint: TPoint);
begin
// do nothing
end;

function TdxBarItemControl.CanResize(APoint: TPoint): Boolean;
begin
  Result := False;
end;

procedure TdxBarItemControl.EndResize(AAllowResize: Boolean);
begin
// do nothing
end;

procedure TdxBarItemControl.Resizing(APoint: TPoint);
begin
// do nothing
end;

class function TdxBarItemControl.HasWindow: Boolean;
begin
  Result := False;
end;

function TdxBarItemControl.IsDroppedDown: Boolean;
begin
  Result := False;
end;

procedure TdxBarItemControl.Repaint;
begin
  if Parent.HandleAllocated then
    Parent.UpdateItem(Self);
end;

{ TdxBarCustomStaticControl}

function TdxBarCustomStaticControl.CanClicked: Boolean;
begin
  Result := False;
end;

function TdxBarCustomStaticControl.CanSelect: Boolean;
begin
  Result := inherited CanSelect and BarManager.IsCustomizing;
end;

procedure TdxBarCustomStaticControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
begin
  Painter.DrawStaticGlyphAndCaption(DrawParams, ARect);
end;

function TdxBarCustomStaticControl.GetDefaultViewStructure: TdxBarItemControlViewStructure;
begin
  Result := [];
  if Item.ShowCaption then
    Result := [cpText];
  if IconAssigned(GetViewSize) then
    Include(Result, cpIcon);
end;

function TdxBarCustomStaticControl.GetDrawParamsClass: TdxBarItemControlDrawParamsClass;
begin
  Result := TdxBarStaticLikeControlDrawParams;
end;

function TdxBarCustomStaticControl.GetDrawParams: TdxBarStaticLikeControlDrawParams;
begin
  Result := TdxBarStaticLikeControlDrawParams(FDrawParams);
end;

{ TdxBarSeparatorControl }

procedure TdxBarSeparatorControl.CalcDrawParams(AFull: Boolean = True);
begin
  inherited;
  DrawParams.IsTop := ItemLink.VisibleIndex = 0;
end;

procedure TdxBarSeparatorControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
begin
  Painter.DrawSeparatorControl(DrawParams, ARect);
end;

function TdxBarSeparatorControl.GetIndents(ADrawAreaType: TdxBarItemControlPart): TRect;
begin
  Result := Painter.SeparatorControlGetIndents(DrawParams, ADrawAreaType);
end;

function TdxBarSeparatorControl.GetMenuItemSize: TdxBarMenuItemSize;
begin
  Result := misNormal;
end;

function TdxBarSeparatorControl.GetGlyphAreaWidth: Integer;
begin
  Result := 0;
end;

function TdxBarSeparatorControl.GetDefaultHeightInSubMenu: Integer;
const
  ASeparatorsCount: array [Boolean] of Integer = (2, 1);
begin
  if cpText in DrawParams.ViewStructure then
    Result := inherited GetDefaultHeightInSubMenu + Painter.SubMenuGetSeparatorSize * ASeparatorsCount[DrawParams.IsTop]
  else
    Result := Parent.BeginGroupSize
end;

function TdxBarSeparatorControl.GetDefaultWidthInSubMenu: Integer;
begin
  Result := inherited GetDefaultWidthInSubMenu;
end;

function TdxBarSeparatorControl.GetMinWidth: Integer;
begin
  Result := Parent.IconAreaSize + Painter.GetTailAreaSize(FDrawParams);
end;

function TdxBarSeparatorControl.InternalGetDefaultHeight: Integer;
begin
  Result := GetTextSize;
end;

function TdxBarSeparatorControl.InternalGetDefaultWidth: Integer;
begin
  Result := Parent.BeginGroupSize;
end;

procedure TdxBarSeparatorControl.PrepareCanvasFont(ABaseFont: HFONT; AStyle: TcxStyle;
  out ASavedFont: TdxBarSavedFont);
begin
  Canvas.Font.Style := [fsBold];
end;

procedure TdxBarSeparatorControl.RestoreCanvasFont(const ASavedFont: TdxBarSavedFont);
begin
  Canvas.Font.Style := [];
end;

function TdxBarSeparatorControl.GetDefaultViewStructure: TdxBarItemControlViewStructure;
begin
  if (DrawParams.PaintType = ptMenu) and Item.ShowCaption then
    Result := [cpText]
  else
    Result := [];
end;

function TdxBarSeparatorControl.GetDrawParamsClass: TdxBarItemControlDrawParamsClass;
begin
  Result := TdxBarSeparatorControlDrawParams;
end;

function TdxBarSeparatorControl.GetDrawParams: TdxBarSeparatorControlDrawParams;
begin
  Result := TdxBarSeparatorControlDrawParams(FDrawParams);
end;

{ TdxBarWinControl }

procedure TdxBarWinControl.DefaultHandler(var Message);
begin
  inherited;
  if Handle <> 0 then
    with TMessage(Message) do
      Result := CallWindowProc(FPrevDefWndProc, Handle, Msg, WParam, LParam);
end;

class function TdxBarWinControl.HasWindow: Boolean;
begin
  Result := True;
end;

function TdxBarWinControl.HandleAllocated: Boolean;
begin
  Result := Handle <> 0;
end;

function TdxBarWinControl.DoCallKeyboardHook(wParam: WParam; lParam: LParam): Boolean;
begin
  DontCallNextKeybHook := True;
  try
    Result := dxBarKeyboardHook(0, WParam, LParam) = 1;
  finally
    DontCallNextKeybHook := False;
  end;
end;

function TdxBarWinControl.GetItem: TdxBarWindowItem;
begin
  Result := TdxBarWindowItem(ItemLink.Item);
end;

function TdxBarWinControl.GetWindowRect: TRect;
begin
  if Enabled and not Item.EmptyWindow then
    Result := FWindowRect
  else
    Result := cxEmptyRect;
end;

procedure TdxBarWinControl.SetWindowRect(const Value: TRect);
var
  R: TRect;
begin
  FWindowRect := Value;
  if IsWindowVisible(Handle) then
  begin
    R := cxGetWindowRect(Handle);
    MapWindowRect(0, Parent.Handle, R);
    if not EqualRect(R, FWindowRect) then
    begin
      with WindowRect do
        SetWindowPos(Handle, 0, Left, Top,
          Right - Left, Bottom - Top, SWP_NOZORDER or SWP_NOACTIVATE {SWP_SHOWWINDOW});
      PrepareEditWnd;
    end;
  end;
end;

function TdxBarWinControl.CanClicked: Boolean;
begin
  Result := FParent.IsVertical;
end;

function TdxBarWinControl.CanDeselect(ABarManager: TdxBarManager): Boolean;
begin
  Result := inherited CanDeselect(ABarManager) and
    ((BarManager = ABarManager) or
      IsMDIForm(ABarManager.MasterForm) and IsMDIChild(BarManager.MasterForm) and not FFocusing);
end;

function TdxBarWinControl.CanSelect: Boolean;
begin
  Result := inherited CanSelect and Item.CanSelect;
end;

procedure TdxBarWinControl.ControlInactivate(Immediately: Boolean);
begin
  inherited;
  Focused := False;
end;

procedure TdxBarWinControl.ControlClick(AByMouse: Boolean; AKey: Char = #0);
begin
  Focused := True;
  inherited;
  ActivateEdit(AByMouse, AKey);
end;

procedure TdxBarWinControl.ControlGetFocus(AIsSelected: Boolean; var AProcessed: Boolean);
begin
  if AIsSelected and Focused then
  begin
    AProcessed := True;
    if not PtInRect(WindowRect, GetMouseCursorPos) then
      TransferMessage(Parent.Handle, Parent.FCurrentMessage);
  end
  else
    inherited
end;

procedure TdxBarWinControl.EnabledChanged;
begin
  Focused := False;
  inherited;
end;

function TdxBarWinControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarWinControlAccessibilityHelper;
end;

function TdxBarWinControl.IsChildWindow(AWnd: HWND): Boolean;
begin
  Result := inherited IsChildWindow(AWnd) or IsChildEx(Handle, AWnd);
end;

function TdxBarWinControl.IsDestroyOnClick: Boolean;
begin
  Result := False;
end;

function TdxBarWinControl.IsWindowEnabled: Boolean;
begin
  Result := Parent.IsWindowEnabled and
    (not HandleAllocated or Windows.IsWindowEnabled(Handle));
end;

procedure TdxBarWinControl.KeyDown(var Key: Word; Shift: TShiftState);

  function IsSysKeyDown: Boolean;
  begin
    Result := (Key = VK_F10) or (Key = VK_MENU) or (ssAlt in Shift);
  end;

  function IsWindowDistroyed: Boolean;
  begin
    Result := Handle = 0;
  end;

var
  ALinkSelf: TcxObjectLink;
begin
  if IsSysKeyDown then
    SysKeyDown(Key, Shift)
  else
  begin
    ALinkSelf := cxAddObjectLink(Self);
    try
      Item.KeyDown(Key, Shift);
      if (ALinkSelf.Ref = nil) or IsWindowDistroyed then
        Key := 0;
      case Key of
        VK_ESCAPE:
          begin
            DoEscape;
            Key := 0;
          end;
        VK_RETURN:
          begin
            DoEnter;
            Key := 0;
         end;
        VK_TAB:
          begin
            DoNavigation;
            Key := 0;
          end;
      end;
    finally
      cxRemoveObjectLink(ALinkSelf);
    end;
  end;
end;

procedure TdxBarWinControl.KeyPress(var Key: Char);
begin
  Item.KeyPress(Key);
end;

procedure TdxBarWinControl.KeyUp(var Key: Word; Shift: TShiftState);

  function IsSysKeyUp: Boolean;
  begin
    Result := (Key = VK_MENU) or (ssAlt in Shift);
  end;

begin
  if IsSysKeyUp then
    SyskeyUp(Key, Shift)
  else
    Item.KeyUp(Key, Shift);
end;

function TdxBarWinControl.ClientToParent(const APoint: TPoint): TPoint;
begin
  Result := APoint;
  MapWindowPoint(Handle, Parent.Handle, Result);
end;

function TdxBarWinControl.ParentToClient(const APoint: TPoint): TPoint;
begin
  Result := APoint;
  MapWindowPoint(Parent.Handle, Handle, Result);
end;

procedure TdxBarWinControl.CreateInnerEdit;
begin
  if Handle <> 0 then
  begin
    FDefWndProc := MakeObjectInstance(MainWndProc);
    FPrevDefWndProc := Pointer(SetWindowLong(Handle, GWL_WNDPROC, Longint(FDefWndProc)));
  end;
end;

procedure TdxBarWinControl.DestroyInnerEdit(AFullDestroy: Boolean = True);
begin
  if Handle <> 0 then
  begin
    Focused := False;
    SetWindowLong(Handle, GWL_WNDPROC, Longint(FPrevDefWndProc));
    FreeObjectInstance(FDefWndProc);
    FDefWndProc := nil;
  end;
end;

procedure TdxBarWinControl.DoEnter;
var
  AHandle: HWND;
  AParent: TCustomdxBarControl;
begin
  AHandle := Handle;
  AParent := Parent;
  if (ItemLink.RealItemLink <> nil) then
    ItemLink.RealItemLink.BringToTopInRecentList(True);
  StoreDisplayValue;
  if IsWindowVisible(AHandle) then
  begin
    AParent.SetKeySelectedItem(nil);
    KillBeep(AHandle);
    AParent.HideAll;
  end;
end;

procedure TdxBarWinControl.DoEscape;
begin
  Parent.SetKeySelectedItem(nil);
  KillBeep(Handle);
  Parent.AfterControlEscape(Self);
end;

procedure TdxBarWinControl.DoNavigation;
begin
  StoreDisplayValue;
  if IsWindowVisible(Handle) then
  begin
    KillBeep(Handle);
    BarNavigationController.HandleKey(VK_TAB, []);
  end;
end;

function TdxBarWinControl.DoKeyDown(var Message: TWMKey): Boolean;
begin
  KeyDown(Message.CharCode, KeyDataToShiftState(Message.KeyData));
  Result := (Message.CharCode = 0);
end;

function TdxBarWinControl.DoKeyPress(var Message: TWMKey): Boolean;
var
  Ch: Char;
begin
  Ch := Char(Message.CharCode);
  KeyPress(Ch);
  Message.CharCode := Word(Ch);
  Result := (Ch = #0);
end;

function TdxBarWinControl.DoKeyUp(var Message: TWMKey): Boolean;
begin
  KeyUp(Message.CharCode, KeyDataToShiftState(Message.KeyData));
  Result := (Message.CharCode = 0);
end;

procedure TdxBarWinControl.DoKillFocus(var Message: TMessage);
begin
  KillFocus(Message.WParam);
end;

procedure TdxBarWinControl.DoMouseDown(var Message: TWMMouse;
  AButton: TMouseButton; AShift: TShiftState);
var
  APoint: TPoint;
begin
  MouseDown(AButton, KeysToShiftState(Message.Keys), Message.XPos, Message.YPos);

  if mbRight = AButton then
  begin
    APoint := ClientToParent(Point(Message.XPos, Message.YPos));
    SendMessage(Parent.Handle, WM_RBUTTONDOWN, Message.Keys, MakeLParam(APoint.X, APoint.Y));
  end;
end;

procedure TdxBarWinControl.ActivateEdit(AByMouse: Boolean; AKey: Char = #0);
var
  P: TPoint;
begin
  if AByMouse then
  begin
    P := Parent.ScreenToClient(GetMouseCursorPos);
    if not PtInRect(WindowRect, P) then
    begin
      P := ParentToClient(P);
      SendMessage(Handle, WM_LBUTTONDOWN, ShiftStateToKeys(InternalGetShiftState), MakeLParam(P.X, P.Y));
    end;
  end;
end;

function TdxBarWinControl.GetText: string;
var
  S: PChar;
  Len: Integer;
begin
  if Handle <> 0 then
  begin
    S := StrAlloc(256);
    Len := SendMessage(Handle, WM_GETTEXT, 255, Longint(S));
    if Len = 0 then Result := ''
    else Result := S;
    StrDispose(S);
  end;
end;

procedure TdxBarWinControl.KillFocus(AHandle: THandle);
begin
  // do nothing
end;

procedure TdxBarWinControl.MainWndProc(var Message: TMessage);
begin
  try
    WndProc(Message);
  except
    Application.HandleException(Self);
  end;
end;

procedure TdxBarWinControl.PrepareEditWnd;
begin
  // do nothing
end;

procedure TdxBarWinControl.RestoreDisplayValue;
begin
  Text := Item.Text;
end;

procedure TdxBarWinControl.SetFocused(Value: Boolean);
var
  IsDesignForm: Boolean;

  procedure SetTopMosts(AShow: Boolean);
  begin
    if BarDesignController.IsCustomizedByPopup then
      BarDesignController.SetCustomizePopupTopMosts(AShow);
  end;

begin
  if FFocused <> Value then
  begin
    FFocused := Value;
    if FFocused then
    begin
      if BarManager.FChangingFocusedItemControlLockCount = 0 then
        BarManager.FPrevFocusedControl := Windows.GetFocus;
      if not IsActive then
        ControlActivate(True);
      Parent.MakeItemControlFullyVisible(Self);
      Show;
    end
    else
    begin
{      if FHandle <> 0 then
        SetWindowPos(Handle, 0, 0, 0, 0, 0,
          SWP_NOZORDER or SWP_NOMOVE or SWP_NOSIZE or SWP_HIDEWINDOW or SWP_NOACTIVATE);}

      Hide(BarManager.AlwaysSaveText and
        ((GetAsyncKeyState(VK_ESCAPE) >= 0) or
         (GetAsyncKeyState(VK_CONTROL) < 0) or (GetAsyncKeyState(VK_MENU) < 0)));

      if (Barmanager.FChangingFocusedItemControlLockCount = 0) and
        not (bisToolbarsVisibleChanging in BarManager.FInternalState) and not BarManager.IsDestroying then
      begin
        IsDesignForm := (dxBarCustomizingForm <> nil) and
          (GetParentForm(FindControl(Barmanager.FPrevFocusedControl)) = dxBarCustomizingForm);
        if IsDesignForm then
          SetTopMosts(True);
        if (Barmanager.FPrevFocusedControl > 0) and IsWindowVisible(Barmanager.FPrevFocusedControl) then
          SetFocus(Barmanager.FPrevFocusedControl)
        else
          if IsControlVisible(BarManager.Owner) then
            Windows.SetFocus(BarManager.Owner.Handle)
          else
            Windows.SetFocus(GetNextWindow(BarManager.Owner.Handle, GW_HWNDNEXT));
        if IsDesignForm then SetTopMosts(False);
        Barmanager.FPrevFocusedControl := 0;
      end;
    end;
  end;
end;

procedure TdxBarWinControl.SetText(Value: string);
begin
  SetWindowText(Handle, PChar(Value));
  if Item.EmptyWindow then Repaint;
end;

procedure TdxBarWinControl.Show;
begin
  FOnGlass := Parent.IsOnGlass;
end;

procedure TdxBarWinControl.StoreDisplayValue;
begin
  Item.Text := Text;
end;

procedure TdxBarWinControl.SysKeyDown(var Key: Word; Shift: TShiftState); 
begin
  Inc(FKeyPressedInside);
  case Key of
    VK_MENU: Key := 0;
    VK_F10:
      begin
        FKeyPressedInside := 0;
        Parent.HideAll;
        if (ssShift in Shift) or DoCallKeyboardHook(Key, 1) then
          Key := 0;
      end;
  end;
end;

procedure TdxBarWinControl.SysKeyUp(var Key: Word; Shift: TShiftState);
begin
  if FKeyPressedInside > 0 then
  begin
    FKeyPressedInside := 0;
    if (Key = VK_MENU) then
    begin
      Parent.HideAll;
      WaitForMenu := True;
      if DoCallKeyboardHook(Key, Integer($80000001)) then
        Key := 0;
    end;
  end
  else
    Key := 0;
end;

procedure TdxBarWinControl.TransferMessage(AFromWindow: HWND; const Message: TMessage);
var
  APoint: TPoint;
begin
  case Message.Msg of
    WM_MOUSEFIRST..WM_MOUSELAST:
      begin
        APoint := SmallPointToPoint(TSmallPoint(Message.lParam));
        MapWindowPoint(AFromWindow, Handle, APoint);
        SendMessage(Handle, Message.Msg, Message.WParam, MakeLParam(APoint.X, APoint.Y));
      end;
  end;
end;

procedure TdxBarWinControl.WndProc(var Message: TMessage);
var
  AItem: TdxBarWindowItem;
  AFocusedParent: HWND;
  ALinkSelf: TcxObjectLink;
  P: TPoint;
begin
  AItem := Item;
  ALinkSelf := cxAddObjectLink(Self);
  try
    case Message.Msg of
      WM_SETFOCUS:
        AItem.DoEnter;
      WM_KILLFOCUS:
        try
          DoKillFocus(Message);
          if Focused then
          begin
            DefaultHandler(Message);
            //KillBeep(Handle);
            Parent.HideAll;
            Exit;
          end;
          if Parent is TdxBarControl then
          begin
            if GetFocus = Parent.Handle then
              AFocusedParent := Parent.Handle
            else
              AFocusedParent := GetParent(GetFocus);
            if not (FindControl(AFocusedParent) is TdxBarControl) then
              AFocusedParent := GetParent(AFocusedParent);
            if AFocusedParent <> Parent.Handle then
            begin
              DefaultHandler(Message);
              KillBeep(Handle);
              Parent.HideAll;
              Exit;
            end;
          end;
        finally
          AItem.DoExit;
        end;
      WM_MOUSEFIRST..WM_MOUSELAST:
        case Message.Msg of
          WM_RBUTTONDOWN:
            begin
              DoMouseDown(TWMMouse(Message), mbRight, []);
              Exit;
            end;
          WM_MOUSEMOVE: ;
        else
          P := ClientToParent(Point(TWMMouse(Message).XPos, TWMMouse(Message).YPos));
          if (GetCapture <> Handle) and
            not PtInRect(WindowRect, P) and PtInRect(Parent.GetItemRect(Self), P) then
              Exit;
        end;
      WM_CHAR:
        if DoKeyPress(TWMKey(Message)) then
          Exit;
      WM_KEYDOWN, WM_SYSKEYDOWN:
        if DoKeyDown(TWMKey(Message)) then
          Exit;
      WM_KEYUP, WM_SYSKEYUP:
        if DoKeyUp(TWMKey(Message)) then
          Exit;
      WM_COMMAND:
        if (HiWord(Message.WParam) = EN_CHANGE) and not FFocusing then
          Item.CurChange;
    end;
    if ALinkSelf.Ref <> nil then
      DefaultHandler(Message);
  finally
    cxRemoveObjectLink(ALinkSelf);
  end;
end;

{ TdxBarButtonLikeControl }

procedure FinishSubMenuTracking(var ADropDownControl: TdxBarButtonLikeControl; var ATimerID: DWORD);
begin
  dxKillTimer(0, ATimerID);
  ADropDownControl := nil;
end;

procedure FinishSubMenuActivationTracking;
begin
  FinishSubMenuTracking(ABarActivationDropDownControl, ABarActivationDropDownControlTimerID);
end;

procedure FinishSubMenuDeActivationTracking;
begin
  FinishSubMenuTracking(ABarDeActivationDropDownControl, ABarDeActivationDropDownControlTimerID);
end;

procedure DeActivateSubMenu;
begin
  if ABarDeActivationDropDownControl <> nil then
    ABarDeActivationDropDownControl.ControlInActivate(True);
  FinishSubMenuDeActivationTracking;
end;

procedure ActivateSubMenu;
begin
  if ABarActivationDropDownControl <> nil then
    ABarActivationDropDownControl.ControlActivate(True);
  FinishSubMenuActivationTracking;
end;

procedure ActivateSubMenuTimerProc(Wnd: HWnd; Msg, TimerID, SysTime: Longint); stdcall;
begin
  ActivateSubMenu;
end;

procedure DeActivateSubMenuTimerProc(Wnd: HWnd; Msg, TimerID, SysTime: Longint); stdcall;
begin
  DeActivateSubMenu;
end;

procedure StartSubMenuActivationTracking(ADropDownControl: TdxBarButtonLikeControl);
begin
  ABarActivationDropDownControl := ADropDownControl;
  ABarActivationDropDownControlTimerID := SetTimer(0, 0, dxBarWaitForSubMenuTime, @ActivateSubMenuTimerProc);
end;

procedure StartSubMenuDeActivationTracking(ADropDownControl: TdxBarButtonLikeControl);
begin
  ABarDeActivationDropDownControl := ADropDownControl;
  ABarDeActivationDropDownControlTimerID := SetTimer(0, 0, dxBarWaitForSubMenuTime, @DeActivateSubMenuTimerProc);
end;

destructor TdxBarButtonLikeControl.Destroy;
begin
  FinishSubMenuTracking;
  if (SubMenuControl <> nil) {and not ItemLink.Item.IsDestroying} then
    SubMenuControl.Hide;
  inherited;
end;

function TdxBarButtonLikeControl.ArrowWidth: Integer;
begin
  if Parent.Kind = bkSubMenu then
    Result := Parent.MenuArrowWidth
  else
    Result := Painter.RealButtonArrowWidth(BarManager);
end;

procedure TdxBarButtonLikeControl.CalcDrawParams(AFull: Boolean = True);
begin
  inherited CalcDrawParams(AFull);
  if AFull then
  begin
    DrawParams.ButtonGroup := ViewInfo.RealPositionInButtonGroup;
    DrawParams.IsTextSelected := IsTextSelected;
    DrawParams.IsFlatText := IsFlatText;
  end;

  DrawParams.ArrowSize := cxSize(ArrowWidth, Parent.MenuArrowHeight);
end;

function TdxBarButtonLikeControl.CanBePartOfButtonGroup: Boolean;
begin
  Result := True;
end;

function TdxBarButtonLikeControl.CanFade: Boolean;
begin
  Result := IsFadingAvailable and not IsDroppedDown;
end;

function TdxBarButtonLikeControl.CanActivate: Boolean;
begin
  Result := Enabled or BarManager.Designing;
end;

procedure TdxBarButtonLikeControl.ControlActivate(Immediately: Boolean);
begin
  if IsDroppedDown then
    FinishSubMenuTracking
  else
  begin
    inherited;
    if IsDropDown and CanActivate then
    begin
      if Parent is TdxBarControl then
        if Parent.IsCustomizing or TdxBarControl(Parent).IsDowned then
          Immediately := True
        else
          Exit;
      if not Immediately and not BarManager.IsCustomizing then
        StartSubMenuTracking(True)
      else
      begin
        DeActivateSubMenu;
        DoDropDown(True);
      end;
    end;
  end;
end;

procedure TdxBarButtonLikeControl.ControlInactivate(Immediately: Boolean);
begin
  if Parent is TdxBarControl then
    Immediately := True;

  if not Immediately and {(ABarDeActivationDropDownControl = nil) and }(Parent <> nil) and
    not Parent.IsDestroying and not BarManager.IsCustomizing then
  begin
    StartSubMenuTracking(False);
    Exit;
  end;

  inherited;

  DoCloseUp(SubMenuControl <> nil);
end;

procedure TdxBarButtonLikeControl.ControlGetFocus(AIsSelected: Boolean; var AProcessed: Boolean);
begin
  if not AIsSelected then
    inherited
  else
    if Parent.IsDowned and IsDroppedDown then
      Parent.BarLostFocus;
end;

procedure TdxBarButtonLikeControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
begin
  Painter.DrawButtonLikeControl(DrawParams, ARect);
end;

procedure TdxBarButtonLikeControl.DropDown(AByMouse: Boolean);
begin
  Parent.IsDowned := True;
end;

function TdxBarButtonLikeControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarButtonLikeControlAccessibilityHelper;
end;

function TdxBarButtonLikeControl.GetDrawParamsClass: TdxBarItemControlDrawParamsClass;
begin
  Result := TdxBarButtonLikeControlDrawParams;
end;

function TdxBarButtonLikeControl.GetSubMenuControl: TdxBarSubMenuControl;
begin
  Result := nil;
end;

procedure TdxBarButtonLikeControl.GetFadingParams(out AFadeOutImage: TcxBitmap;
  out AFadeInImage: TcxBitmap; var AFadeInAnimationFrameCount: Integer;
  var AFadeInAnimationFrameDelay: Integer; var AFadeOutAnimationFrameCount: Integer;
  var AFadeOutAnimationFrameDelay: Integer);

  procedure PrepareImage(const ABitmap: TcxBitmap;
    AFadingHelper: IdxFadingPainterHelper; ADrawHot: Boolean);
  var
    ADrawParams: TdxBarButtonLikeControlDrawParams;
  begin
    FActiveCanvas := ABitmap.cxCanvas;
    CalcDrawParams;
    try
      ADrawParams := DrawParams;
      with ItemBounds do
        SetViewportOrgEx(ABitmap.cxCanvas.Handle, -Left, -Top, nil);
      ADrawParams.DrawSelected := ADrawHot;
      if not ADrawHot then
        ADrawParams.HotPartIndex := icpNone;
      AFadingHelper.DrawButtonBackground(DrawParams);
      ABitmap.cxCanvas.ViewportOrg := cxNullPoint;
    finally
      FActiveCanvas := nil;
      CalcDrawParams(False);
    end;
  end;

var
  AFadingHelper: IdxFadingPainterHelper;
  R: TRect;
begin
  if (DrawParams.PaintType <> ptMenu) and
    Supports(Painter, IdxFadingPainterHelper, AFadingHelper) then
  begin
    R := ItemBounds;
    OffsetRect(R, -R.Left, -R.Top);
    AFadeInImage := TcxBitmap.CreateSize(R, pf32bit);
    AFadeOutImage := TcxBitmap.CreateSize(R, pf32bit);
    PrepareImage(AFadeOutImage, AFadingHelper, False);
    PrepareImage(AFadeInImage, AFadingHelper, True);
  end;
end;

function TdxBarButtonLikeControl.IsFlatText: Boolean;
begin
  Result := Painter.UseTextColorForItemArrow;
end;

function TdxBarButtonLikeControl.IsTextSelected: Boolean;
begin
  Result := Painter.IsCustomSelectedTextColorExists(Self);
end;

procedure TdxBarButtonLikeControl.KeyDown(var Key: Word; Shift: TShiftState);
begin
  inherited;
  if WantsKey(Key) then
    DropDown(False);
end;

function TdxBarButtonLikeControl.WantsKey(Key: Word): Boolean;
begin
  Result := inherited WantsKey(Key) or
    IsDropDown and
    ((Parent.Kind = bkSubMenu) and (Key = VK_RIGHT) or
     (Parent.Kind <> bkSubMenu) and (Key in [VK_UP, VK_DOWN]));
end;

procedure TdxBarButtonLikeControl.FinishSubMenuTracking;
begin
  if ABarActivationDropDownControl = Self then
    FinishSubMenuActivationTracking;
  if ABarDeActivationDropDownControl = Self then
    FinishSubMenuDeActivationTracking;
end;

procedure TdxBarButtonLikeControl.StartSubMenuTracking(AActivation: Boolean);
begin
  if AActivation then
  begin
    if ABarDeActivationDropDownControl = Self then
      FinishSubMenuDeActivationTracking;
    if ABarActivationDropDownControl <> nil then
      FinishSubMenuActivationTracking;
    StartSubMenuActivationTracking(Self);
  end
  else
  begin
    if ABarActivationDropDownControl = Self then
      FinishSubMenuActivationTracking;
    if IsDroppedDown then
    begin
      if ABarDeActivationDropDownControl <> nil then
        FinishSubMenuDeActivationTracking;
      StartSubMenuDeActivationTracking(Self);
    end;
  end;
end;

procedure TdxBarButtonLikeControl.DoCloseUp(AHadSubMenuControl: Boolean);
begin
  FinishSubMenuTracking;
  if AHadSubMenuControl then
    SubMenuControl.Hide;
  Repaint;
end;

function TdxBarButtonLikeControl.GetDrawParams: TdxBarButtonLikeControlDrawParams;
begin
  Result := TdxBarButtonLikeControlDrawParams(FDrawParams);
end;

{ TdxBarButtonControl }

function TdxBarButtonControl.IsDroppedDown: Boolean;
begin
  Result := FDroppedDown and (SubMenuControl <> nil);
end;

function TdxBarButtonControl.GetButtonItem: TdxBarButton;
begin
  if Item is TdxBarButton then
    Result := TdxBarButton(Item)
  else
    Result := nil;
end;

function TdxBarButtonControl.GetDown: Boolean;
begin
  if ButtonItem <> nil then
    Result := ButtonItem.Down
  else
    Result := False;
end;

function TdxBarButtonControl.GetDropDownEnabled: Boolean;
begin
  Result := (ButtonItem <> nil) and ButtonItem.DropDownEnabled;
end;

function TdxBarButtonControl.GetDroppedDownFlat: Boolean;
begin
  Result := Painter.IsFlatItemText and IsDroppedDown;
end;

function TdxBarButtonControl.GetGroupIndex: Integer;
begin
  Result := ButtonItem.GroupIndex;
end;

function TdxBarButtonControl.GetInternalStates: TdxBarButtonStates;
begin
  if ButtonItem <> nil then
    Result := ButtonItem.FInternalStates
  else
    Result := [];
end;

function TdxBarButtonControl.GetLowered: Boolean;
begin
  Result := (ButtonItem <> nil) and ButtonItem.Lowered;
end;

function TdxBarButtonControl.MouseOverArrow: Boolean;
begin
  Result := IsDropDown and (FHotPartIndex = bcpDropButton);
end;

function TdxBarButtonControl.ArrowPressed: Boolean;
begin
  Result := MousePressed and MouseOverArrow;
end;

procedure TdxBarButtonControl.CalcDrawParams(AFull: Boolean = True);
begin
  inherited CalcDrawParams(AFull);
  if AFull then
  begin
    DrawParams.ShortCut := ShortCutToText(ShortCut);
    DrawParams.IsPressed := IsPressed;
    DrawParams.Downed := Down;
    DrawParams.DrawDowned := DrawParams.IsPressed;
    DrawParams.DroppedDown := DroppedDown;
    DrawParams.DroppedDownFlat := DroppedDownFlat;
    DrawParams.SplitDropDown := True;
    DrawParams.DropDownEnabled := DropDownEnabled;
    DrawParams.GrayScale := GrayScale;
    DrawParams.IsLowered := Lowered;
  end;
end;

procedure TdxBarButtonControl.CalcParts;
begin
  inherited;
  Painter.CalculateButtonParts(DrawParams, FParts, ItemBounds);
end;

procedure TdxBarButtonControl.ControlClick(AByMouse: Boolean; AKey: Char = #0);
begin
  inherited;

//#DG TODO:
  if (Parent is TdxBarControl) and not TdxBarControl(Parent).IsDowned then
    Exit;

  if IsDropDown and ArrowPressed then
    ControlActivate(True)
  else
    if (Parent is TdxBarControl) or IsDropDown then
      Repaint;
end;

procedure TdxBarButtonControl.ControlUnclick(ByMouse: Boolean);
begin
  if not ByMouse or (FHotPartIndex = bcpButton) then
  begin
    if (ButtonItem <> nil) and (bstChecked in ButtonItem.FInternalStates) then
      ButtonItem.Down := not ButtonItem.Down;
    ControlInactivate(True);
    inherited;
  end;
end;

procedure TdxBarButtonControl.ControlGetFocus(AIsSelected: Boolean; var AProcessed: Boolean);
begin
  if AIsSelected and Parent.IsDowned and IsDroppedDown and (FHotPartIndex = bcpButton) then
  begin
    if bboSubMenuCaptureMouse in Parent.BehaviorOptions then
      Parent.BarLostFocus;
    Parent.BarGetFocus(Self)
  end
  else
    inherited;
end;

procedure TdxBarButtonControl.DoCloseUp(AHadSubMenuControl: Boolean);
begin
  if AHadSubMenuControl then
    SubMenuControl.FDropDownButton := nil;
  FDroppedDown := False;
  inherited;
end;

procedure TdxBarButtonControl.DoDropDown(AByMouse: Boolean);
var
  Rect: TRect;
  P: TPoint;
begin
  if not FDroppedDown and Enabled and DropDownEnabled and
    (ButtonItem.DropDownMenu <> nil) then
  begin
    FDroppedDown := True;
    Parent.MakeItemControlFullyVisible(Self);
    Repaint;
    Rect := Parent.GetItemRect(Self);
    with Rect do
      if (Parent.Kind = bkSubMenu) or Parent.IsRealVertical then
      begin
        P := Point(Right, Top);
        if {not Flat or }(Parent.Kind = bkSubMenu) then // fix
          Dec(P.Y, SubMenuParent.BorderSize);
      end
      else
        P := Point(Left, Bottom);
    P := Parent.ClientToScreen(P);
    ButtonItem.DoDropDown(Self, P.X, P.Y, AByMouse);
    if Painter.IsDropDownRepaintNeeded then Repaint;
  end;
end;

function TdxBarButtonControl.DrawSelected: Boolean;
begin
  Result := inherited DrawSelected and not FParent.IsCustomizing or Pressed;
end;

procedure TdxBarButtonControl.DropDown(AByMouse: Boolean);
begin
  inherited;
  DoDropDown(AByMouse);
end;

function TdxBarButtonControl.GetSubMenuControl: TdxBarSubMenuControl;
begin
  if (ButtonItem <> nil) and (ButtonItem.DropDownMenu <> nil) then
    Result := TdxBarSubMenuControl(ButtonItem.DropDownMenu.ItemLinks.BarControl)
  else
    Result := nil;
end;

function TdxBarButtonControl.IsFlatText: Boolean;
begin
  Result := not IsTextSelected or inherited IsFlatText;
end;

function TdxBarButtonControl.IsTextSelected: Boolean;
begin
  Result := Painter.IsFlatItemText and
    (((IsPressed or Down and DrawSelected) and Painter.IsItemTextSelectedInverted) or
    ((IsPressed or Down or DrawSelected) and (IsHighContrastWhite and not DroppedDown or inherited IsTextSelected)));
end;

function TdxBarButtonControl.GetDefaultHeight: Integer;
begin
  Result := inherited GetDefaultHeight;
  if Lowered then
    Inc(Result, 2 * Painter.LoweredBorderSize(Self));
end;

function TdxBarButtonControl.GetDefaultWidth: Integer;
begin
  Result := inherited GetDefaultWidth;
  Painter.InflateSizeForArrow(DrawParams, Result);
  if Lowered then
    Inc(Result, 2 * Painter.LoweredBorderSize(Self));
end;

function TdxBarButtonControl.GetSmallHeight: Integer;
begin
  Result := inherited GetSmallHeight;
  if cpText in DrawParams.ViewStructure then
    Result := Max(Result, GetRotationDependentHeight(DrawParams.DefaultButtonSize));
end;

function TdxBarButtonControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarButtonControlAccessibilityHelper;
end;

function TdxBarButtonControl.GetDefaultViewStructure: TdxBarItemControlViewStructure;
begin
  case PaintStyle of
    psStandard:
      if GetPaintType = ptMenu then
        Result := [cpIcon, cpText]
      else
        if IconAssigned(GetViewSize) then
          Result := [cpIcon]
        else
          Result := [cpText];
    psCaption: Result := [cpText];
    psCaptionInMenu:
      if GetPaintType = ptMenu then
        Result := [cpText]
      else
        Result := [cpIcon];
    psCaptionGlyph: Result := [cpIcon, cpText];
  end;
end;

function TdxBarButtonControl.GetOwnedBarControl: TCustomdxBarControl;
begin
  Result := SubMenuControl;
end;

function TdxBarButtonControl.GetPaintStyle: TdxBarPaintStyle;
begin
  if FItemLink <> nil then
    Result := FItemLink.PaintStyle
  else
    Result := psStandard;
//  if (Parent is TdxBarControl) and (Result = psStandard) and not ImageExists then
//    Result := psCaption;
  if (Parent is TdxBarControl) and (Result = psStandard) then
    PreparePaintStyleOnBar(Result);
end;

function TdxBarButtonControl.GetPartCount: Integer;
begin
  if FDrawParams.IsDropDown then
    Result := 2
  else
    Result := 1;
end;

function TdxBarButtonControl.GetViewStructure: TdxBarItemControlViewStructure;
begin
  if ViewInfo.ViewLevel = ivlSmallIcon then
    Result := [cpIcon]
  else
    Result := inherited GetViewStructure;
end;

function TdxBarButtonControl.IsDestroyOnClick: Boolean;
begin
  Result := (Parent is TdxBarControl) or ButtonItem.CloseSubMenuOnClick;
end;

function TdxBarButtonControl.IsDropDown: Boolean;
begin
  Result := bstDropDown in InternalStates;
end;

function TdxBarButtonControl.IsPressed: Boolean;
begin
  Result := DrawSelected and Parent.IsActive and MousePressed and (FHotPartIndex = bcpButton) or
    Pressed and not(bstChecked in InternalStates);
end;

function TdxBarButtonControl.NeedCaptureMouse: Boolean;
begin
  Result := not DroppedDown and (Parent.Kind = bkBarQuickControl);
end;

procedure TdxBarButtonControl.PaintStyleChanged;
begin
  Parent.RepaintBar;
end;

procedure TdxBarButtonControl.PreparePaintStyleOnBar(var APaintStyle: TdxBarPaintStyle);
begin
  if not IconAssigned(GetViewSize) then
    APaintStyle := psCaption;
end;

{ TdxBarApplicationMenuButtonControl }

procedure TdxBarApplicationMenuButtonControl.CalcDrawParams(AFull: Boolean = False);
begin
  inherited CalcDrawParams(AFull);
  if AFull then
    DrawParams.ContentWidth := inherited InternalGetDefaultWidth;
end;

procedure TdxBarApplicationMenuButtonControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
begin
  Painter.ApplicationMenuDrawButton(DrawParams, ARect);
end;

function TdxBarApplicationMenuButtonControl.GetDefaultViewStructure: TdxBarItemControlViewStructure;
begin
  Result := [cpText];
  if IconAssigned(GetViewSize) then
    Include(Result, cpIcon);
end;

function TdxBarApplicationMenuButtonControl.GetDrawParamsClass: TdxBarItemControlDrawParamsClass;
begin
  Result := TdxBarApplicationMenuButtonControlDrawParams;
end;

function TdxBarApplicationMenuButtonControl.GetPaintType: TdxBarPaintType;
begin
  Result := ptHorz;
end;

function TdxBarApplicationMenuButtonControl.InternalGetDefaultWidth: Integer;
begin
  if Item.Width <> 0 then
    Result := Item.Width
  else
    Result := inherited InternalGetDefaultWidth;
end;

procedure TdxBarApplicationMenuButtonControl.CaptionChanged;
begin
  Parent.Repaint;
end;

procedure TdxBarApplicationMenuButtonControl.GlyphChanged;
begin
  Parent.Repaint;
end;

procedure TdxBarApplicationMenuButtonControl.VisibleChanged;
begin
  Parent.Repaint;
end;

procedure TdxBarApplicationMenuButtonControl.WidthChanged;
begin
  Parent.Repaint;
end;

function TdxBarApplicationMenuButtonControl.GetDrawParams: TdxBarApplicationMenuButtonControlDrawParams;
begin
  Result := TdxBarApplicationMenuButtonControlDrawParams(FDrawParams);
end;

{ TdxBarCustomEditControl }

destructor TdxBarCustomEditControl.Destroy;
begin
  FreeAndNil(FBkBrush);
  inherited Destroy;
end;

procedure TdxBarCustomEditControl.CorrectFrameRect(var ARect: TRect);
begin
// do nothing
end;

procedure TdxBarCustomEditControl.DoCalcDrawingConsts;
var
  ASavedFont: TdxBarSavedFont;
begin
  inherited DoCalcDrawingConsts;
  PrepareCanvasFont(Parent.EditFontHandle, Item.StyleEdit, ASavedFont);
  try
    FEditTextSize := Parent.GetTextSize;
  finally
    RestoreCanvasFont(ASavedFont);
  end;
end;

procedure TdxBarCustomEditControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
begin
  Painter.DrawEditLikeControl(DrawParams, ARect);
end;

procedure TdxBarCustomEditControl.DrawFrame;

  function IsEditorFrameOnly: Boolean;
  begin
    Result := not IsEditTransparent or (GetPaintType = ptMenu);
  end;

var
  AFrameRect, AContentRect: TRect;
begin
  if IsEditorFrameOnly then
    AFrameRect := GetEditRect
  else
    AFrameRect := ItemBounds;

  CorrectFrameRect(AFrameRect);
  AContentRect := AFrameRect;
  Painter.EditControlDrawBorder(DrawParams, AContentRect);
  ExcludeFrameRegion(Canvas, AFrameRect, AContentRect);
end;

procedure TdxBarCustomEditControl.CalcDrawParams(AFull: Boolean = True);
begin
  inherited;
  if AFull then
  begin
    DrawParams.IsTransparent := IsEditTransparent;
    DrawParams.Focused := Focused;
  end;
end;

procedure TdxBarCustomEditControl.CalcParts;
begin
  inherited;
  Painter.CalculateEditParts(DrawParams, FParts, ItemBounds);
end;

procedure TdxBarCustomEditControl.DrawEditSizingFrame(AWidth: Integer);
var
  AItemRect: TRect;
  ADC: HDC;
begin
  AItemRect := ItemBounds;
  if FRightBorderSizing then
    AItemRect.Right := AItemRect.Left + AWidth
  else
    AItemRect.Left := AItemRect.Right - AWidth;
  ADC := GetDC(0);
  MapWindowRect(Parent.Handle, 0, AItemRect);
  with AItemRect do
  begin
    PatBlt(ADC, Left, Top, Right - Left, 2, DSTINVERT);
    PatBlt(ADC, Left, Bottom - 2, Right - Left, 2, DSTINVERT);
    PatBlt(ADC, Left, Top + 2, 2, Bottom - Top - 4, DSTINVERT);
    PatBlt(ADC, Right - 2, Top + 2, 2, Bottom - Top - 4, DSTINVERT);
  end;
  ReleaseDC(0, ADC);
end;

function TdxBarCustomEditControl.DrawSelected: Boolean;
begin
  Result := inherited DrawSelected and not FParent.IsCustomizing;
end;

function TdxBarCustomEditControl.GetDefaultViewStructure: TdxBarItemControlViewStructure;
begin
  Result := [];
  if ShowCaption then
    Result := [cpText];
  if IconAssigned(GetViewSize) and Painter.EditControlShowIconDefault(DrawParams) then
    Include(Result, cpIcon);
end;

function TdxBarCustomEditControl.GetDrawParamsClass: TdxBarItemControlDrawParamsClass;
begin
  Result := TdxBarEditLikeControlDrawParams;
end;

function TdxBarCustomEditControl.GetPartCount: Integer;
begin
  Result := inherited GetPartCount + 2;
end;

function TdxBarCustomEditControl.GetPossibleViewLevels: TdxBarItemViewLevels;
begin
  Result := inherited GetPossibleViewLevels;
  Include(Result, ivlControlOnly);
end;

function TdxBarCustomEditControl.GetCaptionAreaWidth: Integer;
begin
  Result := 0;
  if cpText in DrawParams.ViewStructure then
  begin
    Result := GetCaptionWidth;
    if Result <> 0 then
      Inc(Result, GetIndents(cpText).Right);
    Inc(Result, GetIndents(cpText).Left);
  end;
end;

function TdxBarCustomEditControl.GetControlAreaWidth: Integer;
begin
  Result := ItemLink.Width;
end;

function TdxBarCustomEditControl.GetGlyphAreaWidth: Integer;
begin
  if cpIcon in DrawParams.ViewStructure then
  begin
    Result := GetGlyphSize(DrawParams.ViewSize).cx;
    Inc(Result, GetIndents(cpIcon).Left + GetIndents(cpIcon).Right);
  end
  else
    Result := 0;
end;

function TdxBarCustomEditControl.GetDefaultHeight: Integer;
begin
  Result := GetEditTextSize;
  if ShowCaption then
    Result := Max(Result, Parent.GetDefaultItemHeight(Self));
end;

function TdxBarCustomEditControl.GetDefaultWidth: Integer;
begin
  Result := GetDefaultWidthHorzLayout;
end;

function TdxBarCustomEditControl.GetEditOffset: Integer;
begin
  Result := GetEditRect.Left - ItemBounds.Left;
end;

function TdxBarCustomEditControl.GetEditRect: TRect;
begin
  Result := ItemBounds;
  if not IsRectEmpty(Result) then
  begin
    if (Align = iaClient) and not (bboExtendItemWhenAlignedToClient in Parent.BehaviorOptions) then
      Result.Left := Result.Right - GetControlAreaWidth
    else
      Result.Left := ItemBounds.Left + GetCaptionAreaWidth + GetGlyphAreaWidth;
  end;
end;

function TdxBarCustomEditControl.GetEditTextSize: Integer;
begin
  if (Item.StyleEdit <> nil) and (svFont in Item.StyleEdit.AssignedValues) then
    Result := FEditTextSize
  else
    Result := Parent.EditTextSize;
end;

function TdxBarCustomEditControl.GetIndents(ADrawAreaType: TdxBarItemControlPart): TRect;
begin
  Result := Painter.EditControlIndents(DrawParams, ADrawAreaType);
end;

function TdxBarCustomEditControl.GetMinWidth: Integer;
begin
  Result := GetCaptionAreaWidth + GetMinEditorWidth;
end;

function TdxBarCustomEditControl.GetShowCaption: Boolean;
begin
  Result := (Parent.Kind = bkSubMenu) or Item.ShowCaption;
end;

procedure TdxBarCustomEditControl.Show;
begin
  inherited Show;
  InitEdit;
end;

procedure TdxBarCustomEditControl.BeginResize(APoint: TPoint);
begin
  FRightBorderSizing := PtInRect(RightSizingRect, APoint);
  FSizingEditWidth := cxRectWidth(ItemBounds);
  Paint(Canvas, ItemBounds, ptHorz);
  DrawEditSizingFrame(FSizingEditWidth);
end;

function TdxBarCustomEditControl.CanResize(APoint: TPoint): Boolean;
begin
  Result := BarManager.IsCustomizing and (PtInRect(RightSizingRect, APoint) or PtInRect(LeftSizingRect, APoint));
end;

procedure TdxBarCustomEditControl.EndResize(AAllowResize: Boolean);
begin
  DrawEditSizingFrame(FSizingEditWidth);
  if AAllowResize and (GetControlAreaWidth <> FSizingEditWidth - GetEditOffset) then
    ItemLink.UserWidth := FSizingEditWidth - GetEditOffset
  else
    Repaint;
end;

procedure TdxBarCustomEditControl.Resizing(APoint: TPoint);
var
  AItemRect: TRect;
  APrevSizingEditWidth: Integer;
begin
  AItemRect := ItemBounds;
  APrevSizingEditWidth := FSizingEditWidth;
  if FRightBorderSizing then
    FSizingEditWidth := APoint.X - AItemRect.Left
  else
    FSizingEditWidth := AItemRect.Right - APoint.X;

  CheckEditWidth(FSizingEditWidth, MinWidth);

  if FSizingEditWidth <> APrevSizingEditWidth then
  begin
    DrawEditSizingFrame(APrevSizingEditWidth);
    DrawEditSizingFrame(FSizingEditWidth);
  end;
end;

function TdxBarCustomEditControl.HotPartWantMouse: Boolean;
begin
  Result := inherited HotPartWantMouse;
  if not BarManager.IsCustomizing and (GetPaintType <> ptMenu) then
   // Result := Result and not (FHotPartIndex in ecpHeaderParts);
    Result := Result and not (FHotPartIndex in [ecpIcon, ecpText]) // TODO must be checked
end;

procedure TdxBarCustomEditControl.RefreshBkBrush(var AHandle: HBRUSH);
begin
  if FBkBrush = nil then
    FBkBrush := TBrush.Create;
  FBkBrush.Color := Painter.EditGetBkColor(DrawParams);
  AHandle := FBkBrush.Handle;
end;

function TdxBarCustomEditControl.GetCaptionBkBrush: HBRUSH;
begin
  if DrawSelected and (GetPaintType = ptMenu) then
    Result := Parent.ToolbarSelBrush
  else
    Result := Parent.BkBrush;
end;

function TdxBarCustomEditControl.GetDrawParams: TdxBarEditLikeControlDrawParams;
begin
  Result := TdxBarEditLikeControlDrawParams(FDrawParams);
end;

function TdxBarCustomEditControl.GetEditBkBrush: HBRUSH;
begin
  RefreshBkBrush(Result);
end;

function TdxBarCustomEditControl.GetEditFont: TFont;
var
  AStyleEdit: TcxStyle;
begin
  AStyleEdit := Item.StyleEdit;
  if (AStyleEdit <> nil) and (svFont in AStyleEdit.AssignedValues) then
    Result := AStyleEdit.Font
  else
    Result := Parent.EditFont;
end;

function TdxBarCustomEditControl.GetItem: TdxCustomBarEdit;
begin
  Result := TdxCustomBarEdit(inherited GetItem);
end;

function TdxBarCustomEditControl.LeftSizingRect: TRect;
begin
  Result := ItemBounds;
  Result.Right := Result.Left + EditSizingZoneSize;
end;

function TdxBarCustomEditControl.RightSizingRect: TRect;
begin
  Result := ItemBounds;
  Result.Left := Result.Right - EditSizingZoneSize;
end;

{ TdxBarEditControl }

constructor TdxBarEditControl.Create(AItemLink: TdxBarItemLink);
begin
  inherited Create(AItemLink);
  if not ((Parent is TdxBarControl) and TdxBarControl(Parent).Moving) then
    CreateInnerEdit;
end;

destructor TdxBarEditControl.Destroy;
begin
  if not ((Parent is TdxBarControl) and TdxBarControl(Parent).Moving) then
    DestroyInnerEdit;
  inherited Destroy;
end;

procedure TdxBarEditControl.CreateWindowHandle;
begin
  FHandle := CreateWindowEx(0, 'EDIT', '', GetWindowStyle, 0, 0, 100, 100, Parent.Handle, 0, HInstance, nil);

  RestoreDisplayValue;
  SendMessage(FHandle, EM_SETLIMITTEXT, MaxLength, 0);
end;

procedure TdxBarEditControl.DestroyWindowHandle(ADestroyWindow: Boolean = True);
begin
  dxBar.DestroyWindowHandle(FHandle, ADestroyWindow);
end;

function TdxBarEditControl.GetItem: TdxBarEdit;
begin
  Result := TdxBarEdit(ItemLink.Item);
end;

function TdxBarEditControl.GetMaxLength: Integer;
begin
  Result := Item.MaxLength;
end;

function TdxBarEditControl.GetReadOnly: Boolean;
begin
  Result := Item.ReadOnly;
end;

function TdxBarEditControl.CanDrawEditor: Boolean;
begin
  Result := not Focused or not Enabled;
end;

function TdxBarEditControl.GetWindowStyle: DWORD;
begin
  Result := WS_CHILD or ES_AUTOHSCROLL or ES_MULTILINE;
end;

procedure TdxBarEditControl.ControlClick(AByMouse: Boolean; AKey: Char = #0);
begin
  inherited;
  if Focused then SendMessage(FHandle, EM_SETSEL, 0, -1);
end;

procedure TdxBarEditControl.CreateInnerEdit;
begin
  CreateWindowHandle;
  inherited CreateInnerEdit;
end;

procedure TdxBarEditControl.DestroyInnerEdit(AFullDestroy: Boolean = True);
begin
  inherited DestroyInnerEdit(AFullDestroy);
  DestroyWindowHandle(AFullDestroy);
end;

procedure TdxBarEditControl.DrawTextField;
var
  ASavedFont: TdxBarSavedFont;
begin
  if Enabled then
    WindowRect := FParts[ecpEdit];
  if CanDrawEditor then
  begin
    PrepareCanvasFont(Parent.EditFontHandle, Item.StyleEdit, ASavedFont);
    try
      Painter.EditControlDrawTextField(Self, Canvas, FParts[ecpEdit]);
    finally
      RestoreCanvasFont(ASavedFont);
    end;
  end;
end;

function TdxBarEditControl.GetHandle: HWND;
begin
  Result := FHandle;
end;

function TdxBarEditControl.GetMinEditorWidth: Integer;
begin
  Result := MinEditWidth;
end;

function TdxBarEditControl.GetNonBufferedRect: TRect;
begin
  if CanDrawEditor then
    Result := inherited GetNonBufferedRect
  else
    Result := FParts[ecpEdit];
end;

procedure TdxBarEditControl.Hide(AStoreDisplayValue: Boolean);
begin
  if Handle <> 0 then
    ShowWindow(Handle, SW_HIDE);
  if AStoreDisplayValue then
    StoreDisplayValue;
end;

procedure TdxBarEditControl.InitEdit;
begin
  CalcDrawParams;
end;

function TdxBarEditControl.IsTransparentOnGlass: Boolean;
begin
  Result := False;
end;

procedure TdxBarEditControl.PrepareEditWnd;
var
  R: TRect;
begin
  R := WindowRect;
  OffsetRect(R, -R.Left, -R.Top);
  Painter.EditOffsetInteriorRect(Self, R);
  SendMessage(Handle, EM_SETRECTNP, 0, LPARAM(@R));
end;

procedure TdxBarEditControl.SetFocused(Value: Boolean);
begin
  if Value <> FFocused then
  begin
    if Value{Focused} then
      SendMessage(Handle, EM_SETREADONLY, WPARAM(ReadOnly or Item.EmptyWindow), 0);
    inherited;
    Repaint;
  end;
end;

procedure TdxBarEditControl.SetText(Value: string);
var
  ANotEqual: Boolean;
begin
  ANotEqual := Text <> Value;
  inherited;
  Painter.EditControlUpdateWndText(Self, Handle, ANotEqual);
end;

procedure TdxBarEditControl.Show;
begin
  inherited Show;
  SendMessage(Handle, WM_SETFONT, EditFont.Handle, 0);
  with WindowRect do
    SetWindowPos(Handle, 0, Left, Top, Right - Left, Bottom - Top, SWP_SHOWWINDOW);
  PrepareEditWnd;

  FFocusing := True;
  try
    RestoreDisplayValue;
  finally
    FFocusing := False;
  end;

  SetFocus(Handle);
end;

procedure TdxBarEditControl.WndProc(var Message: TMessage);

  procedure DoBufferedPaint(DC: HDC; Rect: TRect);
  var
    MemDC: HDC;
    PaintBuffer: THandle;
  begin
    PaintBuffer := BeginBufferedPaint(DC, @Rect, BPBF_TOPDOWNDIB, nil, MemDC);
    try
      SendMessage(Handle, WM_ERASEBKGND, MemDC, MemDC);
      SendMessage(Handle, WM_PRINTCLIENT, MemDC, PRF_CLIENT);
      BufferedPaintSetAlpha(PaintBuffer, @Rect, 255);
    finally
      HideCaret(Handle);
      EndBufferedPaint(PaintBuffer, True);
      ShowCaret(Handle);
    end;
  end;

  procedure DoWMPaint;
  var
    DC: HDC;
    PS: TPaintStruct;
  begin
    DC := BeginPaint(Handle, PS);
    try
      DoBufferedPaint(DC, PS.rcPaint);
    finally
      EndPaint(Handle, PS);
    end;
  end;

var
  DC: HDC;
  R: TRect;
begin
  case Message.Msg of
    WM_DESTROY:
      begin
        Focused := False;
        DefaultHandler(Message);
        DestroyInnerEdit(False);
      end;
    WM_PAINT:
      if OnGlass then
      begin
        DoWMPaint;
        Message.Result := 1;
      end
      else
        DefaultHandler(Message);
    CM_BUFFEREDPAINTONGLASS:
      if OnGlass and InnerControlBufferedPaint then
      begin
        DC := GetDC(Handle);
        try
          GetClientRect(Handle, R);
          DoBufferedPaint(DC, R);
        finally
          InnerControlBufferedPaint := False;
          ReleaseDC(Handle, DC);
        end;
      end;
  else
    inherited WndProc(Message);
  end;
end;

{ TCustomdxBarComboControl }

destructor TCustomdxBarComboControl.Destroy;
begin
  DroppedDown := False;
  inherited;
end;

function TCustomdxBarComboControl.IsDroppedDown: Boolean;
begin
  Result := DroppedDown;
end;

function TCustomdxBarComboControl.GetDropDownWindow: HWND;
begin
  Result := Item.DropDownWindow;
end;

function TCustomdxBarComboControl.GetItem: TCustomdxBarCombo;
begin
  Result := TCustomdxBarCombo(ItemLink.Item);
end;

procedure TCustomdxBarComboControl.CalcDrawParams(AFull: Boolean = True);
begin
  inherited;
  if AFull then
    DrawParams.DroppedDown := FDroppedDown;
end;

procedure TCustomdxBarComboControl.CalcParts;
begin
  inherited;
  Painter.CalculateComboParts(DrawParams, FParts, ItemBounds);
end;

function TCustomdxBarComboControl.CanDrawEditor: Boolean;
begin
  Result := not Enabled or not Focused or Item.EmptyWindow;
end;

procedure TCustomdxBarComboControl.ControlInactivate(Immediately: Boolean);
begin
  DroppedDown := False;
  inherited;
end;

procedure TCustomdxBarComboControl.CorrectFrameRect(var ARect: TRect);
begin
  ARect.Right := FParts[ccpDropButton].Right + Painter.ComboControlButtonOffsets(DrawParams.PaintType).Right;
end;

procedure TCustomdxBarComboControl.DrawTextField;
begin
  Painter.ComboControlDrawArrowButton(DrawParams, FParts[ccpDropButton], True);
  inherited DrawTextField;
end;

procedure TCustomdxBarComboControl.EnabledChanged;
begin
  DroppedDown := False;
  inherited;
end;

function TCustomdxBarComboControl.GetPartCount: Integer;
begin
  Result := inherited GetPartCount + 1;
end;

function TCustomdxBarComboControl.IsChildWindow(AWnd: HWND): Boolean;
begin
  Result := inherited IsChildWindow(AWnd) or
    (DroppedDown and IsWindowVisible(DropDownWindow) and IsChildEx(DropDownWindow, AWnd));
end;

procedure TCustomdxBarComboControl.CalcDropDownPos(out APoint: TPoint);
begin
  with Parent.GetItemRect(Self) do
    if (Parent.Kind = bkSubMenu) or Parent.IsRealVertical then
    begin
      APoint.X := Right;
      APoint.Y := Top;
    end
    else
    begin
      APoint.X := Left + GetEditOffset;
      APoint.Y := Bottom;
    end;
  ClientToScreen(Parent.Handle, APoint);
end;

procedure TCustomdxBarComboControl.SetDroppedDown(Value: Boolean);
var
  P: TPoint;
begin
  if (FDroppedDown <> Value) and not Item.ReadOnly then
  begin
    FDroppedDown := Value;
    Repaint;
    if FDroppedDown then
    begin
      CalcDropDownPos(P);
      Item.DropDown(P.X, P.Y);
    end
    else
      Item.CloseUp;
  end;
end;

procedure TCustomdxBarComboControl.SysKeyDown(var Key: Word; Shift: TShiftState);
begin
  if (Key = VK_UP) or (Key = VK_DOWN) then
  begin
    DroppedDown := not DroppedDown;
    Key := 0;
  end;
  inherited SysKeyDown(Key, Shift);
end;

procedure TCustomdxBarComboControl.SysKeyUp(var Key: Word; Shift: TShiftState);
begin
  if (Key = VK_UP) or (Key = VK_DOWN) then
    Key := 0;
  inherited SysKeyUp(Key, Shift);
end;

procedure TCustomdxBarComboControl.WndProc(var Message: TMessage);

  function IsMouseCursorInDroppedDownArea: Boolean;
  begin
    if Item.ShowEditor then
      Result := FHotPartIndex in [ccpDropButton]
    else
      Result := FHotPartIndex in [ecpEdit, ccpDropButton];
  end;

  function LButtonDowned: Boolean;
  begin
    with Message do
      LButtonDowned := (Msg = WM_LBUTTONDOWN) or (Msg = WM_LBUTTONDBLCLK);
  end;

var
  Shift: TShiftState;
  AHandle: HWND;
begin
  with Message do
    case Msg of
      WM_KEYDOWN, WM_KEYUP, WM_CHAR:
        begin
          Shift := KeyDataToShiftState(lParam);
          if (Msg = WM_KEYDOWN) and (wParam = VK_F4) then
          begin
            DroppedDown := not DroppedDown;
            Exit;
          end
          else
            if DroppedDown and (DropDownWindow <> 0) and
              Item.CheckKeyForDropDownWindow(wParam, Shift) then
            begin
              Result := SendMessage(DropDownWindow, Msg, wParam, lParam);
              Exit;
            end;
        end;
    end;
  AHandle := Handle;
  inherited;
  if not IsWindowVisible(AHandle) then Exit;
  if LButtonDowned then FOnPressDroppedDown := DroppedDown;
  if IsMouseCursorInDroppedDownArea and (not FOnPressDroppedDown and LButtonDowned or
    FOnPressDroppedDown and (Message.Msg = WM_LBUTTONUP)) then
      DroppedDown := not DroppedDown;
end;

{ TdxBarComboControl }

function TdxBarComboControl.GetItem: TdxBarCustomCombo;
begin
  Result := TdxBarCustomCombo(ItemLink.Item);
end;

function TdxBarComboControl.GetItemIndex: Integer;
begin
  Result := Item.ItemIndex;
end;

function TdxBarComboControl.GetItems: TStrings;
begin
  Result := Item.Items;
end;

function TdxBarComboControl.GetSorted: Boolean;
begin
  Result := Item.Sorted;
end;

procedure TdxBarComboControl.SetLocalItemIndex(Value: Integer);
begin
  FLocalItemIndex := Value;
  RestoreDisplayValue;
  if Item.EmptyWindow then Repaint;
end;

procedure TdxBarComboControl.RestoreDisplayValue;
begin
  if (0 <= FLocalItemIndex) and (FLocalItemIndex <= Items.Count - 1) then
    Text := Items[FLocalItemIndex]
  else
    inherited RestoreDisplayValue;
end;

procedure TdxBarComboControl.SetFocused(Value: Boolean);
begin
  FFocusing := True;
  try
    if Value then LocalItemIndex := ItemIndex;
  finally
    FFocusing := False;
  end;
  inherited;
end;

procedure TdxBarComboControl.WndProc(var Message: TMessage);
var
  Shift: TShiftState;
begin
  if not ReadOnly then
  begin
    with Message do
      case Msg of
        WM_MOUSEWHEEL:
          begin
            if SmallInt(HIWORD(TWMMOuse(Message).Keys)) > 0 then
            begin
              if not DroppedDown then
              begin
                if LocalItemIndex > 0 then
                  LocalItemIndex := LocalItemIndex - 1;
              end
              else
                SendMessage(DropDownWindow, WM_VScroll, SB_LINEUP, 0);
            end
            else
            begin
              if not DroppedDown then
              begin
                if LocalItemIndex < (Items.Count - 1) then
                  LocalItemIndex := LocalItemIndex + 1;
              end
              else
                SendMessage(DropDownWindow, WM_VScroll, SB_LINEDOWN, 0);
            end;
          end;
        WM_KEYDOWN:
          begin
            if (wParam = VK_RETURN) or (wParam = VK_TAB) then
            begin
              if (LocalItemIndex <> -1) and (Item.Items[LocalItemIndex] = Text) then
              begin
                Item.ItemIndex := LocalItemIndex;
                if not IsWindowVisible(Handle) then Exit;
              end;
            end
            else
            begin
              Shift := KeyDataToShiftState(lParam);
              if not DroppedDown and ((wParam = VK_UP) or (wParam = VK_DOWN)) and (Shift = []) then
              begin
                if (wParam = VK_UP) and (LocalItemIndex > 0) then
                  LocalItemIndex := LocalItemIndex - 1
                else
                  if (wParam = VK_DOWN) and (LocalItemIndex < Items.Count - 1) then
                    LocalItemIndex := LocalItemIndex + 1;
                Exit;
              end;
            end;
          end;
      end;
  end;
  inherited WndProc(Message);
end;

{ TdxBarSubItemControl }

destructor TdxBarSubItemControl.Destroy;
begin
  FIsActive := False;
  inherited Destroy;
end;

function TdxBarSubItemControl.IsDroppedDown: Boolean;
begin
  Result := (SubMenuControl <> nil) and IsActive and (SubMenuControl.ParentItemControl = Self);
end;

function TdxBarSubItemControl.GetCaptionOffset: Integer;
begin
  Result := Painter.GetControlCaptionOffset(Self);
end;

function TdxBarSubItemControl.GetItem: TCustomdxBarSubItem;
begin
  Result := TCustomdxBarSubItem(ItemLink.Item);
end;

function TdxBarSubItemControl.GetSubMenuControl: TdxBarSubMenuControl;
begin
  if Item.ItemLinks = nil then
    Result := nil
  else
    Result := TdxBarSubMenuControl(Item.ItemLinks.BarControl);
end;

procedure TdxBarSubItemControl.CalcDrawParams(AFull: Boolean = True);
begin
  inherited;
  if AFull then
  begin
    DrawParams.IsPressed := IsPressed;
    DrawParams.DrawDowned := IsDroppedDown;
    DrawParams.DroppedDown := IsDroppedDown;
    DrawParams.IsMenuItem := IsMenuItem;
  end;
end;

function TdxBarSubItemControl.CanActivate: Boolean;
begin
  Result := inherited CanActivate and (Enabled or not Item.IsInternal);
end;

function TdxBarSubItemControl.CanClicked: Boolean;
begin
  Result := False;
end;

procedure TdxBarSubItemControl.ControlActivate(Immediately: Boolean);
begin
  if not HasSubMenu then Exit;

{ #DG TODO: Check it
  if IsDroppedDown then
    if (ItemLink.Item.CurItemLink = nil) or (Self = ItemLink.Item.CurItemLink.Control) then
    begin
      FinishSubMenuTracking;
      Exit;
    end
    else
      ItemLink.Item.CurItemLink.Control.ControlInActivate(True);
}

  inherited;
end;

procedure TdxBarSubItemControl.ControlInactivate(Immediately: Boolean);
begin
  if HasSubMenu then
    inherited;
end;

procedure TdxBarSubItemControl.ControlClick(AByMouse: Boolean; AKey: Char = #0);
begin
  if IsDroppedDown then
  begin
    if Parent.IsCustomizing or (BarManager.GetPaintStyle = bmsStandard) then // ???
      ControlInactivate(True)
  end
  else
  begin
    ControlActivate(True);
    if not AByMouse and (SubMenuControl <> nil) then
      with SubMenuControl do
        if NeedsSelectFirstItemOnDropDownByKey and (ItemLinks.First <> nil) then
          SetKeySelectedItem(ItemLinks.First.Control);
  end;
end;

procedure TdxBarSubItemControl.CreateSubMenuControl;
begin
  Item.ItemLinks.CreateBarControl;
end;

procedure TdxBarSubItemControl.DoCreateSubMenuControl;
begin
  CreateSubMenuControl;
  if SubMenuControl <> nil then
    SubMenuControl.FSubItem := Self;
  if HasShadow and IsDroppedDown then
  begin
    SubMenuControl.OwnerBounds := Parent.GetItemScreenRect(Self);
    SubMenuControl.FOwnerControl := Parent;
  end;
end;

procedure TdxBarSubItemControl.DoCloseUp(AHadSubMenuControl: Boolean);
begin
  if AHadSubMenuControl then
    SubMenuControl.FSubItem := nil;
  inherited DoCloseUp(AHadSubMenuControl);
  if AHadSubMenuControl then
    Item.DoCloseUp;
end;

procedure TdxBarSubItemControl.DoDropDown(AByMouse: Boolean);
begin
  Item.DoPopup;
  Item.DirectClick;
  DoCreateSubMenuControl;
  if SubMenuControl <> nil then
    ShowSubMenuControl;
end;

procedure TdxBarSubItemControl.DropDown(AByMouse: Boolean);
begin
  inherited;
  Click(AByMouse);
end;

procedure TdxBarSubItemControl.GetSubMenuControlPositionParams(out P: TPoint;
  out AOwnerWidth, AOwnerHeight: Integer);
var
  R: TRect;
begin
  AOwnerWidth := 0;
  AOwnerHeight := 0;
  R := Parent.GetItemRect(Self);
  if Parent.Kind = bkSubMenu then
  begin
    P := Point(R.Right, R.Top - SubMenuParent.BorderSize);
    AOwnerWidth := R.Right - R.Left;
  end
  else
    if Parent.IsRealVertical then
    begin
      P := Point(R.Right, R.Top);
      AOwnerWidth := R.Right - R.Left;
    end
    else
    begin
      P := Point(R.Left, R.Bottom);
      AOwnerHeight := R.Bottom - R.Top;
    end;
  P := Parent.ClientToScreen(P);
end;

function TdxBarSubItemControl.IsFlatText: Boolean;
begin
  Result := Painter.IsFlatItemText and (not IsHighContrastWhite or inherited IsFlatText);
end;

function TdxBarSubItemControl.IsTextSelected: Boolean;

  function IsFlatText: Boolean;
  begin
    Result := Painter.IsFlatItemText and IsHighContrastWhite;
  end;

begin
  Result := DrawSelected and
    (not IsFlatText and Painter.IsMenuItem(Self) or IsFlatText and not IsDroppedDown or inherited IsTextSelected);
end;

procedure TdxBarSubItemControl.ShowSubMenuControl;
var
  AOwnerHeight, AOwnerWidth: Integer;
  P: TPoint;
begin
  GetSubMenuControlPositionParams(P, AOwnerWidth, AOwnerHeight);
  SubMenuControl.OwnerWidth := AOwnerWidth;
  SubMenuControl.OwnerHeight := AOwnerHeight;
  SubMenuControl.Left := P.X;
  SubMenuControl.Top := P.Y;
  // ***
  Parent.ChildBar := SubMenuControl;
//#DG    SubMenuControl.UpdateDoubleBuffered; - ? why ?
  // ***
  if Parent.Kind <> bkSubMenu then
    Repaint;
  SubMenuControl.FShowAnimation := FShowAnimation;
  FShowAnimation := False;
  SubMenuControl.Show;
  if Painter.IsDropDownRepaintNeeded then
    Repaint;
end;

function TdxBarSubItemControl.GetCaptionAreaWidth: Integer;
begin
  Result := inherited GetCaptionAreaWidth;
  Painter.InflateSizeForArrow(DrawParams, Result);
end;

function TdxBarSubItemControl.GetControlCaptionOffset: Integer;
begin
  Result := Painter.GetControlCaptionOffset(Self);
end;

function TdxBarSubItemControl.GetAccessibilityHelperClass: TdxBarAccessibilityHelperClass;
begin
  Result := TdxBarSubItemControlAccessibilityHelper;
end;

function TdxBarSubItemControl.GetOwnedBarControl: TCustomdxBarControl;
begin
  Result := SubMenuControl;
end;

function TdxBarSubItemControl.HasSubMenu: Boolean;
begin
  Result := True;
end;

function TdxBarSubItemControl.IsDestroyOnClick: Boolean;
begin
  Result := False;
end;

function TdxBarSubItemControl.IsDropDown: Boolean;
begin
  Result := True;
end;

function TdxBarSubItemControl.IsExpandable: Boolean;
begin
  Result := True;
end;

function TdxBarSubItemControl.IsMenuItem: Boolean;
begin
  Result := Parent.IsMainMenu;
end;

function TdxBarSubItemControl.IsPressed: Boolean;
begin
  Result := IsDroppedDown and (FHotPartIndex <> icpNone) and MousePressed;
end;

function TdxBarSubItemControl.WantsDblClick: Boolean;
begin
  Result := inherited WantsDblClick and not BarManager.Designing;
end;

function TdxBarSubItemControl.WantsKey(Key: Word): Boolean;
begin
  Result := inherited WantsKey(Key) or (Key = VK_RETURN);
end;

function TdxBarSubItemControl.GetPossibleViewLevels: TdxBarItemViewLevels;
begin
  Result := inherited GetPossibleViewLevels;
  Include(Result, ivlLargeIconWithText);
end;

function TdxBarSubItemControl.GetDefaultViewStructure: TdxBarItemControlViewStructure;
begin
  Result := [];
  if Item.ShowCaption or (GetPaintType = ptMenu) then
    Include(Result, cpText);
  if IconAssigned(GetViewSize) or not (cpText in Result) then
    Include(Result, cpIcon);
end;

{ TContainerItemSubMenuControl }

type
  TContainerItemSubMenuControl = class(TdxBarSubMenuControl)
  private
    FContainerItem: TCustomdxBarContainerItem;
  protected
    procedure DoCloseUp; override;
    function GetIsCustomizing: Boolean; override;
  public
    destructor Destroy; override;
  end;

destructor TContainerItemSubMenuControl.Destroy;
var
  AContainerItem: TCustomdxBarContainerItem;
begin
  AContainerItem := FContainerItem;
  inherited;
  AContainerItem.NeedClearItemList;
end;

procedure TContainerItemSubMenuControl.DoCloseUp;
begin
  with FContainerItem do
    DeleteListedItemLinks(ItemLinks, 0);
  inherited DoCloseUp;
end;

function TContainerItemSubMenuControl.GetIsCustomizing: Boolean;
begin
  Result := False;
end;

{ TdxBarContainerItemControl }

function TdxBarContainerItemControl.GetItem: TCustomdxBarContainerItem;
begin
  Result := TCustomdxBarContainerItem(ItemLink.Item);
end;

procedure TdxBarContainerItemControl.CreateSubMenuControl;
begin
  if BarManager.IsCustomizing then Exit;
  Item.ItemLinks.FBarControl := TContainerItemSubMenuControl.Create(BarManager);
  SubMenuControl.FItemLinks := Item.ItemLinks;
  TContainerItemSubMenuControl(SubMenuControl).FContainerItem := Item;
  with Item do AddListedItemLinks(ItemLinks, 0, True, ItemLink);
end;

procedure TdxBarContainerItemControl.DoPaint(ARect: TRect; PaintType: TdxBarPaintType);
begin
  if PaintType = ptMenu then
    Painter.DrawGlyphAndTextInSubMenu(DrawParams, ARect)
  else
    inherited;
end;

function TdxBarContainerItemControl.DrawSelected: Boolean;
begin
  Result := inherited DrawSelected and not Parent.IsCustomizing;
end;

function TdxBarContainerItemControl.GetCaption: string;
begin
  Result := inherited GetCaption;
  if not ShowRealCaption then
    Result := '(' + Result + ')';
end;

function TdxBarContainerItemControl.IsExpandable: Boolean;
begin
  Result := not BarManager.IsCustomizing;
end;

function TdxBarContainerItemControl.ShowRealCaption: Boolean;
begin
  Result := (Parent is TdxBarControl) or not Item.HideWhenRun;
end;

{ TdxBarPainter }

constructor TdxBarPainter.Create(AData: Integer);
begin
  inherited Create;
end;

procedure TdxBarPainter.CalculateButtonParts(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; var AParts: array of TRect; const AItemRect: TRect);
begin
  if ADrawParams.IsDropDown then
  begin
    AParts[bcpDropButton].Left := AParts[bcpDropButton].Right - ADrawParams.ArrowSize.cx;
    AParts[bcpButton].Right := AParts[bcpDropButton].Left;
  end;
end;

procedure TdxBarPainter.CalculateColorComboParts(const ADrawParams: TdxBarColorComboControlDrawParams;
  var AParts: array of TRect; const AItemRect: TRect);
begin
  AParts[clcpCustomColorButton] := GetCustomColorButtonBounds(ADrawParams, AItemRect);
  AParts[ccpDropButton].Right := AParts[clcpCustomColorButton].Left;
  if IsCustomColorButtonVisible(ADrawParams) then
    Dec(AParts[ccpDropButton].Right, GetCustomColorButtonIndents(ADrawParams.PaintType).Left);
  if not ColorComboHasCompleteFrame or not IsCustomColorButtonVisible(ADrawParams) then
    Dec(AParts[ccpDropButton].Right, ComboControlButtonOffsets(ADrawParams.PaintType).Right);
  InternalCalculateComboParts(ADrawParams, AParts);
end;

procedure TdxBarPainter.CalculateComboParts(const ADrawParams: TdxBarEditLikeControlDrawParams;
  var AParts: array of TRect; const AItemRect: TRect);
begin
  AParts[ccpDropButton] := cxRectContent(AItemRect, ComboControlButtonOffsets(ADrawParams.PaintType));
  InternalCalculateComboParts(ADrawParams, AParts);
end;

procedure TdxBarPainter.CalculateEditParts(const ADrawParams: TdxBarEditLikeControlDrawParams;
  var AParts: array of TRect; const AItemRect: TRect);
var
  ATransparentIndent: Integer;
begin
  with ADrawParams do
  begin
    if IsTransparent and (PaintType <> ptMenu) then
      ATransparentIndent := EditControlBorderOffsets(PaintType).Left
    else
      ATransparentIndent := 0;

    AParts[ecpIcon].Left := AParts[ecpIcon].Left + ATransparentIndent;
    AParts[ecpIcon].Right := AParts[ecpIcon].Left + BarEditControl.GetGlyphAreaWidth;

    AParts[ecpText].Left := AParts[ecpIcon].Right;
    AParts[ecpText].Right := AParts[ecpText].Left + BarEditControl.GetCaptionAreaWidth;

    AParts[ecpEdit] := EditControlGetContentRect(PaintType, BarEditControl.GetEditRect);
  end;
end;

procedure TdxBarPainter.CalculateSpinEditParts(const ADrawParams: TdxBarSpinEditDrawParams;
  var AParts: array of TRect; const AItemRect: TRect);
begin
  AParts[secButtonUp] := GetSpinEditButtonBounds(ADrawParams, AItemRect, sbUp);
  AParts[secButtonDown] := GetSpinEditButtonBounds(ADrawParams, AItemRect, sbDown);
  AParts[ecpEdit].Right := AParts[secButtonUp].Left - EditControlBorderOffsets(ADrawParams.PaintType).Right - GetSpinEditButtonIndents(ADrawParams.PaintType).Left;
end;

function TdxBarPainter.GetToolbarContentOffsets(ABar: TdxBar;
  ADockingStyle: TdxBarDockingStyle; AHasSizeGrip: Boolean): TRect;
begin
  if ADockingStyle = dsNone then
  begin
    Result := Rect(BorderSizeX, BorderSizeY, BorderSizeX, BorderSizeY);
    if (ABar.Control = nil) or ABar.Control.HasCaption then
    begin
      Inc(Result.Left, BarHorSize);
      Inc(Result.Right, BarHorSize);
      Inc(Result.Top, BarCaptionAreaSize + BarTopSize);
      Inc(Result.Bottom, BarBottomSize);
    end;
  end
  else
    if ABar.BorderStyle = bbsSingle then
    begin
      BarBorderSizes(ABar, ADockingStyle, Result);
      if ADockingStyle in [dsTop, dsBottom] then
        Inc(Result.Left, BarFingersSize(ABar))
      else
        Inc(Result.Top, BarFingersSize(ABar));
    end
    else
    begin
      Result := cxEmptyRect;
      if ABar.IsStatusBar then
      begin
        Inc(Result.Top, StatusBarTopBorderSize);
        Result.TopLeft := cxPointOffset(Result.TopLeft, StatusBarBorderOffsets.TopLeft);
        Result.BottomRight := cxPointOffset(Result.BottomRight, StatusBarBorderOffsets.BottomRight);
      end;
      if AHasSizeGrip then
        Inc(Result.Right, StatusBarGripSize(ABar.BarManager).cx);
    end;
end;

function TdxBarPainter.GetToolbarsOffsetForAutoAlign: Integer;
begin
  Result := 0;
end;

class procedure TdxBarPainter.CalculateArrowPoints(const ARect: TRect; AArrowSize: Integer; AArrowDirection: TcxArrowDirection; out P: TcxArrowPoints);

  procedure OffsetPoints(var P: TcxArrowPoints; ADisplace: TPoint);
  var
    I: Integer;
  begin
    for I := Low(P) to High(P) do
      P[I] := cxPointOffset(P[I], ADisplace);
  end;

  procedure CorrectArrowPoints(var P: TcxArrowPoints; AArrowDirection: TcxArrowDirection);
  begin
    case AArrowDirection of
      adUp:
        begin
          P[cxArrowLeftBasePointIndex] := cxPointOffset(P[cxArrowLeftBasePointIndex], 0, 1);
          P[cxArrowRightBasePointIndex] := cxPointOffset(P[cxArrowRightBasePointIndex], 1, 1);
        end;
      adDown:
        begin
          P[cxArrowLeftBasePointIndex] := cxPointOffset(P[cxArrowLeftBasePointIndex], 1, 0);
          P[cxArrowTopPointIndex] := cxPointOffset(P[cxArrowTopPointIndex], 0, 1);
          if Odd(AArrowSize + cxRectHeight(ARect)) then
            OffsetPoints(P, Point(0, -1));
        end;
      adLeft:
        begin
          P[cxArrowLeftBasePointIndex] := cxPointOffset(P[cxArrowLeftBasePointIndex], 1, 1);
          P[cxArrowRightBasePointIndex] := cxPointOffset(P[cxArrowRightBasePointIndex], 1, 0);
        end;
      adRight:
        begin
          P[cxArrowRightBasePointIndex] := cxPointOffset(P[cxArrowRightBasePointIndex], 0, 1);
          P[cxArrowTopPointIndex] := cxPointOffset(P[cxArrowRightBasePointIndex], 1, 0);
          if Odd(AArrowSize + cxRectWidth(ARect)) then
            OffsetPoints(P, Point(-1, 0));
        end;
    end;
  end;

begin
  TcxCustomLookAndFeelPainter.CalculateArrowPoints(ARect, P, AArrowDirection, False, AArrowSize);
  CorrectArrowPoints(P, AArrowDirection);
end;

class function TdxBarPainter.GetArrowRectByPoints(const P: TcxArrowPoints; AArrowDirection: TcxArrowDirection): TRect;
begin
  case AArrowDirection of
    adUp:
      Result := Rect(P[cxArrowLeftBasePointIndex].X, P[cxArrowTopPointIndex].Y, P[cxArrowRightBasePointIndex].X, P[cxArrowRightBasePointIndex].Y);
    adDown:
      Result := Rect(P[cxArrowRightBasePointIndex].X, P[cxArrowRightBasePointIndex].Y, P[cxArrowLeftBasePointIndex].X, P[cxArrowTopPointIndex].Y);
    adLeft:
      Result := Rect(P[cxArrowTopPointIndex].X, P[cxArrowRightBasePointIndex].Y, P[cxArrowLeftBasePointIndex].X, P[cxArrowLeftBasePointIndex].Y);
    adRight:
      Result := Rect(P[cxArrowLeftBasePointIndex].X, P[cxArrowLeftBasePointIndex].Y, P[cxArrowTopPointIndex].X, P[cxArrowRightBasePointIndex].Y);
  end;
end;

procedure TdxBarPainter.GetTextColors(ABarItemControl: TdxBarItemControl;
  AEnabled, ASelected, AFlat: Boolean; var AColor1, AColor2: TColor);
var
  ATextViewParams: TcxViewParams;
begin
  if AEnabled then
  begin
    ABarItemControl.Item.GetTextViewParams(ATextViewParams);
    if ATextViewParams.TextColor <> clDefault then
      AColor1 := ATextViewParams.TextColor
    else
      AColor1 := GetEnabledTextColor(ABarItemControl, ASelected, AFlat);
    AColor2 := AColor1;
  end
  else
    GetDisabledTextColors(ABarItemControl, ASelected, AFlat, AColor1, AColor2);
end;

class procedure TdxBarPainter.SetArrowRegion(ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection;
  P: TcxArrowPoints; AOperation: TcxRegionOperation);

  procedure CalculateClipArea(var P: TcxArrowPoints);
  begin
    case AArrowDirection of
      adUp:
        begin
          Dec(P[cxArrowLeftBasePointIndex].X);
          Inc(P[cxArrowRightBasePointIndex].X);
          Dec(P[cxArrowTopPointIndex].Y);
        end;
      adLeft:
        begin
          Inc(P[cxArrowRightBasePointIndex].X);
          Dec(P[cxArrowRightBasePointIndex].Y, 2);
          Dec(P[cxArrowTopPointIndex].X);
        end;
      adRight:
        begin
          Dec(P[cxArrowLeftBasePointIndex].X);
          Dec(P[cxArrowLeftBasePointIndex].Y, 2);
        end;
    end;
  end;

var
  ARgn: HRGN;
begin
  CalculateClipArea(P);
  ARgn := CreatePolygonRgn(P, 3, WINDING);
  ACanvas.SetClipRegion(TcxRegion.Create(ARgn), AOperation);
end;

class function TdxBarPainter.GetControlCaptionOffset(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := -ABarItemControl.Parent.Font.Height div 2;
end;

class function TdxBarPainter.GetDefaultTextSize(ACanvas: TcxCanvas): Integer;
begin
  Result := ACanvas.TextHeight('Wg') + 6;
end;

class function TdxBarPainter.GetPopupWindowBorderWidth: Integer;
begin
  Result := 2;
end;

class function TdxBarPainter.SubMenuControlGetItemIconRect(
  const AItemRect: TRect; AIconAreaSize: Integer): TRect;
begin
  Result := AItemRect;
  Result.Right := Result.Left + AIconAreaSize;
end;

class function TdxBarPainter.SubMenuControlGetItemTextRect(const ADrawParams: TdxBarButtonLikeControlDrawParams; const AItemRect: TRect): TRect;
begin
  Result := AItemRect;
  Inc(Result.Left, SubMenuControlGetItemTextIndent(ADrawParams));
end;

class function TdxBarPainter.SubMenuControlGetItemTextIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer;
begin
  Result := ADrawParams.BarItemControl.SubMenuParent.BandSize + 3;
end;

class procedure TdxBarPainter.DrawBackground(ABarItemControl: TdxBarItemControl;
  DC: HDC; const R: TRect; ABrush: HBRUSH; AOpaque: Boolean);
begin
  if AOpaque then
    FillRect(DC, R, ABrush)
  else
  begin
    ABarItemControl.CheckNonRecent;
    try
      ABarItemControl.Parent.FillBackground(DC, R, ABrush, clNone, True);
    finally
      ABarItemControl.UncheckNonRecent;
    end;
  end;
end;

class procedure TdxBarPainter.DrawBackgroundFrameRect(ABarItemControl: TdxBarItemControl;
  DC: HDC; R: TRect; ABrush: HBRUSH; AOpaque: Boolean);
var
  AClipRgn: HRGN;
  AClipRgnExists: Boolean;
begin
  if AOpaque then
    FrameRect(DC, R, ABrush)
  else
  begin
    SaveClipRgn(DC, AClipRgn, AClipRgnExists);
    InflateRect(R, -1, -1);
    with R do
      ExcludeClipRect(DC, Left, Top, Right, Bottom);
    InflateRect(R, 1, 1);
    DrawBackground(ABarItemControl, DC, R, ABrush, False);
    RestoreClipRgn(DC, AClipRgn, AClipRgnExists);
  end;
end;

class procedure TdxBarPainter.DrawDisabledShadowRect(ABarItemControl: TdxBarItemControl;
  DC: HDC; R: TRect);
begin
  FillRect(DC, R, COLOR_BTNSHADOW + 1);
end;

procedure TdxBarPainter.DrawItemBackground(ABarItemControl: TdxBarItemControl;
  ACanvas: TcxCanvas; const ASourceRect: TRect; ABrush: HBRUSH);
begin
  ABarItemControl.Parent.FillBackground(ACanvas.Handle, ASourceRect, ABrush, clNone, True);
end;

procedure TdxBarPainter.DrawGlyph(ABarItemControl: TdxBarItemControl; ADC: HDC;
  ADrawRect: TRect; const AFullBounds: TRect; APaintType: TdxBarPaintType;
  AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown, ACenter, AForceUseBkBrush, AIsSplit: Boolean);
var
  AImageBounds: TRect;
begin
  DrawGlyph(ABarItemControl, ADC, ADrawRect, AFullBounds, AImageBounds,
    APaintType, ABarItemControl.GetViewStructure, ABarItemControl.GetViewSize,
    AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown, ACenter, AForceUseBkBrush, False, AIsSplit);
end;

procedure TdxBarPainter.DrawGlyph(
  ABarItemControl: TdxBarItemControl; ADC: HDC;
  ADrawRect: TRect; const AFullBounds: TRect; out AImageBounds: TRect;
  APaintType: TdxBarPaintType; AViewStructure: TdxBarItemControlViewStructure;
  AViewSize: TdxBarItemControlViewSize;
  AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown, ACenter, AForceUseBkBrush, AGrayScale, AIsSplit: Boolean);
var
  ACurrentGlyph: TBitmap;
  ACurrentImages: TCustomImageList;
  ACurrentImageIndex: Integer;
begin
  GetImageParams(ABarItemControl, ADrawRect, APaintType, AViewStructure, AViewSize, ACenter,
    ASelected, ADowned, ADrawDowned, AGlyphEmpty, ACurrentGlyph, ACurrentImages, ACurrentImageIndex, AImageBounds);

  ABarItemControl.ViewInfo.ImageBounds := AImageBounds;

  if not IsRectEmpty(AFullBounds) then
    ADrawRect := AFullBounds;
  DrawGlyphAndBkgnd(ABarItemControl, ADC, ADrawRect, AImageBounds, APaintType, ACurrentGlyph,
    ACurrentImages, ACurrentImageIndex,
    AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown,
    AForceUseBkBrush, AGrayScale, AIsSplit);
end;

procedure TdxBarPainter.DrawGlyphAndBkgnd(
  ABarItemControl: TdxBarItemControl; ADC: HDC;
  const R, AGlyphRect: TRect; APaintType: TdxBarPaintType; AGlyph: TBitmap;
  AImages: TCustomImageList; AImageIndex: Integer; AGlyphEmpty, ASelected, ADowned,
  ADrawDowned, ADroppedDown, AForceUseBkBrush, AGrayScale, AIsSplit: Boolean);

  procedure GetDimensions(out AWidth, AHeight: Integer);
  begin
    AWidth := cxRectWidth(R);
    AHeight := cxRectHeight(R);
  end;

  procedure GetImageDimensions(out AWidth, AHeight: Integer);
  begin
    AWidth := cxRectWidth(AGlyphRect);
    AHeight := cxRectHeight(AGlyphRect);
  end;

  function GetImageGlyphRect(const ARect: TRect; ANeedBorder: Boolean): TRect;
  begin
    if ANeedBorder then
      Result := cxRectInflate(ARect, -1, -1)
    else
      Result := ARect;
  end;

  procedure DrawGlyphImageBackground(ABarItemControl: TdxBarItemControl; ADC: HDC; const R: TRect;
    ADown, ADrawDowned, ASelected, AGlyphEmpty: Boolean; ABrush: HBRUSH);
  begin
    if not IsNativeBackground and
      (AGlyphEmpty or not AGlyphEmpty and IsGlyphImageTransparent(ABarItemControl)) then
      DrawBackground(ABarItemControl, ADC, R, ABrush,
          IsGlyphImageBackgroundOpaque(ABarItemControl, ADown, ADrawDowned, ASelected, AGlyphEmpty));
  end;

var
  ABrush: HBRUSH;
  AWidth, AHeight, AImageWidth, AImageHeight: Integer;
  ANeedBorder: Boolean;
  AFullGlyphRect: TRect;
begin
  GetDimensions(AWidth, AHeight);
  ABrush := GlyphBkgndBrush(ABarItemControl, APaintType, AGlyphEmpty, ASelected,
    ADowned, ADrawDowned, ADroppedDown, AForceUseBkBrush, AGrayScale);

  if AGlyphEmpty then
  begin
    ANeedBorder :=
      (ABarItemControl.BarManager.GlyphSize + 2 <= AWidth) and
      (ABarItemControl.BarManager.GlyphSize + 2 <= AHeight);
  end
  else
  begin
    GetImageDimensions(AImageWidth, AImageHeight);
    ANeedBorder :=
      (AImageWidth + 2 <= AWidth) and (AImageHeight + 2 <= AHeight);
  end;

  if IsNativeBackground then
    DrawGlyphBorder(ABarItemControl, ADC, ABrush, ANeedBorder, R, APaintType, AGlyphEmpty,
       ASelected, ADowned, ADrawDowned, ADroppedDown, AIsSplit);

  AFullGlyphRect := GetImageGlyphRect(R, ANeedBorder);
  DrawGlyphImageBackground(ABarItemControl, ADC, AFullGlyphRect,
    ADowned, ADrawDowned, ASelected, AGlyphEmpty, ABrush);

  if AGlyphEmpty then
    DrawGlyphEmptyImage(ABarItemControl, ADC, AFullGlyphRect, APaintType, ADowned)
  else
  begin
    if IsGlyphImageTransparent(ABarItemControl) then
      ABrush := 0;

    TransparentDraw(ABarItemControl, ADC, ABrush, AFullGlyphRect, AGlyphRect,
      AGlyph, AImages, AImageIndex, ABarItemControl.BarManager.ImageListBkColor,
      ABarItemControl.GetImageEnabled(APaintType), AGrayScale, IsFlatGlyphImage, ASelected, ADowned, ADrawDowned,
      IsGlyphImageHasShadow, GetFaded(ABarItemControl.Parent){Faded},
      ABarItemControl.BarManager.ImageOptions.SmoothGlyphs,
      ABarItemControl.BarManager.ImageOptions.UseLeftBottomPixelAsTransparent);
  end;

  if not IsNativeBackground then
    DrawGlyphBorder(ABarItemControl, ADC, ABrush, ANeedBorder, R, APaintType, AGlyphEmpty,
       ASelected, ADowned, ADrawDowned, ADroppedDown, AIsSplit);
end;

procedure TdxBarPainter.DrawGlyphAndTextInSubMenu(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; const R: TRect);
var
  AIsGlyphEmpty: Boolean;
begin
  with ADrawParams do
  begin
    DrawItemBackgroundInSubMenu(ADrawParams, R);

    AIsGlyphEmpty := not BarItemControl.HasIcon(ViewSize, ViewStructure);
    DrawGlyph(BarItemControl, Canvas.Handle, SubMenuControlGetItemIconRect(R, BarItemControl.Parent.IconAreaSize),
      cxEmptyRect, ptMenu, AIsGlyphEmpty, DrawSelected, Downed, False, False, False, False, False);

    DrawItemTextInSubMenu(ADrawParams, SubMenuControlGetItemTextRect(ADrawParams, R));
  end;
end;

procedure TdxBarPainter.DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect);
begin
  // Required
end;

procedure TdxBarPainter.DrawItemMultilineText(const ADrawParams: TdxBarItemControlDrawParams;
  const AText: string; const ATextRect: TRect; AAlignment: UINT; AMaxLineCount: Integer);
var
  ALines: TStrings;
  I, ALettersCount, ALineHeight: Integer;
  ARect: TRect;
begin
  ARect := ATextRect;
  ALines := TStringList.Create;
  try
    cxGetTextLines(AText, ADrawParams.Canvas, ARect, ALines);
    if ALines.Count > AMaxLineCount then
    begin
      for I := ALines.Count - 1 downto AMaxLineCount - 1 do
        ALines.Delete(I);
      if ALines.Count > 0 then
        ALettersCount := Length(ALines[0]) + 1
      else
        ALettersCount := 0;
      ALines.Add(Trim(Copy(AText, ALettersCount, MaxInt)));
    end;
    ALineHeight := ADrawParams.Canvas.TextHeight('Wg');
    for I := 0 to ALines.Count - 1 do
    begin
      DrawItemText(ADrawParams.BarItemControl, ADrawParams.Canvas.Handle,
        ALines[I], ARect, AAlignment or DT_TOP, ADrawParams.Enabled,
        ADrawParams.DrawSelected, False, True, IsFlatItemTextForMenu, DT_END_ELLIPSIS);
      OffsetRect(ARect, 0, ALineHeight);
    end;
  finally
    ALines.Free;
  end;
end;

procedure TdxBarPainter.DrawItemText(ABarItemControl: TdxBarItemControl;
  ADC: HDC; S: string; APaintRect: TRect; AAlignment: UINT; AEnabled, ASelected,
  ARotated, AClipped, AFlatText: Boolean; AFormat: UINT);

  procedure UnderlineAccel(ACanvas: TcxCanvas; const APaintRect: TRect; const ATextSize: TSize; AAccelWidth, AAccelOffset: Integer);
  var
    X, Y: Integer;
    ATextMetric: TTextMetric;
  begin
    ACanvas.Pen.Color := ACanvas.Font.Color;
    GetTextMetrics(ACanvas.Handle, ATextMetric);
    X := (APaintRect.Left + APaintRect.Right - ATextSize.cy) div 2 + ATextMetric.tmDescent - 2;
    Y := APaintRect.Top + AAccelOffset;
    ACanvas.MoveTo(X, Y);
    ACanvas.LineTo(X, Y + AAccelWidth);
  end;

var
  R: TRect;
  AAccelPos: Integer;
  AFlat: Boolean;
  AColor1, AColor2: TColor;
  ATextSize: TSize;
  ATextOffsetY, AAccelWidth, AAccelOffsetY: Integer;
begin
  BarCanvas.BeginPaint(ADC);
  try
    R := APaintRect;
    if not AClipped then
      AFormat := AFormat or DT_NOCLIP
    else
      if ARotated then
      begin
        AFormat := AFormat or DT_NOCLIP;
        BarCanvas.SetClipRegion(TcxRegion.Create(APaintRect), roIntersect);
      end;

    AAccelPos := 0;
    AAccelWidth := 0;
    AAccelOffsetY := 0;
    if ARotated then
    begin
      AAccelPos := GetAccelPos(S, True);
      if AAccelPos > 0 then
        AFormat := AFormat or DT_NOPREFIX;
      ATextSize := BarCanvas.TextExtent(S);
      case AAlignment of
        DT_CENTER:
          ATextOffsetY := (cxRectHeight(APaintRect) - ATextSize.cx) div 2;
        DT_RIGHT:
          ATextOffsetY := cxRectHeight(APaintRect) - ATextSize.cx;
      else
        ATextOffsetY := 0;
      end;
      OffsetRect(APaintRect, (cxRectWidth(APaintRect) + ATextSize.cy) div 2, ATextOffsetY);
      if AAccelPos > 0 then
      begin
        AAccelOffsetY := ATextOffsetY + BarCanvas.TextWidth(Copy(S, 1, AAccelPos - 1));
        AAccelWidth := BarCanvas.TextWidth(S[AAccelPos]);
      end;
    end
    else
      AFormat := AFormat or AAlignment or DT_VCENTER;

    AFlat := IsFlatItemText and AFlatText; // TODO and ...
    GetTextColors(ABarItemControl, AEnabled, ASelected, AFlat, AColor1, AColor2);
    BarCanvas.Brush.Style := bsClear;

    if AColor2 <> AColor1 then
    begin
      BarCanvas.Font.Color := AColor1;
      OffsetRect(APaintRect, 1, 1);
      cxDrawText(BarCanvas.Handle, S, APaintRect, AFormat);
      OffsetRect(APaintRect, -1, -1);
      if ARotated and (AAccelPos > 0) then
      begin
        OffsetRect(R, 1, 1);
        UnderlineAccel(BarCanvas, R, ATextSize, AAccelWidth, AAccelOffsetY);
        OffsetRect(R, -1, -1);
      end;
    end;

    BarCanvas.Font.Color := AColor2;
    cxDrawText(BarCanvas.Handle, S, APaintRect, AFormat);
    if ARotated and (AAccelPos > 0) then
      UnderlineAccel(BarCanvas, R, ATextSize, AAccelWidth, AAccelOffsetY);
  finally
    BarCanvas.EndPaint;
  end;
end;

procedure TdxBarPainter.DrawItemTextInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect);

  procedure DrawDescription(var ACaptionRect: TRect);
  var
    ADescriptionRect: TRect;
    ATextHeight, AOffset: Integer;
  begin
    with ADrawParams do
    begin
      if Description <> '' then
      begin
        ATextHeight := Canvas.TextHeight('Wg');
        AOffset := (cxRectHeight(R) - ATextHeight * 3) div 4;

        ADescriptionRect.Left := R.Left;
        ADescriptionRect.Top := R.Bottom - (ATextHeight + AOffset) * 2;
        ADescriptionRect.Right := R.Right - BarItemControl.Parent.TextSize;
        ADescriptionRect.Bottom := R.Bottom;

        ACaptionRect.Bottom := ADescriptionRect.Top;

        DrawItemMultilineText(ADrawParams, Description, ADescriptionRect, DT_LEFT, 2);
      end;
      Canvas.Font.Style := Canvas.Font.Style + [fsBold];
    end;
  end;

var
  ACaptionRect: TRect;
begin
  with ADrawParams do
  begin
    InflateRect(R, 0, SubMenuControlInternalBorderSize);
    ACaptionRect := R;
    if BarItemControl.ShowDescription then
      DrawDescription(ACaptionRect);
    DrawItemText(BarItemControl, Canvas.Handle, Caption, ACaptionRect, DT_LEFT,
      Enabled, DrawSelected, False, False, IsFlatItemTextForMenu);
    if BarItemControl.CanShowShortCut and (ShortCut <> '') then
    begin
      Dec(ACaptionRect.Right, 5 + BarItemControl.Parent.TextSize);
      DrawItemText(BarItemControl, Canvas.Handle, ShortCut, ACaptionRect, DT_RIGHT,
        Enabled, DrawSelected, False, False, IsFlatItemTextForMenu);
    end;
  end;
end;

class procedure TdxBarPainter.DrawLowered(DC: HDC; var R: TRect);
begin
  DrawEdge(DC, R, BDR_SUNKENOUTER, BF_RECT);
  InflateRect(R, -1, -1); // LoweredBorderSize(ABarItemControl) = 1
end;

class procedure TdxBarPainter.FrameAndFillRect(ABarItemControl: TdxBarItemControl;
  DC: HDC; var R: TRect; Enabled, Selected, Pressed: Boolean);
begin
  // Required
end;

class function TdxBarPainter.GetCaptionOffsets: TRect;
begin
  Result := Rect(2, 2, 2, 3);
end;

class function TdxBarPainter.GlyphBkgndBrush(ABarItemControl: TdxBarItemControl;
  APaintType: TdxBarPaintType; AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown,
  AForceUseBkBrush, AGrayScale: Boolean): HBRUSH;
begin
  Result := ABarItemControl.BkBrush;
end;

class function TdxBarPainter.GlyphDownShift(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := 0;
end;

class function TdxBarPainter.GlyphDrawDownedShift(ABarItemControl: TdxBarItemControl;
  ADown: Boolean): Integer;
begin
  Result := 0;
end;

class function TdxBarPainter.IsFlatGlyphImage: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.IsFlatItemText: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.IsFlatItemTextForMenu: Boolean;
begin
  Result := IsFlatItemText and not IsHighContrastWhite;
end;

function TdxBarPainter.IsCustomSelectedTextColorExists(ABarItemControl: TdxBarItemControl): Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.IsGlyphImageBackgroundOpaque(ABarItemControl: TdxBarItemControl;
  ADown, ADrawDowned, ASelected, AGlyphEmpty: Boolean): Boolean;
begin
  Result := ABarItemControl.FNonRecent;
  if AGlyphEmpty then
    Result := Result or ADown or ADrawDowned or ASelected
  else
    Result := Result or ABarItemControl.IsBkColorAssigned;
end;

class function TdxBarPainter.IsGlyphImageHasShadow: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.IsGlyphImageTransparent(ABarItemControl: TdxBarItemControl): Boolean;
begin
  Result := IsNativeBackground or not ABarItemControl.FNonRecent and ABarItemControl.Parent.IsTransparent;
end;

class function TdxBarPainter.IsItemTextSelectedInverted: Boolean;
begin
  Result := True;
end;

class function TdxBarPainter.LoweredBorderSize(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := 0;
end;

class function TdxBarPainter.TextAreaOffset(ABarItemControl: TdxBarItemControl): Integer;
begin
  if ABarItemControl.Parent.Kind = bkSubMenu then
    Result := ABarItemControl.Parent.TextSize + 1
  else
    Result := 0;
end;

function TdxBarPainter.BarFingersSize(ABar: TdxBar): Integer;
begin
  if ABar.Control.CanMoving then
    Result := FingersSize(ABar.Control)
  else
    Result := EmptyFingersSize;
end;

function TdxBarPainter.BeforeFingersSize: Integer;
begin
  // Required
  Result := 0;
end;

class function TdxBarPainter.BorderSizeX: Integer;
begin
  Result := GetSystemMetrics(SM_CXFRAME);
end;

class function TdxBarPainter.BorderSizeY: Integer;
begin
  Result := GetSystemMetrics(SM_CYFRAME);
end;

class function TdxBarPainter.EmptyFingersSize: Integer;
begin
  Result := 0;
end;

function TdxBarPainter.FingersSize(ABarControl: TdxBarControl): Integer;
begin
  // Required
  Result := 0;
end;

function TdxBarPainter.GripperSize(ABarControl: TdxBarControl): Integer;
begin
  Result := dxBarFingerSize;
end;

class function TdxBarPainter.RealButtonArrowWidth(ABarManager: TdxBarManager): Integer;
begin
  Result := (1 + Byte(ABarManager.LargeIcons)) * ABarManager.FButtonArrowWidth;
  if not Odd(Result) then Inc(Result);
end;

class function TdxBarPainter.RealLargeButtonArrowWidth(ABarManager: TdxBarManager): Integer;
begin
  Result := ABarManager.FLargeButtonArrowWidth;
end;

class function TdxBarPainter.SubMenuBeginGroupIndent: Integer;
begin
  // Required
  Result := 0;
end;

procedure TdxBarPainter.DockControlFillBackground(ADockControl: TdxDockControl;
  DC: HDC; ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  FillBackgroundRect(DC, ADestR, ASourceR, ABrush, AColor, nil);
end;

class function TdxBarPainter.IsNativeBackground: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.BarChildrenHaveShadows(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := False;
end;

procedure TdxBarPainter.BarDrawDockedBackground(ABarControl: TdxBarControl;
  DC: HDC; ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  BarFillParentBackground(ABarControl, DC, ADestR, ASourceR, ABrush, AColor);
end;

class function TdxBarPainter.BarControlOwnerBrush(ABarManager: TdxBarManager): HBRUSH;
begin
  Result := ABarManager.FlatToolbarsBrush;
end;

class function TdxBarPainter.BarDockedGetRowIndent: Integer;
begin
  Result := 0;
end;

procedure TdxBarPainter.BarDrawFloatingBackground(ABarControl: TCustomdxBarControl;
  DC: HDC; ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  FillBackgroundRect(DC, ADestR, ASourceR, ABrush, AColor, ABarControl.BarManager.Backgrounds.Bar);
end;

class procedure TdxBarPainter.BarDrawOwnerLink(ABarControl: TCustomdxBarControl; DC: HDC);
begin
  if not IsRectEmpty(ABarControl.OwnerLinkBounds[False]) then
    FillRect(DC, ABarControl.OwnerLinkBounds[False], ABarControl.BarControlOwnerBrush);
end;

procedure TdxBarPainter.BarFillParentBackground(ABarControl: TCustomdxBarControl;
  DC: HDC; const ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor);
var
  ABounds: TRect;
begin
  if ABarControl.DockControl <> nil then
  begin
    ABounds := ABarControl.BoundsRect;
    ABarControl.DockControl.FillBackground(DC, ADestR,
      cxRectOffset(ASourceR, ABounds.Left, ABounds.Top), ABrush, AColor);
  end;
end;

function TdxBarPainter.BarHasShadow(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := IsButtonControlArrowFlat and (ABarControl.DockingStyle = dsNone);
end;

function TdxBarPainter.BarLinkedOwnerHasShadow(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := BarHasShadow(ABarControl);
end;

class function TdxBarPainter.BarToolbarBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := GetSysColorBrush(COLOR_BTNFACE);
end;

class function TdxBarPainter.BarToolbarBrushEx(ABarControl: TdxBarControl): HBRUSH;
begin
  Result := BarToolbarBrush(ABarControl);
end;

class function TdxBarPainter.BarToolbarDownedBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := PatternBrush;
end;

class function TdxBarPainter.BarToolbarDownedSelBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := GetSysColorBrush(COLOR_BTNFACE);
end;

class function TdxBarPainter.BarToolbarSelBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := GetSysColorBrush(COLOR_HIGHLIGHT);
end;

function TdxBarPainter.ComboBoxArrowWidth(ABarControl: TCustomdxBarControl; cX: Integer): Integer;
begin
  Result := 2 * cX - 1;
end;

class function TdxBarPainter.EditTextSize(ABarControl: TCustomdxBarControl; cY: Integer): Integer;
var
  ABorderOffsets, ATextOffsets: TRect;
  ATextHeightCorrection: Integer;
begin
  ABorderOffsets := EditControlBorderOffsets(ABarControl.GetPaintType);
  GetEditTextParams(ATextOffsets, ATextHeightCorrection);
  Result := ABorderOffsets.Top + ATextOffsets.Top + cY + ATextOffsets.Bottom +
    ABorderOffsets.Bottom + ATextHeightCorrection;
end;

class procedure TdxBarPainter.GetEditTextParams(out AOffsets: TRect;
  out AHeightCorrection: Integer);
var
  ACaptionOffsets: TRect;
begin
  ACaptionOffsets := GetCaptionOffsets;
  AOffsets := ACaptionOffsets;
  GetEditTextVerticalOffsets(AOffsets.Top, AOffsets.Bottom);
  AHeightCorrection := ACaptionOffsets.Top + ACaptionOffsets.Bottom -
   (AOffsets.Top + AOffsets.Bottom);
end;

class procedure TdxBarPainter.GetEditTextVerticalOffsets(
  out ATop, ABottom: Integer);
begin
  ATop := 2;
  ABottom := 2;
end;

class procedure TdxBarPainter.SetWindowRgn(AHandle: THandle;
  const AWindowRect: TRect; ARedraw: Boolean = False);
begin
// do nothing
end;

class function TdxBarPainter.BarAllowHotTrack: Boolean;
begin
  Result := True;
end;

class function TdxBarPainter.BarAllowQuickCustomizing: Boolean;
begin
  Result := True;
end;

function TdxBarPainter.BarBeginGroupSideSize: Integer;
begin
  Result := (BarBeginGroupSize - (1 + 1){|}) div 2;
end;

function TdxBarPainter.BarBeginGroupSize: Integer;
begin
  Result := 2 + (1 + 1){|} + 2;
end;

procedure TdxBarPainter.BarBorderPaintSizes(ABarControl: TdxBarControl;
  var R: TRect);
begin
  R := Rect(BarBorderSize, BarBorderSize, BarBorderSize, BarBorderSize);
end;

class function TdxBarPainter.BarBorderSize: Integer;
begin
  Result := 1;
end;

procedure TdxBarPainter.BarBorderSizes(ABar: TdxBar; AStyle: TdxBarDockingStyle;
  var R: TRect);
begin
  R := Rect(2, 2, 2, 2);
end;

class function TdxBarPainter.BarCaptionAreaSize: Integer;
begin
  Result := BarCaptionSize + 1;
end;

procedure TdxBarPainter.BarCaptionFillBackground(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AToolbarBrush: HBRUSH);
begin
  FillRect(DC, R, AToolbarBrush);
end;

class function TdxBarPainter.BarCaptionSize: Integer;
var
  NonClientMetrics: TNonClientMetrics;
begin
  NonClientMetrics.cbSize := SizeOf(NonClientMetrics);
  SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, @NonClientMetrics, 0);
  Result := NonClientMetrics.iSmCaptionHeight;
end;

class function TdxBarPainter.BarCaptionTransparent: Boolean;
begin
  Result := False; 
end;

class function TdxBarPainter.BarCloseButtonSize: TSize;
begin
  Result.cx := BarCaptionSize;
  Result.cy := Result.cx;
end;

procedure TdxBarPainter.BarDrawBackground(ABarControl: TdxBarControl; ADC: HDC;
  const ADestRect, ASourceRect: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  // check background
  if not ABarControl.GetBackgroundBitmap.Empty then
    FillBackgroundRect(ADC, ADestRect, ASourceRect, ABrush, AColor, ABarControl.GetBackgroundBitmap)
  else
  begin
    if ABarControl.Bar.IsStatusBar and ABarControl.BarManager.Backgrounds.Bar.Empty then
      StatusBarFillBackground(ABarControl, ADC, ADestRect, ASourceRect, Rect(0, 0, ABarControl.Width, ABarControl.Height), ABrush, AColor)
    else
    begin
      if ABarControl.Bar.Color = clDefault then
      begin
        if ABarControl.DockControl <> nil then
          BarDrawDockedBackground(ABarControl, ADC, ADestRect, ASourceRect, ABrush, AColor)
        else
          BarDrawFloatingBackground(ABarControl, ADC, ADestRect, ASourceRect, ABrush, AColor)
      end
      else
        FillRectByColor(ADC, ADestRect, ABarControl.Bar.Color); // TODO
    end;
  end;
end;

procedure TdxBarPainter.BarDrawBeginGroup(ABarControl: TCustomdxBarControl;
  DC: HDC; ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean);
begin
  if AHorz then
  begin
    with ABeginGroupRect do
    begin
      ABarControl.FillBackground(DC,
        Rect(Left, Top, Right, Top + BarBeginGroupSideSize),
        AToolbarBrush, clNone, True);
      ABarControl.FillBackground(DC,
        Rect(Left, Bottom - BarBeginGroupSideSize, Right, Bottom),
        AToolbarBrush, clNone, True);
    end;
    InflateRect(ABeginGroupRect, 0, -BarBeginGroupSideSize);
    DrawEdge(DC, ABeginGroupRect, EDGE_ETCHED, BF_TOP)
  end
  else
  begin
    with ABeginGroupRect do
    begin
      ABarControl.FillBackground(DC,
        Rect(Left, Top, Left + BarBeginGroupSideSize, Bottom),
        AToolbarBrush, clNone, True);
      ABarControl.FillBackground(DC,
        Rect(Right - BarBeginGroupSideSize, Top, Right, Bottom),
        AToolbarBrush, clNone, True);
    end;
    InflateRect(ABeginGroupRect, -BarBeginGroupSideSize, 0);
    DrawEdge(DC, ABeginGroupRect, EDGE_ETCHED, BF_LEFT);
  end;  
end;

class procedure TdxBarPainter.BarDrawCaptionElement(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AState: TdxBarMarkState);
var
  ABrush: HBRUSH;
begin
  if AState <> msNone then
  begin
    FrameFlatSelRect(DC, R);
    InflateRect(R, -1, -1);
    if AState = msSelected then
      ABrush := ABarControl.ToolbarSelBrush
    else
      ABrush := ABarControl.ToolbarDownedSelBrush;
    FillRect(DC, R, ABrush);
  end
  else
    FillRectByColor(DC, R, ABarControl.CaptionBkColor);
end;

procedure TdxBarPainter.BarDrawCloseButton(ABarControl: TdxBarControl;
  DC: HDC; R: TRect);
begin
  // Required
end;

procedure TdxBarPainter.BarDrawDockedBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AToolbarBrush: HBRUSH);
begin
  // Required
end;

procedure TdxBarPainter.BarDrawFloatingBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R, CR: TRect; AToolbarBrush: HBRUSH);
begin
  // Required
end;

procedure TdxBarPainter.BarDrawFloatingBarCaption(ABarControl: TdxBarControl;
  DC: HDC; R, CR: TRect; AToolbarBrush: HBRUSH);
var
  R1: TRect;
  X: Integer;
  ATransparent: Boolean;

  procedure DrawCaption;
  var
    S: string;
    AFont: HFONT;
    Size: TSize;
    APrevBkMode: Integer;
    AFlags: Integer;
  begin
    if R.Right - R.Left <= 0 then Exit;
    S := ABarControl.GetCaption;
    AFont := SelectObject(DC, CreateToolbarCaptionFontHandle(ABarControl.Font, ABarControl.BarManager.UseSystemFont));
//    SetTextColor(DC, GetSysColor(COLOR_CAPTIONTEXT));
    SetTextColor(DC, ABarControl.CaptionColor);
    SetBkColor(DC, ABarControl.CaptionBkColor);
    AFlags := ETO_CLIPPED;
    if ATransparent then
      APrevBkMode := SetBkMode(DC, TRANSPARENT)
    else
    begin
      AFlags := AFlags or ETO_OPAQUE;
      APrevBkMode := 0; // WARN OFF
    end;  
    cxGetTextExtentPoint32(DC, S, Size);
    cxExtTextOut(DC, S, Point(X, (R.Top + R.Bottom - Size.cy) div 2), R, AFlags);
    if ATransparent then
      SetBkMode(DC, APrevBkMode);
    DeleteObject(SelectObject(DC, AFont));
  end;

begin
  R1 := R;
  R1.Top := R.Bottom;
  R1.Bottom := R1.Top + 1;
  FillRect(DC, R1, AToolbarBrush);

  ATransparent := BarCaptionTransparent;
  if ATransparent then
    BarCaptionFillBackground(ABarControl, DC, R, AToolbarBrush);
  if ABarControl.HasCloseButton then
  begin
    Dec(R.Right, BarCaptionSize);
    ABarControl.DrawCloseButton(DC);
  end;
  X := R.Left;
  if ABarControl.MarkExists then
    BarOffsetFloatingBarCaption(ABarControl, X, R)
  else
    Inc(X, 2);

  DrawCaption;
  if ABarControl.MarkExists then ABarControl.DrawMark(DC);
end;

procedure TdxBarPainter.BarDrawMark(ABarControl: TdxBarControl; DC: HDC; MarkR: TRect);
begin
  BarDrawMarkArrow(ABarControl, DC, MarkR);
end;

procedure TdxBarPainter.BarDrawMarks(ABarControl: TdxBarControl;
  ACanvas: TcxCanvas; const AItemRect: TRect; AToolbarBrush: HBRUSH);
begin
  if ABarControl.MarkFadingHelper.IsEmpty then
    BarDrawMarkBackground(ABarControl, ACanvas.Handle, AItemRect, AToolbarBrush)
  else
    ABarControl.MarkFadingHelper.DrawImage(ACanvas.Handle, AItemRect);
  BarDrawMarkElements(ABarControl, ACanvas.Handle, AItemRect);
end;

procedure TdxBarPainter.BarDrawMDIButton(ABarControl: TdxBarControl;
  AButton: TdxBarMDIButton; AState: Integer; DC: HDC; R: TRect);
begin
  // Required
end;

procedure TdxBarPainter.BarDrawStatusBarGrip(ABarControl: TdxBarControl;
  DC: HDC; const R: TRect; AToolbarBrush: HBRUSH);
var
  AGripRect: TRect;
  AGripBackgroundRect: TRect;
begin
  AGripBackgroundRect := cxRectContent(R, StatusBarBorderOffsets);
  AGripBackgroundRect.Left := AGripBackgroundRect.Right - StatusBarGripSize(ABarControl.BarManager).cx;
  AGripRect := AGripBackgroundRect;
  AGripRect.Top := AGripRect.Bottom - StatusBarGripSize(ABarControl.BarManager).cy;
  ABarControl.FillBackground(DC, AGripBackgroundRect, AToolbarBrush, clNone, False);
  BarDrawGrip(ABarControl, DC, AGripRect, AToolbarBrush);
end;

procedure TdxBarPainter.BarDrawStatusBarBorder(ABarControl: TdxBarControl; DC: HDC;
  R: TRect; AToolbarBrush: HBRUSH);
begin
  R.Bottom := R.Top + StatusBarTopBorderSize;
  ABarControl.FillBackground(DC, R, AToolbarBrush, clNone, False);
end;

class function TdxBarPainter.BarHorSize: Integer;
begin
  Result := 0;
end;

function TdxBarPainter.BarMarkRect(ABarControl: TdxBarControl): TRect;
begin
  Result := BarMarkItemRect(ABarControl);
end;

function TdxBarPainter.BarMarkItemRect(ABarControl: TdxBarControl): TRect;
var
  ACaptionRect: TRect;
begin
  case ABarControl.DockingStyle of
    dsTop, dsBottom:
      with Result do
      begin
        Left := ABarControl.ClientWidth - ABarControl.MarkSize;
        Top := 0;
        Right := Left + ABarControl.MarkSize;
        Bottom := ABarControl.ClientHeight;
      end;
    dsLeft, dsRight:
      with Result do
      begin
        Left := 0;
        Top := ABarControl.ClientHeight - ABarControl.MarkSize;
        Right := ABarControl.ClientWidth;
        Bottom := Top + ABarControl.MarkSize;
      end;
  else
    Result := ABarControl.GetCaptionRect;
    if ABarControl.DockingStyle = dsNone then
    begin
      ACaptionRect := Result;
      Result.Left := Result.Right - cxRectHeight(Result);
      if ABarControl.HasCloseButton then
        OffsetRect(Result, -(cxRectWidth(ABarControl.CloseButtonRect) + FloatToolbarMarkIndent), 0);
      Result.Left := Max(Result.Left, ACaptionRect.Left{ - 3});
    end;
  end;
end;

procedure TdxBarPainter.BarMarkRectInvalidate(ABarControl: TdxBarControl);
var
  DC: HDC;
begin
  if ABarControl.DockingStyle = dsNone then
  begin
    DC := GetWindowDC(ABarControl.Handle);
    ABarControl.DrawMark(DC);
    ReleaseDC(ABarControl.Handle, DC);
  end
  else
    cxInvalidateRect(ABarControl.Handle, BarMarkItemRect(ABarControl), False);
end;

class function TdxBarPainter.BarTopSize: Integer;
begin
  Result := 0;
end;

class function TdxBarPainter.BarBottomSize: Integer;
begin
  Result := 0;
end;

class function TdxBarPainter.BarUseSystemClose: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.BarUseSystemNCBorder: Boolean;
begin
  Result := False;
end;

function TdxBarPainter.MarkSizeX(ABarControl: TdxBarControl): Integer;
begin
  Result := 11;
end;

procedure TdxBarPainter.StatusBarFillBackground(ABarControl: TdxBarControl; DC: HDC;
  ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  if IsNativeBackground and ABarControl.BarManager.FThemeAvailable then
    TdxBarXPPainter.StatusBarFillNativeBackground(ABarControl, DC, ADestR,
      ASourceR, AWholeR, ABrush, AColor)
  else
    FillBackgroundRect(DC, ADestR, ASourceR, ABrush, AColor, nil);
end;

function TdxBarPainter.StatusBarBorderOffsets: TRect;
begin
  Result := cxEmptyRect;
end;

class function TdxBarPainter.StatusBarTopBorderSize: Integer;
begin
  Result := 2;
end;

function TdxBarPainter.StatusBarGripSize(ABarManager: TdxBarManager): TSize;
begin
  if IsNativeBackground and ABarManager.FThemeAvailable then
    Result := TdxBarXPPainter.StatusBarNativeGripSize(ABarManager)
  else
    Result := cxSize(GetSystemMetrics(SM_CXHSCROLL), GetSystemMetrics(SM_CYHSCROLL));
end;

class function TdxBarPainter.BarToolbarBrushEx2(ABarControl: TdxBarControl): HBRUSH;
begin
  Result := BarToolbarBrushEx(ABarControl);
end;

class procedure TdxBarPainter.DrawQuickCustItemFrame(ABarItemControl: TdxBarItemControl;
  DC: HDC; var R, ARect: TRect; Selected: Boolean);
begin
  with R do
    Right := Left + Bottom - Top;
  ARect.Left := R.Right;
end;

class procedure TdxBarPainter.DrawQuickCustItemFrameSelected(ABarItemControl: TdxBarItemControl;
  DC: HDC; WholeR, R: TRect; Selected: Boolean);
begin
end;

class function TdxBarPainter.IsQuickControlPopupOnRight: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.GetTailAreaSize(const ADrawParams: TdxBarItemControlDrawParams): Integer;
begin
  Result := ADrawParams.BarItemControl.Parent.IconAreaSize;
end;

class function TdxBarPainter.ItemControlGetIndents(const ADrawParams: TdxBarItemControlDrawParams;
  ADrawAreaType: TdxBarItemControlPart): TRect;
begin
  Result := cxRect(3, 0, 3, 0);
end;

function TdxBarPainter.ButtonControlArrowBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH;
begin
  Result := ADrawParams.BarItemControl.BkBrush;
end;

function TdxBarPainter.IsButtonControlArrowBackgroundOpaque(const ADrawParams: TdxBarButtonLikeControlDrawParams): Boolean;
begin
  with ADrawParams do
    Result := BarItemControl.FNonRecent or IsFlatItemText and (DroppedDown or DrawSelected);
end;

function TdxBarPainter.IsButtonControlArrowDrawSelected(const ADrawParams: TdxBarButtonLikeControlDrawParams): Boolean;
begin
  with ADrawParams do
    Result := IsFlatItemText and
      (IsHighContrastWhite and DrawSelected and
      ((PaintType = ptMenu) or not DroppedDown) or ((PaintType = ptMenu) and DroppedDown)) or
      not IsFlatItemText and IsButtonControlArrowFlat and DroppedDown;
end;

function TdxBarPainter.IsButtonControlArrowFlat: Boolean;
begin
  Result := IsFlatItemText;
end;

function TdxBarPainter.IsDropDownRepaintNeeded: Boolean;
begin
  Result := IsFlatItemText;
end;

function TdxBarPainter.GetButtonBorderHeight: Integer;
begin
  Result := dxBarButtonBorderHeight;
end;

function TdxBarPainter.GetButtonBorderWidth: Integer;
begin
  Result := dxBarButtonBorderWidth;
end;

function TdxBarPainter.GetButtonHeight(AIconSize, ATextSize: Integer): Integer;
begin
  Result := AIconSize + GetButtonBorderHeight;
end;

function TdxBarPainter.GetButtonWidth(AIconSize, ATextSize: Integer): Integer;
begin
  Result := AIconSize + GetButtonBorderWidth;
end;

function TdxBarPainter.GetButtonSize(AIconSize, ATextSize: Integer): TSize;
begin
  Result := Size(GetButtonWidth(AIconSize, ATextSize), GetButtonHeight(AIconSize, ATextSize));
end;

class procedure TdxBarPainter.CorrectButtonControlDefaultHeight(var DefaultHeight: Integer);
begin
end;

class procedure TdxBarPainter.CorrectButtonControlDefaultWidth(var DefaultWidth: Integer);
begin
end;

procedure TdxBarPainter.OffsetCaptionBounds(ADowned, ADrawDowned: Boolean; var R: TRect);
begin
  if not IsFlatItemText then
  begin
    if ADowned or ADrawDowned then
      OffsetRect(R, 1, 1);
    if not IsButtonControlArrowFlat and ADowned and ADrawDowned then
      OffsetRect(R, 1, 1);
  end;
end;

class procedure TdxBarPainter.OffsetEllipsisBounds(APressed: Boolean; var R: TRect);
begin
  if not IsFlatItemText and APressed then
    OffsetRect(R, 1, 1);
end;

procedure TdxBarPainter.DrawButtonLikeControl(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect);

  function GetFullBounds(const AFullRect: TRect): TRect;
  begin
    if ADrawParams.DroppedDownFlat then
      Result := ARect
    else
      if ADrawParams.ViewSize = cvsLarge then
        Result := AFullRect
      else
        Result := cxEmptyRect;
  end;

var
  R, AFullRect, AImageBounds: TRect;
  ATextAlignment: DWORD;
begin
  with ADrawParams do
  begin
    if IsLowered then
      DrawLowered(Canvas.Handle, ARect);

    if PaintType = ptMenu then
      DrawGlyphAndTextInSubMenu(ADrawParams, ARect)
    else
    begin
      R := ARect;

      if IsDropDown and SplitDropDown then
        Dec(R.Right, cxRectWidth(BarItemControl.FParts[bcpDropButton]));

      if ViewSize = cvsLarge then
      begin
        AFullRect := R;
        InflateRect(R, -1, -1);
        OffsetCaptionBounds(Downed, DrawDowned, R);
      end
      else
        AFullRect := ARect;

      DrawGlyph(BarItemControl, Canvas.Handle, R, GetFullBounds(AFullRect), AImageBounds,
        PaintType, ViewStructure, ViewSize, not (cpIcon in ViewStructure),
        DrawSelected, Downed, DrawDowned, DroppedDown, False, False, GrayScale, SplitDropDown and IsDropDown);

      if cpText in ViewStructure then
      begin
        CorrectCaptionParams(ADrawParams, R, AImageBounds, ATextAlignment);
        DrawItemText(BarItemControl, Canvas.Handle, Caption, R, ATextAlignment, Enabled, IsTextSelected, PaintType = ptVert, False, IsFlatText);
      end;
    end;

    if IsDropDown and not IsMenuItem then
    begin
      if SplitDropDown then
        DrawSplitControlArrow(ADrawParams, ARect)
      else
        DrawAssociateControlArrow(ADrawParams, ARect);
    end;
  end;
end;

procedure TdxBarPainter.DrawButtonLikeControlCaption(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; const ARect, AImageBounds: TRect);
var
  ATextAlignment: DWORD;
  ATextBounds: TRect;
begin
  if cpText in ADrawParams.ViewStructure then
  begin
    ATextBounds := ARect;
    CorrectCaptionParams(ADrawParams, ATextBounds, AImageBounds, ATextAlignment);
    ButtonLikeControlDoDrawCaption(ADrawParams, ATextBounds, ATextAlignment, DT_END_ELLIPSIS or DT_SINGLELINE);
  end;
end;

procedure TdxBarPainter.DrawButtonControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams;
  R1: TRect);
begin
  with ADrawParams do
  begin
    if not IsButtonControlArrowFlat and DroppedDown and ((cxRectWidth(R1) > 9) or (PaintType = ptMenu)) then
      OffsetRect(R1, 1, 1);

    if PaintType = ptMenu then
      DrawLargeItemArrow(Canvas.Handle, R1, adRight, ArrowSize.cy,
        IsButtonControlArrowDrawSelected(ADrawParams), Enabled and DropDownEnabled, IsButtonControlArrowFlat, GetItemArrowColor(ADrawParams))
    else
      DrawItemArrow(Canvas.Handle, R1, adDown, Enabled and DropDownEnabled,
        IsButtonControlArrowDrawSelected(ADrawParams), IsButtonControlArrowFlat, GetItemArrowColor(ADrawParams));
  end;
end;

procedure TdxBarPainter.DrawButtonControlArrowBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams;
  var R1: TRect; ABrush: HBRUSH);
begin
  with ADrawParams do
  begin
    if IsFlatItemText and (PaintType <> ptMenu) then
      Dec(R1.Left);
    if not IsFlatItemText or (PaintType = ptMenu) or not DroppedDown then
      DrawBackground(BarItemControl, Canvas.Handle, R1, ABrush, IsButtonControlArrowBackgroundOpaque(ADrawParams));
  end;
end;

procedure TdxBarPainter.DrawSplitControlArrow(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect);
begin
  ARect.Left := ARect.Right - ADrawParams.ArrowSize.cx;
  DrawButtonControlArrowBackground(ADrawParams, ARect, ButtonControlArrowBrush(ADrawParams));
  DrawButtonControlArrow(ADrawParams, ARect);
end;

procedure TdxBarPainter.DrawAssociateControlArrow(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect);

  function IsArrowDrawSelected: Boolean;
  begin
    with ADrawParams do
      Result := (PaintType = ptMenu) and DrawSelected and not IsFlatItemTextForMenu or
        (PaintType <> ptMenu) and IsTextSelected; 
  end;

  function GetArrowRect(const ARect: TRect): TRect;
  begin
    Result := ARect;
    with ADrawParams do
      case PaintType of
        ptVert: Result.Top := Result.Bottom - BarItemControl.Parent.TextSize div 2 + BarItemControl.Parent.Font.Height div 2;
        ptHorz: Result.Left := Result.Right - BarItemControl.Parent.TextSize div 2 + BarItemControl.Parent.Font.Height div 2;
      else{ptMenu}
        Result.Left := Result.Right - BarItemControl.Parent.TextSize + ArrowSize.cy;
      end;
  end;

  function GetArrowSize: Integer;
  begin
    Result := ADrawParams.ArrowSize.cy;
    if ADrawParams.PaintType <> ptMenu then
      Dec(Result);
  end;

const
  Direction: array[TdxBarPaintType] of TcxArrowDirection = (adDown, adRight, adRight);
begin
  with ADrawParams do
  begin
    if PaintType <> ptMenu then
      OffsetCaptionBounds(False, DroppedDown, ARect);
    DrawLargeItemArrow(Canvas.Handle, GetArrowRect(ARect), Direction[PaintType], GetArrowSize,
      IsArrowDrawSelected, Enabled, IsFlatItemText, GetItemArrowColor(ADrawParams));
  end;
end;

function TdxBarPainter.ComboControlArrowColor(ADrawParams: TdxBarItemControlDrawParams): TColor;
begin
  Result := clBtnText;
end;

function TdxBarPainter.ComboControlButtonBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH;
begin
  Result := ButtonControlArrowBrush(ADrawParams);
end;

class function TdxBarPainter.ComboControlArrowOffset: Integer;
begin
  Result := 1;
end;

class function TdxBarPainter.ComboControlButtonOffsets(APaintType: TdxBarPaintType): TRect;
begin
  Result := EditControlBorderOffsets(APaintType);
end;

procedure TdxBarPainter.ComboControlDrawArrowButton(
  const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect;
  AInClientArea: Boolean);

  function GetArrowSize(const AArrowRect: TRect): Integer;
  begin
    Result := cxRectWidth(AArrowRect) div 4;
    if not Odd(Result) then
      Inc(Result);
  end;

begin
  ComboControlDrawSimpleButton(ADrawParams, ARect, ComboControlButtonBrush(ADrawParams));
  ComboControlDrawArrow(ADrawParams, ARect, GetArrowSize(ARect), ComboControlArrowColor(ADrawParams));
end;

class procedure TdxBarPainter.ComboControlDrawSimpleButton(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect; ABrush: HBRUSH);
begin
  // Required
end;

class function TdxBarPainter.DropDownListBoxBorderSize: Integer;
begin
  Result := 2;
end;

procedure TdxBarPainter.DropDownListBoxDrawBorder(DC: HDC; AColor: TColor; ARect: TRect);
begin
  FrameRect(DC, ARect, GetSysColorBrush(COLOR_BTNSHADOW));
  InflateRect(ARect, -1, -1);
  FrameRectByColor(DC, ARect, AColor);
end;

class function TdxBarPainter.SubMenuControlHasBand: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.SubMenuControlIsOffsetRecentGroupNeeded: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.SubMenuControlArrowsOffset: Integer;
begin
  Result := 2;
end;

class function TdxBarPainter.SubMenuControlArrowWidth(ATextSize: Integer): Integer;
begin
  Result := ATextSize div 4 * 3 + 1;
end;

function TdxBarPainter.SubMenuControlBeginGroupRect(
  ABarSubMenuControl: TdxBarSubMenuControl; AControl: TdxBarItemControl;
  const AItemRect: TRect): TRect;
begin
  Result := AItemRect;
  if AControl.FChangeRecentGroup and AControl.NonRecent then
    Dec(Result.Top);
  Result.Bottom := Result.Top;
  Dec(Result.Top, ABarSubMenuControl.BeginGroupSize);
end;

function TdxBarPainter.SubMenuControlBeginGroupSize: Integer;
begin
  Result := 4 + 2 + 4;
end;

class function TdxBarPainter.SubMenuControlBorderSize: Integer;
begin
  Result := SubMenuControlNCBorderSize + SubMenuControlClientBorderSize;
end;

class function TdxBarPainter.SubMenuControlNCBorderSize: Integer;
begin
  Result := 1;
end;

class function TdxBarPainter.SubMenuControlClientBorderSize: Integer;
begin
  Result := 1;
end;

procedure TdxBarPainter.SubMenuControlCalcDrawingConsts(ACanvas: TcxCanvas;
  ATextSize: Integer; out AMenuArrowWidth, AMarkSize: Integer);
var
  AArrowSize: Integer;
begin
  AMenuArrowWidth := SubMenuControlArrowWidth(ATextSize);
  AMarkSize := ACanvas.TextHeight('0') + 1;
  AArrowSize := SubMenuControlMarkArrowSize(AMarkSize);
  if Odd(AArrowSize) then AMarkSize := (AArrowSize - 1) * 2 + 2 * 3;
end;

class function TdxBarPainter.SubMenuControlInternalBorderSize: Integer;
begin
  Result := 0;
end;

class function TdxBarPainter.SubMenuControlInternalBorderOffset: Integer;
begin
  Result := 0;
end;

class function TdxBarPainter.SubMenuControlContentRectOffset(ABarSubMenuControl: TdxBarSubMenuControl): TRect;
var
  AOffset: Integer;
begin
  AOffset := SubMenuControlClientBorderSize;
  Result := Rect(AOffset, AOffset, AOffset, AOffset);
end;

class function TdxBarPainter.SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := 2 + ABarSubMenuControl.DetachCaptionSize + 1;
end;

procedure TdxBarPainter.SubMenuControlDrawScrollButton(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection);
begin
  // do nothing
end;

procedure TdxBarPainter.SubMenuControlDrawBackground(ABarSubMenuControl: TdxBarSubMenuControl;
  ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  FillBackgroundRect(ACanvas.Handle, ARect, ARect, ABrush, AColor, ABarSubMenuControl.GetBackgroundBitmap);
end;

procedure TdxBarPainter.SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect);
begin
  with R do
  begin
    FillRect(DC, Rect(Left, Top, Left + 1, Bottom - 1), COLOR_BTNFACE + 1);
    FillRect(DC, Rect(Left + 1, Top, Right - 1, Top + 1), COLOR_BTNFACE + 1);
  end;
  DrawEdge(DC, R, BDR_RAISEDOUTER, BF_BOTTOMRIGHT);
  if ABarSubMenuControl.Detachable then
  begin
    InflateRect(R, -1, -1);
    DrawEdge(DC, R, BDR_RAISEDINNER, BF_RECT - BF_BOTTOM);
    InflateRect(R, -1, -1);
    R.Bottom := R.Top + ABarSubMenuControl.DetachCaptionAreaSize - 1;
    FrameRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));
    SubMenuControlDrawDetachCaption(ABarSubMenuControl, DC, ABarSubMenuControl.DetachCaptionRect);
  end;
end;

procedure TdxBarPainter.SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; const R: TRect; ABrush: HBRUSH);
var
  ARect: TRect;
begin
  ARect := R;
  if ABarSubMenuControl.Detachable then
    ARect.Top := ARect.Top - 2;
  DrawEdge(DC, ARect, BDR_RAISEDINNER, BF_RECT);
  InflateRect(ARect, -1, -1);
  FrameRect(DC, ARect, ABrush);
end;

procedure TdxBarPainter.SubMenuControlDrawDetachCaption(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect);
const
  Colors: array[Boolean] of COLORREF = (COLOR_INACTIVECAPTION, COLOR_ACTIVECAPTION);
begin
  FillRect(DC, R, Colors[ABarSubMenuControl.DetachCaptionSelected] + 1);
end;

procedure TdxBarPainter.SubMenuControlDrawBeginGroup(ABarSubMenuControl: TdxBarSubMenuControl;
  AControl: TdxBarItemControl; ACanvas: TcxCanvas; const ABeginGroupRect: TRect);
var
  R: TRect;
  ABrush: HBRUSH;
  LD, RD: Integer;
  AOpaque: Boolean;
  ADC: HDC;
begin
  ADC := ACanvas.Handle;
  RD := Byte(AControl.FNonRecent);
  R := ABeginGroupRect;
  if AControl.FChangeRecentGroup and AControl.FNonRecent then
  begin
    RD := 0;
    ABrush := ABarSubMenuControl.ToolbarBrush;
  end
  else
    ABrush := ABarSubMenuControl.BkBrush;
  LD := RD * Ord(ABarSubMenuControl.BarSize = 0);
  AOpaque := AControl.FNonRecent and not AControl.FChangeRecentGroup;
  DrawBackground(AControl, ADC, Rect(R.Left - LD, R.Top, R.Right + 2 * RD, R.Bottom), ABrush, AOpaque);
  InflateRect(R, -SubMenuBeginGroupIndent, -4);
  SubMenuControlDrawSeparator(ACanvas, R);
end;

class procedure TdxBarPainter.SubMenuControlDrawItemFrame(ABarSubMenuControl: TdxBarSubMenuControl;
  AControl: TdxBarItemControl; DC: HDC; AItemRect: TRect; AIndex: Integer);
begin
// do nothing
end;

procedure TdxBarPainter.SubMenuControlDrawSeparator(ACanvas: TcxCanvas; const ARect: TRect);
var
  R: TRect;
begin
  R := ARect;
  DrawEdge(ACanvas.Handle, R, EDGE_ETCHED, BF_TOP);
end;

class function TdxBarPainter.SubMenuControlGetBandSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := ABarSubMenuControl.IconAreaSize;
end;

class function TdxBarPainter.SubMenuControlGetControlContentIndent(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := ABarSubMenuControl.BarSize + ABarSubMenuControl.IconAreaSize;
  CorrectButtonControlDefaultHeight(Result);
end;

class function TdxBarPainter.SubMenuControlMarkArrowSize(AMarkSize: Integer): Integer;
begin
  Result := (AMarkSize - 2 * (2 + 1)) div 2;
end;

class function TdxBarPainter.SubMenuControlNormalItemHeight: Integer;
begin
  Result := 19;
end;

class procedure TdxBarPainter.SubMenuControlOffsetDetachCaptionRect(ABarSubMenuControl: TdxBarSubMenuControl;
  var R: TRect);
begin
  InflateRect(R, -3, -3);
end;

class procedure TdxBarPainter.SubMenuControlPrepareBkBrush(ABarSubMenuControl: TdxBarSubMenuControl;
  var ABkBrush: HBRUSH);
begin
  if BarAllowHotTrack then
    ABkBrush := SubMenuControlToolbarItemsBrush(ABarSubMenuControl);
end;

class function TdxBarPainter.SubMenuControlTextSize(ACanvas: TcxCanvas): Integer;
begin
  Result := GetDefaultTextSize(ACanvas);
end;

class function TdxBarPainter.SubMenuControlToolbarItemsBrush(ABarSubMenuControl: TdxBarSubMenuControl): HBRUSH;
begin
  Result := COLOR_BTNFACE + 1;
end;

procedure TdxBarPainter.ApplicationMenuDrawBorder(
  ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const ARect: TRect);
begin
  SubMenuControlDrawBorder(ABarSubMenuControl, DC, ARect);
end;

procedure TdxBarPainter.ApplicationMenuDrawButton(const ADrawParams: TdxBarApplicationMenuButtonControlDrawParams; var R: TRect);
begin
  // do nothing
end;

procedure TdxBarPainter.ApplicationMenuDrawContentArea(
  ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; const AContentRect, AItemsArea: TRect);
begin
  ACanvas.ExcludeClipRect(AItemsArea);
  SubMenuControlDrawBackground(ABarSubMenuControl, ACanvas, AContentRect, ABarSubMenuControl.ToolbarDownedBrush, clNone);
end;

function TdxBarPainter.ApplicationMenuGetFrameSizes: TRect;
begin
  Result := cxNullRect;
end;

procedure TdxBarPainter.ExtraMenuControlDrawBackground(AExtraMenuControl: TCustomdxBarControl;
  ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  FillBackgroundRect(ACanvas.Handle, ARect, ARect, ABrush, AColor, AExtraMenuControl.GetBackgroundBitmap);
//  SubMenuControlDrawBackground(ABarSubMenuControl, ACanvas, ARect, ABrush, AColor);
end;

procedure TdxBarPainter.ExtraMenuControlDrawBeginGroup(AExtraMenuControl: TCustomdxBarControl;
  ACanvas: TcxCanvas; ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean);
begin
  BarDrawBeginGroup(AExtraMenuControl, ACanvas.Handle, ABeginGroupRect, AToolbarBrush, AHorz);
end;

class procedure TdxBarPainter.EditDrawInterior(ABarEditControl: TdxBarEditControl;
  ABarEdit: TdxBarEdit; ACanvas: TCanvas; R: TRect; ItemLink: TdxBarItemLink);
var
  ADC: HDC;
  S: string;
begin
  ADC := ACanvas.Handle;
  FillRect(ADC, R, ACanvas.Brush.Handle); // draw only client area
  EditOffsetInteriorRect(ABarEditControl, R);
  if ABarEdit.FocusedItemLink = ItemLink then
    S := ABarEdit.CurText
  else
    S := ABarEdit.Text;
  SetBkMode(ADC, TRANSPARENT);
  cxDrawText(ADC, S, R, DT_NOPREFIX);
  SetBkMode(ADC, OPAQUE);
end;

procedure TdxBarPainter.EditGetRealLookAndFeel(ABarManager: TdxBarManager; ALookAndFeel: TcxLookAndFeel);
begin
  ABarManager.GetRealLookAndFeel(ALookAndFeel);
end;

function TdxBarPainter.EditGetEnabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF;
begin
  Result := GetSysColor(COLOR_WINDOW);
end;

function TdxBarPainter.EditGetDisabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF;
begin
  Result := cxGetBrushData(ABarItemControl.Parent.BkBrush).lbColor;
end;

function TdxBarPainter.EditGetBkColor(const ADrawParams: TdxBarEditLikeControlDrawParams): COLORREF;
var
  AEditViewParams: TcxViewParams;
begin
  with ADrawParams do
    if Enabled then
    begin
      BarEditControl.Item.GetEditViewParams(AEditViewParams);
      Result := AEditViewParams.Color;
      if Result = COLORREF(clDefault) then
        Result := EditGetEnabledBkColor(BarEditControl);
    end
    else
      Result := EditGetDisabledBkColor(BarEditControl);
end;

function TdxBarPainter.EditGetEnabledTextColor: COLORREF;
begin
  Result := GetSysColor(COLOR_WINDOWTEXT);
end;

function TdxBarPainter.EditGetDisabledTextColor: COLORREF;
begin
  Result := GetSysColor(COLOR_GRAYTEXT);
end;

function TdxBarPainter.EditGetTextColor(ABarItemControl: TdxBarCustomEditControl): COLORREF;
var
  AEditViewParams: TcxViewParams;
begin
  if ABarItemControl.Enabled then
  begin
    ABarItemControl.Item.GetEditViewParams(AEditViewParams);
    Result := AEditViewParams.TextColor;
    if Result = COLORREF(clDefault) then
      Result := EditGetEnabledTextColor;
  end
  else
    Result := EditGetDisabledTextColor;
end;

procedure TdxBarPainter.EditGetColors(ABarItemControl: TdxBarCustomEditControl;
  var ATextColor, ABkColor: COLORREF);
begin
  ATextColor := EditGetTextColor(ABarItemControl);
  ABkColor := EditGetBkColor(ABarItemControl.DrawParams);
end;

function TdxBarPainter.EditButtonAllowOffsetContent: Boolean;
begin
  Result := True;
end;

procedure TdxBarPainter.EditButtonDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams; AState: Integer;
  ARect: TRect; ABrush: HBrush);
begin
// do nothing
end;

function TdxBarPainter.EditButtonAllowCompositeFrame: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.EditButtonAllowHotTrack(const ADrawParams: TdxBarItemControlDrawParams): Boolean;
begin
  Result := ADrawParams.DrawSelected;
end;

function TdxBarPainter.EditButtonIsCustomBorder: Boolean;
begin
  Result := False;
end;

function TdxBarPainter.EditButtonIsCustomBackground(AState: Integer): Boolean;
begin
  Result := False;
end;

procedure TdxBarPainter.EditButtonCorrectDefaultWidth(var ADefaultWidth: Integer);
begin
  // do nothing
end;

procedure TdxBarPainter.EditButtonDrawBorder(
  const ADrawParams: TdxBarItemControlDrawParams; AState: Integer; var ADrawRect: TRect; out AContentRect: TRect);
begin
  // do nothing
end;

class procedure TdxBarPainter.CustomComboDrawItem(ABarCustomCombo: TdxBarCustomCombo;
  ACanvas: TCanvas; AIndex: Integer; ARect: TRect; AState: TOwnerDrawState; AInteriorIsDrawing: Boolean);
var
  S: string;
begin
  with ACanvas, ARect do
  begin
    if AIndex = -1 then
      S := ABarCustomCombo.Text
    else
      S := ABarCustomCombo.Items[AIndex];
    FillRect(ARect);
    TextOut(Left + 2, Top, S);
  end;
end;

procedure TdxBarPainter.DrawEditLikeControl(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect);
begin
  with ADrawParams do
  begin
    EditControlDrawBackground(ADrawParams);

    if (PaintType = ptMenu) and DrawSelected then
      EditControlDrawSelectionFrame(ADrawParams, ARect);

    BarEditControl.DrawFrame;

    if cpIcon in ViewStructure then
      EditControlDrawGlyph(ADrawParams, BarEditControl.FParts[ecpIcon]);

    if cpText in ViewStructure then
      EditControlDrawCaption(ADrawParams, BarEditControl.FParts[ecpText]);

    BarEditControl.DrawTextField;
  end;
end;

class function TdxBarPainter.EditControlBorderOffsets(APaintType: TdxBarPaintType): TRect;
begin
  Result := Rect(2, 2, 2, 2);
end;

procedure TdxBarPainter.EditControlDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams);
var
  AIndentRect, ATextRect: TRect;
begin
  with ADrawParams do
  begin
    if (cpText in ViewStructure) or (PaintType = ptMenu) and SubMenuControlHasBand and not (cpIcon in ViewStructure) then
    begin
      ATextRect := BarEditControl.FParts[ecpText];
      AIndentRect := ATextRect;

      ATextRect.Right := ATextRect.Right - EditControlIndents(ADrawParams, cpText).Right;
      AIndentRect.Left := ATextRect.Right;

      DrawBackground(BarEditControl, Canvas.Handle, ATextRect,
        BarEditControl.CaptionBkBrush, EditControlCaptionBackgroundIsOpaque(ADrawParams));
      DrawBackground(BarEditControl, Canvas.Handle, AIndentRect,
        EditControlGetRightCaptionIndentBrush(BarEditControl), EditControlCaptionRightIndentIsOpaque(ADrawParams));
    end;

    if (cpIcon in ViewStructure) and (PaintType <> ptMenu) then
      DrawBackground(BarEditControl, Canvas.Handle, BarEditControl.FParts[ecpIcon], BarEditControl.CaptionBkBrush,
        EditControlCaptionBackgroundIsOpaque(ADrawParams));
  end;
end;

procedure TdxBarPainter.EditControlDrawBorder(
  const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect);
var
  ABrush: HBRUSH;
begin
  with ADrawParams do
  begin
    if DrawSelected then
      DrawEdge(Canvas.Handle, ARect, BDR_SUNKENOUTER, BF_RECT)
    else
      DrawBackgroundFrameRect(BarEditControl, Canvas.Handle, ARect,
        BarEditControl.Parent.BkBrush, BarEditControl.FNonRecent);
    InflateRect(ARect, -1, -1);
    if Enabled or IsTransparent then
      ABrush := BarEditControl.Parent.BkBrush
    else
      ABrush := GetSysColorBrush(COLOR_BTNHIGHLIGHT);
    DrawBackgroundFrameRect(BarEditControl, Canvas.Handle, ARect, ABrush, BarEditControl.FNonRecent or
      (DrawSelected or not Enabled) and not IsTransparent);
    InflateRect(ARect, -1, -1);
  end;
end;

procedure TdxBarPainter.EditControlDrawCaption(const ADrawParams: TdxBarEditLikeControlDrawParams; const ARect: TRect);
var
  ATextRect: TRect;
begin
  with ADrawParams do
  begin
    ATextRect := ARect;
    ATextRect.Right := ATextRect.Right - EditControlIndents(ADrawParams, cpText).Right;

    DrawItemText(BarEditControl, Canvas.Handle, Caption, ATextRect, DT_RIGHT, Enabled,
      DrawSelected and (PaintType = ptMenu), False, False, IsFlatItemTextForMenu);

    Canvas.SetClipRegion(TcxRegion.Create(ARect), roSubtract);
  end;
end;

procedure TdxBarPainter.EditControlDrawSelectionFrame(const ADrawParams: TdxBarEditLikeControlDrawParams; const ARect: TRect);
begin
  FrameFlatSelRect(ADrawParams.Canvas.Handle, ARect);
end;

procedure TdxBarPainter.EditControlDrawGlyph(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect);
begin
  with ADrawParams do
  begin
    if PaintType <> ptMenu then
    begin
      Inc(ARect.Left, EditControlIndents(ADrawParams, cpIcon).Left);
      Dec(ARect.Right, EditControlIndents(ADrawParams, cpIcon).Right);
    end;

    DrawGlyph(BarEditControl, Canvas.Handle, ARect, ARect, PaintType, False,
      EditControlGlyphIsDrawSelected(BarEditControl), False, False, False, True,
      False, False);

    Canvas.SetClipRegion(TcxRegion.Create(ARect), roSubtract);
  end;
end;

class function TdxBarPainter.EditControlCaptionBackgroundIsOpaque(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  with ADrawParams do
    Result := (PaintType = ptMenu) and (DrawSelected or ADrawParams.BarItemControl.FNonRecent);
end;

class function TdxBarPainter.EditControlCaptionRightIndentIsOpaque(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  with ADrawParams do
    Result := (PaintType = ptMenu) and (ADrawParams.BarItemControl.FNonRecent);
end;

procedure TdxBarPainter.EditControlDrawTextField(ABarEditControl: TdxBarEditControl;
  ACanvas: TcxCanvas; const ARect: TRect);

  procedure SetColors(ATextColor, ABkColor: COLORREF);
  begin
    ACanvas.Font.Color := ATextColor;
    ACanvas.Brush.Color := ABkColor;
    ACanvas.Handle; // RequiredState(csAllValid)
  end;

var
  ATextColor, ABkColor: COLORREF;
begin
  EditGetColors(ABarEditControl, ATextColor, ABkColor);
  SetColors(ATextColor, ABkColor);

  ACanvas.SaveClipRegion;
  ACanvas.SetClipRegion(TcxRegion.Create(ARect), roIntersect);
  try
    ABarEditControl.Item.DrawInterior(ABarEditControl, ACanvas.Canvas,
      ARect, ABarEditControl.ItemLink);
  finally
    ACanvas.RestoreClipRegion;
  end;
end;

function TdxBarPainter.EditControlGetContentRect(APaintType: TdxBarPaintType; const ARect: TRect): TRect;
begin
  Result := cxRectContent(ARect, EditControlBorderOffsets(APaintType));
end;

class function TdxBarPainter.EditControlShowIconDefault(const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.EditControlIndents(
  const ADrawParams: TdxBarEditLikeControlDrawParams; ADrawAreaType: TdxBarItemControlPart): TRect;
begin
  case ADrawAreaType of
    cpText:
      Result := Rect(EditControlCaptionLeftIndent(ADrawParams), 0, EditControlCaptionRightIndent, 0);//4
  else {cpIcon}
    if ADrawParams.PaintType = ptMenu then
      Result := EditControlSubMenuGlyphIndents(ADrawParams) //Result := Rect(2, 0, 2, 0)
    else
      Result := Rect((ADrawParams.DefaultButtonSize.cx - ADrawParams.BarItemControl.GetGlyphSize(ADrawParams.ViewSize).cx) div 2, 0, GetControlTextIndents.Left, 0);
  end;
end;

class function TdxBarPainter.EditControlCaptionLeftIndent(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  if (cpIcon in ADrawParams.ViewStructure) then
    if (ADrawParams.PaintType <> ptMenu) then
      Result := 0
    else
      Result := EditControlCaptionRelativeLeftIndent(ADrawParams) //In SubMenu
  else
    Result := EditControlCaptionAbsoluteLeftIndent(ADrawParams);
end;

class function TdxBarPainter.EditControlCaptionRelativeLeftIndent(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  Result := 2;
end;

class function TdxBarPainter.EditControlCaptionAbsoluteLeftIndent(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  Result := 2
end;

class function TdxBarPainter.EditControlCaptionRightIndent: Integer;
begin
  Result := 4;
end;

class function TdxBarPainter.EditControlSubMenuGlyphIndents(
  const ADrawParams: TdxBarEditLikeControlDrawParams): TRect;
begin
  Result := Rect(4, 0, 0, 0);
end;

class function TdxBarPainter.EditControlGetRightCaptionIndentBrush(
  ABarEditControl: TdxBarCustomEditControl): HBRUSH;
begin
  Result := ABarEditControl.Parent.BkBrush;
end;

class function TdxBarPainter.EditControlGlyphIsDrawSelected(
  ABarEditControl: TdxBarCustomEditControl): Boolean;
begin
  Result := False;
end;

class procedure TdxBarPainter.EditControlUpdateWndText(ABarEditControl: TdxBarEditControl;
  AHandle: HWND; ANotEqual: Boolean);
begin
  if ANotEqual then
    SendMessage(AHandle, WM_COMMAND, MAKEWPARAM(0, EN_CHANGE), AHandle);
  SendMessage(AHandle, EM_SETSEL, 0, -1);
end;

function TdxBarPainter.ColorComboHasCompleteFrame: Boolean;
begin
  Result := False;
end;

function TdxBarPainter.IsCustomColorButtonVisible(
  const ADrawParams: TdxBarColorComboControlDrawParams): Boolean;
begin
  Result := cxRectWidth(ADrawParams.BarItemControl.FParts[clcpCustomColorButton]) <> 0;
end;

procedure TdxBarPainter.ColorComboCorrectFrameRect(
  const ADrawParams: TdxBarColorComboControlDrawParams; var ARect: TRect);
begin
  if ColorComboHasCompleteFrame and IsCustomColorButtonVisible(ADrawParams) then
    ARect.Right := ADrawParams.BarItemControl.FParts[clcpCustomColorButton].Right + GetCustomColorButtonIndents(ADrawParams.PaintType).Right;
end;

function TdxBarPainter.GetCustomColorButtonIndents(APaintType: TdxBarPaintType): TRect;
begin
  Result := Rect(1, 2, 1, 2);
end;

procedure TdxBarPainter.ColorComboDrawCustomButton(
  const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect);
begin
  with ADrawParams do
    FrameAndFillRect(BarItemControl, Canvas.Handle, ARect, Enabled, DrawSelected, IsPressed);
  DrawDots(ADrawParams, ARect);
end;

procedure TdxBarPainter.ColorComboDrawCustomButtonAdjacentZone(
  const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect);
begin
  with ADrawParams do
  begin
    DrawBackgroundFrameRect(BarItemControl, Canvas.Handle, ARect, BarItemControl.Parent.BkBrush, False);
    InflateRect(ARect, 0, -1);
    DrawBackgroundFrameRect(BarItemControl, Canvas.Handle, ARect, BarItemControl.Parent.BkBrush, False);
  end;
end;

class procedure TdxBarPainter.SysPanelCalcSize(AHandle: HWND; var ARect: TRect;
  var Corner: TdxCorner; Combo: TdxBarItem; AllowResizing: Boolean);
var
  R: TRect;
  AControl: TdxBarWinControl;
begin
  InflateRect(ARect, -1, -1);
  if AllowResizing and
    (Combo.CurItemLink <> nil) and (Combo.CurItemLink.Control <> nil) then
  begin
    R := cxGetWindowRect(AHandle);
    AControl := TdxBarWinControl(Combo.CurItemLink.Control);
    MapWindowRect(0, AControl.Parent.Handle, R);
    Corner := GetCornerForRects(AControl.WindowRect, R);
    with ARect do
      if Corner in [coBottomLeft, coBottomRight] then
        Dec(Bottom, SysPanelSize)
      else
        Inc(Top, SysPanelSize);
  end;
end;

class procedure TdxBarPainter.SysPanelDraw(AHandle: HWND; AllowResizing,
  MouseAboveCloseButton, CloseButtonIsTracking: Boolean; var CloseButtonRect,
  GripRect: TRect; Corner: TdxCorner);
begin
  dxBarPopupNCPaint(AHandle, AllowResizing, False, MouseAboveCloseButton,
    CloseButtonIsTracking, CloseButtonRect, GripRect, Corner);
end;

class function TdxBarPainter.SysPanelSize: Integer;
begin
  Result := dxDropDownNCHeight;
end;

class function TdxBarPainter.IsDateNavigatorFlat: Boolean;
begin
  Result := False;
end;

procedure TdxBarPainter.DateNavigatorDrawButton(ABarItem: TdxBarItem;
  DC: HDC; R: TRect; const ACaption: string; APressed: Boolean);
var
  Offset: Integer;
  APrevPen: HPEN;
begin
  Offset := 0;
  with R do
  begin
    if APressed then
    begin
      DrawFrameControl(DC, R, DFC_BUTTON, DFCS_BUTTONPUSH or DFCS_PUSHED);
      Offset := 1;
    end
    else
    begin
      APrevPen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNTEXT)));
      MoveToEx(DC, Left, Bottom - 1, nil);
      LineTo(DC, Right - 1, Bottom - 1);
      LineTo(DC, Right - 1, Top);
      DeleteObject(SelectObject(DC, APrevPen));

      APrevPen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNFACE)));
      LineTo(DC, Left, Top);
      LineTo(DC, Left, Bottom - 1);
      DeleteObject(SelectObject(DC, APrevPen));

      APrevPen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNSHADOW)));
      MoveToEx(DC, Left + 1, Bottom - 2, nil);
      LineTo(DC, Right - 2, Bottom - 2);
      LineTo(DC, Right - 2, Top + 1);
      DeleteObject(SelectObject(DC, APrevPen));

      APrevPen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNHIGHLIGHT)));
      MoveToEx(DC, Left + 1, Bottom - 3, nil);
      LineTo(DC, Left + 1, Top + 1);
      LineTo(DC, Right - 2, Top + 1);
      DeleteObject(SelectObject(DC, APrevPen));

      SetPixel(DC, Right - 2, Top + 1, GetSysColor(COLOR_BTNFACE));
    end;
    InflateRect(R, -2, -2);
  end;
  // draw button's caption
  DateNavigatorDrawButtonCaption(DC, R, Offset, ACaption, True);
end;

function TdxBarPainter.DateNavigatorHeaderColor: TColor;
begin
  Result := clBtnFace;
end;

function TdxBarPainter.GetSpinEditArrowPos(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer): TPoint;
begin
  with ADrawParams do
  begin
    Result.X := ARect.Left + ArrowSize.cy;
    ARect.Top := (ARect.Top + ARect.Bottom - ArrowSize.cy) div 2 + Byte(AButtonIndex = secButtonUp) * (ArrowSize.cy - 1);
    Result.Y := ARect.Top;
  end;
end;

procedure TdxBarPainter.SpinEditCorrectFrameRect(const ADrawParams: TdxBarItemControlDrawParams; var ARect: TRect);
begin
  ARect.Right := ADrawParams.BarItemControl.FParts[secButtonUp].Left - GetSpinEditButtonIndents(ADrawParams.PaintType).Left;
end;

function TdxBarPainter.GetSpinEditArrowSize(AHeight: Integer): TSize;
begin
  Result.cy := (AHeight div 2 - 2) div 2;
  Result.cx := 2 * Result.cy - 1;
end;

function TdxBarPainter.GetSpinEditButtonBounds(const ADrawParams: TdxBarSpinEditDrawParams; const ARect: TRect; AButton: TdxBarSpinEditButton): TRect;

  function IsButtonsWidthTooLarge(AButtonsWidth: Integer): Boolean;
  begin
    Result := AButtonsWidth >= cxRectWidth(ADrawParams.BarEditControl.GetEditRect) div 2;
  end;

begin
  Result := ARect;
  Result.Left := Result.Right - GetSpinEditButtonWidth(ADrawParams.PaintType, ARect) - GetSpinEditButtonIndents(ADrawParams.PaintType).Left -
    GetSpinEditButtonIndents(ADrawParams.PaintType).Right;
  
  if IsButtonsWidthTooLarge(cxRectWidth(Result)) then
    Result.Left := Result.Right
  else
  begin
    Result := cxRectContent(Result, GetSpinEditButtonIndents(ADrawParams.PaintType));
    case AButton of
      sbUp: Result.Bottom := (Result.Bottom + Result.Top) div 2;
      sbDown: Result.Top := (Result.Bottom + Result.Top) div 2;
    end;
  end;
end;

function TdxBarPainter.GetSpinEditButtonIndents(APaintType: TdxBarPaintType): TRect;
begin
  Result := Rect(1, 0, 1, 0);
end;

function TdxBarPainter.GetSpinEditButtonWidth(APaintType: TdxBarPaintType; const ARect: TRect): Integer;
var
  AArrowSize: TSize;
begin
  AArrowSize := GetSpinEditArrowSize(cxRectHeight(ARect));
  Result := AArrowSize.cx + 2 * (1 + 1 + AArrowSize.cy);
  Result := Result - GetSpinEditButtonIndents(APaintType).Left -
    GetSpinEditButtonIndents(APaintType).Right
end;

function TdxBarPainter.GetSpinEditButtonState(const ADrawParams: TdxBarSpinEditDrawParams; AButtonIndex: Integer): TcxButtonState;
begin
  with ADrawParams do
  if not Enabled then
    Result := cxbsDisabled
  else
    if AButtonIndex = ActiveButtonIndex then
      Result := cxbsPressed
    else
      if AButtonIndex = HotPartIndex then
        Result := cxbsHot
      else
        Result := cxbsNormal;
end;

procedure TdxBarPainter.SpinEditControlDrawButton(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer);

   procedure OffsetArrowPosIfActive(var AArrowPos: TPoint);
   begin
     if AButtonIndex = ADrawParams.ActiveButtonIndex then
       AArrowPos := cxPointOffset(AArrowPos, 1, 1);
   end;

var
  AArrowPos: TPoint;
begin
  with ADrawParams do
  begin
    FrameAndFillRect(BarEditControl, Canvas.Handle, ARect, Enabled, DrawSelected,
      ActiveButtonIndex = AButtonIndex);
    AArrowPos := GetSpinEditArrowPos(ADrawParams, ARect, AButtonIndex);
    OffsetArrowPosIfActive(AArrowPos);
    DrawSpinEditArrow(ADrawParams, AArrowPos, AButtonIndex);
  end;
end;

procedure TdxBarPainter.SpinEditControlDrawButtonsAdjacentZone(const ADrawParams: TdxBarSpinEditDrawParams; const ARect: TRect);
begin
  with ADrawParams do
    DrawBackground(BarEditControl, Canvas.Handle, ARect, BarEditControl.Parent.BkBrush, False);
end;

class function TdxBarPainter.ProgressControlBarBrushColor: TColorRef;
begin
  Result := GetSysColor(COLOR_HIGHLIGHT);
end;

function TdxBarPainter.CanUpdateBarPartly: Boolean;
begin
  Result := False;
end;

function TdxBarPainter.ProgressControlBarHeight(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := 12;
end;

class function TdxBarPainter.ProgressControlIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer;
begin
  Result := 0;
end;

procedure TdxBarPainter.ProgressControlDrawBar(const ADrawParams: TdxBarProgressControlDrawParams; BarR: TRect; ABarBrushColor: TColorRef);

  procedure CalculateBandRect;
  var
    ABeginPos, AEndPos: ^Integer;
  begin
    with BarR do
      if ADrawParams.PaintType = ptVert then
      begin
        ABeginPos := @Top;
        AEndPos := @Bottom;
      end
      else
      begin
        ABeginPos := @Left;
        AEndPos := @Right;
      end;
    with ADrawParams do
      AEndPos^ := ABeginPos^ + MulDiv(AEndPos^ - ABeginPos^, Position - Min, Max - Min);
  end;

  procedure DrawBand;
  var
    ABarBrush: HBRUSH;
  begin
    ABarBrush := CreateSolidBrush(ABarBrushColor);
    try
      if ADrawParams.Smooth then
        ProgressControlFillContent(ADrawParams, BarR, ABarBrush)
      else
        ProgressControlDrawChunks(ADrawParams, BarR, ABarBrush);
    finally
      DeleteObject(ABarBrush);
    end;
  end;

begin
  ProgressControlDrawBackground(ADrawParams, BarR);
  CalculateBandRect;
  DrawBand;
end;

procedure TdxBarPainter.ProgressControlFillContent(const ADrawParams: TdxBarItemControlDrawParams; const R: TRect; ABarBrush: HBRUSH);
begin
  FillRect(ADrawParams.Canvas.Handle, R, ABarBrush);
end;

procedure TdxBarPainter.ProgressControlFillDiscreteContent(const ADrawParams: TdxBarItemControlDrawParams; const R: TRect; ABarBrush: HBRUSH);
begin
  ProgressControlFillContent(ADrawParams, R, ABarBrush);
end;

procedure TdxBarPainter.ProgressControlDrawBackground(const ADrawParams: TdxBarItemControlDrawParams; var BarR: TRect);
begin
  with ADrawParams do
    DrawBackground(BarItemControl, Canvas.Handle, BarR, BarItemControl.Parent.BkBrush, False);
end;

procedure TdxBarPainter.ProgressControlDrawChunks(const ADrawParams: TdxBarItemControlDrawParams; BarR: TRect; ABarBrush: HBRUSH);
var
  ALimit, AStep: Integer;
  ABeginPos, AEndPos: ^Integer;
begin
  with ADrawParams do
  begin
    with BarR do
      if PaintType = ptVert then
      begin
        ABeginPos := @Top;
        AEndPos := @Bottom;
      end
      else
      begin
        ABeginPos := @Left;
        AEndPos := @Right;
      end;
      ALimit := AEndPos^;
      if PaintType = ptVert then
        AStep := MulDiv(cxRectWidth(BarR), 2, 3)
      else
        AStep := MulDiv(cxRectHeight(BarR), 2, 3);
      repeat
        AEndPos^ := ABeginPos^ + AStep;
        if AEndPos^ > ALimit then AEndPos^ := ALimit;
        ProgressControlFillDiscreteContent(ADrawParams, BarR, ABarBrush);
        ABeginPos^ := AEndPos^;
        Inc(AEndPos^, 2);
        if AEndPos^ > ALimit then AEndPos^ := ALimit;
        ABeginPos^ := AEndPos^;
      until AEndPos^ = ALimit;
    end;
end;

class function TdxBarPainter.ContainerControlSubMenuOffset: Integer;
begin
  Result := 0;
end;

class function TdxBarPainter.InPlaceSubItemControlBrush: HBRUSH;
begin
  Result := GetSysColorBrush(COLOR_BTNSHADOW);
end;

class function TdxBarPainter.InPlaceSubItemGetArrowWidth(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Integer;
begin
  Result := ADrawParams.BarItemControl.SubMenuParent.TextSize;
end;

class function TdxBarPainter.InPlaceSubItemGetTextIndent: Integer;
begin
  Result := 5;
end;

function TdxBarPainter.InPlaceSubItemControlIsFlatItemText(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Boolean;
begin
  Result := ADrawParams.DrawSelected;
end;

function TdxBarPainter.InPlaceSubItemControlIsArrowSelected(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Boolean;
begin
  Result := True;
end;

procedure TdxBarPainter.InPlaceSubItemControlDrawArrow(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams;
  ADirection: TcxArrowDirection; ARect: TRect);
var
  ASize: Integer;
begin
  with ADrawParams do
  begin
    ASize := ArrowSize.cy;
    ARect.Left := ARect.Right - ArrowSize.cx;
    if not IsExpanded then
      Inc(ARect.Left, ASize);
    DrawLargeItemArrow(Canvas.Handle, ARect, ADirection, ASize,
      InPlaceSubItemControlIsArrowSelected(ADrawParams), True, IsFlatItemText, GetItemArrowColor(ADrawParams));
  end;
end;

procedure TdxBarPainter.InPlaceSubItemControlDrawBackground(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams; ARect: TRect);
const
  InternalSeparatorSize = 1;
var
  ABrush: HBRUSH;
begin
  with ADrawParams do
  begin
    FillRect(Canvas.Handle, cxRectInflate(ARect, 0, cxRectHeight(ARect) - InternalSeparatorSize, 0, 0), BarItemControl.Parent.BkBrush);

    Dec(ARect.Bottom, InternalSeparatorSize);

    if DrawSelected then
      ABrush := BarItemControl.Parent.ToolbarSelBrush
    else
      ABrush := InPlaceSubItemControlBrush;

    DrawBackground(BarItemControl, Canvas.Handle, ARect, ABrush, True{Opaque});

    if DrawSelected then
      FrameFlatSelRect(Canvas.Handle, ARect);
  end;
end;

procedure TdxBarPainter.InPlaceSubItemControlDrawInMenu(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams; ARect: TRect);
const
  Arrows: array[Boolean] of TcxArrowDirection = (adRight, adDown);
begin
  with ADrawParams do
  begin
    InPlaceSubItemControlDrawBackground(ADrawParams, ARect);

    Inc(ARect.Left, InPlaceSubItemGetTextIndent);
    DrawItemText(BarItemControl, Canvas.Handle, Caption,
      ARect, DT_LEFT, True, True, False, False, InPlaceSubItemControlIsFlatItemText(ADrawParams));

    if Enabled then
      InPlaceSubItemControlDrawArrow(ADrawParams, Arrows[IsExpanded], ARect);
  end;
end;

procedure TdxBarPainter.DrawStaticBackground(const ADrawParams: TdxBarStaticLikeControlDrawParams; ARect: TRect);
begin
  with ADrawParams do
    DrawBackground(BarItemControl, Canvas.Handle, ARect, BarItemControl.BkBrush, StaticBackgroundIsOpaque(ADrawParams));
end;

procedure TdxBarPainter.DrawStaticBorder(const ADrawParams: TdxBarStaticLikeControlDrawParams; var ARect: TRect);
const
  Borders: array[TdxBarStaticBorderStyle] of Integer =
    (0, BDR_SUNKENOUTER, BDR_RAISEDINNER, EDGE_ETCHED, 0);
begin
  with ADrawParams do
  begin
    if BorderStyle = sbsNone then Exit;
    if BorderStyle = sbsBump then
    begin
      DrawEdge(Canvas.Handle, ARect, BDR_RAISEDINNER, BF_RECT);
      InflateRect(ARect, -1, -1);
      DrawEdge(Canvas.Handle, ARect, BDR_SUNKENOUTER, BF_RECT);
      InflateRect(ARect, -1, -1);
    end
    else
    begin
      DrawEdge(Canvas.Handle, ARect, Borders[BorderStyle], BF_RECT);
      ARect := cxRectContent(ARect, BorderOffsets);
    end;
  end;
end;

procedure TdxBarPainter.DrawStaticGlyphAndCaption(const ADrawParams: TdxBarStaticLikeControlDrawParams; const ARect: TRect);

  function IsGlyphCenter: Boolean;
  begin
    Result := ADrawParams.AllowCenter;
    if ADrawParams.PaintType = ptMenu then
      Result := Result and not (cpText in ADrawParams.ViewStructure);
  end;

  function GetGlyphRect: TRect;
  begin
    Result := ARect;
    with ADrawParams do
      case PaintType of
        ptMenu:
          if not IsGlyphCenter then
            Result := SubMenuControlGetItemIconRect(ARect, BarItemControl.Parent.IconAreaSize);
        ptHorz:
          if cpText in ViewStructure then
            Result.Right := Result.Left + DefaultButtonSize.cx;
        ptVert:
          if cpText in ViewStructure then
            Result.Bottom := Result.Top + DefaultButtonSize.cy;
      end;
  end;

  function IsTextCenter: Boolean;
  begin
    Result := ADrawParams.AllowCenter and (ADrawParams.Alignment = taCenter);
  end;

  function GetTextIndent: Integer;
  begin
    Result := 0;
    with ADrawParams do
      if cpIcon in ViewStructure then
        case PaintType of
          ptHorz: Result := DefaultButtonSize.cx + 2;
          ptVert: Result := DefaultButtonSize.cy + 2;
          ptMenu:
            if Alignment = taLeftJustify then
              Result := SubMenuControlGetItemTextIndent(ADrawParams)
        end
      else
        if not IsTextCenter then
          Result := BarItemControl.Parent.TextSize div 4;
  end;

  function GetTextRect: TRect;
  var
    ALeftJustify: Boolean;
  begin
    Result := ARect;
    with ADrawParams do
    begin
      ALeftJustify := Alignment = taLeftJustify;
      if PaintType in [ptMenu, ptHorz] then
        if ALeftJustify or IsTextCenter then
          Inc(Result.Left, GetTextIndent)
        else
          Dec(Result.Right, 2)
      else
        if ALeftJustify or IsTextCenter then
          Inc(Result.Top, GetTextIndent)
        else
          Dec(Result.Bottom, 2);
    end;
  end;

begin
  with ADrawParams do
  begin
    DrawStaticBackground(ADrawParams, ARect);
    if cpIcon in ViewStructure then
      DrawGlyph(BarItemControl, Canvas.Handle, GetGlyphRect, cxEmptyRect, ptMenu, False, False, False, False, False, IsGlyphCenter, True, False);

    if cpText in ViewStructure then
      DrawItemText(BarItemControl, Canvas.Handle, Caption, GetTextRect, SystemAlignmentsHorz[Alignment], Enabled, False,
        PaintType = ptVert, True, False);
  end;
end;

procedure TdxBarPainter.DrawStaticLikeControl(const ADrawParams: TdxBarStaticLikeControlDrawParams; var ARect: TRect; const AIndentsRect: TRect);

  procedure DrawIndents;

    procedure DrawLeftIndent;
    var
      R: TRect;
    begin
      R := ARect;
      if AIndentsRect.Left <> 0 then
      begin
        if ADrawParams.PaintType = ptVert then
        begin
          Inc(ARect.Top, AIndentsRect.Left);
          R.Bottom := ARect.Top;
        end
        else
        begin
          Inc(ARect.Left, AIndentsRect.Left);
          R.Right := ARect.Left;
        end;
        with ADrawParams do
          DrawBackground(BarItemControl, Canvas.Handle, R, BarItemControl.Parent.BkBrush, False);
      end;
    end;

    procedure DrawRightIndent;
    var
      R: TRect;
    begin
      R := ARect;
      if AIndentsRect.Right <> 0 then
      begin
        if ADrawParams.PaintType = ptVert then
        begin
          R.Bottom := ARect.Bottom;
          Dec(ARect.Bottom, AIndentsRect.Right);
          R.Top := ARect.Bottom;
        end
        else
        begin
          R.Right := ARect.Right;
          Dec(ARect.Right, AIndentsRect.Right);
          R.Left := ARect.Right;
        end;
        with ADrawParams do
          DrawBackground(BarItemControl, Canvas.Handle, R, BarItemControl.Parent.BkBrush, False);
      end;
    end;

  begin
    DrawLeftIndent;
    DrawRightIndent;
  end;

begin
  with ADrawParams do
  begin
    DrawIndents;
    DrawStaticBorder(ADrawParams, ARect);
    BarStaticControl.DrawInterior(ARect);
  end;
end;

class function TdxBarPainter.StaticBackgroundIsOpaque(const ADrawParams: TdxBarItemControlDrawParams): Boolean;
begin
  Result := ADrawParams.BarItemControl.IsBkColorAssigned;
end;

function TdxBarPainter.StaticControlGetBorderOffsets(AParent: TCustomdxBarControl; ABorderStyle: TdxBarStaticBorderStyle): TRect;
const
  Widths: array[TdxBarStaticBorderStyle] of Integer = (0, 1, 1, 2, 2);
var
  ABorderWidth: Integer;
begin
  ABorderWidth := Widths[ABorderStyle];
  Result := Rect(ABorderWidth, ABorderWidth, ABorderWidth, ABorderWidth);
end;

class function TdxBarPainter.SeparatorControlGetIndents(const ADrawParams: TdxBarSeparatorControlDrawParams;
  ADrawAreaType: TdxBarItemControlPart): TRect;
begin
  Result := cxRect(6, 0, 0, 0);
end;

function TdxBarPainter.SubMenuGetSeparatorSize: Integer;
begin
  Result := MenuSeparatorSize;
end;

procedure TdxBarPainter.DrawSeparatorGlyphAndCaption(
  const ADrawParams: TdxBarSeparatorControlDrawParams; const ARect: TRect);
begin
  DrawStaticGlyphAndCaption(ADrawParams, ARect);
end;

procedure TdxBarPainter.DrawSeparatorControl(
  const ADrawParams: TdxBarSeparatorControlDrawParams; const ARect: TRect);
begin
  with ADrawParams do
    if cpText in ADrawParams.ViewStructure then
    begin
      DrawSeparatorGlyphAndCaption(ADrawParams, ARect);
      if not IsTop then
        SubMenuControlDrawSeparator(Canvas, cxRectSetTop(ARect, ARect.Top, SubMenuGetSeparatorSize));
      SubMenuControlDrawSeparator(Canvas, cxRectSetBottom(ARect, ARect.Bottom, SubMenuGetSeparatorSize));
    end
    else
      if PaintType = ptMenu then
        SubMenuControlDrawBeginGroup(BarItemControl.SubMenuParent, BarItemControl, Canvas, ARect)
      else
        BarDrawBeginGroup(BarItemControl.Parent, Canvas.Handle, ARect,
          BarItemControl.Parent.ToolbarBrush, False);
end;

function TdxBarPainter.ScreenTipGetDescriptionTextColor: TColor;
begin
  Result := clDefault;
end;

function TdxBarPainter.ScreenTipGetTitleTextColor: TColor;
begin
  Result := clDefault;
end;

function TdxBarPainter.ScreenTipGetFooterLineSize: Integer;
begin
  Result := 3;
end;

procedure TdxBarPainter.ScreenTipDrawBackground(ACanvas: TcxCanvas; ARect: TRect);
begin
  // do nothing
end;

procedure TdxBarPainter.ScreenTipDrawFooterLine(ACanvas: TcxCanvas; const ARect: TRect);
begin
  // do nothing
end;

class function TdxBarPainter.HasEditControlExternalFrame(
  APaintType: TdxBarPaintType; ASelected: Boolean): Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.IsCompoundPainting: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.NeedDoubleBuffer: Boolean; 
begin
  Result := False;
end;

procedure TdxBarPainter.DrawToolbarContentPart(
  ABarControl: TdxBarControl; ACanvas: TcxCanvas);
begin
  with ABarControl do
    FillBackground(Canvas.Handle, ClientRect, ToolbarBrush, clNone, True);
end;

procedure TdxBarPainter.DrawToolbarNonContentPart(
  ABarControl: TdxBarControl; DC: HDC);
begin
end;

class function TdxBarPainter.GetDefaultArrowSignSize: TSize;
begin
  Result := Size(5, 3);
end;

function TdxBarPainter.GetToolbarCaptionRect(const ARect: TRect): TRect;
begin
  Result := ARect;
  InflateRect(Result, -BorderSizeX, -BorderSizeY);
  Result.Bottom := Result.Top + BarCaptionSize;
end;

function TdxBarPainter.AllowLargeIcons: Boolean;
begin
  Result := True;
end;

procedure TdxBarPainter.CorrectCaptionParams(
  const ADrawParams: TdxBarButtonLikeControlDrawParams;
  var ATextBounds: TRect; const AImageBounds: TRect; out ATextAlignment: DWORD);

  procedure OffsetTextBounds(var ATextBounds: TRect);
  begin
    if not IsMenuItem(ADrawParams.BarItemControl) then
      OffsetCaptionBounds(ADrawParams.Downed, ADrawParams.DrawDowned, ATextBounds);
  end;

begin
  if ADrawParams.ViewSize = cvsLarge then
  begin
    ATextAlignment := DT_CENTER;
    case ADrawParams.BarItemControl.Item.GlyphLayout of
      glLeft:
        begin
          ATextAlignment := DT_LEFT;
          if ADrawParams.PaintType = ptHorz then
            ATextBounds.Left := AImageBounds.Right + 3
          else
            ATextBounds.Top := AImageBounds.Bottom + 3;
        end;
      glRight:
        begin
          ATextAlignment := DT_RIGHT;
          if ADrawParams.PaintType = ptHorz then
            ATextBounds.Right := AImageBounds.Left - 3
          else
            ATextBounds.Bottom := AImageBounds.Top - 3;
        end;
      glTop:
        if ADrawParams.PaintType = ptHorz then
          ATextBounds.Top := AImageBounds.Bottom
        else
          ATextBounds.Right := AImageBounds.Left;
      glBottom:
        if ADrawParams.PaintType = ptHorz then
          ATextBounds.Bottom := AImageBounds.Top
        else
          ATextBounds.Left := AImageBounds.Right;
    end;
  end
  else
  begin
    ATextAlignment := DT_LEFT;
    if cpIcon in ADrawParams.ViewStructure then
      if ADrawParams.PaintType = ptHorz then
        Inc(ATextBounds.Left, ADrawParams.DefaultButtonSize.cx)
      else
        Inc(ATextBounds.Top, ADrawParams.DefaultButtonSize.cy)
    else
      if ADrawParams.PaintType = ptHorz then
        Inc(ATextBounds.Left, ADrawParams.BarItemControl.GetControlCaptionOffset)
      else
        Inc(ATextBounds.Top, ADrawParams.BarItemControl.GetControlCaptionOffset);

    OffsetTextBounds(ATextBounds);
  end;
end;

function TdxBarPainter.GetBorderSize: Integer;
begin
  Result := 0;
end;

function TdxBarPainter.GetIconAreaSize(ABarControl: TCustomdxBarControl): Integer;
const
  AIconAreaOffset = 4; // !
begin
  case ABarControl.ItemLinks.ItemSize of
    misNormal: Result := ABarControl.TextSize;
  else //misLarge
    Result := Round((DefautGlyphSize * 2 + AIconAreaOffset * 2) * ABarControl.Ratio);
  end;
  CorrectButtonControlDefaultHeight(Result);
end;

procedure TdxBarPainter.DrawGlyphBorder(ABarItemControl: TdxBarItemControl;
  DC: HDC; ABrush: HBRUSH; NeedBorder: Boolean; R: TRect; PaintType: TdxBarPaintType;
  IsGlyphEmpty, Selected, Down, DrawDowned, ADroppedDown, IsSplit: Boolean);
begin
  // Required
end;

procedure TdxBarPainter.DrawGlyphCheckMark(ABarItemControl: TdxBarItemControl;
  DC: HDC; X, Y, DoubleSize: Integer);
begin
  // Required
  // TODO: make default from Flat?
end;

procedure TdxBarPainter.DrawGlyphEmptyImage(ABarItemControl: TdxBarItemControl;
  DC: HDC; R: TRect; APaintType: TdxBarPaintType; ADown: Boolean);
var
  ADoubleSize: Integer;
begin
  if (APaintType = ptMenu) and ADown then
    with R do
    begin
      ADoubleSize := 1 + Byte(ABarItemControl.Parent.Font.Size >= 16);
      DrawGlyphCheckMark(ABarItemControl, DC,
        (Left + Right - ADoubleSize * 9) div 2,
        (Top + Bottom - ADoubleSize * 7) div 2, ADoubleSize);
    end;
end;

class procedure TdxBarPainter.DrawItemArrow(DC: HDC; R: TRect;
  ArrowType: TcxArrowDirection; Enabled, Selected, Flat: Boolean; AColor: TColor = clDefault);
begin
  dxBar.DrawItemArrow(DC, R, ArrowType, Enabled, Selected, Flat, AColor);
end;

procedure TdxBarPainter.DrawLargeItemArrow(DC: HDC; R: TRect;
  ArrowType: TcxArrowDirection; Size: Integer; Selected, Enabled, Flat: Boolean; AColor: TColor = clDefault);
begin
  dxBar.DrawLargeItemArrow(DC, R, ArrowType, Size, Selected, Enabled, Flat, AColor);
end;

class procedure TdxBarPainter.FrameFlatSelRect(DC: HDC; const R: TRect);
begin
  // do nothing
end;

procedure TdxBarPainter.GetImageParams(AItemControl: TdxBarItemControl;
  const ADrawRect: TRect; APaintType: TdxBarPaintType;
  AViewStructure: TdxBarItemControlViewStructure;
  AViewSize: TdxBarItemControlViewSize; ACenter, ASelected, ADowned, ADrawDowned: Boolean;
  var AGlyphEmpty: Boolean; out ACurrentGlyph: TBitmap;
  out ACurrentImages: TCustomImageList; out ACurrentImageIndex: Integer; out AImageBounds: TRect);
var
  AImageSize: TSize;
begin
  AImageSize := AItemControl.GetGlyphSize(AViewSize, ASelected);
  AGlyphEmpty := not AItemControl.GetCurrentImage(AViewSize, ASelected, ACurrentGlyph, ACurrentImages, ACurrentImageIndex) or AGlyphEmpty;

  if (AViewSize = cvsLarge) and (APaintType <> ptMenu) then
    AImageBounds := GetLargeImageBounds(AItemControl, AImageSize, ADrawRect, APaintType, AViewStructure, AItemControl.Item.GlyphLayout)
  else
    AImageBounds := GetSmallImageBounds(AItemControl, AImageSize, ADrawRect, APaintType, AViewStructure, ACenter, AGlyphEmpty, AItemControl.BarManager.StretchGlyphs, ADowned, ADrawDowned);
end;

function TdxBarPainter.GetLargeImageBounds(AItemControl: TdxBarItemControl;
  const AImageSize: TSize; const ADrawRect: TRect; APaintType: TdxBarPaintType;
  AViewStructure: TdxBarItemControlViewStructure; AGlyphLayout: TdxBarGlyphLayout): TRect;

  function GetImageOffset: TPoint;
  begin
    Result := cxRectCenter(ADrawRect, AImageSize).TopLeft;
    if cpText in AViewStructure then
    begin
      case APaintType of
        ptHorz:
          case AGlyphLayout of
            glLeft:
              Result.X := ADrawRect.Left + 4;
            glRight:
              Result.X := ADrawRect.Right - 4 - AImageSize.cx;
            glTop:
              Result.Y := ADrawRect.Top + 2;
            glBottom:
              Result.Y := ADrawRect.Bottom - 2 - AImageSize.cy;
          end;
        ptVert:
          case AGlyphLayout of
            glLeft:
              Result.Y := ADrawRect.Top + 4;
            glRight:
              Result.Y := ADrawRect.Bottom - 4 - AImageSize.cy;
            glTop:
              Result.X := ADrawRect.Right - 2 - AImageSize.cx;
            glBottom:
              Result.X := ADrawRect.Left + 2;
          end;
      end;
    end;
  end;

var
  AOffset: TPoint;
begin
  AOffset := GetImageOffset;
  Result := cxRectBounds(AOffset.X, AOffset.Y, AImageSize.cx, AImageSize.cy);
end;

class function TdxBarPainter.GetSmallImageBounds(AItemControl: TdxBarItemControl;
  const AImageSize: TSize; const ADrawRect: TRect; APaintType: TdxBarPaintType;
  AViewStructure: TdxBarItemControlViewStructure;
  ACenter, AGlyphEmpty, AStretchGlyph, ADowned, ADrawDowned: Boolean): TRect;

  procedure GetDimensions(out AWidth, AHeight: Integer);
  begin
    AWidth := cxRectWidth(ADrawRect);
    AHeight := cxRectHeight(ADrawRect);
    if not ACenter then
      case APaintType of
        ptHorz: AWidth := AItemControl.FDrawParams.DefaultButtonSize.cx;
        ptVert: AHeight := AItemControl.FDrawParams.DefaultButtonSize.cy;
      end;
  end;

  procedure GetRealImageDimensions(AWidth, AHeight: Integer; out AImageWidth, AImageHeight: Integer);
  var
    ARatio: Double;
  begin
    AImageWidth := AImageSize.cx;
    AImageHeight := AImageSize.cy;
    if APaintType = ptMenu then
    begin
      if AStretchGlyph then
      begin
        ARatio := AItemControl.Parent.Ratio;
        AImageWidth := Round(AImageWidth * ARatio);
        AImageHeight := Round(AImageHeight * ARatio);
        if Odd(AWidth - AImageWidth) and Odd(AHeight - AImageHeight) then
        begin
          Dec(AImageWidth);
          Dec(AImageHeight);
        end;
      end
    end
    else
    begin
      if AItemControl.UseLargeIcons then
      begin
        if AItemControl.BarManager.IsLargeImagesForLargeIcons then
        begin
          AImageWidth := AItemControl.BarManager.LargeImages.Width;
          AImageHeight := AItemControl.BarManager.LargeImages.Height;
        end
        else
          if not AItemControl.BarManager.UseLargeImagesForLargeIcons or
            not IsGlyphAssigned(AItemControl.LargeGlyph) then
          begin
            AImageWidth := 2 * AImageWidth;
            AImageHeight := 2 * AImageHeight;
          end;
      end;
    end;
  end;

  function GetImageBounds(AWidth, AHeight, AImageWidth, AImageHeight: Integer): TRect;
  begin
    Result := Bounds(
      ADrawRect.Left + (AWidth - AImageWidth) div 2,
      ADrawRect.Top + (AHeight - AImageHeight) div 2,
      AImageWidth, AImageHeight);
      if ADowned then
        OffsetRect(Result, GlyphDownShift(AItemControl), GlyphDownShift(AItemControl));
      if ADrawDowned then
        OffsetRect(Result, GlyphDrawDownedShift(AItemControl, ADowned), GlyphDrawDownedShift(AItemControl, ADowned));
  end;

var
  AWidth, AHeight, AImageWidth, AImageHeight: Integer;
begin
  Result := Rect(0, 0, AImageSize.cx, AImageSize.cy);
  GetDimensions(AWidth, AHeight);

//#DG SC-AS12012  if not AGlyphEmpty or ADowned then
  begin
    GetRealImageDimensions(AWidth, AHeight, AImageWidth, AImageHeight);
    Result := GetImageBounds(AWidth, AHeight, AImageWidth, AImageHeight);
  end;
end;

function TdxBarPainter.GetDefaultEnabledTextColor(
  ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean): TColor;
begin
  if ASelected and not AFlat then
    Result := GetSysColor(COLOR_HIGHLIGHTTEXT)
  else
    Result := GetSysColor(COLOR_BTNTEXT);
end;

procedure TdxBarPainter.GetDisabledTextColors(
  ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean;
  var AColor1, AColor2: TColor);
begin
  if ASelected or AFlat then
  begin
    AColor1 := GetSysColor(COLOR_GRAYTEXT);
    AColor2 := AColor1;
  end
  else
  begin
    AColor1 := GetSysColor(COLOR_BTNHIGHLIGHT);
    AColor2 := GetSysColor(COLOR_BTNSHADOW);
  end;
end;

function TdxBarPainter.GetEnabledTextColor(
  ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean): TColor;
begin
  Result := GetDefaultEnabledTextColor(ABarItemControl, ASelected, AFlat);
end;

function TdxBarPainter.GetItemArrowColor(const ADrawParams: TdxBarButtonLikeControlDrawParams): TColor;
begin
  if UseTextColorForItemArrow then
    with ADrawParams do
      GetTextColors(BarItemControl, Enabled, IsTextSelected, IsFlatText, Result, Result)
  else
    Result := clDefault;
end;

class function TdxBarPainter.GetFaded(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := ABarControl.BarManager.MakeDisabledImagesFaded;
end;

class function TdxBarPainter.IsFadingAvailable: Boolean;
begin
  Result := Supports(Self, IdxFadingPainterHelper);
end;

class function TdxBarPainter.IgnoreGlyphOpaque: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.IgnoreNonRecentColor: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.IsMenuItem(ABarItemControl: TdxBarItemControl): Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.UseTextColorForItemArrow: Boolean;
begin
  Result := False;
end;

class function TdxBarPainter.GetBarItemContolHintPosition(
  ABarControl: TCustomdxBarControl; const AItemBounds: TRect;
  const ACursorPos: TPoint; AHeight: Integer): TPoint;
var
  R: TRect;
begin
  Result := ACursorPos;
  R := AItemBounds;
  MapWindowRect(ABarControl.Handle, 0, R);
  ABarControl.AdjustHintWindowPosition(Result, R, AHeight);
end;

function TdxBarPainter.CreateHintViewInfo(ABarManager: TdxBarManager; AHintText: string; const AShortCut: string;
  AScreenTip: TdxBarScreenTip): TdxBarCustomHintViewInfo;
begin
  Result := TdxBarHintViewInfo.Create(ABarManager, AHintText, AShortCut, GetMouseCursorPos);
end;

class function TdxBarPainter.BarIsBarSmall(ABarControl: TdxBarControl;
  const R: TRect): Boolean;
begin
  with R do
    Result := Bottom - Top <= 1 + 3 + 5 + 3 + 3 + 1;
end;

class function TdxBarPainter.BarCaptionBkColor(ABarControl: TdxBarControl;
  AMainFormActive: Boolean): COLORREF;
const
  CaptionBkColors: array[Boolean] of Integer =
    (COLOR_INACTIVECAPTION, COLOR_ACTIVECAPTION);
begin
  Result := GetSysColor(CaptionBkColors[AMainFormActive]);
end;

function TdxBarPainter.BarCaptionColor(ABarControl: TdxBarControl): COLORREF;
begin
  Result := GetSysColor(COLOR_CAPTIONTEXT);
end;

class function TdxBarPainter.BarMarkArrowColor(ABarControl: TdxBarControl;
  AState: TdxBarMarkState): COLORREF;
begin
  Result := GetSysColor(COLOR_CAPTIONTEXT);
end;

procedure TdxBarPainter.BarDrawGrip(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AToolbarBrush: HBRUSH);
begin
  if IsNativeBackground and ABarControl.BarManager.FThemeAvailable then
    TdxBarXPPainter.BarDrawNativeGrip(ABarControl, DC, R, AToolbarBrush)
  else
  //  DrawFrameControl(DC, R, DFC_SCROLL, DFCS_SCROLLSIZEGRIP);
    BarDrawSizeGrip(DC, R);
end;

procedure TdxBarPainter.BarDrawMarkArrow(ABarControl: TdxBarControl;
  DC: HDC; MarkR: TRect);
var
  P: array[1..3] of TPoint;
  AColor: COLORREF;
begin
  with MarkR, P[1] do
  begin
    P[1] := Point((Left + Right - MarkSizeArrowX) div 2,
      (Top + Bottom - MarkSizeArrowY) div 2 + (Top + Bottom - MarkSizeArrowY) mod 2);
    P[2] := Point(X + MarkSizeArrowX - 1, Y);
    P[3] := Point(X + MarkSizeArrowX div 2, Y + MarkSizeArrowY - 1);
  end;
  AColor := BarMarkArrowColor(ABarControl, ABarControl.MarkDrawState);
  PolygonByColor(DC, P, AColor, AColor);
end;

class procedure TdxBarPainter.BarDrawMarkAtPos(ABarControl: TdxBarControl;
  DC: HDC; const ItemRect: TRect; Offset: Integer);
var
  APen: HPEN;
  X, Y: Integer;
begin
  APen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNTEXT)));
  if ABarControl.Horizontal then
  begin
    X := Offset;
    Y := 4 - Byte(BarIsBarSmall(ABarControl, ItemRect));
    MoveToEx(DC, X, Y, nil);
    LineTo(DC, X + 2, Y + 2);
    LineTo(DC, X - 1, Y + 5);
    MoveToEx(DC, X + 1, Y, nil);
    LineTo(DC, X + 3, Y + 2);
    LineTo(DC, X, Y + 5);
  end
  else
  begin
    X := ABarControl.ClientWidth - 8;
    MoveToEx(DC, X, Offset, nil);
    LineTo(DC, X + 2, Offset + 2);
    LineTo(DC, X + 5, Offset - 1);
    MoveToEx(DC, X, Offset + 1, nil);
    LineTo(DC, X + 2, Offset + 3);
    LineTo(DC, X + 5, Offset);
  end;
  ReverseGDIObject(DC, APen);
end;

procedure TdxBarPainter.BarDrawMarkBackground(ABarControl: TdxBarControl;
  DC: HDC; ItemRect: TRect; AToolbarBrush: HBRUSH);
begin
  // Required
end;

procedure TdxBarPainter.BarDrawMarkElements(ABarControl: TdxBarControl;
  DC: HDC; ItemRect: TRect);

  procedure DrawArrow(X, Y: Integer; Vertical: Boolean);
  var
    P: array[1..3] of TPoint;
    AColor: COLORREF;
  begin
    if Vertical then
    begin
      P[1] := Point(X, Y);
      P[2] := Point(X, Y + 4);
      P[3] := Point(X - 2, Y + 2);
    end
    else
    begin
      P[1] := Point(X, Y);
      P[2] := Point(X + 4, Y);
      P[3] := Point(X + 2, Y + 2);
    end;
    AColor := GetSysColor(GetDrawMarkElementColor(ABarControl));
    PolygonByColor(DC, P, AColor, AColor);
  end;

begin
  with ItemRect do
  begin
    if BarAllowQuickCustomizing then
      if ABarControl.Horizontal then
        DrawArrow(Left + 3, Bottom - 7 + Byte(BarIsBarSmall(ABarControl, ItemRect)), False)
      else
        DrawArrow(Left + 5, Top + 3, True);

    if ABarControl.FTruncated then
      if ABarControl.Horizontal then
      begin
        BarDrawMarkAtPos(ABarControl, DC, ItemRect, Left + 2);
        BarDrawMarkAtPos(ABarControl, DC, ItemRect, Left + 6);
      end
      else
      begin
        BarDrawMarkAtPos(ABarControl, DC, ItemRect, Top + 2);
        BarDrawMarkAtPos(ABarControl, DC, ItemRect, Top + 6);
      end;
  end;
end;

class procedure TdxBarPainter.BarOffsetFloatingBarCaption(ABarControl: TdxBarControl;
  var X: Integer; var R: TRect);
begin
  X := ABarControl.MarkNCRect.Right + 3 * FloatToolbarMarkIndent;
end;

class function TdxBarPainter.GetDrawMarkElementColor(ABarControl: TdxBarControl): Integer;
begin
  Result := COLOR_BTNTEXT;
end;

procedure TdxBarPainter.ButtonLikeControlDoDrawCaption(const ADrawParams: TdxBarButtonLikeControlDrawParams;
  const ATextBounds: TRect; ATextAlignment, AFormat: DWORD);
begin
  with ADrawParams do
    DrawItemText(BarItemControl, Canvas.Handle, Caption, ATextBounds,
      ATextAlignment, Enabled, IsTextSelected, PaintType = ptVert, False, IsFlatText, AFormat);
end;

class function TdxBarPainter.GetControlTextIndents: TRect;
begin
  Result := Rect(4, 0, 0, 0);
end;

class function TdxBarPainter.GetControlCaptionRect(const ADrawParams: TdxBarItemControlDrawParams): TRect;
begin
  Result := cxGetTextRect(ADrawParams.Canvas.Handle, ADrawParams.Caption, 1);
end;

procedure TdxBarPainter.InflateSizeForArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; var ASize: Integer);
begin
  if ADrawParams.SplitDropDown then
  begin
    if (ADrawParams.PaintType <> ptMenu) and ADrawParams.IsDropDown then
      Inc(ASize, GetControlTextIndents.Right + ADrawParams.ArrowSize.cx);
  end
  else
    if not ADrawParams.IsMenuItem then
      Inc(ASize, ADrawParams.BarItemControl.Parent.TextSize div 2);
end;

function TdxBarPainter.GetDotSpaceAfter(ADotWidth: Integer): Integer;
begin
  Result := ADotWidth;
end;

function TdxBarPainter.GetCustomColorButtonBounds(const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect): TRect;

  function IsCustomButtonTooLarge(AButtonWidth: Integer): Boolean;
  begin
    Result := AButtonWidth >= (cxRectWidth(ADrawParams.BarEditControl.GetEditRect) div 2);
  end;

begin
  Result := ARect;
  Result.Left := Result.Right - GetCustomColorButtonWidth(ADrawParams.PaintType, ARect) - GetCustomColorButtonIndents(ADrawParams.PaintType).Left -
    GetCustomColorButtonIndents(ADrawParams.PaintType).Right;
  if IsCustomButtonTooLarge(cxRectWidth(Result)) or not ADrawParams.IsShowCustomColorButton then
    Result.Left := Result.Right
  else
    Result := cxRectContent(Result, GetCustomColorButtonIndents(ADrawParams.PaintType));
end;

function TdxBarPainter.GetCustomColorButtonWidth(APaintType: TdxBarPaintType; const ARect: TRect): Integer;
begin
  Result := (cxRectHeight(ARect) - 2 - 2) div 7 * 7 + 2 + 2 - GetCustomColorButtonIndents(APaintType).Left - GetCustomColorButtonIndents(APaintType).Right;
end;

procedure TdxBarPainter.DrawDot(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect);
begin
  if ADrawParams.Enabled then
    if IsHighContrastWhite and ADrawParams.DrawSelected then
      FillRect(ADrawParams.Canvas.Handle, ARect, COLOR_BTNFACE + 1)
    else
      FillRect(ADrawParams.Canvas.Handle, ARect, COLOR_BTNTEXT + 1)
  else
    DrawDisabledShadowRect(ADrawParams.BarItemControl, ADrawParams.Canvas.Handle, ARect);
end;

procedure TdxBarPainter.DrawDots(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect);

  procedure CalculateFirstDotBounds(ADotWidth: Integer; var ARect: TRect);
  var
    ALeftIndent, ASpaceAfter: Integer;
  begin
    ALeftIndent := (cxRectWidth(ARect) - ADotWidth * 5) div 2;
    ARect.Right := ARect.Left + ADotWidth;
    ARect.Top := ARect.Bottom - ADotWidth;
    ASpaceAfter := GetDotSpaceAfter(ADotWidth);
    OffsetRect(ARect, ALeftIndent, - ASpaceAfter);
  end;

const
  DotsCount = 3;
var
  ADotWidth, I: Integer;
begin
  with ADrawParams do
  begin
    ADotWidth := (ARect.Right - ARect.Left) div 7;
    CalculateFirstDotBounds(ADotWidth, ARect);
    OffsetEllipsisBounds(IsPressed, ARect);
    for I := 0 to DotsCount - 1 do
    begin
      DrawDot(ADrawParams, ARect);
      OffsetRect(ARect, ADotWidth * 2, 0);
    end;
  end;
end;

class procedure TdxBarPainter.ComboControlDrawArrow(const ADrawParams: TdxBarEditLikeControlDrawParams;
  const ARect: TRect; ASize: Integer; AColor: TColor);
begin
  if not IsFlatItemText and not ADrawParams.Enabled then
    AColor := clDefault;
  dxBar.DrawLargeItemArrow(ADrawParams.Canvas.Handle, ARect, True, ASize, False, ADrawParams.Enabled, IsFlatItemText, AColor);
end;

procedure TdxBarPainter.SubMenuControlFillScrollArrow(ACanvas: TcxCanvas; ARect: TRect; AColor: TColor);
begin
  FillRectByColor(ACanvas.Handle, ARect, AColor);
end;

procedure TdxBarPainter.SubMenuControlDrawScrollArrow(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas;
  const AArrowRect: TRect; AColor: COLORREF; AArrowDirection: TcxArrowDirection);
var
  P: TcxArrowPoints;
begin
  CalculateArrowPoints(AArrowRect, SubMenuControlGetScrollArrowSize(ABarSubMenuControl.TextSize), AArrowDirection, P);
  ACanvas.SaveClipRegion;
  try
    SetArrowRegion(ACanvas, AArrowDirection, P, roSet);
    SubMenuControlFillScrollArrow(ACanvas, GetArrowRectByPoints(P, AArrowDirection), AColor);
  finally
    ACanvas.RestoreClipRegion;
  end;
  SetArrowRegion(ACanvas, AArrowDirection, P, roSubtract);
end;

procedure TdxBarPainter.SubMenuControlDrawScrollBand(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection);
begin
  SubMenuControlDrawScrollArrow(ABarSubMenuControl, ACanvas, SubMenuControlGetScrollBandBounds(ABarSubMenuControl, AArrowDirection),
    GetSysColor(COLOR_BTNTEXT), AArrowDirection);
  SubMenuControlDrawScrollButton(ABarSubMenuControl, ACanvas, AArrowDirection);
  SubMenuControlDrawNonRecentGroupSeparator(ABarSubMenuControl, ACanvas, AArrowDirection);
  SubMenuControlDrawScrollBandBackground(ABarSubMenuControl, ACanvas, AArrowDirection);
end;

procedure TdxBarPainter.SubMenuControlDrawScrollBandBackground(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection);
var
  AControl: TdxBarItemControl;
begin
  case AArrowDirection of
    adUp:
      AControl := ABarSubMenuControl.TopItemControl;
  else {adDown}
    AControl := ABarSubMenuControl.BottomItemControl;
  end;
  DrawBackground(AControl, ACanvas.Handle, ABarSubMenuControl.GetItemRectEx(AControl, True),
    ABarSubMenuControl.ToolbarItemsBrush, False);
end;

procedure TdxBarPainter.SubMenuControlDrawNonRecentGroupSeparator(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection);
const
  BrushColors: array[Boolean] of COLORREF = (COLOR_BTNHIGHLIGHT, COLOR_BTNSHADOW);
var
  R: TRect;
begin
  with ABarSubMenuControl do
    if (AArrowDirection = adDown) and BottomItemControl.FChangeRecentGroup then
    begin
      R := GetItemRectEx(BottomItemControl, True);
      R := Rect(R.Left - 1, R.Top, R.Right + 1, R.Top + 1);
      DrawBackground(BottomItemControl, ACanvas.Handle, R,
        BrushColors[BottomItemControl.FNonRecent] + 1, False);
      ACanvas.SetClipRegion(TcxRegion.Create(R), roSubtract);
    end
end;

function TdxBarPainter.SubMenuControlGetScrollBandBounds(ABarSubMenuControl: TdxBarSubMenuControl; AArrowDirection: TcxArrowDirection): TRect;
var
  AScrollAreaSize: Integer;
begin
  AScrollAreaSize := SubMenuControlGetScrollBandSize(ABarSubMenuControl);
  Result := ABarSubMenuControl.FItemsRect;
  if AArrowDirection = adUp then
    Result.Bottom := Result.Top + AScrollAreaSize
  else
    Result.Top := Result.Bottom - AScrollAreaSize;
end;

function TdxBarPainter.SubMenuControlGetScrollBandSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := ABarSubMenuControl.TextSize;
end;

class function TdxBarPainter.SubMenuControlGetScrollArrowSize(ATextSize: Integer): Integer;
begin
  Result := ATextSize div 3 - 1
end;

procedure TdxBarPainter.SubMenuControlDrawMarkContent(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect; ASelected: Boolean);
var
  APen: HPEN;
  Size, X, Y, I: Integer;

  procedure DrawOneMark(const Y: Integer);
  begin
    MoveToEx(DC, X, Y, nil);
    LineTo(DC, X + Size div 2, Y + Size div 2);
    LineTo(DC, X + Size + 1, Y - 1);
  end;

var
  AColor: COLORREF;
begin
  Size := ABarSubMenuControl.MarkArrowSize;
  if IsHighContrastWhite and IsFlatItemText and ASelected then
    AColor := GetSysColor(COLOR_BTNFACE)
  else
    AColor := GetSysColor(COLOR_BTNTEXT);
  APen := SelectObject(DC, CreatePen(PS_SOLID, 1, AColor));
  with R do
  begin
    X := (Left + Right - (Size + 1)) div 2;
    Y := Top + (ABarSubMenuControl.MarkSize - 2 * Size) div 2;
    for I := Y to Y + Size - 1 do
      DrawOneMark(I + Byte(I >= Y + Size div 2) * Size div 2);
  end;
  ReverseGDIObject(DC, APen);
end;

procedure TdxBarPainter.SubMenuControlDrawMarkBand(
  ABarSubMenuControl: TdxBarSubMenuControl; const AMarkRect: TRect; ASelected: Boolean);

  procedure DrawMarkBackground(ABarSubMenuControl: TdxBarSubMenuControl; ADC: HDC; const AMarkRect: TRect);
  begin
    ABarSubMenuControl.FillBackground(ADC, AMarkRect, ABarSubMenuControl.ToolbarItemsBrush, clNone, True);
    if ASelected then
      SubMenuControlDrawMarkSelection(ABarSubMenuControl, ADC, AMarkRect);
  end;

var
  ABitmap: TBitmap;
begin
  ABitmap := cxCreateBitmap(AMarkRect);
  try
    BarCanvas.BeginPaint(ABitmap.Canvas);
    try
      BarCanvas.WindowOrg := AMarkRect.TopLeft;
      DrawMarkBackground(ABarSubMenuControl, BarCanvas.Handle, AMarkRect);
      SubMenuControlDrawMarkContent(ABarSubMenuControl, BarCanvas.Handle, AMarkRect, ASelected);
      ABarSubMenuControl.Canvas.CopyRect(AMarkRect, BarCanvas.Canvas, AMarkRect);
    finally
      BarCanvas.EndPaint;
    end;
  finally
    FreeAndNil(ABitmap);
  end;
  ABarSubMenuControl.Canvas.SetClipRegion(TcxRegion.Create(AMarkRect), roSubtract);
end;

procedure TdxBarPainter.SubMenuControlDrawMarkSelection(
  ABarSubMenuControl: TdxBarSubMenuControl; ADC: HDC; const AMarkRect: TRect);
var
  R: TRect;
begin
  R := AMarkRect;
  DrawEdge(ADC, R, BDR_RAISEDINNER, BF_RECT);
  ABarSubMenuControl.PreparePalette(ADC);
  DrawBackground(ABarSubMenuControl.BottomItemControl, ADC, cxRectInflate(R, -1, -1), ABarSubMenuControl.FLightBrush, False);
  ABarSubMenuControl.UnpreparePalette(ADC);
end;

class function TdxBarPainter.SubMenuControlUseScrollButtons: Boolean;
begin
  Result := False;
end;

class procedure TdxBarPainter.EditOffsetInteriorRect(ABarEditControl: TdxBarCustomEditControl; var R: TRect);
var
  AOffsets: TRect;
  AHeightCorrection: Integer;
begin
  GetEditTextParams(AOffsets, AHeightCorrection);
  R := cxRectContent(R, AOffsets);
end;

procedure TdxBarPainter.DrawSpinEditArrow(const ADrawParams: TdxBarSpinEditDrawParams; AArrowPos: TPoint; AButtonIndex: Integer);
begin
  with ADrawParams do
  begin
    if Enabled then
      SpinEditControlDrawArrowByPoints(ADrawParams, AArrowPos, COLOR_BTNTEXT, AButtonIndex)
    else
    begin
      SpinEditControlDrawArrowByPoints(ADrawParams, Point(AArrowPos.X + 1, AArrowPos.Y + 1), COLOR_BTNHIGHLIGHT, AButtonIndex);
      SpinEditControlDrawArrowByPoints(ADrawParams, AArrowPos, COLOR_BTNSHADOW, AButtonIndex);
    end;
  end;
end;

class procedure TdxBarPainter.SpinEditControlDrawArrowByPoints(const ADrawParams: TdxBarSpinEditDrawParams;
  AStartPoint: TPoint; AColorIndex: Integer; AButtonIndex: Integer);
var
  P: array[1..3] of TPoint;
  AColor: COLORREF;
begin
  P[1] := Point(AStartPoint.X, AStartPoint.Y);
  P[2] := Point(AStartPoint.X + ADrawParams.ArrowSize.cx - 1, AStartPoint.Y);
  if AButtonIndex = secButtonUp then
    P[3] := Point(AStartPoint.X + ADrawParams.ArrowSize.cx div 2,
      AStartPoint.Y - ADrawParams.ArrowSize.cx div 2)
  else
    P[3] := Point(AStartPoint.X + ADrawParams.ArrowSize.cx div 2,
      AStartPoint.Y + ADrawParams.ArrowSize.cx div 2);

  AColor := GetSysColor(AColorIndex);
  PolygonByColor(ADrawParams.Canvas.Handle, P, AColor, AColor);
end;

class procedure TdxBarPainter.DateNavigatorDrawButtonCaption(DC: HDC; const R: TRect;
  AOffset: Integer; const ACaption: string; AOpaque: Boolean);
var
  AFlags: Integer;
  ASize: TSize;
  APrevBkMode: Integer;
begin
  cxGetTextExtentPoint32(DC, ACaption, ASize);
  SetTextColor(DC, GetSysColor(COLOR_BTNTEXT));
  SetBkColor(DC, GetSysColor(COLOR_BTNFACE));
  AFlags := ETO_CLIPPED;
  APrevBkMode := GetBkMode(DC);
  if AOpaque then
    AFlags := AFlags or ETO_OPAQUE
  else
    SetBkMode(DC, TRANSPARENT);
  cxExtTextOut(DC, ACaption, cxPointOffset(cxRectCenter(R, ASize).TopLeft, AOffset, AOffset), R, AFlags);
  SetBkMode(DC, APrevBkMode);
end;

procedure TdxBarPainter.InternalCalculateComboParts(
  const ADrawParams: TdxBarEditLikeControlDrawParams; var AParts: array of TRect);
begin
  AParts[ccpDropButton].Left := AParts[ccpDropButton].Right - ADrawParams.BarItemControl.Parent.ComboBoxArrowWidth;
  AParts[ecpEdit].Right := AParts[ccpDropButton].Left - ComboControlArrowOffset;
end;

{ TdxBarStandardPainter }

class procedure TdxBarStandardPainter.DrawDisabledShadowRect(ABarItemControl: TdxBarItemControl;
  DC: HDC; R: TRect);
begin
  OffsetRect(R, 1, 1);
  FillRect(DC, R, COLOR_BTNHIGHLIGHT + 1);
  OffsetRect(R, -1, -1);
  inherited DrawDisabledShadowRect(ABarItemControl, DC, R);
end;

procedure TdxBarStandardPainter.DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect);
var
  AIconRect: TRect;
  AIsGlyphEmpty, AOpaque: Boolean;
  Brush: HBRUSH;
  ADC: HDC;
begin
  with ADrawParams do
  begin
    AIconRect := SubMenuControlGetItemIconRect(R, BarItemControl.Parent.IconAreaSize);
    AIsGlyphEmpty := not BarItemControl.HasIcon(ViewSize, ViewStructure);
    ADC := Canvas.Handle;

    if DrawSelected and AIsGlyphEmpty and not Downed then
      Brush := BarItemControl.Parent.ToolbarSelBrush
    else
      Brush := BarItemControl.BkBrush;

    R.Left := AIconRect.Right + 1;

    AOpaque := DrawSelected or BarItemControl.FNonRecent;
    DrawBackground(BarItemControl, ADC, Rect(AIconRect.Right, AIconRect.Top, R.Left, AIconRect.Bottom), Brush, AOpaque);
    if AIconRect.Top > R.Top then
      DrawBackground(BarItemControl, ADC, Rect(AIconRect.Left, R.Top, R.Left, AIconRect.Top), Brush, AOpaque);
    if AIconRect.Bottom < R.Bottom then
      DrawBackground(BarItemControl, ADC, Rect(AIconRect.Left, AIconRect.Bottom, R.Left, R.Bottom), Brush, AOpaque);

    if DrawSelected then
      Brush := BarItemControl.Parent.ToolbarSelBrush
    else
      Brush := BarItemControl.BkBrush;
    DrawBackground(BarItemControl, ADC, R, Brush, AOpaque);
  end;
end;

class procedure TdxBarStandardPainter.FrameAndFillRect(ABarItemControl: TdxBarItemControl;
  DC: HDC; var R: TRect; Enabled, Selected, Pressed: Boolean);
const
  Borders: array[Boolean] of Integer = (BDR_RAISEDINNER, BDR_SUNKENOUTER);
var
  Brush: HBRUSH;
begin
  Brush := ABarItemControl.Parent.BkBrush;
  if Selected then
    DrawEdge(DC, R, Borders[Pressed], BF_RECT)
  else
    FrameRect(DC, R, ABarItemControl.Parent.BkBrush);
  InflateRect(R, -1, -1);
  FillRect(DC, R, Brush);
end;

class function TdxBarStandardPainter.GlyphBkgndBrush(ABarItemControl: TdxBarItemControl;
  APaintType: TdxBarPaintType; AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown,
  AForceUseBkBrush, AGrayScale: Boolean): HBRUSH;
begin
  if ADowned and ABarItemControl.Enabled then
    if ASelected then
      Result := ABarItemControl.Parent.ToolbarDownedSelBrush
    else
      Result := ABarItemControl.Parent.ToolbarDownedBrush
  else
    if ASelected and (APaintType = ptMenu) and AGlyphEmpty and not ADowned then
      Result := ABarItemControl.Parent.ToolbarSelBrush
    else
      Result := ABarItemControl.BkBrush;
end;

class function TdxBarStandardPainter.GlyphDownShift(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := 1;
end;

class function TdxBarStandardPainter.GlyphDrawDownedShift(ABarItemControl: TdxBarItemControl;
  ADown: Boolean): Integer;
begin
  Result := 1;
end;

class function TdxBarStandardPainter.LoweredBorderSize(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := 1;
end;

function TdxBarStandardPainter.BeforeFingersSize: Integer;
begin
  Result := 2;
end;

function TdxBarStandardPainter.FingersSize(ABarControl: TdxBarControl): Integer;
begin
  Result := BeforeFingersSize + 2 * GripperSize(ABarControl) + 1;
end;

class procedure TdxBarStandardPainter.GetEditTextVerticalOffsets(out ATop, ABottom: Integer);
begin
  ATop := 0;
  ABottom := 2;
end;

class function TdxBarStandardPainter.BarAllowHotTrack: Boolean;
begin
  Result := False;
end;

class function TdxBarStandardPainter.BarAllowQuickCustomizing: Boolean;
begin
  Result := False;
end;

procedure TdxBarStandardPainter.BarDrawCloseButton(ABarControl: TdxBarControl;
  DC: HDC; R: TRect);
const
  Pushes: array[Boolean] of Integer = (0, DFCS_PUSHED);
begin
  FrameRectByColor(DC, R, ABarControl.CaptionBkColor);
  InflateRect(R, -1, -1);
  DrawFrameControl(DC, R, DFC_CAPTION,
    DFCS_CAPTIONCLOSE or Pushes[ABarControl.CloseButtonState = msPressed]);
end;

procedure TdxBarStandardPainter.BarDrawDockedBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AToolbarBrush: HBRUSH);

  procedure DrawFinger;
  begin
    with R do
    begin
      DrawEdge(DC, R, BDR_RAISEDINNER, BF_RECT);
      if ABarControl.Horizontal then
        SetPixel(DC, Left, Bottom - 1, GetSysColor(COLOR_BTNHIGHLIGHT))
      else
        SetPixel(DC, Right - 1, Top, GetSysColor(COLOR_BTNHIGHLIGHT));
      InflateRect(R, -1, -1);
      FillRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));
      InflateRect(R, 1, 1);
      ExcludeClipRect(DC, Left, Top, Right, Bottom);
    end;
  end;

var
  AGripperSize: Integer;
begin
  with R do
  begin
    DrawEdge(DC, R, BDR_RAISEDINNER, BF_RECT);
    InflateRect(R, -2, -2);
    if ABarControl.CanMoving then
    begin
      AGripperSize := GripperSize(ABarControl);
      if ABarControl.Horizontal then
      begin
        Inc(Left, BeforeFingersSize);
        Right := Left + AGripperSize;
      end
      else
      begin
        Inc(Top, BeforeFingersSize);
        Bottom := Top + AGripperSize;
      end;
      DrawFinger;
      if ABarControl.Horizontal then
        OffsetRect(R, AGripperSize, 0)
      else
        OffsetRect(R, 0, AGripperSize);
      DrawFinger;
    end;
  end;
end;

procedure TdxBarStandardPainter.BarDrawFloatingBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R, CR: TRect; AToolbarBrush: HBRUSH);
begin
  DrawEdge(DC, R, EDGE_RAISED, BF_RECT);
  InflateRect(R, -2, -2);
  FrameRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));
  InflateRect(R, -1, -1);
  FrameRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));
end;

procedure TdxBarStandardPainter.BarDrawMDIButton(ABarControl: TdxBarControl;
  AButton: TdxBarMDIButton; AState: Integer; DC: HDC; R: TRect);
const
  Borders: array[Boolean] of Integer = (BDR_RAISEDINNER, BDR_SUNKENOUTER);
var
  AFlat, ClipRgnExists: Boolean;
  Rgn1, Rgn2: HRGN;
  AFlags: Integer;
begin
  AFlat :=
    (AButton = mdibClose) and ABarControl.BarManager.FlatCloseButton and
    ABarControl.MDIButtonsOnBar and not ABarControl.RealMDIButtonsOnBar;
  Rgn1 := 0;
  ClipRgnExists := False;
  if AFlat then
  begin
    Rgn1 := CreateRectRgn(0, 0, 0, 0);
    ClipRgnExists := GetClipRgn(DC, Rgn1) = 1;
    InflateRect(R, -1, -1);
    Rgn2 := CreateRectRgnIndirect(R);
    SelectClipRgn(DC, Rgn2);
    DeleteObject(Rgn2);
    InflateRect(R, 1, 1);
  end;

  AFlags := 0;
  if AState = DXBAR_DISABLED then
    AFlags := AFlags or DFCS_INACTIVE
  else
    if AState = DXBAR_PRESSED then
      AFlags := AFlags or DFCS_PUSHED;
  DrawFrameControl(DC, R, DFC_CAPTION,
    MDIButtonStyles[AButton] or AFlags or Byte(AFlat) * DFCS_FLAT);

  if AFlat then
  begin
    if ClipRgnExists then
      SelectClipRgn(DC, Rgn1)
    else
      SelectClipRgn(DC, 0);
    DeleteObject(Rgn1);
    DrawEdge(DC, R, Borders[AState = DXBAR_PRESSED], BF_RECT);
  end;
end;

class function TdxBarStandardPainter.BarHorSize: Integer;
begin
  Result := dxBarHorSize;
end;

function TdxBarStandardPainter.BarMarkItemRect(ABarControl: TdxBarControl): TRect;
begin
  if ABarControl.DockingStyle = dsNone then
  begin
    Result := ABarControl.GetCaptionRect;
    Result.Right := Result.Left + 3 + 7 + 3;
  end
  else
    Result := inherited BarMarkItemRect(ABarControl);
end;

class function TdxBarStandardPainter.BarTopSize: Integer;
begin
  Result := dxBarTopSize;
end;

class function TdxBarStandardPainter.BarBottomSize: Integer;
begin
  Result := dxBarBottomSize;
end;

class function TdxBarStandardPainter.BarUseSystemClose: Boolean;
begin
  Result := True;
end;

class function TdxBarStandardPainter.BarUseSystemNCBorder: Boolean;
begin
  Result := True;
end;

class function TdxBarStandardPainter.SubMenuBeginGroupIndent: Integer;
begin
  Result := 2;
end;

procedure TdxBarStandardPainter.DrawButtonControlArrowBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams;
  var R1: TRect; ABrush: HBRUSH);
const
  Borders: array[Boolean] of Integer = (BDR_RAISEDINNER, BDR_SUNKENOUTER);
var
  R: TRect;
begin
  inherited;
  with ADrawParams do
    if DrawSelected then
      DrawEdge(Canvas.Handle, R1, Borders[DroppedDown], BF_RECT)
    else
      if PaintType = ptMenu then
      begin
        R := cxRectSetWidth(R1, R1.Left - 1, 2);
        DrawEdge(Canvas.Handle, R, EDGE_ETCHED, BF_LEFT or BF_RIGHT);
      end;
end;

class procedure TdxBarStandardPainter.ComboControlDrawSimpleButton(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect; ABrush: HBRUSH);
const
  Borders: array[Boolean] of Integer = (BDR_RAISEDINNER, BDR_SUNKENOUTER);
var
  ASpaceBrush: HBRUSH;
begin
  with ADrawParams do
  begin
    if DrawSelected and Enabled then
    begin
      DrawEdge(Canvas.Handle, ARect, Borders[DroppedDown], BF_RECT);
      ASpaceBrush := BarEditControl.Parent.BkBrush;
    end
    else
    begin
      if Enabled then
        ASpaceBrush := BarEditControl.EditBkBrush
      else
        ASpaceBrush := BarEditControl.Parent.BkBrush;
      FrameRect(Canvas.Handle, ARect, ASpaceBrush);
    end;
    FillRect(Canvas.Handle, Rect(ARect.Left - 1, ARect.Top, ARect.Left, ARect.Bottom), ASpaceBrush);
    InflateRect(ARect, -1, -1);
    FillRect(Canvas.Handle, ARect, ABrush);
    if DroppedDown then
      OffsetRect(ARect, 1, 1);
  end;
end;

procedure TdxBarStandardPainter.DropDownListBoxDrawBorder(DC: HDC; AColor: TColor; ARect: TRect);
begin
  DrawEdge(DC, ARect, EDGE_RAISED, BF_RECT);
end;

class procedure TdxBarStandardPainter.SubMenuControlDrawItemFrame(ABarSubMenuControl: TdxBarSubMenuControl;
  AControl: TdxBarItemControl; DC: HDC; AItemRect: TRect; AIndex: Integer);

  procedure DrawChangeRecentGroupLine(ALeftDelta: Integer);
  const
    ABrushColors: array[Boolean] of COLORREF = (COLOR_BTNHIGHLIGHT, COLOR_BTNSHADOW);
  var
    R: TRect;
    ASeparatorIndex: Integer;
  begin
    R := AItemRect;
    if not AControl.FNonRecent and ABarSubMenuControl.ViewInfo.IsAssociatedWithSeparator(AControl, ASeparatorIndex) then
      R.Top := ABarSubMenuControl.ViewInfo.SeparatorInfos[ASeparatorIndex].Bounds.Top;
    with R do
    begin
      Bottom := Top;
      Dec(Top);
      Dec(Left, ALeftDelta);
      Inc(Right);
    end;
    FillRect(DC, R, GetSysColor(ABrushColors[AControl.FNonRecent]));
  end;

var
  ALeftDelta: Integer;
begin
  ALeftDelta := Ord(ABarSubMenuControl.BarSize = 0);
  if AControl.FChangeRecentGroup then
    DrawChangeRecentGroupLine(ALeftDelta);

  if AControl.FNonRecent then
    with AItemRect do
    begin
      if (AIndex = 0) and not ABarSubMenuControl.Detachable then
      begin
        FillRect(DC, Rect(Left - ALeftDelta, Top - 1, Right + 2, Top), ABarSubMenuControl.BkBrush);
        SetPixel(DC, Right + 1, Top - 2, GetSysColor(COLOR_BTNHIGHLIGHT));
      end;
      FillRect(DC, Rect(Left - ALeftDelta, Top, Left, Bottom), ABarSubMenuControl.BkBrush);
      FillRect(DC, Rect(Right, Top, Right + 2, Bottom), ABarSubMenuControl.BkBrush);
      if AIndex = AControl.ItemLink.Owner.VisibleItemCount - 1 then
      begin
        FillRect(DC, Rect(Left - ALeftDelta, Bottom, Right + 2, ABarSubMenuControl.ClientHeight), ABarSubMenuControl.BkBrush);
        if ALeftDelta <> 0 then
          SetPixel(DC, Left - 2, ABarSubMenuControl.ClientHeight - 1, GetSysColor(COLOR_BTNHIGHLIGHT));
      end;
    end;
end;

class function TdxBarStandardPainter.SubMenuControlIsOffsetRecentGroupNeeded: Boolean;
begin
  Result := True;
end;

class function TdxBarStandardPainter.SubMenuControlContentRectOffset(ABarSubMenuControl: TdxBarSubMenuControl): TRect;
begin
  Result := inherited SubMenuControlContentRectOffset(ABarSubMenuControl);
  if ABarSubMenuControl.Detachable then
    Result.Top := 0;
end;

class function TdxBarStandardPainter.SubMenuControlClientBorderSize: Integer;
begin
  Result := 2;
end;

function TdxBarStandardPainter.CanUpdateBarPartly: Boolean;
begin
  Result := True;
end;

function TdxBarStandardPainter.GetBorderSize: Integer;
begin
  Result := 2;
end;

class function TdxBarStandardPainter.GetCaptionOffsets: TRect;
begin
  Result := Rect(2, 1, 2, 1);
end;

procedure TdxBarStandardPainter.DrawGlyphBorder(ABarItemControl: TdxBarItemControl;
  DC: HDC; ABrush: HBRUSH; NeedBorder: Boolean; R: TRect; PaintType: TdxBarPaintType;
  IsGlyphEmpty, Selected, Down, DrawDowned, ADroppedDown, IsSplit: Boolean);
const
  Borders: array[Boolean] of Integer = (BDR_RAISEDINNER, BDR_SUNKENOUTER);
begin
  if Down or (Selected and ((PaintType <> ptMenu) or not IsGlyphEmpty)) then
    DrawEdge(DC, R, Borders[Down or DrawDowned or ADroppedDown and not IsSplit], BF_RECT)
  else
    if NeedBorder then
      DrawBackgroundFrameRect(ABarItemControl, DC, R, ABrush, Selected or Down or
        DrawDowned or ABarItemControl.FNonRecent or ABarItemControl.IsBkColorAssigned);
end;

procedure TdxBarStandardPainter.DrawGlyphCheckMark(ABarItemControl: TdxBarItemControl;
  DC: HDC; X, Y, DoubleSize: Integer);
const
  Colors: array[Boolean] of TColor = (clBlack, clWhite);
var
  OffsetY, I: Integer;

  procedure DrawOneMark;
  begin
    with ABarItemControl.Canvas do
    begin
      MoveTo(X + DoubleSize * 1, Y + OffsetY + DoubleSize * 2);
      LineTo(X + DoubleSize * 3, Y + OffsetY + DoubleSize * 4);
      LineTo(X + DoubleSize * 8, Y + OffsetY - DoubleSize * 1);
    end;
    Inc(OffsetY);
  end;

begin
  with ABarItemControl.Canvas do
    if ABarItemControl.Enabled then
    begin
      OffsetY := 0;
      Pen.Color := clSilver;
      for I := 1 to DoubleSize do DrawOneMark;
      Pen.Color := Colors[GetSysColor(COLOR_BTNFACE) = 0];
      for I := 1 to 2 * DoubleSize do DrawOneMark;
      Pen.Color := Colors[GetSysColor(COLOR_BTNFACE) <> 0];
      for I := 1 to DoubleSize do DrawOneMark;
      MoveTo(X + DoubleSize - 1, Y + DoubleSize * 3 - (DoubleSize - 1));
      LineTo(X + DoubleSize - 1, Y + DoubleSize * 5 + (DoubleSize - 1));
      MoveTo(X + DoubleSize * 8, Y - DoubleSize * 1 + 2);
      LineTo(X + DoubleSize * 8, Y + DoubleSize * 3);
    end
    else
    begin
      OffsetY := 1;
      Pen.Color := GetSysColor(COLOR_BTNSHADOW);
      for I := 1 to 2 * DoubleSize do DrawOneMark;
      Pen.Color := GetSysColor(COLOR_BTNHIGHLIGHT);
      for I := 0 to DoubleSize - 1 do
      begin
        MoveTo(X + DoubleSize * 4 - (DoubleSize - 1),
          Y + DoubleSize * 6 + (DoubleSize - 1 - I));
        LineTo(X + DoubleSize * 9, Y + DoubleSize * 1 - I);
        MoveTo(X + DoubleSize * 4, Y + DoubleSize * 7 - I);
        LineTo(X + DoubleSize * 9, Y + DoubleSize * 2 - I);
      end;
    end;
end;

class function TdxBarStandardPainter.IgnoreGlyphOpaque: Boolean;
begin
  Result := True;
end;

class function TdxBarStandardPainter.BarIsBarSmall(ABarControl: TdxBarControl;
  const R: TRect): Boolean;
begin
  Result := False;
end;

class procedure TdxBarStandardPainter.BarDrawMarkAtPos(ABarControl: TdxBarControl;
  DC: HDC; const ItemRect: TRect; Offset: Integer);
var
  Pen: HPEN;
  X: Integer;
begin
  if ABarControl.Horizontal then
  begin
    Pen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNHIGHLIGHT)));
    X := Offset;
    MoveToEx(DC, X - 1, 1, nil);
    LineTo(DC, X + 2, 4);
    MoveToEx(DC, X + 3, 4, nil);
    LineTo(DC, X - 1, 8);
    ReverseGDIObject(DC, Pen);

    Pen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNSHADOW)));
    MoveToEx(DC, X, 1, nil);
    LineTo(DC, X + 2, 3);
    LineTo(DC, X + 2, 4);
    LineTo(DC, X - 1, 7);
    ReverseGDIObject(DC, Pen);
  end
  else
  begin
    Pen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNSHADOW)));
    X := ABarControl.ClientWidth - 8;
    MoveToEx(DC, X, Offset, nil);
    LineTo(DC, X + 4, Offset + 4);
    MoveToEx(DC, X + 4, Offset + 1, nil);
    LineTo(DC, X + 6, Offset - 1);
    ReverseGDIObject(DC, Pen);

    Pen := SelectObject(DC, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNHIGHLIGHT)));
    MoveToEx(DC, X + 1, Offset, nil);
    LineTo(DC, X + 3, Offset + 2);
    LineTo(DC, X + 4, Offset + 2);
    LineTo(DC, X + 7, Offset - 1);
    ReverseGDIObject(DC, Pen);
  end;
end;

procedure TdxBarStandardPainter.BarDrawMarkBackground(ABarControl: TdxBarControl;
  DC: HDC; ItemRect: TRect; AToolbarBrush: HBRUSH);
begin
  ABarControl.FillBackground(DC, ItemRect, AToolbarBrush, clNone, True);
end;

{ TdxBarEnhancedPainter }

function TdxBarEnhancedPainter.BeforeFingersSize: Integer;
begin
  Result := 1;
end;

function TdxBarEnhancedPainter.FingersSize(ABarControl: TdxBarControl): Integer;
begin
  Result := BeforeFingersSize + GripperSize(ABarControl) + 2;
end;

class function TdxBarEnhancedPainter.SubMenuBeginGroupIndent: Integer;
begin
  Result := 12;
end;

class function TdxBarEnhancedPainter.BarAllowQuickCustomizing: Boolean;
begin
  Result := True;
end;

procedure TdxBarEnhancedPainter.BarDrawDockedBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AToolbarBrush: HBRUSH);

  procedure DrawFinger;
  begin
    with R do
    begin
      DrawEdge(DC, R, BDR_RAISEDINNER, BF_RECT);
      InflateRect(R, -1, -1);
      FillRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));
      InflateRect(R, 1, 1);
      ExcludeClipRect(DC, Left, Top, Right, Bottom);
    end;
  end;

begin
  with R do
  begin
    DrawEdge(DC, R, BDR_RAISEDINNER, BF_RECT);
    InflateRect(R, -2, -2);
    if ABarControl.CanMoving then
    begin
      if ABarControl.Horizontal then
      begin
        Inc(Left, BeforeFingersSize);
        Right := Left + GripperSize(ABarControl);
        InflateRect(R, 0, -1);
      end
      else
      begin
        Inc(Top, BeforeFingersSize);
        Bottom := Top + GripperSize(ABarControl);
        InflateRect(R, -1, 0);
      end;
      DrawFinger;
    end;
  end;
end;

class procedure TdxBarEnhancedPainter.BarDrawMarkAtPos(ABarControl: TdxBarControl;
  DC: HDC; const ItemRect: TRect; Offset: Integer);
begin
  TdxBarPainter.BarDrawMarkAtPos(ABarControl, DC, ItemRect, Offset);
end;

procedure TdxBarEnhancedPainter.BarDrawMarkBackground(ABarControl: TdxBarControl;
  DC: HDC; ItemRect: TRect; AToolbarBrush: HBRUSH);
const
  MarkEdges: array[msSelected..msPressed] of UINT = (BDR_RAISEDINNER, BDR_SUNKENOUTER);
begin
  if ABarControl.MarkDrawState = msNone then
    FrameRect(DC, ItemRect, AToolbarBrush)
  else
    DrawEdge(DC, ItemRect, MarkEdges[ABarControl.MarkDrawState], BF_RECT);
  InflateRect(ItemRect, -1, -1);
  ABarControl.FillBackground(DC, ItemRect, AToolbarBrush, clNone, True);
  InflateRect(ItemRect, 1, 1);
end;

{ TdxBarFlatPainter }

procedure TdxBarFlatPainter.CalculateSpinEditParts(const ADrawParams: TdxBarSpinEditDrawParams;
  var AParts: array of TRect; const AItemRect: TRect);
begin
  inherited;
  Inc(AParts[secButtonUp].Bottom);
end;

class function TdxBarFlatPainter.GetControlCaptionOffset(ABarItemControl: TdxBarItemControl): Integer;
begin
  if ABarItemControl.IsMenuItem then
    Result := 8
  else
    Result := inherited GetControlCaptionOffset(ABarItemControl);
end;

procedure TdxBarFlatPainter.DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect);
var
  AIconRect: TRect;
  AOpaque: Boolean;
  ABrush: HBRUSH;
  ADC: HDC;
  I: Integer;
begin
  with ADrawParams do
  begin
    AIconRect := SubMenuControlGetItemIconRect(R, BarItemControl.Parent.IconAreaSize);
    ADC := Canvas.Handle;
  
    AOpaque := DrawSelected or BarItemControl.FNonRecent;
    if DrawSelected then
      FrameFlatSelRect(ADC, R)
    else
    begin
      I := R.Left + 1 + BarItemControl.Parent.IconAreaSize;

      ABrush := BarItemControl.BarManager.FlatToolbarsBrush;
      DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Top, I, R.Top + 1), ABrush, AOpaque);
      DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Bottom - 1, I, R.Bottom), ABrush, AOpaque);
      DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Top + 1, R.Left + 1, R.Bottom - 1), ABrush, AOpaque);

      ABrush := BarItemControl.Parent.BkBrush;
      DrawBackground(BarItemControl, ADC, Rect(I, R.Top, R.Right, R.Top + 1), ABrush, AOpaque);
      DrawBackground(BarItemControl, ADC, Rect(I, R.Bottom - 1, R.Right, R.Bottom), ABrush, AOpaque);
      DrawBackground(BarItemControl, ADC, Rect(R.Right - 1, R.Top + 1, R.Right, R.Bottom - 1), ABrush, AOpaque);
    end;
    InflateRect(R, -1, -1);

    if DrawSelected then
      ABrush := BarItemControl.Parent.ToolbarSelBrush
    else
      ABrush := BarItemControl.BarManager.FlatToolbarsBrush;
    R.Left := AIconRect.Right + 2;
    DrawBackground(BarItemControl, ADC, Rect(AIconRect.Right, AIconRect.Top, R.Left, AIconRect.Bottom), ABrush, AOpaque);
    if AIconRect.Top > R.Top then
      DrawBackground(BarItemControl, ADC, Rect(AIconRect.Left, R.Top, R.Left, AIconRect.Top), ABrush, AOpaque);
    if AIconRect.Bottom < R.Bottom then
      DrawBackground(BarItemControl, ADC, Rect(AIconRect.Left, AIconRect.Bottom, R.Left, R.Bottom), ABrush, AOpaque);

    if DrawSelected then
      ABrush := BarItemControl.Parent.ToolbarSelBrush
    else
      ABrush := BarItemControl.BkBrush;
    DrawBackground(BarItemControl, ADC, R, ABrush, AOpaque);
  end;
end;

class procedure TdxBarFlatPainter.DrawLowered(DC: HDC; var R: TRect);
begin
  FrameRect(DC, R, GetSysColorBrush(COLOR_BTNSHADOW));
  InflateRect(R, -1, -1); // LoweredBorderSize(ABarItemControl) = 1
end;

procedure TdxBarFlatPainter.DrawStaticBorder(const ADrawParams: TdxBarStaticLikeControlDrawParams; var ARect: TRect);
var
  AContentRect: TRect;
begin
  with ADrawParams do
  begin
    AContentRect := cxRectContent(ARect, BorderOffsets);
    Canvas.SaveClipRegion;
    Canvas.ExcludeClipRect(AContentRect);
    FillRect(Canvas.Handle, ARect, StaticBorderBrush(BarItemControl, BorderStyle));
    Canvas.RestoreClipRegion;
    ARect := AContentRect;
  end;
end;

class procedure TdxBarFlatPainter.FrameAndFillRect(ABarItemControl: TdxBarItemControl;
  DC: HDC; var R: TRect; Enabled, Selected, Pressed: Boolean);
var
  Brush: HBRUSH;
begin
  Brush := ABarItemControl.Parent.BkBrush;
  if Selected then
  begin
    FrameFlatSelRect(DC, R);
    if Pressed then
      Brush := ABarItemControl.Parent.ToolbarDownedSelBrush
    else
      Brush := ABarItemControl.Parent.ToolbarSelBrush;
  end
  else
    FrameRect(DC, R, ABarItemControl.Parent.BkBrush);
  InflateRect(R, -1, -1);
  FillRect(DC, R, Brush);
end;

class function TdxBarFlatPainter.GlyphBkgndBrush(ABarItemControl: TdxBarItemControl;
  APaintType: TdxBarPaintType; AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown,
  AForceUseBkBrush, AGrayScale: Boolean): HBRUSH;
begin
  if ADroppedDown then
    if ADowned then
      Result := ABarItemControl.Parent.ToolbarDownedSelBrush
    else
      Result := ABarItemControl.Parent.BarControlOwnerBrush
  else
    if ASelected then
      if ADowned or ADrawDowned then
        Result := ABarItemControl.Parent.ToolbarDownedSelBrush
      else
        Result := ABarItemControl.Parent.ToolbarSelBrush
    else
      if ADowned then
        Result := ABarItemControl.Parent.ToolbarDownedBrush
      else
        if (APaintType = ptMenu) and not AForceUseBkBrush then
          Result := GetToolbarBrush(ABarItemControl)
        else
          Result := ABarItemControl.BkBrush;
end;

class function TdxBarFlatPainter.IsFlatGlyphImage: Boolean;
begin
  Result := True;
end;

class function TdxBarFlatPainter.IsFlatItemText: Boolean;
begin
  Result := True;
end;

class function TdxBarFlatPainter.IsGlyphImageBackgroundOpaque(ABarItemControl: TdxBarItemControl;
  ADown, ADrawDowned, ASelected, AGlyphEmpty: Boolean): Boolean;
begin
  Result := inherited IsGlyphImageBackgroundOpaque(ABarItemControl, ADown, ADrawDowned, ASelected, AGlyphEmpty);
  if not AGlyphEmpty then
    Result := Result or ADown or ADrawDowned or ASelected;
end;

class function TdxBarFlatPainter.IsGlyphImageHasShadow: Boolean;
begin
  Result := True;
end;

class function TdxBarFlatPainter.LoweredBorderSize(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := 1;
end;

class function TdxBarFlatPainter.StaticBorderBrush(ABarItemControl: TdxBarItemControl;
  ABorderStyle: TdxBarStaticBorderStyle): HBRUSH;
begin
  Result := GetSysColorBrush(COLOR_BTNSHADOW);
end;

class function TdxBarFlatPainter.TextAreaOffset(ABarItemControl: TdxBarItemControl): Integer;
begin
  // WARNING!!! sync with Indent
  if ABarItemControl.Parent.Kind = bkSubMenu then
    Result := 1 + ABarItemControl.Parent.TextSize + 2
  else
    Result := 0;
end;

function TdxBarFlatPainter.BeforeFingersSize: Integer;
begin
  Result := 1;
end;

function TdxBarFlatPainter.FingersSize(ABarControl: TdxBarControl): Integer;
begin
  Result := BeforeFingersSize + GripperSize(ABarControl) + 2;
end;

class function TdxBarFlatPainter.RealButtonArrowWidth(ABarManager: TdxBarManager): Integer;
begin
  Result := inherited RealButtonArrowWidth(ABarManager);
  Dec(Result);
end;

class function TdxBarFlatPainter.RealLargeButtonArrowWidth(ABarManager: TdxBarManager): Integer;
begin
  Result := inherited RealLargeButtonArrowWidth(ABarManager) - 1;
end;

class function TdxBarFlatPainter.SubMenuBeginGroupIndent: Integer;
begin
  Result := 8;
end;

class function TdxBarFlatPainter.BarChildrenHaveShadows(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := True;
end;

class procedure TdxBarFlatPainter.BarDrawBarControlOwner(ACustomBarControl: TCustomdxBarControl;
  DC: HDC; R: TRect; ABarControl: TCustomdxBarControl);
begin
  BarDrawBarControlOwnerBorder(ACustomBarControl, DC, R, nil, ABarControl);
  InflateRect(R, -1, -1);
  FillRect(DC, R, ACustomBarControl.BarControlOwnerBrush);
end;

class procedure TdxBarFlatPainter.BarDrawBarControlOwnerBorder(ACustomBarControl: TCustomdxBarControl;
  DC: HDC; R: TRect; ABarItemControl: TdxBarItemControl; ABarControl: TCustomdxBarControl);
var
  AClipRgn: HRGN;
  AClipRgnExists: Boolean;

  procedure DrawBarControlOwnerLink;
  var
    ALinkR, ATempRect, CR, WR: TRect;
    AOrigin: TPoint;
    AHandle: HWND;
  begin
    AClipRgn := 0;
    if not ABarControl.HandleAllocated then Exit;
    ALinkR := ABarControl.OwnerLinkBounds[True];

    if ABarControl.OwnerControl = nil then // !!!
    begin
      GetDCOrgEx(DC, AOrigin);
      OffsetRect(ALinkR, -AOrigin.X, -AOrigin.Y);
    end
    else
    begin
      AHandle := ABarControl.OwnerControl.Handle;
      GetClientRect(AHandle, CR);
      MapWindowRect(AHandle, 0, CR);
      if IntersectRect(ATempRect, CR, ALinkR) then // client area
        OffsetRect(ALinkR, -CR.Left, -CR.Top)
      else
      begin
        WR := cxGetWindowRect(AHandle);               // NC
        OffsetRect(ALinkR, -WR.Left, -WR.Top);
      end;
    end;
    BarDrawBarControlOwnerLink(ACustomBarControl, DC, R, ALinkR, ABarItemControl);
    AClipRgn := CreateRectRgn(0, 0, 0, 0);
    AClipRgnExists := GetClipRgn(DC, AClipRgn) = 1;
    with ALinkR do
      ExcludeClipRect(DC, Left, Top, Right, Bottom);
  end;

begin
  DrawBarControlOwnerLink;
  BarDrawBarControlOwnerFrame(ACustomBarControl, DC, R);
  if AClipRgn <> 0 then
  begin
    if AClipRgnExists then
      SelectClipRgn(DC, AClipRgn)
    else
      SelectClipRgn(DC, 0);
    DeleteObject(AClipRgn);
  end;
end;

class procedure TdxBarFlatPainter.BarDrawBarControlOwnerFrame(ACustomBarControl: TCustomdxBarControl;
  DC: HDC; R: TRect);
begin
  FrameRect(DC, R, ACustomBarControl.BarManager.FlatToolbarsBorderBrush);
end;

class procedure TdxBarFlatPainter.BarDrawBarControlOwnerLink(ACustomBarControl: TCustomdxBarControl;
  DC: HDC; R, ALinkR: TRect; ABarItemControl: TdxBarItemControl);
begin
  FillRect(DC, ALinkR, ACustomBarControl.BarControlOwnerBrush);
end;

class function TdxBarFlatPainter.BarToolbarBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := ABarControl.BarManager.FlatToolbarsBrush;
end;

class function TdxBarFlatPainter.BarToolbarBrushEx(ABarControl: TdxBarControl): HBRUSH;
begin
  if not (ABarControl.IsMainMenu or ABarControl.Bar.IsStatusBar) then
    Result := inherited BarToolbarBrushEx(ABarControl)
  else
    Result := GetSysColorBrush(COLOR_BTNFACE);
end;

class function TdxBarFlatPainter.BarToolbarDownedBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := ABarControl.BarManager.FlatToolbarsDownedBrush;
end;

class function TdxBarFlatPainter.BarToolbarDownedSelBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := ABarControl.BarManager.FlatToolbarsDownedSelBrush;
end;

class function TdxBarFlatPainter.BarToolbarSelBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := ABarControl.BarManager.FlatToolbarsSelBrush;
end;

function TdxBarFlatPainter.BarBeginGroupSideSize: Integer;
begin
  Result := (BarBeginGroupSize - 1{|}) div 2;
end;

function TdxBarFlatPainter.BarBeginGroupSize: Integer;
begin
  Result := 2 + 1{|} + 2;
end;

procedure TdxBarFlatPainter.BarDrawBeginGroup(ABarControl: TCustomdxBarControl;
  DC: HDC; ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean);
begin
  with ABeginGroupRect do
    if AHorz then
    begin
      ABarControl.FillBackground(DC,
        Rect(Left, Top, Right, Top + BarBeginGroupSideSize),
        AToolbarBrush, clNone, True);
      ABarControl.FillBackground(DC,
        Rect(Left, Bottom - BarBeginGroupSideSize, Right, Bottom),
        AToolbarBrush, clNone, True);
      InflateRect(ABeginGroupRect, 0, -BarBeginGroupSideSize);
      FillRect(DC, Rect(Left, Top, Right, Top + 1), COLOR_BTNSHADOW + 1);
    end
    else
    begin
      ABarControl.FillBackground(DC,
        Rect(Left, Top, Left + BarBeginGroupSideSize, Bottom),
        AToolbarBrush, clNone, True);
      ABarControl.FillBackground(DC,
        Rect(Right - BarBeginGroupSideSize, Top, Right, Bottom),
        AToolbarBrush, clNone, True);
      InflateRect(ABeginGroupRect, -BarBeginGroupSideSize, 0);
      FillRect(DC, Rect(Left, Top, Left + 1, Bottom), COLOR_BTNSHADOW + 1);
    end;
end;

procedure TdxBarFlatPainter.BarDrawCloseButton(ABarControl: TdxBarControl;
  DC: HDC; R: TRect);

  procedure DrawCross(var R: TRect);
//  const
//    CrossColors: array[Boolean] of Integer = (COLOR_CAPTIONTEXT, COLOR_BTNTEXT);
  var
    APen: HPEN;
  begin
    InflateRect(R, -3, -4);
    with R do
    begin
      if Odd(Right - Left) then Dec(Right);
      Bottom := Top + (Right - Left - 1);
    end;
    with R do
    begin
//      APen := SelectObject(DC, CreatePen(PS_SOLID, 1,
//        GetSysColor(CrossColors[ABarControl.CloseButtonState = msSelected])));
      APen := SelectObject(DC, CreatePen(PS_SOLID, 1,
        BarMarkArrowColor(ABarControl, ABarControl.CloseButtonState)));

      MoveToEx(DC, Left, Top, nil);
      LineTo(DC, Right - 1, Bottom);
      MoveToEx(DC, Left + 1, Top, nil);
      LineTo(DC, Right, Bottom);

      MoveToEx(DC, Left, Bottom - 1, nil);
      LineTo(DC, Right - 1, Top - 1);
      MoveToEx(DC, Left + 1, Bottom - 1, nil);
      LineTo(DC, Right, Top - 1);

      DeleteObject(SelectObject(DC, APen));
    end;
  end;

begin
  BarDrawCaptionElement(ABarControl, DC, R, ABarControl.CloseButtonState);
  DrawCross(R);
end;

procedure TdxBarFlatPainter.BarDrawDockedBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AToolbarBrush: HBRUSH);

  procedure DrawFinger;
  var
    I: Integer;
    Brush: HBRUSH;
  begin
    with R do
    begin
      if ABarControl.Horizontal then
        for I := Top to Bottom - 1 do
        begin
          if Odd(I - Top) then
            Brush := AToolbarBrush
          else
            Brush := COLOR_BTNSHADOW + 1;
          FillRect(DC, Rect(Left, I, Right, I + 1), Brush);
        end
      else
        for I := Left to Right - 1 do
        begin
          if Odd(I - Left) then
            Brush := AToolbarBrush
          else
            Brush := COLOR_BTNSHADOW + 1;
          FillRect(DC, Rect(I, Top, I + 1, Bottom), Brush);
        end;
    end;
  end;

begin
  with R do
  begin
    FrameRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));
    InflateRect(R, -1, -1);
    FillRect(DC, Rect(Left, Top, Left + 1, Top + 1), COLOR_BTNFACE + 1);
    FillRect(DC, Rect(Right - 1, Top, Right, Top + 1), COLOR_BTNFACE + 1);
    FillRect(DC, Rect(Left, Bottom - 1, Left + 1, Bottom), COLOR_BTNFACE + 1);
    FillRect(DC, Rect(Right - 1, Bottom - 1, Right, Bottom), COLOR_BTNFACE + 1);
    InflateRect(R, -1, -1);
    if ABarControl.CanMoving then
    begin
      if ABarControl.Horizontal then
      begin
        Inc(Left, BeforeFingersSize);
        Right := Left + GripperSize(ABarControl);
        InflateRect(R, 0, -3);
      end
      else
      begin
        Inc(Top, BeforeFingersSize);
        Bottom := Top + GripperSize(ABarControl);
        InflateRect(R, -3, 0);
      end;
      DrawFinger;
    end;
  end;
end;

procedure TdxBarFlatPainter.BarDrawFloatingBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R, CR: TRect; AToolbarBrush: HBRUSH);
var
  I: Integer;
begin
  FrameRect(DC, R, ABarControl.BarManager.FlatToolbarsBorderBrush);
  InflateRect(R, -1, -1);
  FrameRect(DC, R, GetSysColorBrush(COLOR_BTNHIGHLIGHT));
  for I := R.Left + 1 to CR.Left - 1 do
  begin
    InflateRect(R, -1, -1);
    FrameRect(DC, R, AToolbarBrush);
  end;
end;

procedure TdxBarFlatPainter.BarDrawMark(ABarControl: TdxBarControl;
  DC: HDC; MarkR: TRect);

  procedure DrawBackground;
  var
    R: TRect;
  begin
    if ABarControl.HasCloseButton then
    begin
      R := MarkR;
      with R do
      begin
        Left := Right;
        Right := Left + FloatToolbarMarkIndent;
      end;
      FillRectByColor(DC, R, ABarControl.CaptionBkColor);
    end;
    if ABarControl.MarkDrawState = msPressed then
      BarDrawBarControlOwner(ABarControl, DC, MarkR, ABarControl.FQuickPopup)
    else
      BarDrawCaptionElement(ABarControl, DC, MarkR, ABarControl.MarkDrawState);
  end;

begin
  DrawBackground;
  inherited BarDrawMark(ABarControl, DC, MarkR);
end;

procedure TdxBarFlatPainter.BarDrawMDIButton(ABarControl: TdxBarControl;
  AButton: TdxBarMDIButton; AState: Integer; DC: HDC; R: TRect);
const
  Enables: array[Boolean] of Integer = (DFCS_INACTIVE, 0);
var
  ABitmap: TBitmap;
  ABrush: HBRUSH;
begin
  ABitmap := TBitmap.Create;
  try
    InflateRect(R, -1, -1);
    ABitmap.Width := R.Right - R.Left;
    ABitmap.Height := R.Bottom - R.Top;
    DrawFrameControl(ABitmap.Canvas.Handle,
      Rect(-1, -1, ABitmap.Width + 1, ABitmap.Height + 1),
      DFC_CAPTION, MDIButtonStyles[AButton] or DFCS_FLAT or
      Enables[AState <> DXBAR_DISABLED]);

    if AState in [DXBAR_ACTIVE, DXBAR_HOT, DXBAR_PRESSED] then
    begin
      case AState of
        DXBAR_ACTIVE:
          ABrush := ABarControl.ToolbarDownedBrush;
        DXBAR_HOT:
          ABrush := ABarControl.ToolbarSelBrush;
      else{DXBAR_PRESSED}
        ABrush := ABarControl.ToolbarDownedSelBrush;
      end;

      FillRect(DC, R, ABrush);
      FrameFlatSelRect(DC, cxRectInflate(R, 1, 1));
    end
    else
      ABarControl.FillBackground(DC, cxRectInflate(R, 1, 1), ABarControl.BkBrush, clNone, True);

    TransparentDraw(DC, R, ABitmap);
  finally
    ABitmap.Free;
  end;
end;

class function TdxBarFlatPainter.BarToolbarBrushEx2(ABarControl: TdxBarControl): HBRUSH;
begin
  Result := GetSysColorBrush(COLOR_WINDOW);
end;

class procedure TdxBarFlatPainter.DrawQuickCustItemFrame(ABarItemControl: TdxBarItemControl;
  DC: HDC; var R, ARect: TRect; Selected: Boolean);
begin
  inherited;
  if not Selected then
    DrawBackgroundFrameRect(ABarItemControl, DC, R, BarToolbarBrush(ABarItemControl.Parent), False);

  InflateRect(R, -1, -1);
end;

class procedure TdxBarFlatPainter.DrawQuickCustItemFrameSelected(ABarItemControl: TdxBarItemControl;
  DC: HDC; WholeR, R: TRect; Selected: Boolean);
begin
  if Selected then
  begin
    FrameFlatSelRect(DC, WholeR);
    with R do
    begin
      Left := Right;
      Right := Left + 2; // paint over!
    end;
    FillRect(DC, R, ABarItemControl.Parent.ToolbarSelBrush);
  end;
end;

class function TdxBarFlatPainter.IsQuickControlPopupOnRight: Boolean;
begin
  Result := True;
end;

function TdxBarFlatPainter.ButtonControlArrowBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH;
begin
  with ADrawParams do
    if DrawSelected then
      if DroppedDown or IsHighContrastWhite then
        Result := BarItemControl.Parent.ToolbarDownedSelBrush
      else
        Result := BarItemControl.Parent.ToolbarSelBrush
    else
      Result := inherited ButtonControlArrowBrush(ADrawParams);
end;

class procedure TdxBarFlatPainter.CorrectButtonControlDefaultHeight(var DefaultHeight: Integer);
begin
  Inc(DefaultHeight, 2);
end;

class procedure TdxBarFlatPainter.CorrectButtonControlDefaultWidth(var DefaultWidth: Integer);
begin
  Inc(DefaultWidth, 2 + 1 + 6);
end;

procedure TdxBarFlatPainter.DrawButtonControlArrowBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams;
  var R1: TRect; ABrush: HBRUSH);
begin
  inherited;
  with ADrawParams do
    if (PaintType = ptMenu) or not DroppedDown then
      DrawFrameRect(BarItemControl, Canvas.Handle, R1, ABrush, PaintType, DrawSelected, Downed);
end;

function TdxBarFlatPainter.ComboControlArrowColor(ADrawParams: TdxBarItemControlDrawParams): TColor;
begin
  Result := inherited ComboControlArrowColor(ADrawParams);
  with ADrawParams do
    if DrawSelected then
    begin
      if DroppedDown or IsHighContrastWhite then
        Result := clHighlightText;
    end
    else
      if not Enabled then
        Result := clBtnShadow;
end;

function TdxBarFlatPainter.ComboControlButtonBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH;
begin
   Result := inherited ComboControlButtonBrush(ADrawParams);
   with ADrawParams do
      if (PaintType = ptMenu) and not DrawSelected then
        Result := BarItemControl.Parent.ToolbarBrush;
end;

class procedure TdxBarFlatPainter.ComboControlDrawSimpleButton(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect; ABrush: HBRUSH);
var
  ASpaceBrush: HBRUSH;
begin
  with ADrawParams do
  begin
    if DrawSelected then
    begin
      InflateRect(ARect, 1, 1);
      FrameFlatSelRect(Canvas.Handle, ARect);
    end
    else
    begin
      if Enabled then
        ASpaceBrush := BarEditControl.EditBkBrush
      else
        ASpaceBrush := BarEditControl.Parent.BkBrush;
      FrameRect(Canvas.Handle, ARect, ASpaceBrush);
      FillRect(Canvas.Handle, Rect(ARect.Left - 1, ARect.Top, ARect.Left, ARect.Bottom), ASpaceBrush);
    end;
    InflateRect(ARect, -1, -1);
    FillRect(Canvas.Handle, ARect, ABrush);
  end;
end;

class function TdxBarFlatPainter.SubMenuControlArrowsOffset: Integer;
begin
  Result := 1;
end;

function TdxBarFlatPainter.SubMenuControlBeginGroupRect(
  ABarSubMenuControl: TdxBarSubMenuControl; AControl: TdxBarItemControl;
  const AItemRect: TRect): TRect;
begin
  Result := AItemRect;
  Result.Bottom := Result.Top;
  Dec(Result.Top, SubMenuControlBeginGroupSize);
end;

function TdxBarFlatPainter.SubMenuControlBeginGroupSize: Integer;
begin
  Result := 2 + 1 + 2;
end;

procedure TdxBarFlatPainter.SubMenuControlCalcDrawingConsts(ACanvas: TcxCanvas;
  ATextSize: Integer; out AMenuArrowWidth, AMarkSize: Integer);
var
  AArrowSize: Integer;
begin
  inherited;
  AArrowSize := SubMenuControlMarkArrowSize(AMarkSize - 2);
  if Odd(AArrowSize) then AMarkSize := (AArrowSize - 1) * 2 + 2 * 3;
end;

class function TdxBarFlatPainter.SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := ABarSubMenuControl.DetachCaptionSize + 1;
end;

class function TdxBarFlatPainter.SubMenuControlGetItemIconRect(const AItemRect: TRect; AIconAreaSize: Integer): TRect;
begin
  Result := inherited SubMenuControlGetItemIconRect(cxRectInflate(AItemRect, -1, -1), AIconAreaSize - 2)
end;

class function TdxBarFlatPainter.SubMenuControlGetItemTextRect(const ADrawParams: TdxBarButtonLikeControlDrawParams; const AItemRect: TRect): TRect;
begin
  Result := inherited SubMenuControlGetItemTextRect(ADrawParams, cxRectInflate(AItemRect, 0, -1, -1, -1));
end;

class function TdxBarFlatPainter.SubMenuControlGetItemTextIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer;
begin
  Result := inherited SubMenuControlGetItemTextIndent(ADrawParams) + 6;
end;

procedure TdxBarFlatPainter.SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect);

  procedure DrawFlatBorder;
  begin
    FrameRect(DC, R, ABarSubMenuControl.BarManager.FlatToolbarsBorderBrush);
    BarDrawOwnerLink(ABarSubMenuControl, DC);
  end;

begin
  with R do
  begin
    DrawFlatBorder;
    if ABarSubMenuControl.Detachable then
    begin
      InflateRect(R, -1, -1);
      Bottom := Top + 1;
      FillRect(DC, R, COLOR_WINDOW + 1);
      Top := Bottom;
      Bottom := Top + ABarSubMenuControl.DetachCaptionSize;
      FillRect(DC, Rect(Left, Top, Left + 1, Bottom), COLOR_WINDOW + 1);
      FillRect(DC, Rect(Right - 1, Top, Right, Bottom), COLOR_WINDOW + 1);
      SubMenuControlDrawDetachCaption(ABarSubMenuControl, DC, ABarSubMenuControl.DetachCaptionRect);
    end;
  end
end;

procedure TdxBarFlatPainter.SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; const R: TRect; ABrush: HBRUSH);
begin
  FrameRect(DC, R, ABarSubMenuControl.ToolbarItemsBrush);
  with R do
    FillRect(DC, Rect(Left, Top + 1, Left + 1, Bottom - 1), ABrush);
end;

procedure TdxBarFlatPainter.SubMenuControlDrawDetachCaption(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect);
const
  MarkSize = 33;
  Colors: array[Boolean] of COLORREF = (COLOR_BTNSHADOW, COLOR_BTNTEXT);
var
  Brush: HBRUSH;
  I: Integer;
begin
  if ABarSubMenuControl.DetachCaptionSelected then
  begin
    FrameFlatSelRect(DC, R);
    InflateRect(R, -1, -1);
    Brush := ABarSubMenuControl.ToolbarSelBrush;
  end
  else
    Brush := ABarSubMenuControl.BarManager.FlatToolbarsBrush;
  FillRect(DC, R, Brush);
  Brush := Colors[ABarSubMenuControl.DetachCaptionSelected] + 1;
  with R do
  begin
    InflateRect(R, -(Right - Left - MarkSize) div 2, -1);
    Right := Left + MarkSize;
    for I := Top to Bottom - 1 do
      if not Odd(I - Top) then
        FillRect(DC, Rect(Left, I, Right, I + 1), Brush);
  end;
end;

procedure TdxBarFlatPainter.SubMenuControlDrawBeginGroup(ABarSubMenuControl: TdxBarSubMenuControl;
  AControl: TdxBarItemControl; ACanvas: TcxCanvas; const ABeginGroupRect: TRect);
var
  R: TRect;
  ABrush: HBRUSH;
  LD, RD: Integer;
  AOpaque: Boolean;
  ADC: HDC;
begin
  ADC := ACanvas.Handle;
  R := ABeginGroupRect;
  if not IgnoreNonRecentColor and AControl.FChangeRecentGroup and AControl.FNonRecent then
    ABrush := SubMenuControlToolbarItemsBrush(ABarSubMenuControl)
  else
    ABrush := ABarSubMenuControl.BkBrush;
  AOpaque := not IgnoreNonRecentColor and AControl.FNonRecent and not AControl.FChangeRecentGroup;
  with R do
  begin
    LD := Left + AControl.TextAreaOffset;
    DrawBackground(AControl, ADC, Rect(Left, Top, LD, Bottom), ABarSubMenuControl.BarManager.FlatToolbarsBrush, AOpaque);
    DrawBackground(AControl, ADC, Rect(LD, Top, Right, Bottom), ABrush, AOpaque);
    RD := (Top + Bottom) div 2;
    SubMenuControlDrawSeparator(ACanvas, Rect(LD + SubMenuBeginGroupIndent, RD, Right + 1, RD + 1));
  end;
end;

procedure TdxBarFlatPainter.SubMenuControlDrawSeparator(ACanvas: TcxCanvas; const ARect: TRect);
begin
  ACanvas.FrameRect(ARect, SubMenuControlGetSeparatorColor, 1, [bTop]);
end;

class function TdxBarFlatPainter.SubMenuControlGetSeparatorColor: TColor;
begin
  Result := GetSysColor(COLOR_BTNSHADOW);
end;

class function TdxBarFlatPainter.SubMenuControlMarkArrowSize(AMarkSize: Integer): Integer;
begin
  Result := (AMarkSize - 2 * 2) div 2;
  if (Result > 4) and Odd(Result) then
    Dec(Result);
end;

class function TdxBarFlatPainter.SubMenuControlNormalItemHeight: Integer;
begin
  Result := 19 + 1;
end;

class procedure TdxBarFlatPainter.SubMenuControlOffsetDetachCaptionRect(ABarSubMenuControl: TdxBarSubMenuControl;
  var R: TRect);
begin
  InflateRect(R, -2, -2);
end;

class function TdxBarFlatPainter.SubMenuControlTextSize(ACanvas: TcxCanvas): Integer;
begin
  Result := inherited SubMenuControlTextSize(ACanvas) + 1;
end;

class function TdxBarFlatPainter.SubMenuControlToolbarItemsBrush(ABarSubMenuControl: TdxBarSubMenuControl): HBRUSH;
begin
  Result := GetSysColorBrush(COLOR_WINDOW);
end;

class procedure TdxBarFlatPainter.CustomComboDrawItem(ABarCustomCombo: TdxBarCustomCombo;
  ACanvas: TCanvas; AIndex: Integer; ARect: TRect; AState: TOwnerDrawState;
  AInteriorIsDrawing: Boolean);
var
  S: string;
begin
  with ACanvas, ARect do
  begin
    if AIndex = -1 then
      S := ABarCustomCombo.Text
    else
      S := ABarCustomCombo.Items[AIndex];
    FillRect(ARect);
    TextOut(Left + 2, Top + Byte(AInteriorIsDrawing) * 2, S);
  end;
end;

class function TdxBarFlatPainter.EditControlBorderOffsets(APaintType: TdxBarPaintType): TRect;
begin
  Result := Rect(1, 1, 1, 1);
end;

procedure TdxBarFlatPainter.EditControlDrawBorder(
  const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect);
begin
  with ADrawParams do
  begin
    if DrawSelected then
      FrameFlatSelRect(Canvas.Handle, ARect)
    else
      if (PaintType = ptMenu) and not IsTransparent then
        FrameRect(Canvas.Handle, ARect, BarEditControl.Parent.ToolbarBrush)
      else
        if not Enabled and not IsTransparent then
          FrameRect(Canvas.Handle, ARect, GetSysColorBrush(COLOR_BTNSHADOW))
        else
          DrawBackgroundFrameRect(BarEditControl, Canvas.Handle, ARect, BarEditControl.Parent.BkBrush,
            IsTransparent and BarEditControl.FNonRecent);
    InflateRect(ARect, -1, -1);
  end;
end;

procedure TdxBarFlatPainter.EditControlDrawSelectionFrame(const ADrawParams: TdxBarEditLikeControlDrawParams; const ARect: TRect);
begin
  inherited;
  ExcludeFrameRegion(ADrawParams.Canvas, ARect, cxRectInflate(ARect, -1, -1));
end;

class function TdxBarFlatPainter.EditControlCaptionRightIndentIsOpaque(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  with ADrawParams do
    Result := (PaintType = ptMenu) and (DrawSelected or BarItemControl.FNonRecent);
end;

class function TdxBarFlatPainter.EditControlCaptionRelativeLeftIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  Result := SubMenuControlGetItemTextIndent(ADrawParams) - ADrawParams.BarItemControl.Parent.GetIconAreaSize;
end;

class function TdxBarFlatPainter.EditControlCaptionAbsoluteLeftIndent(const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  Result := 6;
end;

class function TdxBarFlatPainter.EditControlCaptionRightIndent: Integer;
begin
  Result := 5;
end;

class function TdxBarFlatPainter.EditControlSubMenuGlyphIndents(const ADrawParams: TdxBarEditLikeControlDrawParams): TRect;
begin
  Result := Rect(7, 0, 0, 0);
end;

class function TdxBarFlatPainter.EditControlGetRightCaptionIndentBrush(ABarEditControl: TdxBarCustomEditControl): HBRUSH;
begin
  Result := ABarEditControl.CaptionBkBrush;
end;

class function TdxBarFlatPainter.EditControlGlyphIsDrawSelected(ABarEditControl: TdxBarCustomEditControl): Boolean;
begin
  Result := ABarEditControl.DrawSelected and (ABarEditControl.GetPaintType = ptMenu)
end;

class function TdxBarFlatPainter.HasEditControlExternalFrame(
  APaintType: TdxBarPaintType; ASelected: Boolean): Boolean;
begin
  Result := ASelected and (APaintType = ptMenu);
end;

function TdxBarFlatPainter.CanUpdateBarPartly: Boolean;
begin
  Result := True;
end;

class procedure TdxBarFlatPainter.SysPanelDraw(AHandle: HWND; AllowResizing,
  MouseAboveCloseButton, CloseButtonIsTracking: Boolean; var CloseButtonRect,
  GripRect: TRect; Corner: TdxCorner);
begin
  dxBarPopupNCPaint(AHandle, AllowResizing, True, MouseAboveCloseButton,
    CloseButtonIsTracking, CloseButtonRect, GripRect, Corner);
end;

class function TdxBarFlatPainter.IsDateNavigatorFlat: Boolean;
begin
  Result := True;
end;

procedure TdxBarFlatPainter.DateNavigatorDrawButton(ABarItem: TdxBarItem;
  DC: HDC; R: TRect; const ACaption: string; APressed: Boolean);
begin
  with R do
  begin
    FrameRect(DC, R, GetSysColorBrush(COLOR_BTNSHADOW));
    InflateRect(R, -1, -1);
    FrameRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));
    InflateRect(R, -1, -1);
  end;
  DateNavigatorDrawButtonCaption(DC, R, 0, ACaption, True);
end;

procedure TdxBarFlatPainter.SpinEditControlDrawButton(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer);
var
  AArrowPos: TPoint;
begin
  with ADrawParams do
  begin
    FrameAndFillRect(BarEditControl, Canvas.Handle, ARect, Enabled, DrawSelected,
      ActiveButtonIndex = AButtonIndex);
    AArrowPos := GetSpinEditArrowPos(ADrawParams, ARect, AButtonIndex);
    DrawSpinEditArrow(ADrawParams, AArrowPos, AButtonIndex);
  end;
end;

class function TdxBarFlatPainter.ContainerControlSubMenuOffset: Integer;
begin
  Result := 2 + 1 + 6;
end;

function TdxBarFlatPainter.InPlaceSubItemControlIsFlatItemText(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Boolean;
begin
  Result := inherited InPlaceSubItemControlIsFlatItemText(ADrawParams) and IsFlatItemTextForMenu;
end;

function TdxBarFlatPainter.InPlaceSubItemControlIsArrowSelected(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Boolean;
begin
  Result := not ADrawParams.DrawSelected or IsHighContrastWhite;
end;

function TdxBarFlatPainter.GetBorderSize: Integer;
begin
  Result := 1;
end;

procedure TdxBarFlatPainter.DrawGlyphBorder(ABarItemControl: TdxBarItemControl;
  ADC: HDC; ABrush: HBRUSH; ANeedBorder: Boolean; R: TRect; APaintType: TdxBarPaintType;
  AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown, AIsSplit: Boolean);
begin
  if ADroppedDown then
    BarDrawBarControlOwnerBorder(ABarItemControl.Parent, ADC, R, ABarItemControl, ABarItemControl.OwnedBarControl)
  else
    if ADowned or (ASelected and (APaintType <> ptMenu)) then
      FrameFlatSelRect(ADC, R)
    else
      if ANeedBorder then
        DrawBackgroundFrameRect(ABarItemControl, ADC, R, ABrush, ASelected or ADowned or
          ADrawDowned or ABarItemControl.FNonRecent or ABarItemControl.IsBkColorAssigned);
end;

procedure TdxBarFlatPainter.DrawGlyphCheckMark(ABarItemControl: TdxBarItemControl;
  DC: HDC; X, Y, DoubleSize: Integer);
//const
//  Colors: array[Boolean] of TColor = (clBlack, clWhite);
var
  OffsetY, I: Integer;

  procedure DrawOneMark;
  begin
    with ABarItemControl.Canvas do
    begin
      MoveTo(X + DoubleSize * 1, Y + OffsetY + DoubleSize * 2);
      LineTo(X + DoubleSize * 3, Y + OffsetY + DoubleSize * 4);
      LineTo(X + DoubleSize * 8, Y + OffsetY - DoubleSize * 1);
    end;
    Inc(OffsetY);
  end;

begin
  with ABarItemControl.Canvas do
    if ABarItemControl.Enabled then
    begin
      OffsetY := 0;
      if IsHighContrastWhite or IsHighContrast2 then
        Pen.Color := clWhite
      else{
        if IsHighContrast2 then
          Pen.Color := clBlack
        else}
          Pen.Color := clBlack;
//      Pen.Color := Colors[GetSysColor(COLOR_BTNFACE) = 0];
      for I := 1 to 2 * DoubleSize do DrawOneMark;
    end
    else
    begin
      OffsetY := 1;
      Pen.Color := GetSysColor(COLOR_BTNSHADOW);
      for I := 1 to 2 * DoubleSize do DrawOneMark;
    end;
end;

class procedure TdxBarFlatPainter.DrawFrameRect(ABarItemControl: TdxBarItemControl;
  ADC: HDC; const ARect: TRect; ABrush: HBRUSH; APaintType: TdxBarPaintType; ASelected, ADowned: Boolean);
begin
  if (APaintType = ptMenu) or ASelected or ADowned then
    if (APaintType = ptMenu) and not ASelected then
      FrameRect(ADC, ARect, GetSysColorBrush(COLOR_BTNSHADOW))
    else
      FrameFlatSelRect(ADC, ARect)
  else
    FrameRect(ADC, ARect, ABarItemControl.Parent.BkBrush);
end;

class procedure TdxBarFlatPainter.FrameFlatSelRect(DC: HDC; const R: TRect);
begin
  if IsHighContrastBlack or IsHighContrast2 then
    FrameRectByColor(DC, R, clHighlightText)
  else
    dxBar.FrameFlatSelRect(DC, R);
end;

class function TdxBarFlatPainter.GetToolbarBrush(ABarItemControl: TdxBarItemControl): HBRUSH;
begin
  Result := ABarItemControl.BarManager.FlatToolbarsBrush;
end;

class function TdxBarFlatPainter.BarCaptionBkColor(ABarControl: TdxBarControl;
  AMainFormActive: Boolean): COLORREF;
begin
  Result := inherited BarCaptionBkColor(ABarControl, False);
end;

class function TdxBarFlatPainter.BarMarkArrowColor(ABarControl: TdxBarControl;
  AState: TdxBarMarkState): COLORREF;
begin
  if AState <> msNone then
    Result := GetSysColor(COLOR_BTNTEXT)
  else
    Result := inherited BarMarkArrowColor(ABarControl, AState);
end;

procedure TdxBarFlatPainter.BarDrawMarkBackground(ABarControl: TdxBarControl;
  DC: HDC; ItemRect: TRect; AToolbarBrush: HBRUSH);
begin
  if ABarControl.MarkDrawState = msPressed then
    BarDrawBarControlOwner(ABarControl, DC, ItemRect, ABarControl.FQuickPopup)
  else
  begin
    if ABarControl.MarkDrawState = msNone then
      FrameRect(DC, ItemRect, AToolbarBrush)
    else
      FrameFlatSelRect(DC, ItemRect);
    InflateRect(ItemRect, -1, -1);
    if ABarControl.MarkDrawState = msSelected then
    begin
      AToolbarBrush := ABarControl.ToolbarSelBrush;
      FillRect(DC, ItemRect, AToolbarBrush);
    end
    else
      ABarControl.FillBackground(DC, ItemRect, AToolbarBrush, clNone, True);
    InflateRect(ItemRect, 1, 1);
  end;
end;

class procedure TdxBarFlatPainter.BarOffsetFloatingBarCaption(ABarControl: TdxBarControl;
  var X: Integer; var R: TRect);
begin
  Inc(X, 2);
  R.Right := ABarControl.MarkNCRect.Left;
end;

class function TdxBarFlatPainter.GetDrawMarkElementColor(ABarControl: TdxBarControl): Integer;
begin
  if IsHighContrastWhite and (ABarControl.MarkDrawState = msSelected) then
    Result := COLOR_BTNFACE
  else
    Result := inherited GetDrawMarkElementColor(ABarControl);
end;

procedure TdxBarFlatPainter.SubMenuControlDrawNonRecentGroupSeparator(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection);
begin
// do nothing
end;

procedure TdxBarFlatPainter.SubMenuControlDrawMarkSelection(
  ABarSubMenuControl: TdxBarSubMenuControl; ADC: HDC; const AMarkRect: TRect);
begin
  FrameFlatSelRect(ADC, AMarkRect);
  DrawBackground(ABarSubMenuControl.BottomItemControl, ADC, cxRectInflate(AMarkRect, -1, -1), ABarSubMenuControl.ToolbarSelBrush, True);
end;

procedure TdxBarFlatPainter.DrawSpinEditArrow(const ADrawParams: TdxBarSpinEditDrawParams; AArrowPos: TPoint; AButtonIndex: Integer);
var
  AColor: Integer;
begin
  with ADrawParams do
  begin
    if Enabled then
    begin
      if IsHighContrastWhite and DrawSelected then
        AColor := COLOR_BTNFACE
      else
        AColor := COLOR_BTNTEXT;
    end
    else
      AColor := COLOR_BTNSHADOW;

    SpinEditControlDrawArrowByPoints(ADrawParams, AArrowPos, AColor, AButtonIndex);
  end;
end;

{ TdxBarOffice11Painter }

procedure TdxBarOffice11Painter.DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect);
var
  AIconRect: TRect;
  AOpaque: Boolean;
  ABrush: HBRUSH;
  ADC: HDC;
  I: Integer;
begin
  with ADrawParams do
  begin
    AIconRect := SubMenuControlGetItemIconRect(R, BarItemControl.Parent.IconAreaSize);
    ADC := Canvas.Handle;

    AOpaque := DrawSelected;
    if DrawSelected then
      FrameFlatSelRect(ADC, R)
    else
    begin
      I := R.Left + 1 + BarItemControl.Parent.IconAreaSize;

      ABrush := BarItemControl.Parent.BkBrush;
      DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Top, I, R.Top + 1), ABrush, AOpaque);
      DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Bottom - 1, I, R.Bottom), ABrush, AOpaque);
      DrawBackground(BarItemControl, ADC, Rect(R.Left, R.Top + 1, R.Left + 1, R.Bottom - 1), ABrush, AOpaque);

      ABrush := BarItemControl.Parent.BkBrush;
      DrawBackground(BarItemControl, ADC, Rect(I, R.Top, R.Right, R.Top + 1), ABrush, AOpaque);
      DrawBackground(BarItemControl, ADC, Rect(I, R.Bottom - 1, R.Right, R.Bottom), ABrush, AOpaque);
      DrawBackground(BarItemControl, ADC, Rect(R.Right - 1, R.Top + 1, R.Right, R.Bottom - 1), ABrush, AOpaque);
    end;
    InflateRect(R, -1, -1);

    if DrawSelected then
      ABrush := BarItemControl.Parent.ToolbarSelBrush
    else
      ABrush := BarItemControl.Parent.BkBrush;
    R.Left := AIconRect.Right + 2;
    DrawBackground(BarItemControl, ADC, Rect(AIconRect.Right, AIconRect.Top, R.Left, AIconRect.Bottom), ABrush, AOpaque);
    if AIconRect.Top > R.Top then
      DrawBackground(BarItemControl, ADC, Rect(AIconRect.Left, R.Top, R.Left, AIconRect.Top), ABrush, AOpaque);
    if AIconRect.Bottom < R.Bottom then
      DrawBackground(BarItemControl, ADC, Rect(AIconRect.Left, AIconRect.Bottom, R.Left, R.Bottom), ABrush, AOpaque);

    if DrawSelected then
      ABrush := BarItemControl.Parent.ToolbarSelBrush
    else
      ABrush := BarItemControl.Parent.BkBrush;
    DrawBackground(BarItemControl, ADC, R, ABrush, AOpaque);
  end;
end;

class procedure TdxBarOffice11Painter.FrameAndFillRect(ABarItemControl: TdxBarItemControl;
  DC: HDC; var R: TRect; Enabled, Selected, Pressed: Boolean);
var
  Brush: HBRUSH;
begin
  if Selected then
  begin
    FrameFlatSelRect(DC, R);
    if Pressed then
      Brush := ABarItemControl.Parent.ToolbarDownedSelBrush
    else
      Brush := ABarItemControl.Parent.ToolbarSelBrush;
  end
  else
  begin
    if Enabled then
    begin
      FrameRect(DC, R, ABarItemControl.Parent.BkBrush);
      Brush := dxOffice11OwnerControlDownedBrush;
    end  
    else
    begin
      FrameRectByColor(DC, R, dxOffice11TextDisabledColor);
      Brush := GetSysColorBrush(COLOR_BTNFACE);
    end;
  end;  
  InflateRect(R, -1, -1);
  FillRect(DC, R, Brush);
end;

class function TdxBarOffice11Painter.IsFlatGlyphImage: Boolean;
begin
  Result := False;
end;

class function TdxBarOffice11Painter.IsGlyphImageHasShadow: Boolean;
begin
  Result := False;
end;

class function TdxBarOffice11Painter.IsItemTextSelectedInverted: Boolean;
begin
  if IsXPStandardScheme then
    Result := False
  else
    Result := inherited IsItemTextSelectedInverted;
end;

class function TdxBarOffice11Painter.StaticBorderBrush(ABarItemControl: TdxBarItemControl;
  ABorderStyle: TdxBarStaticBorderStyle): HBRUSH;
begin
  Result := dxOffice11StaticBorderBrush;
end;

function TdxBarOffice11Painter.BeforeFingersSize: Integer;
begin
  Result := inherited BeforeFingersSize + BarBeforeFingersIndent;
end;

class function TdxBarOffice11Painter.BorderSizeX: Integer;
begin
  Result := 3;
end;

class function TdxBarOffice11Painter.BorderSizeY: Integer;
begin
  Result := 3;
end;

class function TdxBarOffice11Painter.EmptyFingersSize: Integer;
begin
  Result := 2;
end;

procedure TdxBarOffice11Painter.DockControlFillBackground(ADockControl: TdxDockControl;
  DC: HDC; ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor);

  procedure FillBackgroundTempBitmap(ABitmap: TBitmap);
  var
    AColor1, AColor2: TColor;
  begin
    with AWholeR do
    begin
      ABitmap.Width := Right - Left;
      ABitmap.Height := Bottom - Top;
    end;
    GetDockColors(ADockControl, AColor1, AColor2);
    FillGradientRect(ABitmap.Canvas.Handle, AWholeR, AColor1, AColor2, True);
  end;

begin
  if ADockControl.BackgroundTempBitmap.Empty then
    FillBackgroundTempBitmap(ADockControl.BackgroundTempBitmap);
  cxBitBlt(DC, ADockControl.BackgroundTempBitmap.Canvas.Handle, ADestR, ASourceR.TopLeft, SRCCOPY);
end;

class function TdxBarOffice11Painter.IsNativeBackground: Boolean;
begin
  Result := True;
end;

class function TdxBarOffice11Painter.BarControlOwnerBrush(ABarManager: TdxBarManager): HBRUSH;
begin
  Result := dxOffice11OwnerControlDownedBrush;
end;

class procedure TdxBarOffice11Painter.BarDrawBarControlOwnerFrame(ACustomBarControl: TCustomdxBarControl;
  DC: HDC; R: TRect);
begin
  FrameRect(DC, R, dxOffice11DropDownBorderBrush1);
end;

class procedure TdxBarOffice11Painter.BarDrawBarControlOwnerLink(ACustomBarControl: TCustomdxBarControl;
  DC: HDC; R, ALinkR: TRect; ABarItemControl: TdxBarItemControl);
var
  AColor: TColor;  
begin
  if (ABarItemControl = nil) or not IsMenuGradient(ABarItemControl) then
    inherited
  else
  begin
    if (ALinkR.Right - ALinkR.Left) > (ALinkR.Bottom - ALinkR.Top) then // Horz
    begin
      if ALinkR.Top > ((R.Bottom + R.Top) div 2) then // bottom
        AColor := dxOffice11MenuDownedColor2
      else
        AColor := dxOffice11MenuDownedColor1;
    end
    else
    begin
      if ALinkR.Left > ((R.Right + R.Left) div 2) then // right
        AColor := dxOffice11MenuDownedColor2
      else
        AColor := dxOffice11MenuDownedColor1;
    end;
    FillRectByColor(DC, ALinkR, AColor);
  end;
end;

procedure TdxBarOffice11Painter.BarDrawDockedBackground(ABarControl: TdxBarControl;
  DC: HDC; ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor);
var
  AWholeR: TRect;
  AClipRgn: HRGN;
  AClipRgnExists: Boolean;
begin
  if (ABarControl.Bar.BorderStyle = bbsNone) or
      (ABarControl.IsMainMenu or ABarControl.IsBackgroundBitmap) then
    inherited
  else
  begin
    SaveClipRgn(DC, AClipRgn, AClipRgnExists);
    with ADestR do
      IntersectClipRect(DC, Left, Top, Right, Bottom);

    AWholeR := GetBarGradientRect(ABarControl);
    OffsetRect(AWholeR, -(ASourceR.Left - ADestR.Left), -(ASourceR.Top - ADestR.Top)); // NC offset

    FillTubeGradientRect(DC, AWholeR, dxOffice11ToolbarsColor1, dxOffice11ToolbarsColor2,
      (ABarControl is TdxBarControl) and TdxBarControl(ABarControl).Vertical);
    RestoreClipRgn(DC, AClipRgn, AClipRgnExists);
  end;
end;

procedure TdxBarOffice11Painter.BarDrawFloatingBackground(ABarControl: TCustomdxBarControl;
  DC: HDC; ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor);
var
  R: TRect;
  AClipRgn: HRGN;
  AClipRgnExists: Boolean;
begin
  if ABarControl.IsInternal or ABarControl.IsBackgroundBitmap then
    inherited
  else
  begin
    R := ABarControl.ClientRect;
    SaveClipRgn(DC, AClipRgn, AClipRgnExists);
    with ADestR do
      IntersectClipRect(DC, Left, Top, Right, Bottom);
    FillGradientRect(DC, R, dxOffice11ToolbarsColor1,
      dxOffice11ToolbarsColor2, False);
    RestoreClipRgn(DC, AClipRgn, AClipRgnExists);
  end;
end;

class procedure TdxBarOffice11Painter.BarDrawOwnerLink(ABarControl: TCustomdxBarControl;
  DC: HDC);
var
  R: TRect;
begin
  R := ABarControl.OwnerLinkBounds[False];
  if not IsRectEmpty(R) then
    FillRect(DC, R, dxOffice11DropDownBorderBrush2);
end;

function TdxBarOffice11Painter.BarHasShadow(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := ABarControl.IsPopup;
end;

class function TdxBarOffice11Painter.BarToolbarBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  // TODO: ?
  Result := dxOffice11MenuBrush;
end;

class function TdxBarOffice11Painter.BarToolbarBrushEx(ABarControl: TdxBarControl): HBRUSH;
begin
  // TODO
  if not (ABarControl.IsMainMenu or ABarControl.Bar.IsStatusBar) then
    Result := inherited BarToolbarBrushEx(ABarControl)
  else
    Result := GetSysColorBrush(COLOR_BTNFACE);
end;

class function TdxBarOffice11Painter.BarToolbarDownedBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := dxOffice11DownedBrush;
end;

class function TdxBarOffice11Painter.BarToolbarDownedSelBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := dxOffice11DownedSelectedBrush;
end;

class function TdxBarOffice11Painter.BarToolbarSelBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := dxOffice11ToolbarSelectedBrush;
end;

function TdxBarOffice11Painter.ComboBoxArrowWidth(ABarControl: TCustomdxBarControl; cX: Integer): Integer;
begin
  Result := 13;
end;

class function TdxBarOffice11Painter.BarBeforeFingersIndent: Integer;
begin
  Result := 2;
end;

procedure TdxBarOffice11Painter.BarBorderPaintSizes(ABarControl: TdxBarControl;
  var R: TRect);
begin
  BarBorderSizes(ABarControl.Bar, ABarControl.DockingStyle, R); 
end;

procedure TdxBarOffice11Painter.BarBorderSizes(ABar: TdxBar; AStyle: TdxBarDockingStyle;
  var R: TRect);
begin
  if ABar.IsMainMenu then
//    SetRectEmpty(R)
  begin
    if AStyle in [dsTop, dsBottom] then
      R := Rect(0, 2, 0, 2)
    else
      R := Rect(2, 0, 2, 0);
  end
  else
    inherited;
end;

procedure TdxBarOffice11Painter.BarDrawBeginGroup(ABarControl: TCustomdxBarControl;
  DC: HDC; ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean);
begin
  ABarControl.FillBackground(DC, ABeginGroupRect, AToolbarBrush, clNone, True);
  with ABeginGroupRect do
    if AHorz then
    begin
      InflateRect(ABeginGroupRect, 0, -BarBeginGroupSideSize);
      FillRect(DC, Rect(Left + 3, Top, Right - 4, Top + 1),
        dxOffice11BarSeparatorBrush1);
      FillRect(DC, Rect(Left + 3 + 1, Top + 1, Right - 4 + 1, Top + 2),
        dxOffice11BarSeparatorBrush2);
    end
    else
    begin
      InflateRect(ABeginGroupRect, -BarBeginGroupSideSize, 0);
      FillRect(DC, Rect(Left, Top + 3, Left + 1, Bottom - 4),
        dxOffice11BarSeparatorBrush1);
      FillRect(DC, Rect(Left + 1, Top + 3 + 1, Left + 1 + 1, Bottom - 4 + 1),
        dxOffice11BarSeparatorBrush2);
    end;
end;

class procedure TdxBarOffice11Painter.BarDrawCaptionElement(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AState: TdxBarMarkState);
var
  AColor: TColor;  
begin
  if AState <> msNone then
  begin
    Office11FrameSelectedRect(DC, R);
    InflateRect(R, -1, -1);
    if AState = msSelected then
      AColor := dxOffice11SelectedColor1
    else
      AColor := dxOffice11SelectedColor2;
    FillRectByColor(DC, R, AColor);
  end
  else
    FillRectByColor(DC, R, ABarControl.CaptionBkColor);
end;

procedure TdxBarOffice11Painter.BarDrawDockedBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AToolbarBrush: HBRUSH);
var
  B1: HBRUSH;
  AMarkColor1, AMarkColor2, AColor6, AColor9: TColor;

  procedure DrawFinger(ARect: TRect);
  begin
  // TODO: !
//  if ABarControl.Bar.NotDocking = [Low(TdxBarDockingStyle)..High(TdxBarDockingStyle)] then Exit;
    InflateRect(ARect, -2, -2);
    with ARect do
      if ABarControl.Horizontal then
      begin
        Inc(Left, BeforeFingersSize);
        Right := Left + GripperSize(ABarControl);
        InflateRect(ARect, 0, -3);
      end
      else
      begin
        Inc(Top, BeforeFingersSize);
        Bottom := Top + GripperSize(ABarControl);
        InflateRect(ARect, -3, 0);
      end;
    BarDrawFingerElements(ABarControl, DC, ARect, ABarControl.Horizontal);
  end;

  procedure FillParentBackground(DC: HDC; const R: TRect);
  begin
    BarFillParentBackground(ABarControl, DC, R, R, AToolbarBrush, clNone);
  end;

  procedure FillBackground(DC: HDC; const R: TRect);
  begin
    BarDrawDockedBackground(ABarControl, DC, R, R, AToolbarBrush, clNone);
  end;

  procedure DrawLeftBorder(var ARect: TRect);
  var
    ADockColor, AC11pxColor, AColor1, AColor2, AColor: TColor;
    R: TRect;
  begin
    GetDockColors(ABarControl.DockControl, AColor1, AColor2);
    with ARect do
    begin
      if ABarControl.Horizontal then
      begin
        FillParentBackground(DC, Rect(Left, Top, Left + BarBeforeFingersIndent, Bottom));
        Inc(ARect.Left, BarBeforeFingersIndent);
        FillParentBackground(DC, Rect(Left, Top, Right, Top + 1));
        Inc(ARect.Top);
        // only for Horizontal
        FillParentBackground(DC, Rect(Left, Bottom - 2, Left + 1, Bottom - 1));
        FillParentBackground(DC, Rect(Left + 1, Bottom - 1, Left + 2, Bottom));
        // left
        FillBackground(DC, Rect(Left, Top + 2, Left + 1, Bottom - 3));
        // edge pixels
        SetPixel(DC, Left + 1, Bottom - 3, dxOffice11BarBorderColors[2]);
        // #3 = (Dock, #2, 50%)
        ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
          ABarControl.PointBarToDock(Point(Left, Top)).X, AColor1, AColor2, True);
        AColor := GetMiddleRGB(ADockColor, dxOffice11BarBorderColors[2], 50);
        SetPixel(DC, Left, Bottom - 3, ColorToRGB(AColor));
        SetPixel(DC, Left + 1, Bottom - 2, ColorToRGB(AColor));
        // #4 = Dock, C1 + 1px
        ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
          ABarControl.PointBarToDock(Point(Left, Top)).X, AColor1, AColor2, True);
        AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
          Top + 1, dxOffice11ToolbarsColor1,
          dxOffice11ToolbarsColor2, False);
        AColor := GetMiddleRGB(ADockColor, AC11pxColor, 50);
        SetPixel(DC, Left, Top + 1, AColor);
        SetPixel(DC, Left + 1, Top, AColor);
      end
      else
      begin
        FillParentBackground(DC, Rect(Left, Top, Right, Top + BarBeforeFingersIndent));
        Inc(ARect.Top, BarBeforeFingersIndent);
        FillParentBackground(DC, Rect(Left, Top, Left + 1, Bottom));
        Inc(ARect.Left);

        R := Rect(Left, Top + 2, Left + 1, Bottom - 2);
        Dec(R.Bottom, ABarControl.GetMarkSize);
        FillBackground(DC, R);

        FillBackground(DC, Rect(Left + 2, Top, Right - 2, Top + 1));
        // edge pixels
        SetPixel(DC, Right - 2, Top + 1, dxOffice11BarBorderColors[2]);
        // #3 = (Dock, #2, 50%)
        ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
          ABarControl.PointBarToDock(Point(Left, Top)).X, AColor1, AColor2, True);
        AColor := GetMiddleRGB(ADockColor, dxOffice11BarBorderColors[2], 50);
        SetPixel(DC, Right - 2, Top, ColorToRGB(AColor));
        SetPixel(DC, Right - 1, Top + 1, ColorToRGB(AColor));
        // #4 = Dock, C1 + 1px
        ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
          ABarControl.PointBarToDock(Point(Left, Top)).X, AColor1, AColor2, True);
        AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
          Left, dxOffice11ToolbarsColor1,
          dxOffice11ToolbarsColor2, True);
        AColor := GetMiddleRGB(ADockColor, AC11pxColor, 50);
        SetPixel(DC, Left, Top + 1, AColor);
        SetPixel(DC, Left + 1, Top, AColor);
      end;
    end;
  end;

  procedure DrawTopBorder(ARect: TRect);
  var
    ADockColor, AC11pxColor, AColor1, AColor2, AColor: TColor;
    R: TRect;
  begin
    GetDockColors(ABarControl.DockControl, AColor1, AColor2);
    with ARect do
    begin
      if ABarControl.Horizontal then
      begin
        R := Rect(Left + 2, Top, Right - 2, Top + 1);
        Dec(R.Right, ABarControl.GetMarkSize);
        FillBackground(DC, R);

        ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
          ABarControl.PointBarToDock(Point(Right, Top)).X, AColor1, AColor2, True);

        if ABarControl.MarkExists then
        begin
          // #6
          SetPixel(DC, Right - ABarControl.MarkSize - 1, Top, AColor6);
          SetPixel(DC, Right - 2, Top + 1, AColor6);
          // #5 = #6, C1+1px
          AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
            Top + 1, dxOffice11ToolbarsColor1,
            dxOffice11ToolbarsColor2, False);
          AColor := GetMiddleRGB(AColor6, AC11pxColor, 50);
          SetPixel(DC, Right - ABarControl.MarkSize - 2, Top, AColor);
          // #7 = #6, Dock
          AColor := GetMiddleRGB(AColor6, ADockColor, 50);
          SetPixel(DC, Right - 2, Top, AColor);
          SetPixel(DC, Right - 1, Top + 1, AColor);
        end
        else
        begin
          // #5 = Dock, C1 + 1px
          AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
            Top + 1, dxOffice11ToolbarsColor1,
            dxOffice11ToolbarsColor2, False);
          AColor := GetMiddleRGB(ADockColor, AC11pxColor, 50);
          SetPixel(DC, Right - 2, Top, AColor);
          SetPixel(DC, Right - 1, Top + 1, AColor);
        end;
      end
      else
      begin
        ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
          ABarControl.PointBarToDock(Point(Left, Bottom)).X, AColor1, AColor2, True);
        if ABarControl.MarkExists then
        begin
          // #5 = #6, C1+1px
          AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
            Left + 1, dxOffice11ToolbarsColor1,
            dxOffice11ToolbarsColor2, True);
          AColor := GetMiddleRGB(AColor6, AC11pxColor, 50);
          SetPixel(DC, Left, Bottom - ABarControl.MarkSize - 2, AColor);
          // #6
          SetPixel(DC, Left, Bottom - ABarControl.MarkSize - 1, AColor6);
          SetPixel(DC, Left + 1, Bottom - 2, AColor6);
          // #7 = #6, Dock
          AColor := GetMiddleRGB(AColor6, ADockColor, 50);
          SetPixel(DC, Left, Bottom - 2, AColor);
          SetPixel(DC, Left + 1, Bottom - 1, AColor);
        end
        else
        begin
          // #5 = Dock, C1 + 1px
          AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
            Left + 1, dxOffice11ToolbarsColor1,
            dxOffice11ToolbarsColor2, True);
          AColor := GetMiddleRGB(ADockColor, AC11pxColor, 50);
          SetPixel(DC, Left, Bottom - 2, AColor);
          SetPixel(DC, Left + 1, Bottom - 1, AColor);
        end;
      end;
    end;
  end;

  procedure DrawRightBorder(ARect: TRect);
  var
    R: TRect;
    AClipRgn: HRGN;
    AClipRgnExists: Boolean;
    ADockColor, AColor1, AColor2, AColor: TColor;
  begin
    with ARect do
    begin
      if ABarControl.Horizontal then
      begin
        if not ABarControl.MarkExists then
        begin
          R := Rect(Right - 2, Top + 1, Right - 1, Bottom - 2);
          FillBackground(DC, R);
        end;
      end
      else
      begin
        R := Rect(Right - 2, Top + 2, Right - 1, Bottom - 2);
        Dec(R.Bottom, ABarControl.GetMarkSize);
        FillBackground(DC, R);
      end;

      if ABarControl.MarkExists then
      begin
        SaveClipRgn(DC, AClipRgn, AClipRgnExists);
        if ABarControl.Horizontal then
        begin
          IntersectClipRect(DC, Right - ABarControl.MarkSize - 2 + 2, Top, Right - 2, Top + 1);
          AddClipRect(DC, Rect(Right - 2, Top + 2, Right, Bottom - 2));
          AddClipRect(DC, Rect(Right - ABarControl.MarkSize - 1, Bottom - 1, Right - 2, Bottom));
          AddClipRect(DC, Rect(Right - ABarControl.MarkSize, Bottom - 2, Right - 1, Bottom - 1));
          R := Rect(Right - ABarControl.MarkSize - 1, Top, Right, Bottom);
        end
        else
        begin
          IntersectClipRect(DC, Left, Bottom - ABarControl.MarkSize, Left + 1, Bottom - 2);
          AddClipRect(DC, Rect(Left + 2, Bottom - 2, Right - 2, Bottom));
          AddClipRect(DC, Rect(Right - 2, Bottom - ABarControl.MarkSize, Right - 1, Bottom - 1));
          AddClipRect(DC, Rect(Right - 1, Bottom - ABarControl.MarkSize - 1, Right, Bottom - 2));
          R := Rect(Left, Bottom - ABarControl.MarkSize - 1, Right, Bottom);
        end;
        FillTubeGradientRect(DC, R, AMarkColor1, AMarkColor2, not ABarControl.Horizontal);
        RestoreClipRgn(DC, AClipRgn, AClipRgnExists);
        // #8 = B, Dock
        GetDockColors(ABarControl.DockControl, AColor1, AColor2);
        ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
          ABarControl.PointBarToDock(Point(Right, Bottom)).X, AColor1, AColor2, True);
        AColor := GetMiddleRGB(AMarkColor2, ADockColor, 50);
        SetPixel(DC, Right - 1, Bottom - 2, AColor);
        SetPixel(DC, Right - 2, Bottom - 1, AColor);
      end
      else
      begin
        if ABarControl.Horizontal then
          FillBackground(DC, Rect(Right - 1, Top + 2, Right, Bottom - 1))
        else
          FillBackground(DC, Rect(Left + 2, Bottom - 1, Right - 1, Bottom));
      end;
    end;
  end;

  procedure DrawBottomBorder(ARect: TRect);
  var
    ADockColor, AColor1, AColor2, AColor: TColor;
    R: TRect;
  begin
    with ARect do
    begin
      if ABarControl.Horizontal then
      begin
        R := Rect(Left + 2, Bottom - 2, Right - 2, Bottom - 1);
        Dec(R.Right, ABarControl.GetMarkSize);
        FillBackground(DC, R);
      end
      else
      begin
        if not ABarControl.MarkExists then
        begin
          R := Rect(Left + 1, Bottom - 2, Right - 2, Bottom - 1);
          FillBackground(DC, R);
        end;
      end;

      if ABarControl.MarkExists then
      begin
        // #9 = B, #2
        AColor := GetMiddleRGB(AMarkColor2, dxOffice11BarBorderColors[2], 50);
        if ABarControl.Horizontal then
        begin
          SetPixel(DC, Right - 2 - ABarControl.MarkSize, Bottom - 1, AColor);
          SetPixel(DC, Right - 1 - ABarControl.MarkSize, Bottom - 2, AColor);
          SetPixel(DC, Right - 2 - ABarControl.MarkSize, Bottom - 2, dxOffice11BarBorderColors[2]);
          FillRect(DC, Rect(Left + 2, Bottom - 1, Right - 2 - ABarControl.MarkSize, Bottom), B1);
        end
        else
        begin
          SetPixel(DC, Right - 2, Bottom - 1 - ABarControl.MarkSize, AColor);
          SetPixel(DC, Right - 1, Bottom - 2 - ABarControl.MarkSize, AColor);
          SetPixel(DC, Right - 2, Bottom - 2 - ABarControl.MarkSize, dxOffice11BarBorderColors[2]);
          FillRect(DC, Rect(Right - 1, Top + 2, Right, Bottom - ABarControl.MarkSize - 2), B1);
        end;
      end
      else
      begin
        // #9 = Dock, #2
        GetDockColors(ABarControl.DockControl, AColor1, AColor2);
        ADockColor := GetGradientColorRect(ABarControl.DockControl.ClientRect,
          ABarControl.PointBarToDock(Point(Right, Bottom)).X, AColor1, AColor2, True);
        AColor := GetMiddleRGB(dxOffice11BarBorderColors[2], ADockColor, 50);
        SetPixel(DC, Right - 2, Bottom - 1, AColor);
        SetPixel(DC, Right - 1, Bottom - 2, AColor);

        SetPixel(DC, Right - 2, Bottom - 2, dxOffice11BarBorderColors[2]);
        if ABarControl.Horizontal then
          FillRect(DC, Rect(Left + 2, Bottom - 1, Right - 2, Bottom), B1)
        else
          FillRect(DC, Rect(Right - 1, Top + 2, Right, Bottom - 2), B1);
      end;
    end;
  end;

  procedure DrawBorder(ARect: TRect);
  begin
    DrawLeftBorder(ARect);
    DrawTopBorder(ARect);
    DrawRightBorder(ARect);
    DrawBottomBorder(ARect);
    with ARect do
    begin
      FillParentBackground(DC, Rect(Left, Top, Left + 1, Top + 1));
      FillParentBackground(DC, Rect(Right - 1, Top, Right, Top + 1));
      FillParentBackground(DC, Rect(Left, Bottom - 1, Left + 1, Bottom));
      FillParentBackground(DC, Rect(Right - 1, Bottom - 1, Right, Bottom));
    end;
  end;

  procedure DrawMainMenuBorder(ARect: TRect);
  begin
    with ARect do
      if ABarControl.Horizontal then
      begin
        FillParentBackground(DC, Rect(Left, Top, Right, Top + 2));
        FillParentBackground(DC, Rect(Left, Bottom - 2, Right, Bottom));
      end
      else
      begin
        FillParentBackground(DC, Rect(Left, Top, Left + 2, Bottom));
        FillParentBackground(DC, Rect(Right - 2, Top, Right, Bottom));
      end;
  end;

begin
  B1 := CreateSolidBrush(dxOffice11BarBorderColors[1]);
  GetMarkColors(ABarControl, AMarkColor1, AMarkColor2, AColor6, AColor9);
  if ABarControl.IsMainMenu then
    DrawMainMenuBorder(R)
  else
    if ABarControl.Bar.BorderStyle = bbsSingle then
      DrawBorder(R);
  if ABarControl.CanMoving then
    DrawFinger(R);
  DeleteObject(B1);
end;

procedure TdxBarOffice11Painter.BarDrawFloatingBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R, CR: TRect; AToolbarBrush: HBRUSH);
var
  I: Integer;
  B1, B2: HBRUSH;
begin
  if not ABarControl.IsInternal then
  begin
    B1 := CreateSolidBrush(dxOffice11BarFloatingBorderColor1);
    B2 := CreateSolidBrush(dxOffice11BarFloatingBorderColor2);
    FrameRect(DC, R, B1);
    InflateRect(R, -1, -1);
    FrameRect(DC, R, B1);
    InflateRect(R, -1, -1);
    FrameRect(DC, R, B2);
    with R do
    begin
      FillRect(DC, Rect(Left, Top, Left + 1, Top + 1), B1);
      FillRect(DC, Rect(Right - 1, Top, Right, Top + 1), B1);
      FillRect(DC, Rect(Right - 1, Bottom - 1, Right, Bottom), B1);
      FillRect(DC, Rect(Left, Bottom - 1, Left + 1, Bottom), B1);
    end;
    DeleteObject(B2);
    DeleteObject(B1);
  end
  else
  begin
    FrameRect(DC, R, dxOffice11DropDownBorderBrush1);
    for I := R.Left + 1 to CR.Left - 1 do
    begin
      InflateRect(R, -1, -1);
      FrameRect(DC, R, AToolbarBrush);
    end;
  end;
end;

procedure TdxBarOffice11Painter.BarDrawFloatingBarCaption(ABarControl: TdxBarControl;
  DC: HDC; R, CR: TRect; AToolbarBrush: HBRUSH);
begin
  AToolbarBrush := CreateSolidBrush(dxOffice11BarFloatingBorderColor3);
  inherited;
  DeleteObject(AToolbarBrush);
end;

function TdxBarOffice11Painter.BarMarkRect(ABarControl: TdxBarControl): TRect;
begin
  Result := inherited BarMarkRect(ABarControl);
  if not IsSimpleMark(ABarControl) then
    case ABarControl.DockingStyle of
      dsTop, dsBottom:
        begin
          Dec(Result.Top, 1);
          Inc(Result.Right, 2);
          Inc(Result.Bottom, 1);
        end;
      dsLeft, dsRight:
        begin
          Dec(Result.Left, 1);
          Inc(Result.Right, 1);
          Inc(Result.Bottom, 2);
        end;
    end;
end;

procedure TdxBarOffice11Painter.BarMarkRectInvalidate(ABarControl: TdxBarControl);
begin
  inherited;
  if ABarControl.DockingStyle <> dsNone then
    SendMessage(ABarControl.Handle, WM_NCPAINT, 0, 0);
end;

class function TdxBarOffice11Painter.SubMenuControlGetSeparatorColor: TColor;
begin
  Result := dxOffice11BarSeparatorColor1;
end;

class function TdxBarOffice11Painter.SubMenuControlToolbarItemsBrush(ABarSubMenuControl: TdxBarSubMenuControl): HBRUSH;
begin
  Result := dxOffice11MenuBrush;
end;

class function TdxBarOffice11Painter.SubMenuControlHasBand: Boolean;
begin
  Result := True;
end;

class function TdxBarOffice11Painter.SubMenuControlIsSingleMenuBorder(ABarSubMenuControl: TdxBarSubMenuControl): Boolean;
begin
  Result := not ABarSubMenuControl.GetBackgroundBitmap.Empty or
    (ABarSubMenuControl.BarSize <> 0);
end;

class procedure TdxBarOffice11Painter.SubMenuControlOffsetDetachCaptionRect(ABarSubMenuControl: TdxBarSubMenuControl;
  var R: TRect);
begin
  InflateRect(R, -2, -4);
end;

procedure TdxBarOffice11Painter.SubMenuControlCalcDrawingConsts(ACanvas: TcxCanvas;
  ATextSize: Integer; out AMenuArrowWidth, AMarkSize: Integer);
begin
  inherited;
  AMarkSize := dxOffice11SubMenuExpandBitmap.Height + SubMenuControlMarkBorderSize;
//  AMarkSize := ACanvas.TextHeight('0') + 5; // to scale
end;

class function TdxBarOffice11Painter.SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := ABarSubMenuControl.DetachCaptionSize + 5;
end;

procedure TdxBarOffice11Painter.SubMenuControlDrawBackground(ABarSubMenuControl: TdxBarSubMenuControl;
  ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor);
var
  W1: Integer;
  W2: Integer;
  AColor1, AColor2: TColor;
begin
  if not ABarSubMenuControl.GetBackgroundBitmap.Empty then
    inherited
  else
  begin
    W1 := ABarSubMenuControl.GetIndent1;
    W2 := ABarSubMenuControl.GetIndent2;
    ACanvas.SaveClipRegion;
    try
      ACanvas.SetClipRegion(TcxRegion.Create(ARect), roIntersect);
      with ARect do
      begin
        // fill
        if ABarSubMenuControl.FNonRecent then
        begin
          AColor1 := dxOffice11MenuNonRecentIndentColor1;
          AColor2 := dxOffice11MenuNonRecentIndentColor2;
        end
        else
        begin
          AColor1 := dxOffice11MenuIndentColor1;
          AColor2 := dxOffice11MenuIndentColor2;
        end;
        FillTubeGradientRect(ACanvas.Handle, Rect(0, Top, W1, Bottom), AColor1, AColor2, True);
        if W2 <> 0 then
          FillRectByColor(ACanvas.Handle, Rect(W1, Top, W1 + W2, Bottom), AColor2);
        if Right > (W1 + W2) then
          FillRect(ACanvas.Handle, Rect(W1 + W2, Top, Right, Bottom), ABrush);
      end;
    finally
      ACanvas.RestoreClipRegion;
    end;
  end;
end;

procedure TdxBarOffice11Painter.SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect);

  procedure DrawFlatBorder;
  var
    ARect: TRect;
  begin
    FrameRect(DC, R, dxOffice11DropDownBorderBrush1);
    ARect := ABarSubMenuControl.OwnerLinkBounds[False];
    if not IsRectEmpty(ARect) then
      FillRect(DC, ARect, dxOffice11MenuBrush);
  end;

begin
  with R do
  begin
    DrawFlatBorder;
    if ABarSubMenuControl.Detachable then
    begin
      InflateRect(R, -1, -1);
      Bottom := Top + ABarSubMenuControl.DetachCaptionSize + 3 + 2;
      FrameRect(DC, R, dxOffice11MenuBrush);
      InflateRect(R, 0, -1);
      FillRect(DC, Rect(Left, Top, Right, Top + 2), dxOffice11MenuBrush);
      FillRect(DC, Rect(Left, Bottom - 1, Right, Bottom), dxOffice11MenuBrush);
      SubMenuControlDrawDetachCaption(ABarSubMenuControl, DC, ABarSubMenuControl.DetachCaptionRect);
    end;
  end
end;

procedure TdxBarOffice11Painter.SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; const R: TRect; ABrush: HBRUSH);
begin
  if SubMenuControlIsSingleMenuBorder(ABarSubMenuControl) then
    FrameRect(DC, R, dxOffice11MenuBrush)
  else
    with R do
    begin
      FillRect(DC, Rect(Left, Top, Right, Top + 1), dxOffice11MenuBrush);
      FillRect(DC, Rect(Right - 1, Top, Right, Bottom), dxOffice11MenuBrush);
      FillRect(DC, Rect(Left, Bottom - 1, Right, Bottom), dxOffice11MenuBrush);
      // Indent
      FillRectByColor(DC, Rect(Left, Top + 1, Left + 1, Bottom - 1), dxOffice11MenuIndentColor1);
    end;
end;

procedure TdxBarOffice11Painter.SubMenuControlDrawDetachCaption(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect);
var
  ABrush: HBRUSH;
  DXY: Integer;
begin
  if ABarSubMenuControl.DetachCaptionSelected then
  begin
    Office11FrameSelectedRect(DC, R);
    InflateRect(R, -1, -1);
    ABrush := dxOffice11DetachableSelectedBrush;
    DXY := 0;
  end
  else
  begin
    ABrush := dxOffice11DetachableBrush;
    DXY := 1;
  end;
  FillRect(DC, R, ABrush);
  // draw marks
  InflateRect(R, -(((R.Right - R.Left + DXY * 2) div 4)), -(DXY + 1));
  BarDrawFingerElements(ABarSubMenuControl, DC, R, False);
end;

procedure TdxBarOffice11Painter.DropDownListBoxDrawBorder(DC: HDC; AColor: TColor; ARect: TRect);
begin
  FrameRect(DC, ARect, dxOffice11DropDownBorderBrush1);
  InflateRect(ARect, -1, -1);
  FrameRect(DC, ARect, dxOffice11DropDownBorderBrush2);
end;

class function TdxBarOffice11Painter.BarToolbarBrushEx2(ABarControl: TdxBarControl): HBRUSH;
begin
  Result := dxOffice11MenuBrush;
end;

class procedure TdxBarOffice11Painter.DrawQuickCustItemFrameSelected(ABarItemControl: TdxBarItemControl;
  DC: HDC; WholeR, R: TRect; Selected: Boolean);
begin
  if Selected then
  begin
    Office11FrameSelectedRect(DC, WholeR);
    with R do
    begin
      Left := Right;
      Right := Left + 2; // paint over!
    end;
    FillRect(DC, R, ABarItemControl.Parent.ToolbarSelBrush);
  end;
end;

function TdxBarOffice11Painter.ButtonControlArrowBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH;
begin
  with ADrawParams do
    if Enabled then
      if DrawSelected then
        if DroppedDown then
          Result := BarItemControl.Parent.ToolbarDownedSelBrush
        else
          Result := BarItemControl.Parent.ToolbarSelBrush
      else
        Result := BarItemControl.Parent.BkBrush
    else
      Result := GetSysColorBrush(COLOR_BTNFACE);
end;

function TdxBarOffice11Painter.EditButtonIsCustomBackground(AState: Integer): Boolean;
begin
  Result := AState in [DXBAR_NORMAL, DXBAR_ACTIVE];
end;

procedure TdxBarOffice11Painter.EditButtonDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams; AState: Integer;
  ARect: TRect; ABrush: HBrush);
begin
  if ADrawParams.PaintType = ptMenu then
    FillRect(ADrawParams.Canvas.Handle, ARect, dxOffice11OwnerControlDownedBrush)
  else
    DrawBackground(ADrawParams.BarItemControl, ADrawParams.Canvas.Handle, ARect, ABrush, ADrawParams.BarItemControl.NonRecent);
end;

class function TdxBarOffice11Painter.EditControlBorderOffsets(APaintType: TdxBarPaintType): TRect;
begin
  Result := Rect(1, 1, 1, 1);
end;

procedure TdxBarOffice11Painter.EditControlDrawBorder(
  const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect);
begin
  with ADrawParams do
  begin
    if DrawSelected then
      Office11FrameSelectedRect(Canvas.Handle, ARect)
    else
      if not Enabled and not IsTransparent then
        FrameRectByColor(Canvas.Handle, ARect, dxOffice11TextDisabledColor)
      else
        if (PaintType = ptMenu) and not IsTransparent then
          FrameRect(Canvas.Handle, ARect, dxOffice11OwnerControlDownedBrush)
        else
          DrawBackgroundFrameRect(BarEditControl, Canvas.Handle, ARect, BarEditControl.Parent.BkBrush, False);
    InflateRect(ARect, -1, -1);
  end;
end;

class function TdxBarOffice11Painter.EditControlCaptionBackgroundIsOpaque(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  Result := (ADrawParams.PaintType = ptMenu) and ADrawParams.DrawSelected;
end;

class function TdxBarOffice11Painter.EditControlCaptionAbsoluteLeftIndent(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  if ADrawParams.PaintType = ptMenu then
    Result := SubMenuControlGetItemTextIndent(ADrawParams)
  else
    Result := ADrawParams.BarItemControl.GetControlCaptionOffset;
end;

class function TdxBarOffice11Painter.EditControlCaptionRightIndentIsOpaque(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  Result := (ADrawParams.PaintType = ptMenu) and ADrawParams.DrawSelected;
end;

class function TdxBarOffice11Painter.EditControlShowIconDefault(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  Result := ADrawParams.PaintType = ptMenu;
end;

class function TdxBarOffice11Painter.EditControlSubMenuGlyphIndents(const ADrawParams: TdxBarEditLikeControlDrawParams): TRect;
begin
  Result := cxEmptyRect;
  Result.Left := ADrawParams.BarItemControl.SubMenuParent.GetIconAreaSize - ADrawParams.BarItemControl.GetGlyphSize(ADrawParams.ViewSize).cx;
end;

function TdxBarOffice11Painter.ComboControlArrowColor(ADrawParams: TdxBarItemControlDrawParams): TColor;
begin
  with ADrawParams do
    if Enabled then
    begin
      Result := dxOffice11TextEnabledColor;
      if DrawSelected then
        if IsHighContrastWhite then
          Result := clWhite
        else
          if DroppedDown and not IsXPStandardScheme then
            Result := ColorToRGB(clHighlightText);
    end
    else
      Result := dxOffice11TextDisabledColor;
end;

function TdxBarOffice11Painter.ComboControlButtonBrush(const ADrawParams: TdxBarItemControlDrawParams): HBRUSH;
begin
  Result := ButtonControlArrowBrush(ADrawParams);
  with ADrawParams do
    if DrawSelected then
      Result := BarItemControl.Parent.ToolbarSelBrush
    else
      if DroppedDown then
        Result := BarItemControl.Parent.ToolbarDownedSelBrush;
end;

class procedure TdxBarOffice11Painter.ComboControlDrawSimpleButton(const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect; ABrush: HBRUSH);
var
  AColor1, AColor2: TColor;
  ASpaceBrush: HBRUSH;
begin
  with ADrawParams do
    if DrawSelected then
    begin
      InflateRect(ARect, 1, 1);
      Office11FrameSelectedRect(Canvas.Handle, ARect);
      InflateRect(ARect, -1, -1);
      GetSelectedColors(BarEditControl, DroppedDown, DrawSelected, AColor1, AColor2);
      FillGradientRect(Canvas.Handle, ARect, AColor1, AColor2, False);
      InflateRect(ARect, -1, -1);
    end
    else
    begin
      if Enabled then
        ASpaceBrush := BarEditControl.EditBkBrush
      else
        ASpaceBrush := ABrush;
      FrameRect(Canvas.Handle, ARect, ASpaceBrush);
      FillRect(Canvas.Handle, Rect(ARect.Left - 1, ARect.Top, ARect.Left, ARect.Bottom), ASpaceBrush);
      InflateRect(ARect, -1, -1);
      if (PaintType = ptMenu) and Enabled then
        FillRect(Canvas.Handle, ARect, dxOffice11OwnerControlDownedBrush)
      else
        DrawBackground(BarEditControl, Canvas.Handle, ARect, ABrush, not Enabled);
      if DroppedDown then
        OffsetRect(ARect, 1, 1);
    end;
end;

class function TdxBarOffice11Painter.ProgressControlIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer;
begin
  Result := 0;
  if not (cpIcon in ADrawParams.ViewStructure) and (ADrawParams.PaintType = ptMenu) then
    Inc(Result, TdxBarSubMenuControl(ADrawParams.BarItemControl.Parent).GetIndent1);
end;

procedure TdxBarOffice11Painter.DateNavigatorDrawButton(ABarItem: TdxBarItem;
  DC: HDC; R: TRect; const ACaption: string; APressed: Boolean);
begin
  if not ABarItem.BarManager.FThemeAvailable then
    inherited
  else
    TdxBarXPPainter.DateNavigatorDrawNativeButton(ABarItem, DC, R, ACaption, APressed);
end;

function TdxBarOffice11Painter.DateNavigatorHeaderColor: TColor;
begin
  Result := dxOffice11DateHeaderColor;
end;

class function TdxBarOffice11Painter.InPlaceSubItemControlBrush: HBRUSH;
begin
  Result := dxOffice11InPlaceSubItemBrush;
end;

function TdxBarOffice11Painter.EditGetDisabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF;
begin
  Result := GetSysColor(COLOR_BTNFACE);
end;

function TdxBarOffice11Painter.EditGetDisabledTextColor: COLORREF;
begin
  Result := dxOffice11TextDisabledColor;
end;

procedure TdxBarOffice11Painter.DrawSeparatorGlyphAndCaption(const ADrawParams: TdxBarSeparatorControlDrawParams; const ARect: TRect);
var
  APrevBrush: HBRUSH;
begin
  APrevBrush := ADrawParams.BarItemControl.FBkBrush;
  ADrawParams.BarItemControl.FBkBrush := CreateSolidBrush(dxOffice11MenuIndentColor2);
  inherited;
  DeleteGDIObject(ADrawParams.BarItemControl.FBkBrush);
  ADrawParams.BarItemControl.FBkBrush := APrevBrush;
end;

procedure TdxBarOffice11Painter.DrawGlyphBorder(ABarItemControl: TdxBarItemControl;
  DC: HDC; ABrush: HBRUSH; NeedBorder: Boolean; R: TRect; PaintType: TdxBarPaintType; IsGlyphEmpty,
  Selected, Down, DrawDowned, ADroppedDown, IsSplit: Boolean);
var
  AOpaque, AVertical: Boolean;
  AColor1, AColor2: TColor;
begin
  if (PaintType = ptMenu) and Selected and IsGlyphEmpty and not Down or ABarItemControl.IsBkColorAssigned then
    FillRect(DC, R, ABrush)
  else
  begin
    AOpaque := Selected or Down or DrawDowned;
    AVertical := ABarItemControl.Parent.IsRealVertical;
    if ADroppedDown and IsMenuGradient(ABarItemControl) and not Down then
      FillGradientRect(DC, R, dxOffice11MenuDownedColor1,
        dxOffice11MenuDownedColor2, AVertical)
    else
    begin
      if (PaintType <> ptMenu) and AOpaque then
      begin
        GetSelectedColors(ABarItemControl, Down or DrawDowned, Selected, AColor1, AColor2);
        FillGradientRect(DC, R, AColor1, AColor2, AVertical);
      end
      else
        DrawBackground(ABarItemControl, DC, R, ABrush, AOpaque);
    end;  

    if Down or (Selected and (PaintType <> ptMenu)) or ADroppedDown then
    begin
      if ADroppedDown then
        BarDrawBarControlOwnerBorder(ABarItemControl.Parent, DC, R, ABarItemControl, ABarItemControl.OwnedBarControl)
      else
        if Selected or
          (Down and (ABarItemControl is TdxBarButtonControl) and TdxBarButtonControl(ABarItemControl).Down) then
          Office11FrameSelectedRect(DC, R)
        else
          FrameRect(DC, R, dxOffice11SelectedBorderBrush);
    end
    else
      if NeedBorder then
        DrawBackgroundFrameRect(ABarItemControl, DC, R, ABrush, AOpaque);
  end;
end;

class procedure TdxBarOffice11Painter.DrawItemArrow(DC: HDC; R: TRect;
  ArrowType: TcxArrowDirection; Enabled, Selected, Flat: Boolean; AColor: TColor = clDefault);
begin
  Office11DrawItemArrow(DC, R, ArrowType = adDown, Enabled, Selected, Flat);
end;

procedure TdxBarOffice11Painter.DrawLargeItemArrow(DC: HDC; R: TRect;
  ArrowType: TcxArrowDirection; Size: Integer; Selected, Enabled, Flat: Boolean; AColor: TColor = clDefault);
begin
  Office11DrawLargeItemArrow(DC, R, ArrowType = adDown, Size, Selected, Enabled, Flat);
end;

class procedure TdxBarOffice11Painter.DrawFrameRect(ABarItemControl: TdxBarItemControl;
  ADC: HDC; const ARect: TRect; ABrush: HBRUSH; APaintType: TdxBarPaintType; ASelected, ADowned: Boolean);
begin
  if (APaintType = ptMenu) or ASelected or ADowned then
    if (APaintType = ptMenu) and not ASelected then
      FrameRect(ADC, ARect, dxOffice11BarSeparatorBrush1)
    else
      Office11FrameSelectedRect(ADC, ARect)
  else
    DrawBackgroundFrameRect(ABarItemControl, ADC, ARect, ABrush, False);
end;

class procedure TdxBarOffice11Painter.FrameFlatSelRect(DC: HDC; const R: TRect);
begin
  Office11FrameSelectedRect(DC, R);
end;

class function TdxBarOffice11Painter.GetBarGradientRect(ABarControl: TCustomdxBarControl): TRect;
begin
  Result := Rect(0, 0, ABarControl.Width, ABarControl.Height);
  if ABarControl is TdxBarControl then
  begin
    if TdxBarControl(ABarControl).Horizontal then
      InflateRect(Result, 0, -1)
    else
      InflateRect(Result, -1, 0);
  end;
end;

class procedure TdxBarOffice11Painter.GetDockColors(ADockControl: TdxDockControl; var AColor1, AColor2: TColor);
begin
  AColor1 := dxOffice11DockColor1;
  AColor2 := dxOffice11DockColor2;
  if ADockControl.Align = alLeft then
    AColor2 := AColor1
  else
    if ADockControl.Align = alRight then
      AColor1 := AColor2;
end;

class procedure TdxBarOffice11Painter.GetMarkColors(ABarControl: TdxBarControl;
  var AMarkColor1, AMarkColor2, AColor6, AColor9: TColor);
var
  I: Integer;
begin
  I := Integer(ABarControl.MarkDrawState) + 1;
  AMarkColor1 := dxOffice11BarMarkColors1[I];
  AMarkColor2 := dxOffice11BarMarkColors2[I];
  AColor6 := dxOffice11BarBorderMarkColors[1, I];
  AColor9 := dxOffice11BarBorderMarkColors[2, I];
end;

class procedure TdxBarOffice11Painter.GetSelectedColors(ABarItemControl: TdxBarItemControl;
  ADown, ASelected: Boolean; var AColor1, AColor2: TColor);
begin
//#DG  if ABarItemControl.Parent.NeedShowGlyphAndCheckForItem then - ???
  if ABarItemControl.Parent.IsInternal then
  begin
    if ADown then
      AColor1 := dxOffice11OwnerControlDownedColor
    else
      AColor1 := dxOffice11SelectedColor1;
    AColor2 := AColor1;
  end
  else
  begin
    if ADown then
    begin
      if not ASelected then
      begin
        AColor1 := dxOffice11SelectedDownColor1;
        AColor2 := dxOffice11SelectedDownColor2;
        if AColor1 = AColor2 then
        begin
          AColor1 := dxOffice11DownedColor; //dxOffice11SelectedColor1;
          AColor2 := AColor1;
        end;
      end
      else
      begin
        AColor1 := dxOffice11SelectedDownColor2;
        AColor2 := dxOffice11SelectedDownColor1;
      end;
    end
    else
    begin
      AColor1 := dxOffice11SelectedColor1;
      AColor2 := dxOffice11SelectedColor2;
    end;
  end;  
end;

class function TdxBarOffice11Painter.GetToolbarBrush(ABarItemControl: TdxBarItemControl): HBRUSH;
begin
  Result := ABarItemControl.Parent.ToolbarBrush;
end;

function TdxBarOffice11Painter.GetDefaultEnabledTextColor(
  ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean): TColor;
begin
  if (ABarItemControl.IsInvertTextColor or True) and ASelected and not AFlat then
  begin
    Result := dxOffice11InPlaceSubItemTextColor; // GetSysColor(COLOR_HIGHLIGHTTEXT)
    if IsHighContrastWhite then
      Result := clWhite;
  end
  else
    Result := dxOffice11TextEnabledColor;
end;

procedure TdxBarOffice11Painter.GetDisabledTextColors(
  ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean;
  var AColor1, AColor2: TColor);
begin
  AColor1 := dxOffice11TextDisabledColor;
  AColor2 := AColor1;
end;

class function TdxBarOffice11Painter.GetFaded(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := True;
end;

class function TdxBarOffice11Painter.IgnoreNonRecentColor: Boolean;
begin
  Result := True;
end;

class function TdxBarOffice11Painter.IsMenuGradient(ABarItemControl: TdxBarItemControl): Boolean;
begin
  Result := not ABarItemControl.Parent.NeedShowGlyphAndCheckForItem and ((ABarItemControl is TdxBarSubItemControl) or
    ((ABarItemControl is TdxBarButtonControl) and TdxBarButtonControl(ABarItemControl).DroppedDownFlat));
end;

class function TdxBarOffice11Painter.IsSimpleMark(ABarControl: TdxBarControl): Boolean;
begin
  Result := (ABarControl.Bar.BorderStyle = bbsNone) or ABarControl.IsMainMenu;
end;

class function TdxBarOffice11Painter.BarCaptionBkColor(ABarControl: TdxBarControl;
  AMainFormActive: Boolean): COLORREF;
begin
  Result := dxOffice11BarFloatingCaptionColor;
end;

function TdxBarOffice11Painter.BarCaptionColor(ABarControl: TdxBarControl): COLORREF;
begin
  Result := dxOffice11BarFloatingCaptionTextColor1;
end;

class function TdxBarOffice11Painter.BarMarkArrowColor(ABarControl: TdxBarControl;
  AState: TdxBarMarkState): COLORREF;
begin
  case AState of
    msSelected:
      Result := dxOffice11BarFloatingCaptionTextColor2;
    msPressed:
      Result := dxOffice11BarFloatingCaptionTextColor3;
  else // msNone
    Result := dxOffice11BarFloatingCaptionTextColor1;
  end;
end;

class procedure TdxBarOffice11Painter.BarDrawFingerElements(ABarControl: TCustomdxBarControl;
  DC: HDC; ARect: TRect; AHorizontal: Boolean);
begin
  Office11DrawFingerElements(DC, ARect, AHorizontal);
end;

procedure TdxBarOffice11Painter.BarDrawMarkBackground(ABarControl: TdxBarControl;
  DC: HDC; ItemRect: TRect; AToolbarBrush: HBRUSH);
var
  R1, R2, R3: TRect;
  C1, C2, AColor6, C4: TColor;
  AC11pxColor, AColor: TColor;
begin
  // TODO: states and colors
  GetMarkColors(ABarControl, C1, C2, AColor6, C4);
  if (ABarControl.Bar.BorderStyle = bbsNone) or
    ABarControl.IsMainMenu then
  begin
    R2 := ItemRect;
{    if ABarControl.Bar.IsMainMenu then
    begin
      InflateRect(R2, 0, -1);
      with R2 do
      begin
        ABarControl.FillBackground(DC, Rect(Left, Top - 1, Right, Top), AToolbarBrush, clNone, True);
        ABarControl.FillBackground(DC, Rect(Left, Bottom, Right, Bottom + 1), AToolbarBrush, clNone, True);
      end;
    end;}
  end
  else
  begin
    R1 := ItemRect;
    R2 := ItemRect;
    if ABarControl.Horizontal then
    begin
      R1.Right := R1.Left + 2;
      Inc(R2.Left, 2);
      InflateRect(R2, 0, 2);
      with R1 do
        R3 := Rect(Right - 1, Top, Right, Top + 1);
      AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
        R3.Top + 2, dxOffice11ToolbarsColor1,
        dxOffice11ToolbarsColor2, False);
    end
    else
    begin
      R1.Bottom := R1.Top + 2;
      Inc(R2.Top, 2);
      InflateRect(R2, 2, 0);
      with R1 do
        R3 := Rect(Left, Bottom - 1, Left + 1, Bottom);
      AC11pxColor := GetGradientColorRect(GetBarGradientRect(ABarControl),
        R3.Left + 2, dxOffice11ToolbarsColor1,
        dxOffice11ToolbarsColor2, True);
    end;
    ABarControl.FillBackground(DC, R1, AToolbarBrush, clNone, True);

    AColor := GetMiddleRGB(AColor6, AC11pxColor, 50);
    SetPixel(DC, R3.Left, R3.Top, AColor);
  end;
  FillTubeGradientRect(DC, R2, C1, C2, not ABarControl.Horizontal);
end;

procedure TdxBarOffice11Painter.BarDrawMarkElements(ABarControl: TdxBarControl;
  DC: HDC; ItemRect: TRect);

  procedure DrawArrow(X, Y: Integer; AVertical: Boolean; AColor: COLORREF);
  const
    YOffset = 3;
  var
    P: array[1..3] of TPoint;
  begin
    if AVertical then
    begin
      FillRectByColor(DC, Rect(X, Y, X + 1, Y + 5), AColor);
      P[1] := Point(X + YOffset, Y);
      P[2] := Point(X + YOffset, Y + 4);
      P[3] := Point(X + YOffset + 2, Y + 2);
    end
    else
    begin
      FillRectByColor(DC, Rect(X, Y, X + 5, Y + 1), AColor);
      P[1] := Point(X, Y + YOffset);
      P[2] := Point(X + 4, Y + YOffset);
      P[3] := Point(X + 2, Y + 2 + YOffset);
    end;
    PolygonByColor(DC, P, AColor, AColor);
  end;

  procedure DrawArrows(X, Y: Integer; Vertical: Boolean);
  begin
    DrawArrow(X + 1, Y + 1, Vertical, dxOffice11BarMarkArrowColor2);
    DrawArrow(X, Y, Vertical, dxOffice11BarMarkArrowColor1);
  end;

  procedure DrawMark(X, Y: Integer; AVertical: Boolean; AColor: COLORREF);
  var
    P: array[1..3] of TPoint;
  begin
    if AVertical then
    begin
      P[1] := Point(X, Y);
      P[2] := Point(X + 1, Y + 1);
      P[3] := Point(X + 2, Y);
    end
    else
    begin
      P[1] := Point(X, Y);
      P[2] := Point(X + 1, Y + 1);
      P[3] := Point(X, Y + 2);
    end;
    PolygonByColor(DC, P, AColor, AColor);
  end;

  procedure DrawMarks(X, Y: Integer; Vertical: Boolean);
  var
    AOffsetX, AOffsetY: Integer;
  begin
    DrawMark(X + 1, Y + 1, Vertical, dxOffice11BarMarkArrowColor2);
    DrawMark(X, Y, Vertical, dxOffice11BarMarkArrowColor1);
    if Vertical then
    begin
      AOffsetX := 0;
      AOffsetY := 4;
    end
    else
    begin
      AOffsetX := 4;
      AOffsetY := 0;
    end;
    DrawMark(X + 1 + AOffsetX, Y + 1 + AOffsetY, Vertical, dxOffice11BarMarkArrowColor2);
    DrawMark(X + AOffsetX, Y + AOffsetY, Vertical, dxOffice11BarMarkArrowColor1);
  end;

var
  AOffsetX, AOffsetY: Integer;
begin
  with ItemRect do
  begin
    if (ABarControl.Bar.BorderStyle = bbsNone) or ABarControl.IsMainMenu then
    begin
      AOffsetX := 2;
      AOffsetY := 1;
    end
    else
    begin
      AOffsetX := 0;
      AOffsetY := 0;
    end;
    if ABarControl.Horizontal then
    begin
      DrawArrows(Right - 6 - AOffsetX, Bottom - 8 - AOffsetY, False);
      if ABarControl.FTruncated then
        DrawMarks(Right - 7 - AOffsetX, Top + 3 - AOffsetY, False); // TODO
    end
    else
    begin
      DrawArrows(Right - 8 - AOffsetY, Bottom - 6 - AOffsetX, True);
      if ABarControl.FTruncated then
        DrawMarks(Left + 3 - AOffsetX, Bottom - 7 - AOffsetY, True); // TODO
    end;
  end;
end;

function TdxBarOffice11Painter.SubMenuControlMarkBorderSize: Integer;
begin
  Result := 2;
end;

function TdxBarOffice11Painter.SubMenuControlMarkContentRect(const ADrawRect: TRect): TRect;
var
  AMarkSize: TSize;
begin
  AMarkSize.cx := cxRectHeight(ADrawRect) - SubMenuControlMarkBorderSize;
  AMarkSize.cy := AMarkSize.cx;
  Result := cxRectCenter(ADrawRect, AMarkSize);
end;

procedure TdxBarOffice11Painter.SubMenuControlDrawMarkContent(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect; ASelected: Boolean);
begin
  TransparentDraw(DC, SubMenuControlMarkContentRect(R), dxOffice11SubMenuExpandBitmap);
end;

{ TdxBarXPPainter }

constructor TdxBarXPPainter.Create(AData: Integer);
begin
  inherited Create(AData);
  InitParams;
end;

procedure TdxBarXPPainter.DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect);
var
  AIconRect: TRect;
  AIsGlyphEmpty, AOpaque: Boolean;
  Brush: HBRUSH;
  ADC: HDC;
begin
  with ADrawParams do
  begin
    AIconRect := SubMenuControlGetItemIconRect(R, BarItemControl.Parent.IconAreaSize);
    AIsGlyphEmpty := not BarItemControl.HasIcon(ViewSize, ViewStructure);
    ADC := Canvas.Handle;

    if DrawSelected and AIsGlyphEmpty and not Downed then
      Brush := BarItemControl.Parent.ToolbarSelBrush
    else
      Brush := BarItemControl.Parent.BkBrush;
    R.Left := AIconRect.Right + 1;
    AOpaque := DrawSelected or BarItemControl.FNonRecent;
    DrawBackground(BarItemControl, ADC, Rect(AIconRect.Right, AIconRect.Top, R.Left, AIconRect.Bottom), Brush, AOpaque);
    if AIconRect.Top > R.Top then
      DrawBackground(BarItemControl, ADC, Rect(AIconRect.Left, R.Top, R.Left, AIconRect.Top), Brush, AOpaque);
    if AIconRect.Bottom < R.Bottom then
      DrawBackground(BarItemControl, ADC, Rect(AIconRect.Left, AIconRect.Bottom, R.Left, R.Bottom), Brush, AOpaque);

    if DrawSelected then
      Brush := BarItemControl.Parent.ToolbarSelBrush
    else
      Brush := BarItemControl.Parent.BkBrush;
    DrawBackground(BarItemControl, ADC, R, Brush, AOpaque);
  end;
end;

class function TdxBarXPPainter.GlyphBkgndBrush(ABarItemControl: TdxBarItemControl;
  APaintType: TdxBarPaintType; AGlyphEmpty, ASelected, ADowned, ADrawDowned, ADroppedDown,
  AForceUseBkBrush, AGrayScale: Boolean): HBRUSH;
begin
  if ASelected and (APaintType = ptMenu) and AGlyphEmpty and not ADowned then // TODO: ref func
    Result := ABarItemControl.Parent.ToolbarSelBrush
  else
    Result := ABarItemControl.BkBrush;
end;

class function TdxBarXPPainter.GlyphDownShift(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := 1;
end;

class function TdxBarXPPainter.GlyphDrawDownedShift(ABarItemControl: TdxBarItemControl;
  ADown: Boolean): Integer;
begin
  if not ADown then
    Result := 1
  else
    Result := 0;
end;

class function TdxBarXPPainter.IsFlatGlyphImage: Boolean;
begin
  Result := True;
end;

function TdxBarXPPainter.BeforeFingersSize: Integer;
begin
//  Result := 3;
  Result := 0;
end;

function TdxBarXPPainter.FingersSize(ABarControl: TdxBarControl): Integer;
begin
  Result := BeforeFingersSize + GripperSize(ABarControl) + 2;
end;

function TdxBarXPPainter.GripperSize(ABarControl: TdxBarControl): Integer;
begin
  Result := FdxBarXPPainterParams.GripperSize;
end;

class function TdxBarXPPainter.RealButtonArrowWidth(ABarManager: TdxBarManager): Integer;
begin
  Result := inherited RealButtonArrowWidth(ABarManager);
  Inc(Result, 3);
end;

class function TdxBarXPPainter.RealLargeButtonArrowWidth(ABarManager: TdxBarManager): Integer;
begin
  Result := inherited RealLargeButtonArrowWidth(ABarManager);
  Inc(Result, 3);
end;

procedure TdxBarXPPainter.DockControlFillBackground(ADockControl: TdxDockControl;
  DC: HDC; ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor);

  procedure FillBackgroundTempBitmap(ABitmap: TBitmap);
  var
    ATheme: TdxTheme;
  begin
    ATheme := OpenTheme(totRebar);
    with AWholeR do
    begin
      ABitmap.Width := Right - Left;
      ABitmap.Height := Bottom - Top;
    end;
    DrawThemeBackground(ATheme, ABitmap.Canvas.Handle, 0, CHEVS_NORMAL, AWholeR);
  end;

  procedure DrawBarSeparators(DC: HDC);

    function GetRowBar(ARow: TdxDockRow): TdxBar;
    var
      I: Integer;
      ABar: TdxBar;
    begin
      if ARow.ColCount = 0 then
      begin
        Result := nil;
        Exit;
      end;
      Result := ARow.Cols[0].BarControl.Bar;
      if Result.BorderStyle = bbsNone then
        for I := 1 to ARow.ColCount - 1 do
        begin
          ABar := ARow.Cols[I].BarControl.Bar;
          if ABar.BorderStyle <> bbsNone then
          begin
            Result := ABar;
            Break;
          end;
        end;
    end;

    function IsNoBorder(ARow: TdxDockRow): Boolean;
    var
      ABar: TdxBar;
    begin
      ABar := GetRowBar(ARow);
      Result := (ABar <> nil) and ((ABar.BorderStyle = bbsNone) or ABar.IsStatusBar);
    end;

    procedure CalcLines(ARow: TdxDockRow; AHorz: Boolean;
      var AIsFirstLineNeeded, AIsLastLineNeeded: Boolean);
    var
      AIsTop, AIsBottom, AIsTopBottom, AIsLeft, AIsRight: Boolean;
    begin
      if IsNoBorder(ARow) then
      begin
        AIsFirstLineNeeded := False;
        AIsLastLineNeeded := False;
      end
      else
      begin
        AIsFirstLineNeeded := True;
        AIsLastLineNeeded := True;
        if AHorz then
        begin
          AIsTop := (ADockControl.DockingStyle = dsTop) and (ARow = ADockControl.Rows[0]);
          AIsBottom := (ADockControl.DockingStyle = dsBottom) and
            (ARow = ADockControl.Rows[ADockControl.RowCount - 1]);
          AIsTopBottom := (ADockControl.DockingStyle = dsTop) and
            (ARow = ADockControl.Rows[ADockControl.RowCount - 1]);  
          if AIsTop then AIsFirstLineNeeded := False;
          if AIsBottom or AIsTopBottom then AIsLastLineNeeded := False;
        end
        else
        begin
          AIsLeft := (ADockControl.DockingStyle = dsLeft) and (ARow = ADockControl.Rows[0]);
          AIsRight := (ADockControl.DockingStyle = dsRight) and
            (ARow = ADockControl.Rows[ADockControl.RowCount - 1]);
          if AIsLeft then AIsFirstLineNeeded := False;
          if AIsRight then AIsLastLineNeeded := False;
        end;
      end;
    end;

  var
    I: Integer;
    R, R1, R2: TRect;
    AHorz: Boolean;
    AIsFirstLineNeeded, AIsLastLineNeeded: Boolean;
  begin
    AHorz := ADockControl.DockingStyle in [dsTop, dsBottom];
    for I := 0 to ADockControl.RowCount - 1 do
    begin
      // rects
      R := ADockControl.GetRectForRow(I);
      if AHorz then
      begin
        R1 := Rect(R.Left, R.Top, R.Right, R.Top + 1);
        R2 := Rect(R.Left, R.Bottom - 1, R.Right, R.Bottom);
      end
      else
      begin
        R1 := Rect(R.Left, R.Top, R.Left + 1, R.Bottom);
        R2 := Rect(R.Right - 1, R.Top, R.Right, R.Bottom);
      end;
      // draw
      CalcLines(ADockControl.Rows[I], AHorz, AIsFirstLineNeeded, AIsLastLineNeeded);
      if AIsFirstLineNeeded then
        FillRect(DC, R1, GetSysColorBrush(COLOR_BTNHIGHLIGHT));
      if AIsLastLineNeeded then
        FillRect(DC, R2, GetSysColorBrush(COLOR_BTNSHADOW)); // TODO: color?
    end;
  end;

begin
  if ADockControl.BackgroundTempBitmap.Empty then
  begin
    FillBackgroundTempBitmap(ADockControl.BackgroundTempBitmap);
    DrawBarSeparators(ADockControl.BackgroundTempBitmap.Canvas.Handle);
  end;
  cxBitBlt(DC, ADockControl.BackgroundTempBitmap.Canvas.Handle, ADestR, ASourceR.TopLeft, SRCCOPY);
end;

class function TdxBarXPPainter.IsNativeBackground: Boolean;
begin
  Result := True;
end;

{class function TdxBarXPPainter.BarChildrenHaveShadows(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := False;
end;}

class function TdxBarXPPainter.BarToolbarBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  Result := ABarControl.BarManager.ThemeToolbarsBrush;
end;

class function TdxBarXPPainter.BarToolbarBrushEx(ABarControl: TdxBarControl): HBRUSH;
begin
  Result := BarToolbarBrush(ABarControl);
end;

class function TdxBarXPPainter.BarToolbarDownedBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  // TODO
  Result := PatternBrush;
//  Result := ABarControl.BarManager.FlatToolbarsDownedBrush;
end;

class function TdxBarXPPainter.BarToolbarDownedSelBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  // TODO
  Result := GetSysColorBrush(COLOR_BTNFACE);
//  Result := ABarControl.BarManager.FlatToolbarsDownedSelBrush;
end;

class function TdxBarXPPainter.BarToolbarSelBrush(ABarControl: TCustomdxBarControl): HBRUSH;
begin
  // TODO
  Result := GetSysColorBrush(COLOR_HIGHLIGHT);
//  Result := ABarControl.BarManager.FlatToolbarsSelBrush;
end;

function TdxBarXPPainter.ComboBoxArrowWidth(ABarControl: TCustomdxBarControl; cX: Integer): Integer;
begin
  Result := FdxBarXPPainterParams.ComboBoxArrowWidth;
end;

function TdxBarXPPainter.BarBeginGroupSideSize: Integer;
begin
  // don't use in xp painter
  Result := (BarBeginGroupSize - 1{|}) div 2;
end;

function TdxBarXPPainter.BarBeginGroupSize: Integer;
begin
  Result := FdxBarXPPainterParams.BarBeginGroupSize;
end;

class function TdxBarXPPainter.BarBorderSize: Integer;
begin
  Result := 0;
end;

procedure TdxBarXPPainter.BarCaptionFillBackground(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AToolbarBrush: HBRUSH);
const
  CaptionBkColors: array[Boolean] of Integer =
    (COLOR_INACTIVECAPTION, COLOR_ACTIVECAPTION);
//const
//  CaptionStates: array[Boolean] of Integer = (CS_INACTIVE, CS_ACTIVE);
//var
//  ATheme: TdxTheme;
begin
//  ATheme := OpenTheme(totWindow);
//  DrawThemeBackground(ATheme, DC, WP_SMALLCAPTION,
//    CaptionStates[ABarControl.BarManager.MainFormActive], @R);
  FillRect(DC, R, GetSysColorBrush(CaptionBkColors[ABarControl.BarManager.MainFormActive]));
end;

{class function TdxBarXPPainter.BarCaptionSize: Integer;
var
  ATheme: TdxTheme;
  ASize: TSize;
begin
  ATheme := OpenTheme(totWindow);
  GetThemePartSize(ATheme, 0, WP_SMALLCAPTION, CS_ACTIVE, TS_TRUE, ASize);
  Result := ASize.cy;
end;}

class function TdxBarXPPainter.BarCaptionTransparent: Boolean;
begin
  Result := True;
end;

class function TdxBarXPPainter.BarCloseButtonSize: TSize;
begin
  Result := FdxBarXPPainterParams.BarCloseButtonSize;
end;

procedure TdxBarXPPainter.BarDrawBeginGroup(ABarControl: TCustomdxBarControl;
  DC: HDC; ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean);
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totToolBar);
  // * IsThemeBackgroundPartiallyTransparent
  ABarControl.FillBackground(DC, ABeginGroupRect, AToolbarBrush, clNone, True);
  if AHorz then
    DrawThemeBackground(ATheme, DC, TP_SEPARATORVERT, TS_NORMAL, ABeginGroupRect)
  else
    DrawThemeBackground(ATheme, DC, TP_SEPARATOR, TS_NORMAL, ABeginGroupRect);
end;

procedure TdxBarXPPainter.BarDrawCloseButton(ABarControl: TdxBarControl;
  DC: HDC; R: TRect);
const
  ButtonStates: array [TdxBarMarkState] of Integer = (CBS_NORMAL, CBS_HOT, CBS_PUSHED);
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totWindow);
  // FillTransparent is not needed (BarCaptionTransparent)
  DrawThemeBackground(ATheme, DC, WP_SMALLCLOSEBUTTON, ButtonStates[ABarControl.CloseButtonState], R);
end;

procedure TdxBarXPPainter.BarDrawDockedBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AToolbarBrush: HBRUSH);
const
  Grippers: array[Boolean] of Integer = (RP_GRIPPER, RP_GRIPPERVERT);
var
  ATheme: TdxTheme;
begin
  InflateRect(R, -2, -2);
  if not ABarControl.CanMoving then Exit;
  ATheme := OpenTheme(totRebar);
  with R do
    if ABarControl.Horizontal then
    begin
      Inc(Left, BeforeFingersSize);
      Right := Left + GripperSize(ABarControl);
      InflateRect(R, 0, -0);
    end
    else
    begin
      Inc(Top, BeforeFingersSize);
      Bottom := Top + GripperSize(ABarControl);
      InflateRect(R, -0, 0);
    end;
  // FillTransparent is not needed (FillBackgroundRgn)
  DrawThemeBackground(ATheme, DC, Grippers[ABarControl.Vertical], CHEVS_NORMAL, R);
end;

procedure TdxBarXPPainter.BarDrawFloatingBarBorder(ABarControl: TdxBarControl;
  DC: HDC; R, CR: TRect; AToolbarBrush: HBRUSH);
begin
  dxBarFlatPainter.BarDrawFloatingBarBorder(ABarControl, DC, R, CR, AToolbarBrush);
end;

class function TdxBarXPPainter.StatusBarNativeGripSize(ABarManager: TdxBarManager): TSize;
begin
  Result := FdxBarXPPainterParams.StatusBarGripSize;
end;

procedure TdxBarXPPainter.BarDrawMDIButton(ABarControl: TdxBarControl;
  AButton: TdxBarMDIButton; AState: Integer; DC: HDC; R: TRect);
const
  Buttons: array[TdxBarMDIButton] of Integer =
    (WP_MDIMINBUTTON, WP_MDIRESTOREBUTTON, WP_MDICLOSEBUTTON);
  States: array[TdxBarMDIButton, 1..4] of Integer = (
    (MINBS_DISABLED, MINBS_HOT, MINBS_NORMAL, MINBS_PUSHED),
    (RBS_DISABLED, RBS_HOT, RBS_NORMAL, RBS_PUSHED),
    (CBS_DISABLED, CBS_HOT, CBS_NORMAL, CBS_PUSHED));
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totWindow);
  // * IsThemeBackgroundPartiallyTransparent
  // ABarControl.MDIButtonEnabled(AButton, MF_GRAYED)
  // MINBS_DISABLED, MINBS_HOT, MINBS_NORMAL, MINBS_PUSHED
  case AState of
    DXBAR_HOT:
      AState := 2;
    DXBAR_PRESSED:
      AState := 4;
    DXBAR_DISABLED:
      AState := 1;
  else{DXBAR_NORMAL, DXBAR_ACTIVE}
    AState := 3;
  end;
  ABarControl.FillBackground(DC, R, ABarControl.ToolbarBrush, clNone, True);
  DrawThemeBackground(ATheme, DC, Buttons[AButton], States[AButton, AState], R);
end;

class procedure TdxBarXPPainter.StatusBarFillNativeBackground(ABarControl: TdxBarControl;
  DC: HDC; ADestR, ASourceR, AWholeR: TRect; ABrush: HBRUSH; AColor: TColor);

  procedure FillBackgroundTempBitmap(ABitmap: TBitmap);
  var
    ATheme: TdxTheme;
  begin
    ATheme := OpenTheme(totStatus);
    with AWholeR do
    begin
      ABitmap.Width := Right - Left;
      ABitmap.Height := Bottom - Top;
    end;
    DrawThemeBackground(ATheme, ABitmap.Canvas.Handle, 0, 0, AWholeR);
  end;

begin
  if ABarControl.BackgroundTempBitmap.Empty then
    FillBackgroundTempBitmap(ABarControl.BackgroundTempBitmap);
  cxBitBlt(DC, ABarControl.BackgroundTempBitmap.Canvas.Handle, ADestR, ASourceR.TopLeft, SRCCOPY);
end;

class function TdxBarXPPainter.SubMenuControlArrowsOffset: Integer;
begin
  Result := 1;
end;

function TdxBarXPPainter.SubMenuControlBeginGroupRect(
  ABarSubMenuControl: TdxBarSubMenuControl; AControl: TdxBarItemControl;
  const AItemRect: TRect): TRect;
begin
  Result := AItemRect;
  Result.Bottom := Result.Top;
  Dec(Result.Top, ABarSubMenuControl.BeginGroupSize);
end;

function TdxBarXPPainter.SubMenuControlBeginGroupSize: Integer;
begin
  Result := FdxBarXPPainterParams.SubMenuControlBeginGroupSize;
end;

class function TdxBarXPPainter.SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := ABarSubMenuControl.DetachCaptionSize + 1;
end;

procedure TdxBarXPPainter.SubMenuControlDrawBeginGroup(ABarSubMenuControl: TdxBarSubMenuControl;
  AControl: TdxBarItemControl; ACanvas: TcxCanvas; const ABeginGroupRect: TRect);
begin
  // * IsThemeBackgroundPartiallyTransparent
  DrawBackground(AControl, ACanvas.Handle, ABeginGroupRect, ABarSubMenuControl.BkBrush,
    AControl.FNonRecent and not AControl.FChangeRecentGroup);
  SubMenuControlDrawSeparator(ACanvas, ABeginGroupRect)
end;

procedure TdxBarXPPainter.SubMenuControlDrawSeparator(ACanvas: TcxCanvas; const ARect: TRect);
begin
  DrawThemeBackground(OpenTheme(totToolBar), ACanvas.Handle, TP_SEPARATORVERT, TS_NORMAL, ARect);
end;

procedure TdxBarXPPainter.SubMenuControlDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect);
begin
  FrameRect(DC, R, GetSysColorBrush(COLOR_BTNSHADOW));
  if ABarSubMenuControl.Detachable then
  begin
    InflateRect(R, -1, -1);
    R.Bottom := R.Top + ABarSubMenuControl.DetachCaptionAreaSize + 1;
    FrameRect(DC, R, ABarSubMenuControl.ToolbarItemsBrush);
    SubMenuControlDrawDetachCaption(ABarSubMenuControl, DC, ABarSubMenuControl.DetachCaptionRect);
  end;
end;

procedure TdxBarXPPainter.SubMenuControlDrawClientBorder(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; const R: TRect; ABrush: HBRUSH);
begin
  FrameRect(DC, R, ABarSubMenuControl.ToolbarItemsBrush);
end;

class procedure TdxBarXPPainter.SubMenuControlOffsetDetachCaptionRect(ABarSubMenuControl: TdxBarSubMenuControl;
  var R: TRect);
begin
  InflateRect(R, -2, -2);
end;

class function TdxBarXPPainter.SubMenuControlToolbarItemsBrush(ABarSubMenuControl: TdxBarSubMenuControl): HBRUSH;
begin
  Result := GetSysColorBrush(COLOR_MENU);
end;

function TdxBarXPPainter.GetCustomColorButtonIndents(APaintType: TdxBarPaintType): TRect;
begin
  Result := Rect(1, 1, 1, 1);
end;

procedure TdxBarXPPainter.ColorComboDrawCustomButton(
  const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect);
begin
  with ADrawParams do
    DrawGlyphBorder(BarItemControl, Canvas.Handle, BarItemControl.Parent.BkBrush, True,
      ARect, ptHorz, True, DrawSelected, False, IsPressed, False, False);
  DrawDots(ADrawParams, ARect);
end;

procedure TdxBarXPPainter.ColorComboDrawCustomButtonAdjacentZone(
  const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect);
begin
  with ADrawParams do
    DrawBackgroundFrameRect(BarItemControl, Canvas.Handle, ARect, BarItemControl.Parent.BkBrush, False);
end;

class function TdxBarXPPainter.IsDateNavigatorFlat: Boolean;
begin
  Result := True;
end;

class procedure TdxBarXPPainter.DateNavigatorDrawNativeButton(ABarItem: TdxBarItem;
  DC: HDC; R: TRect; const ACaption: string; APressed: Boolean);
var
  ATheme: TdxTheme;
  AState: Integer;
  AOffset: Integer;
begin
  ATheme := OpenTheme(totToolbar);
  FillRect(DC, R, GetSysColorBrush(COLOR_WINDOW));
  if APressed then
  begin
    AState := TS_PRESSED;
    AOffset := 1;
  end
  else
  begin
    AState := TS_HOT;
    AOffset := 0;
  end;  
  DrawThemeBackground(ATheme, DC, TP_BUTTON, AState, R);
  DateNavigatorDrawButtonCaption(DC, R, AOffset, ACaption, False);
end;

procedure TdxBarXPPainter.DateNavigatorDrawButton(ABarItem: TdxBarItem;
  DC: HDC; R: TRect; const ACaption: string; APressed: Boolean);
begin
  DateNavigatorDrawNativeButton(ABarItem, DC, R, ACaption, APressed);
end;

class procedure TdxBarXPPainter.SysPanelDraw(AHandle: HWND;
  AllowResizing, MouseAboveCloseButton, CloseButtonIsTracking: Boolean;
  var CloseButtonRect, GripRect: TRect; Corner: TdxCorner);
var
  R, CR: TRect;
  B: Integer;
  BorderBrush: HBRUSH;
  DC: HDC;
  AStyle: Longint;
begin
  DC := GetWindowDC(AHandle);
  try
    R := cxGetWindowRect(AHandle);
    CloseButtonRect := R;
    GripRect := R;
    GetClientRect(AHandle, CR);
    MapWindowRect(0, AHandle, R);
    B := -R.Left;
    OffsetRect(CR, -R.Left, -R.Top);
    OffsetRect(R, -R.Left, -R.Top);

    BorderBrush := GetSysColorBrush(COLOR_BTNSHADOW);
    FrameRect(DC, R, BorderBrush);

    if not AllowResizing then
    begin
      SetRectEmpty(CloseButtonRect);
      SetRectEmpty(GripRect);
      Exit;
    end;

    InflateRect(R, -B, -B);
    if Corner in [coBottomLeft, coBottomRight] then
    begin
      R.Top := R.Bottom - SysPanelSize + 1;
      FillRect(DC, Rect(R.Left, R.Top - 1, R.Right, R.Top), BorderBrush);
    end
    else
    begin
      R.Bottom := R.Top + SysPanelSize - 1;
      FillRect(DC, Rect(R.Left, R.Bottom, R.Right, R.Bottom + 1), BorderBrush);
    end;

    CR := R;
    ThemeDrawSizeGrip(DC, CR, Corner); // TODO:
    with CR do
      ExcludeClipRect(DC, Left, Top, Right, Bottom);
    InflateRect(CR, 2, 2);
    if CR.Top < R.Top then CR.Top := R.Top;
    if CR.Bottom > R.Bottom then CR.Bottom := R.Bottom;
    OffsetRect(CR, GripRect.Left, GripRect.Top);
    GripRect := CR;

    CR := R;
    ThemeDrawCloseButton(DC, CR, MouseAboveCloseButton or CloseButtonIsTracking,
      MouseAboveCloseButton and CloseButtonIsTracking, Corner);

    with CR do
      ExcludeClipRect(DC, Left, Top, Right, Bottom);
    with CloseButtonRect do OffsetRect(CR, Left, Top);
    CloseButtonRect := CR;

    FillRect(DC, R, COLOR_BTNFACE + 1);
    if Corner in [coBottomLeft, coBottomRight] then
    begin
      AStyle := GetWindowLong(AHandle, GWL_STYLE);
      if (AStyle and WS_HSCROLL <> 0) and (AStyle and WS_VSCROLL <> 0) then
        with R do
        begin
          Left := Right - GetSystemMetrics(SM_CXVSCROLL);
          Bottom := Top - 1;
          Top := Bottom - GetSystemMetrics(SM_CYHSCROLL);
          FillRect(DC, R, GetSysColorBrush(COLOR_BTNFACE));
        end;
    end;
  finally
    ReleaseDC(AHandle, DC);
  end;
end;

class function TdxBarXPPainter.SysPanelSize: Integer;
var
  ASizeGripSize: Integer;
begin
  Result := ThemeCloseButtonSize.cy + 2 * 2;
  ASizeGripSize := ThemeSizeGripSize.cy + 1;
  if Result < ASizeGripSize  then
    Result := ASizeGripSize;
end;

procedure TdxBarXPPainter.SpinEditControlDrawButton(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer);
const
  AThemePartId: array [Boolean] of Integer = (SPNP_DOWN, SPNP_UP);
  AThemeSpinState: array[TcxButtonState] of Integer = (UPS_NORMAL, UPS_NORMAL, UPS_HOT, UPS_PRESSED, UPS_DISABLED);
begin
  with ADrawParams do
  begin
    // * IsThemeBackgroundPartiallyTransparent
    DrawBackground(BarEditControl, Canvas.Handle, ARect, BarEditControl.Parent.BkBrush, False);
    DrawThemeBackground(OpenTheme(totSpin), Canvas.Handle, AThemePartId[AButtonIndex = secButtonUp],
      AThemeSpinState[GetSpinEditButtonState(ADrawParams, AButtonIndex)], ARect);
  end;
end;

function TdxBarXPPainter.GetSpinEditButtonIndents(APaintType: TdxBarPaintType): TRect;
begin
  Result := cxEmptyRect;
end;

class function TdxBarXPPainter.ProgressControlBarBrushColor: TColorRef;
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totProgress);
  if FAILED(GetThemeColor(ATheme, PP_CHUNK, 0, TMT_FILLCOLOR, Result)) then
    Result := inherited ProgressControlBarBrushColor;
end;

function TdxBarXPPainter.ProgressControlBarHeight(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := FdxBarXPPainterParams.ProgressControlBarHeight;
end;

procedure TdxBarXPPainter.ProgressControlDrawBackground(const ADrawParams: TdxBarItemControlDrawParams; var BarR: TRect);
const
  BarParts: array[Boolean] of Integer = (PP_BAR, PP_BARVERT);
var
  ATheme: TdxTheme;
  ABarPartId: Integer;
begin
  with ADrawParams do
  begin
    ATheme := OpenTheme(totProgress);
    ABarPartId := BarParts[PaintType = ptVert];
    if IsThemeBackgroundPartiallyTransparent(ATheme, ABarPartId, 0) then
      DrawBackground(BarItemControl, Canvas.Handle, BarR, BarItemControl.Parent.BkBrush, False);
    DrawThemeBackground(ATheme, Canvas.Handle, ABarPartId, 0, BarR);
    GetThemeBackgroundContentRect(ATheme, Canvas.Handle, ABarPartId, 0, BarR, BarR);
  end;
end;

procedure TdxBarXPPainter.ProgressControlDrawChunks(const ADrawParams: TdxBarItemControlDrawParams; BarR: TRect; ABarBrush: HBRUSH);
const
  ChunkParts: array[Boolean] of Integer = (PP_CHUNK, PP_CHUNKVERT);
var
  ATheme: TdxTheme;
  AChunkPartId: Integer;
begin
  ATheme := OpenTheme(totProgress);
  AChunkPartId := ChunkParts[ADrawParams.PaintType = ptVert];
  DrawThemeBackground(ATheme, ADrawParams.Canvas.Handle, AChunkPartId, 0, @BarR);
end;

function TdxBarXPPainter.EditGetEnabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF;
begin
  Result := ThemeEditColor(OpenTheme(totEdit), ETS_NORMAL);
end;

function TdxBarXPPainter.EditGetDisabledBkColor(ABarItemControl: TdxBarCustomEditControl): COLORREF;
begin
  Result := ThemeEditColor(OpenTheme(totEdit), ETS_DISABLED);
end;

function TdxBarXPPainter.EditGetEnabledTextColor: COLORREF;
begin
  Result := ThemeEditTextColor(OpenTheme(totEdit), ETS_NORMAL);
end;

function TdxBarXPPainter.EditGetDisabledTextColor: COLORREF;
begin
  Result := ThemeEditTextColor(OpenTheme(totEdit), ETS_DISABLED);
end;

function TdxBarXPPainter.SubMenuGetSeparatorSize: Integer;
begin
  Result := FdxBarXPPainterParams.SubMenuControlBeginGroupSize;
end;

class function TdxBarXPPainter.IsQuickControlPopupOnRight: Boolean;
begin
  Result := True;
end;

function TdxBarXPPainter.IsButtonControlArrowFlat: Boolean;
begin
  Result := True;
end;

function TdxBarXPPainter.GetButtonBorderHeight: Integer;
begin
  Result := FdxBarXPPainterParams.ButtonBorderHeight;
end;

function TdxBarXPPainter.GetButtonBorderWidth: Integer;
begin
  Result := GetButtonBorderHeight;
end;

class procedure TdxBarXPPainter.CorrectButtonControlDefaultHeight(var DefaultHeight: Integer);
begin
//  Inc(DefaultHeight, 2); // TODO: check!!!
  Inc(DefaultHeight, 1);
end;

procedure TdxBarXPPainter.DrawButtonControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams;
  R1: TRect);
begin
  if ADrawParams.PaintType = ptMenu then
    inherited;
end;

procedure TdxBarXPPainter.DrawButtonControlArrowBackground(const ADrawParams: TdxBarButtonLikeControlDrawParams;
  var R1: TRect; ABrush: HBRUSH);

  function GetState: Integer;
  begin
    with ADrawParams do
      if not (Enabled and DropDownEnabled) then
        Result := TS_DISABLED
      else
        if DroppedDown or IsArrowButtonDowned(PaintType, IsPressed) then
          Result := TS_PRESSED
        else
          if Downed and (PaintType <> ptMenu) then
            Result := TS_CHECKED
          else
            if DrawSelected then
              Result := TS_HOT
            else
              Result := TS_NORMAL;
  end;

var
  ATheme: TdxTheme;
begin
  inherited;
  with ADrawParams do
  begin
    ATheme := OpenTheme(totToolBar);
    // * IsThemeBackgroundPartiallyTransparent
    if PaintType = ptMenu then
      DrawThemeBackground(ATheme, Canvas.Handle, TP_BUTTON, GetState, R1)
    else
      DrawThemeBackground(ATheme, Canvas.Handle, TP_SPLITBUTTONDROPDOWN, GetState, R1);
  end;
end;

class function TdxBarXPPainter.EditControlBorderOffsets(APaintType: TdxBarPaintType): TRect;
begin
  Result := FdxBarXPPainterParams.EditControlBorderOffsets;
end;

procedure TdxBarXPPainter.EditControlDrawBorder(
  const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect);
var
  ATheme: TdxTheme;
  AClipRgn: HRGN;
  AClipRgnExists: Boolean;
  AEditState: Integer;
  R: TRect;
begin
  with ADrawParams do
  begin
    ATheme := OpenTheme(totEdit);
    AEditState := ThemeEditState(BarEditControl);
    R := ARect;
    GetThemeBackgroundContentRect(ATheme, Canvas.Handle, EP_EDITTEXT, AEditState, R, ARect);
    SaveClipRgn(Canvas.Handle, AClipRgn, AClipRgnExists);
    with ARect do
      ExcludeClipRect(Canvas.Handle, Left, Top, Right, Bottom);
    if (not Enabled or (PaintType = ptMenu)) and not IsTransparent or DrawSelected then
      DrawThemeBackground(ATheme, Canvas.Handle, EP_EDITTEXT, AEditState, R)
    else
      DrawBackground(BarEditControl, Canvas.Handle, R, BarEditControl.Parent.BkBrush, BarEditControl.FNonRecent);
    RestoreClipRgn(Canvas.Handle, AClipRgn, AClipRgnExists);
  end;
end;

class function TdxBarXPPainter.EditControlCaptionRightIndentIsOpaque(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  with ADrawParams do
    Result := (PaintType = ptMenu) and (DrawSelected or BarItemControl.FNonRecent);
end;

class function TdxBarXPPainter.EditControlCaptionAbsoluteLeftIndent(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Integer;
begin
  Result := 6;
end;

class function TdxBarXPPainter.EditControlCaptionRightIndent: Integer;
begin
  Result := 5;
end;

class function TdxBarXPPainter.EditControlSubMenuGlyphIndents(
  const ADrawParams: TdxBarEditLikeControlDrawParams): TRect;
begin
  Result := Rect(5, 0, 0, 0);
end;

class function TdxBarXPPainter.EditControlGetRightCaptionIndentBrush(ABarEditControl: TdxBarCustomEditControl): HBRUSH;
begin
  Result := ABarEditControl.CaptionBkBrush;
end;

class procedure TdxBarXPPainter.CustomComboDrawItem(ABarCustomCombo: TdxBarCustomCombo;
  ACanvas: TCanvas; AIndex: Integer; ARect: TRect; AState: TOwnerDrawState;
  AInteriorIsDrawing: Boolean);
begin
  TdxBarFlatPainter.CustomComboDrawItem(ABarCustomCombo, ACanvas,
    AIndex, ARect, AState, AInteriorIsDrawing);
end;

class function TdxBarXPPainter.ComboControlArrowOffset: Integer;
begin
  Result := 0;
end;

procedure TdxBarXPPainter.ComboControlDrawArrowButton(
  const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect;
  AInClientArea: Boolean);

  function GetState: Integer;
  begin
    with ADrawParams do
      if not Enabled then
        Result := CBXS_DISABLED
      else
        if DroppedDown then
          Result := CBXS_PRESSED
        else
          if DrawSelected then
            Result := CBXS_HOT
          else
            Result := CBXS_NORMAL;
  end;

var
  AButtonState: Integer;
begin
  AButtonState := GetState;
  if IsThemeBackgroundPartiallyTransparent(OpenTheme(totComboBox),
    CP_DROPDOWNBUTTON, AButtonState) then
    FillRectByColor(ADrawParams.Canvas.Handle, ARect, EditGetBkColor(ADrawParams));
  DrawThemeBackground(OpenTheme(totComboBox), ADrawParams.Canvas.Handle,
    CP_DROPDOWNBUTTON, AButtonState, ARect);
end;

procedure TdxBarXPPainter.DrawGlyphBorder(ABarItemControl: TdxBarItemControl;
  DC: HDC; ABrush: HBRUSH; NeedBorder: Boolean; R: TRect; PaintType: TdxBarPaintType; IsGlyphEmpty,
  Selected, Down, DrawDowned, ADroppedDown, IsSplit: Boolean);
var
  ATheme: TdxTheme;
  AState: Integer;
begin
  ATheme := OpenTheme(totToolBar);
  // * IsThemeBackgroundPartiallyTransparent
  if (PaintType = ptMenu) and (Selected or ABarItemControl.FNonRecent) and
    IsGlyphEmpty and not Down or ABarItemControl.IsBkColorAssigned then
      FillRect(DC, R, ABrush)
  else
  begin
    DrawBackground(ABarItemControl, DC, R, ABrush, False);
    if IsMenuItem(ABarItemControl) and (PaintType <> ptMenu) and
      (Selected or DrawDowned or Down or ADroppedDown) then
      FillRect(DC, R, GetSysColorBrush(COLOR_HIGHLIGHT)) // ***
    else
    begin
      if not ABarItemControl.Enabled then
        AState := TS_DISABLED
      else
        if DrawDowned then
          AState := TS_PRESSED
        else
          if Down or ADroppedDown and not IsSplit then
            AState := TS_CHECKED
          else
            if Selected then
              AState := TS_HOT
            else
              AState := TS_NORMAL;

      if IsSplit then
        DrawThemeBackground(ATheme, DC, TP_SPLITBUTTON, AState, R)
      else
        DrawThemeBackground(ATheme, DC, TP_BUTTON, AState, R);
    end;
  end;
end;

procedure TdxBarXPPainter.DrawGlyphCheckMark(ABarItemControl: TdxBarItemControl;
  DC: HDC; X, Y, DoubleSize: Integer);
begin
  dxBarFlatPainter.DrawGlyphCheckMark(ABarItemControl, DC, X, Y, DoubleSize);
end;

class function TdxBarXPPainter.GetFaded(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := True;
end;

class function TdxBarXPPainter.IsMenuItem(ABarItemControl: TdxBarItemControl): Boolean;
begin
  Result := ABarItemControl.IsMenuItem;
end;

class procedure TdxBarXPPainter.BarDrawNativeGrip(ABarControl: TdxBarControl;
  DC: HDC; R: TRect; AToolbarBrush: HBRUSH);
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totStatus);
  // * IsThemeBackgroundPartiallyTransparent
  DrawThemeBackground(ATheme, DC, SP_GRIPPER, 0, R);
end;

procedure TdxBarXPPainter.BarDrawMarkBackground(ABarControl: TdxBarControl;
  DC: HDC; ItemRect: TRect; AToolbarBrush: HBRUSH);
const
  States: array[TdxBarMarkState] of Integer =
    (TS_NORMAL, TS_HOT, TS_PRESSED);
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totToolbar);
  // * IsThemeBackgroundPartiallyTransparent
  ABarControl.FillBackground(DC, ItemRect, AToolbarBrush, clNone, True);
  if ABarControl.Bar.BorderStyle = bbsNone then
  begin
    if ABarControl.Horizontal then
      InflateRect(ItemRect, 0, -2)
    else
      InflateRect(ItemRect, -2, 0);
  end;
  DrawThemeBackground(ATheme, DC, TP_BUTTON, States[ABarControl.MarkDrawState], ItemRect);
end;

class procedure TdxBarXPPainter.BarOffsetFloatingBarCaption(ABarControl: TdxBarControl;
  var X: Integer; var R: TRect);
begin
  Inc(X, 2);
  R.Right := ABarControl.MarkNCRect.Left;
end;

function TdxBarXPPainter.GetDotSpaceAfter(ADotWidth: Integer): Integer;
begin
  Result := ADotWidth * 2;
end;

procedure TdxBarXPPainter.DrawDot(const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect);
begin
  if ADrawParams.Enabled then
    FillRect(ADrawParams.Canvas.Handle, ARect, COLOR_BTNTEXT + 1)
  else
    inherited;
end;

procedure TdxBarXPPainter.BarBeginGroupSizeInit;
var
  ATheme: TdxTheme;
  ASize: TSize;
begin
  ATheme := OpenTheme(totToolBar);
  GetThemePartSize(ATheme, 0, TP_SEPARATOR, TS_NORMAL, TS_MIN, ASize);
  FdxBarXPPainterParams.BarBeginGroupSize := ASize.cx;
end;

procedure TdxBarXPPainter.BarCloseButtonSizeInit;
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totWindow);
  GetThemePartSize(ATheme, 0, WP_SMALLCLOSEBUTTON, CBS_NORMAL, TS_TRUE, FdxBarXPPainterParams.BarCloseButtonSize);
end;

procedure TdxBarXPPainter.ButtonBorderHeightInit;
var
  R, RC: TRect;
begin
  R := Rect(0, 0, 100, 100);
  GetThemeBackgroundContentRect(OpenTheme(totToolBar), 0, TP_SPLITBUTTON, TS_NORMAL, R, RC); // ?
  FdxBarXPPainterParams.ButtonBorderHeight := cxRectHeight(R) - cxRectHeight(RC);
end;

procedure TdxBarXPPainter.ComboBoxArrowWidthInit;
var
  ATheme: TdxTheme;
  ASize: TSize;
begin
  ATheme := OpenTheme(totComboBox);
  GetThemePartSize(ATheme, 0, CP_DROPDOWNBUTTON, CBXS_NORMAL, TS_TRUE, ASize);
  FdxBarXPPainterParams.ComboBoxArrowWidth := ASize.cx;
end;

procedure TdxBarXPPainter.EditControlBorderOffsetsInit;
var
  AContentRect, R: TRect;
begin
  R := Rect(0, 0, 100, 100);
  GetThemeBackgroundContentRect(OpenTheme(totEdit), 0, EP_EDITTEXT, ETS_NORMAL, R, AContentRect);
  FdxBarXPPainterParams.EditControlBorderOffsets := Rect(AContentRect.Left, AContentRect.Top,
    R.Right - AContentRect.Right, R.Bottom - AContentRect.Bottom);
end;

procedure TdxBarXPPainter.GripperSizeInit;
var
  ATheme: TdxTheme;
  ASize: TSize;
begin
  ATheme := OpenTheme(totRebar);
  GetThemePartSize(ATheme, 0, RP_GRIPPER, CHEVS_NORMAL, TS_TRUE, ASize);
  FdxBarXPPainterParams.GripperSize := ASize.cx;
end;

procedure TdxBarXPPainter.InitParams;
begin
  BarBeginGroupSizeInit;
  BarCloseButtonSizeInit;
  ButtonBorderHeightInit;
  ComboBoxArrowWidthInit;
  EditControlBorderOffsetsInit;
  GripperSizeInit;
  ProgressControlBarHeightInit;
  SubMenuControlBeginGroupSizeInit;
  StatusBarGripSizeInit;
end;

procedure TdxBarXPPainter.ProgressControlBarHeightInit;
var
  ATheme: TdxTheme;
  ASize: TSize;
  R, CR: TRect;
begin
  ATheme := OpenTheme(totProgress);
  GetThemePartSize(ATheme, 0, PP_CHUNK, 0, TS_TRUE, ASize);
  GetThemeBackgroundContentRect(ATheme, 0, PP_BAR, 0, R, CR);
  FdxBarXPPainterParams.ProgressControlBarHeight := ASize.cy + (R.Right - R.Left) - (CR.Right - CR.Left);
end;

procedure TdxBarXPPainter.StatusBarGripSizeInit;
var
  ATheme: TdxTheme;
begin
  ATheme := OpenTheme(totStatus);
  GetThemePartSize(ATheme, 0, SP_GRIPPER, 0, TS_TRUE, FdxBarXPPainterParams.StatusBarGripSize);
end;

procedure TdxBarXPPainter.SubMenuControlBeginGroupSizeInit;
var
  ATheme: TdxTheme;
  ASize: TSize;
begin
  ATheme := OpenTheme(totToolBar);
  GetThemePartSize(ATheme, 0, TP_SEPARATORVERT, TS_NORMAL, TS_TRUE, ASize);
  FdxBarXPPainterParams.SubMenuControlBeginGroupSize := ASize.cy;
end;

class function TdxBarXPPainter.IsArrowButtonDowned(APaintStyle: TdxBarPaintType; AIsPressed: Boolean): Boolean;
begin
  Result := (APaintStyle <> ptMenu) and AIsPressed;
end;

{ TdxBarSkinnedPainter }

constructor TdxBarSkinnedPainter.Create(AData: Integer);
begin
  inherited Create(AData);
  FSkinnedObject := TObject(AData);
end;

procedure TdxBarSkinnedPainter.CalculateButtonParts(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; var AParts: array of TRect; const AItemRect: TRect);
var
  ACaptionHeight: Integer;
begin
  if ADrawParams.IsDropDown then
  begin
    if (ADrawParams.PaintType = ptMenu) or (ADrawParams.ViewSize = cvsSmall) then
      inherited
    else
    begin
      ACaptionHeight := cxRectHeight(cxGetTextRect(ADrawParams.Canvas.Handle, ADrawParams.Caption, GetMaxLineCount, True)) + 2{!!!};
      AParts[bcpDropButton].Top := AParts[bcpDropButton].Bottom - ACaptionHeight;
      AParts[bcpButton].Bottom := AParts[bcpDropButton].Top;
    end;
  end;
end;

procedure TdxBarSkinnedPainter.CalculateSpinEditParts(const ADrawParams: TdxBarSpinEditDrawParams;
  var AParts: array of TRect; const AItemRect: TRect);
begin
  inherited;
  Dec(AParts[secButtonUp].Bottom);
  AParts[ecpEdit].Right := AParts[secButtonUp].Left;
end;

procedure TdxBarSkinnedPainter.DrawArrow(ADC: HDC; ARect: TRect; AArrowState: Integer);
begin
  Inc(ARect.Left, (cxRectWidth(ARect) div 2) - (GetDefaultArrowSignSize.cx div 2));
  Inc(ARect.Top, (cxRectHeight(ARect) div 2) - (GetDefaultArrowSignSize.cy div 2));
  ARect.Right := ARect.Left + GetDefaultArrowSignSize.cx;
  ARect.Bottom := ARect.Top + GetDefaultArrowSignSize.cy;
  Skin.DrawBackground(ADC, ARect, DXBAR_ARROWDOWN, AArrowState);
end;

class function TdxBarSkinnedPainter.GetDefaultTextSize(ACanvas: TcxCanvas): Integer;
begin
  Result := ACanvas.TextHeight('Wg') + 3;
end;

procedure TdxBarSkinnedPainter.DrawItemBackgroundInSubMenu(const ADrawParams: TdxBarButtonLikeControlDrawParams; R: TRect);

  procedure InternalDrawBackground(AControlPart, ASkinPart: Integer);

    function InternalGetPartState: Integer;
    begin
      if (AControlPart = bcpDropButton) and ADrawParams.DroppedDown or
        (AControlPart = bcpButton) and ADrawParams.DrawSelected and (ADrawParams.ViewSize <> cvsLarge) then
        Result := DXBAR_HOT
      else
        Result := GetPartState(ADrawParams, AControlPart);
    end;

  begin
    Skin.DrawBackground(ADrawParams.Canvas.Handle,
      ADrawParams.BarItemControl.FParts[AControlPart], ASkinPart, InternalGetPartState);
  end;

var
  AButtonPart, AGlyphPart, ADropButtonPart: Integer;
begin
  with ADrawParams do
  begin
    DrawBackground(BarItemControl, Canvas.Handle, R, 0, False);
    if DrawSelected then
    begin
      AButtonPart := DXBAR_SMALLBUTTON;
      AGlyphPart := DXBAR_SMALLBUTTON_GLYPH;
      ADropButtonPart := DXBAR_SMALLBUTTON_DROPBUTTON;

      if SplitDropDown and IsDropDown then
      begin
        InternalDrawBackground(bcpButton, AGlyphPart);
        InternalDrawBackground(bcpDropButton, ADropButtonPart);
      end
      else
        InternalDrawBackground(bcpButton, AButtonPart);
    end;
  end;
end;

procedure TdxBarSkinnedPainter.DrawGlyphAndBkgnd(
  ABarItemControl: TdxBarItemControl; ADC: HDC;
  const R, AGlyphRect: TRect; APaintType: TdxBarPaintType; AGlyph: TBitmap;
  AImages: TCustomImageList; AImageIndex: Integer; AGlyphEmpty, ASelected, ADowned,
  ADrawDowned, ADroppedDown, AForceUseBkBrush, AGrayScale, AIsSplit: Boolean);
var
  ACheckSize: Integer;
  ACheckRect: TRect;
  AState: Integer;
begin
  if (APaintType = ptMenu) and ADowned then
  begin
    if ABarItemControl.Enabled then
      AState := DXBAR_NORMAL
    else
      AState := DXBAR_DISABLED;
    ACheckSize := Min(cxRectWidth(R), cxRectHeight(R));
    ACheckRect := cxRectCenter(R, cxSize(ACheckSize, ACheckSize));
    InflateRect(ACheckRect, -1, -1);
    if AGlyphEmpty then
      Skin.DrawBackground(ADC, ACheckRect, DXBAR_MENUCHECKMARK, AState)
    else
      Skin.DrawBackground(ADC, ACheckRect, DXBAR_MENUCHECK, AState);
  end;
  if not AGlyphEmpty then
    TransparentDraw(ABarItemControl, ADC, 0, R, AGlyphRect,
      AGlyph, AImages, AImageIndex, ABarItemControl.BarManager.ImageListBkColor,
      ABarItemControl.GetImageEnabled(APaintType), AGrayScale, False {Flat}, ASelected, ADowned, ADrawDowned,
      False{Shadow}, GetFaded(ABarItemControl.Parent){Faded},
      ABarItemControl.BarManager.ImageOptions.SmoothGlyphs,
      ABarItemControl.BarManager.ImageOptions.UseLeftBottomPixelAsTransparent);
end;

function TdxBarSkinnedPainter.GetToolbarContentOffsets(ABar: TdxBar;
  ADockingStyle: TdxBarDockingStyle; AHasSizeGrip: Boolean): TRect;
begin
  Result := Skin.GetContentOffsets(DXBAR_TOOLBAR);
end;

function TdxBarSkinnedPainter.GetToolbarsOffsetForAutoAlign: Integer;
begin
  Result := Skin.GetPartOffset(DXBAR_TOOLBAR);
end;

class function TdxBarSkinnedPainter.RealButtonArrowWidth(ABarManager: TdxBarManager): Integer;
begin
  Result := 13;
end;

class function TdxBarSkinnedPainter.LoweredBorderSize(ABarItemControl: TdxBarItemControl): Integer;
begin
  Result := 0;
end;

function TdxBarSkinnedPainter.BarLinkedOwnerHasShadow(ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := False;
end;

procedure TdxBarSkinnedPainter.BarDrawBackground(ABarControl: TdxBarControl; ADC: HDC;
  const ADestRect, ASourceRect: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  BarCanvas.BeginPaint(ADC);
  try
    BarCanvas.SetClipRegion(TcxRegion.Create(ADestRect), roIntersect);
    DrawToolbarContentPart(ABarControl, BarCanvas);
  finally
    BarCanvas.EndPaint;
  end;
end;

procedure TdxBarSkinnedPainter.BarDrawDockedBackground(
  ABarControl: TdxBarControl; DC: HDC; ADestR, ASourceR: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  Skin.DrawBackground(DC, ADestR, DXBAR_TOOLBAR, GetBarControlState(ABarControl));
end;

function TdxBarSkinnedPainter.ComboBoxArrowWidth(ABarControl: TCustomdxBarControl; cX: Integer): Integer;
begin
  if Skin.GetName <> '' then
    Result := 19
  else
    Result := cX + 8;
end;

class procedure TdxBarSkinnedPainter.SetWindowRgn(AHandle: THandle;
  const AWindowRect: TRect; ARedraw: Boolean = False);
var
  ARegion: HRGN;
begin
  with AWindowRect do
    ARegion := CreateRoundRectRgn(0, 0, Right + 1, Bottom + 1, 2, 2);
  Windows.SetWindowRgn(AHandle, ARegion, ARedraw);
end;

procedure TdxBarSkinnedPainter.BarDrawBeginGroup(
  ABarControl: TCustomdxBarControl; DC: HDC; ABeginGroupRect: TRect;
  AToolbarBrush: HBRUSH; AHorz: Boolean);
begin
  InternalDrawBeginGroup(DC, ABeginGroupRect, AHorz, $EBE8E6, $AAA6A2);
end;

class function TdxBarSkinnedPainter.GetTailAreaSize(const ADrawParams: TdxBarItemControlDrawParams): Integer;
begin
  if ADrawParams.ViewSize = cvsLarge then
    Result := ADrawParams.BarItemControl.Parent.TextSize
  else
    Result := inherited GetTailAreaSize(ADrawParams);
end;

function TdxBarSkinnedPainter.GetButtonBorderHeight: Integer;
begin
  with Skin.GetContentOffsets(DXBAR_SMALLBUTTON) do
    Result := Top + Bottom;
end;

function TdxBarSkinnedPainter.GetButtonBorderWidth: Integer;
begin
  with Skin.GetContentOffsets(DXBAR_SMALLBUTTON) do
    Result := Left + Right;
end;

function TdxBarSkinnedPainter.GetButtonHeight(AIconSize, ATextSize: Integer): Integer;
begin
  Result := Max(GetSmallIconSize, ATextSize) + GetButtonBorderHeight;
  if Odd(Result) then
    Inc(Result);
end;

function TdxBarSkinnedPainter.GetButtonWidth(AIconSize, ATextSize: Integer): Integer;
begin
  Result := Max(GetSmallIconSize, ATextSize) + GetButtonBorderWidth;
  if Odd(Result) then
    Inc(Result);
end;

class procedure TdxBarSkinnedPainter.CorrectButtonControlDefaultHeight(var DefaultHeight: Integer);
begin
// do nothing
end;

procedure TdxBarSkinnedPainter.DrawButtonLikeControl(
  const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect);
var
  AImageBounds: TRect;
begin
  with ADrawParams do
  begin
    if PaintType = ptMenu then
      DrawGlyphAndTextInSubMenu(ADrawParams, ARect)
    else
    begin
      if BarItemControl.FadingElementData = nil then
        DrawButtonBackground(ADrawParams)
      else
        BarItemControl.FadingElementData.DrawImage(Canvas.Handle, ARect);
        
      DrawGlyph(BarItemControl, Canvas.Handle, ARect, ARect, AImageBounds,
        PaintType, ViewStructure, ViewSize, not (cpIcon in ViewStructure),
        DrawSelected, Downed, DrawDowned, DroppedDown, False, False, False,
        SplitDropDown and IsDropDown);

      DrawButtonLikeControlCaption(ADrawParams, ARect, AImageBounds);
    end;
    if IsDropDown and not IsMenuItem then
      if SplitDropDown then
        DrawSplitControlArrow(ADrawParams, ARect)
      else
        DrawAssociateControlArrow(ADrawParams, ARect);
  end;
end;

procedure TdxBarSkinnedPainter.DrawButtonControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; R1: TRect);
begin
  if ADrawParams.PaintType = ptMenu then
    ButtonLikeControlDrawMenuArrow(ADrawParams, adRight, R1)
  else
    if ADrawParams.ViewSize <> cvsLarge then
      DrawArrow(ADrawParams.Canvas.Handle, GetArrowRect(ADrawParams, R1), GetButtonPartState(ADrawParams, bcpDropButton));
end;

procedure TdxBarSkinnedPainter.DrawSplitControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect);
var
  ARatio: Double;
begin
  DrawButtonControlArrow(ADrawParams, ARect);

  if (ADrawParams.PaintType = ptMenu) and (ADrawParams.ViewSize <> cvsLarge) and not ADrawParams.DrawSelected then
  begin
    ARect := GetArrowRect(ADrawParams, ARect);
    ARatio := Max(1, cxRectHeight(ARect) / SubMenuControlNormalItemHeight);
    InflateRect(ARect, 0, -Round((cxRectHeight(ARect) - 14 * ARatio) / 2));
    ADrawParams.Canvas.DrawComplexFrame(ARect, Skin.GetPartColor(DXBAR_MENUARROWSEPARATOR), clNone, [bLeft]);
  end;
end;

procedure TdxBarSkinnedPainter.DrawAssociateControlArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ARect: TRect);
begin
  DrawButtonControlArrow(ADrawParams, ARect);
end;

function TdxBarSkinnedPainter.GetBorderSize: Integer;
begin
  Result := 2;
end;

function TdxBarSkinnedPainter.GetIconAreaSize(ABarControl: TCustomdxBarControl): Integer;
begin
  Result := inherited GetIconAreaSize(ABarControl);
  if (ABarControl.Kind = bkSubMenu) and (ABarControl.ItemLinks.ItemSize = misNormal) then
    Inc(Result, MenuSeparatorSize); 
end;

procedure TdxBarSkinnedPainter.CorrectCaptionParams(
  const ADrawParams: TdxBarButtonLikeControlDrawParams;
  var ATextBounds: TRect; const AImageBounds: TRect; out ATextAlignment: DWORD);
var
  ACaptionRect: TRect;
begin
  ACaptionRect := GetControlCaptionRect(ADrawParams);
  if ADrawParams.ViewSize = cvsLarge then
  begin
    OffsetRect(ACaptionRect,
      ATextBounds.Left + (cxRectWidth(ATextBounds) - cxRectWidth(ACaptionRect)) div 2,
      ATextBounds.Top + cxRectHeight(ATextBounds) - (cxRectHeight(ACaptionRect) + 1));
      ATextBounds := ACaptionRect;
    ATextAlignment := DT_CENTER;
  end
  else
  begin
    if cpIcon in ADrawParams.ViewStructure then
      ATextBounds.Left := AImageBounds.Right + GetControlTextIndents.Left
    else
      ATextBounds.Left := ATextBounds.Left + ADrawParams.BarItemControl.GetControlCaptionOffset;
    InflateRect(ATextBounds, 0, -(cxRectHeight(ATextBounds) - cxRectHeight(ACaptionRect)) div 2);
    ATextAlignment := DT_LEFT;
  end;
end;

function TdxBarSkinnedPainter.AllowLargeIcons: Boolean;
begin
  Result := False;
end;

procedure TdxBarSkinnedPainter.BarDrawMarkElements(
  ABarControl: TdxBarControl; DC: HDC; ItemRect: TRect);

  function GetMarkState: Integer;
  begin
    case ABarControl.MarkDrawState of
      msSelected: Result := DXBAR_HOT;
      msPressed: Result := DXBAR_PRESSED;
    else {msNone}
      Result := DXBAR_NORMAL;
    end;
  end;

begin
  if ABarControl.FTruncated then
    Skin.DrawBackground(DC, ItemRect, DXBAR_MARKTRUNCATED, GetMarkState)
  else
    Skin.DrawBackground(DC, ItemRect, DXBAR_MARKARROW, GetMarkState);
end;

procedure TdxBarSkinnedPainter.DropDownListBoxDrawBorder(DC: HDC; AColor: TColor; ARect: TRect);
begin
  Skin.DrawBackground(DC, ARect, DXBAR_DROPDOWNBORDER, DXBAR_NORMAL);
end;

class function TdxBarSkinnedPainter.SubMenuControlHasBand: Boolean;
begin
  Result := True;
end;

class function TdxBarSkinnedPainter.SubMenuControlArrowWidth(ATextSize: Integer): Integer;
begin
  Result := ATextSize;
end;

function TdxBarSkinnedPainter.SubMenuControlBeginGroupSize: Integer;
begin
  Result := 3;
end;

class function TdxBarSkinnedPainter.SubMenuControlDetachCaptionAreaSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := 2 + ABarSubMenuControl.DetachCaptionSize + 1;
end;

class function TdxBarSkinnedPainter.SubMenuControlGetItemIconRect(const AItemRect: TRect; AIconAreaSize: Integer): TRect;
begin
  Result := TdxBarPainter.SubMenuControlGetItemIconRect(AItemRect, AIconAreaSize);
end;

class function TdxBarSkinnedPainter.SubMenuControlGetItemTextIndent(const ADrawParams: TdxBarItemControlDrawParams): Integer;
begin
  with ADrawParams.BarItemControl do
    if SubMenuParent.ItemLinks.ItemSize = misNormal then
      Result := SubMenuParent.IconAreaSize + SubMenuControlTextIndent
    else
      Result := SubMenuParent.IconAreaSize + 4; //!
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawScrollBandBackground(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection);
begin
// do nothing
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawScrollButton(ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AArrowDirection: TcxArrowDirection);
var
  AState: Integer;
  ARect: TRect;
begin
  ARect := SubMenuControlGetScrollBandBounds(ABarSubMenuControl, AArrowDirection);
  if (AArrowDirection = adUp) and (ABarSubMenuControl.MouseOnUpArrow) or
    (AArrowDirection = adDown) and (ABarSubMenuControl.MouseOnDownArrow) then
    AState := DXBAR_HOT
  else
    AState := DXBAR_NORMAL;

  ABarSubMenuControl.FillBackgroundEx(ACanvas, ARect, 0, clNone, True);
  Skin.DrawBackground(ACanvas.Handle, ARect, DXBAR_MENUSCROLLAREA, AState);
  ACanvas.ExcludeClipRect(ARect);
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawBackground(ABarSubMenuControl: TdxBarSubMenuControl;
  ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  SubMenuControlDrawItemBackground(ABarSubMenuControl, ACanvas, ARect);
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawBeginGroup(ABarSubMenuControl: TdxBarSubMenuControl;
  AControl: TdxBarItemControl; ACanvas: TcxCanvas; const ABeginGroupRect: TRect);
var
  ASeparatorRect: TRect;
begin
  with ABeginGroupRect do
    ASeparatorRect := cxRect(Left + ABarSubMenuControl.GetIndent1 + SubMenuControlTextIndent,
      Bottom - SubMenuGetSeparatorSize,
      Right,
      Bottom);
  SubMenuControlDrawBackground(ABarSubMenuControl, ACanvas, ABeginGroupRect, 0, clNone);
  SubMenuControlDrawSeparator(ACanvas, ASeparatorRect);
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawSeparator(ACanvas: TcxCanvas; const ARect: TRect);
begin
  Skin.DrawBackground(ACanvas.Handle, ARect, DXBAR_MENUSEPARATORHORZ, DXBAR_NORMAL);
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawBorder(
  ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; R: TRect);
var
  ARect: TRect;
begin
  BarCanvas.BeginPaint(DC);
  try
    ARect := cxRectOffset(ABarSubMenuControl.ClientRect, ABarSubMenuControl.GetClientOffset.TopLeft);
    BarCanvas.ExcludeClipRect(ARect);

    Skin.DrawBackground(DC, R, DXBAR_DROPDOWNBORDER, DXBAR_NORMAL);

    if ABarSubMenuControl.Detachable then
    begin
      InflateRect(R, -SubMenuControlBorderSize, -SubMenuControlBorderSize);
      FillRectByColor(DC, R, Skin.GetPartColor(DXBAR_MENUDETACHCAPTIONAREA));
      SubMenuControlDrawDetachCaption(ABarSubMenuControl, DC, ABarSubMenuControl.DetachCaptionRect);
    end;
  finally
    BarCanvas.EndPaint;
  end;
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawClientBorder(
  ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const R: TRect; ABrush: HBRUSH);
begin
  // no client border
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawDetachCaption(
  ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; R: TRect);
const
  DetachCaptionStates: array[Boolean] of Integer = (DXBAR_NORMAL, DXBAR_HOT);
begin
  Skin.DrawBackground(DC, R, DXBAR_MENUDETACHCAPTION, DetachCaptionStates[ABarSubMenuControl.DetachCaptionSelected]);
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawItemBackground(
  ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; AItemRect: TRect);
var
  AContentRect, ABarRect, ABandRect, ASeparatorRect, AControlRect: TRect;
begin
  cxRectIntersect(AContentRect, ABarSubMenuControl.ContentRect, AItemRect);
  ABarRect := ABarSubMenuControl.BarRect;

  ABandRect := Rect(ABarRect.Right, AContentRect.Top,
    ABarRect.Right + ABarSubMenuControl.BandSize, AContentRect.Bottom);
  ASeparatorRect := Rect(ABandRect.Right, AContentRect.Top,
    ABandRect.Right + MenuSeparatorSize, AContentRect.Bottom);
  AControlRect := Rect(ASeparatorRect.Right, AContentRect.Top, AContentRect.Right, AContentRect.Bottom);

  if ABarSubMenuControl.ItemLinks.ItemSize = misNormal then
  begin
    Skin.DrawBackground(ACanvas.Handle, ABandRect, DXBAR_MENUGLYPH);
    Skin.DrawBackground(ACanvas.Handle, ASeparatorRect, DXBAR_MENUSEPARATORVERT);
  end
  else
  begin
    Skin.DrawBackground(ACanvas.Handle, ABandRect, DXBAR_MENUCONTENT);
    Skin.DrawBackground(ACanvas.Handle, ASeparatorRect, DXBAR_MENUCONTENT);
  end;
  Skin.DrawBackground(ACanvas.Handle, AControlRect, DXBAR_MENUCONTENT);
end;

class function TdxBarSkinnedPainter.SubMenuControlGetBandSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := SubMenuControlInternalBorderSize + ABarSubMenuControl.IconAreaSize - MenuSeparatorSize;
end;

class function TdxBarSkinnedPainter.SubMenuControlNormalItemHeight: Integer;
begin
  Result := 22;
end;

class function TdxBarSkinnedPainter.SubMenuControlTextIndent: Integer;
begin
  Result := 7;
end;

class function TdxBarSkinnedPainter.SubMenuControlInternalBorderSize: Integer;
begin
  Result := 2;
end;

class function TdxBarSkinnedPainter.SubMenuControlInternalBorderOffset: Integer;
begin
  Result := 1;
end;

class function TdxBarSkinnedPainter.SubMenuControlTextSize(ACanvas: TcxCanvas): Integer;
begin
  Result := GetDefaultTextSize(ACanvas) + (SubMenuControlInternalBorderSize + SubMenuControlInternalBorderOffset) * 2;
end;

class function TdxBarSkinnedPainter.SubMenuControlNCBorderSize: Integer;
begin
  Result := 2;
end;

class function TdxBarSkinnedPainter.SubMenuControlClientBorderSize: Integer;
begin
  Result := 0;
end;

procedure TdxBarSkinnedPainter.ApplicationMenuDrawBorder(ABarSubMenuControl: TdxBarSubMenuControl; DC: HDC; const ARect: TRect);
begin
  BarCanvas.BeginPaint(DC);
  try
    BarCanvas.ExcludeClipRect(cxRectInflate(ARect, -SubMenuControlInternalBorderSize, -SubMenuControlInternalBorderSize));
    Skin.DrawBackground(BarCanvas.Handle, ARect, DXBAR_APPLICATIONMENUBORDER);
  finally
    BarCanvas.EndPaint;
  end;
end;

procedure TdxBarSkinnedPainter.ApplicationMenuDrawButton(const ADrawParams: TdxBarApplicationMenuButtonControlDrawParams; var R: TRect);
const
  AState: array [Boolean] of Integer = (DXBAR_NORMAL, DXBAR_HOT);
var
  AImageBounds: TRect;
begin
  with ADrawParams do
  begin
    DrawBackground(BarItemControl, Canvas.Handle, R, 0, False);
    Skin.DrawBackground(Canvas.Handle, R, DXBAR_APPLICATIONMENUBUTTON, AState[DrawSelected]);
    R.Left := R.Left + Max((cxRectWidth(R) - ContentWidth) div 2, 0);
    DrawGlyph(BarItemControl, Canvas.Handle, R, R, AImageBounds, PaintType,
      ViewStructure, ViewSize, not (cpIcon in ViewStructure), DrawSelected, False, False, False, False, False, False, False);

    DrawButtonLikeControlCaption(ADrawParams, R, AImageBounds)
  end;
end;

procedure TdxBarSkinnedPainter.ApplicationMenuDrawContentArea(
  ABarSubMenuControl: TdxBarSubMenuControl; ACanvas: TcxCanvas; const AContentRect, AItemsArea: TRect);
var
  AInnerBorderRect, AOuterBorderRect, AHeaderRect, AFooterRect, ALeftSideRect, ARightSideRect: TRect;
begin
  AInnerBorderRect := cxRectInflate(AItemsArea, 1, 1);
  AOuterBorderRect := cxRectInflate(AInnerBorderRect, 1, 1);
  AHeaderRect := AContentRect;
  AHeaderRect.Bottom := AOuterBorderRect.Top;
  AFooterRect := AContentRect;
  AFooterRect.Top := AOuterBorderRect.Bottom;
  ALeftSideRect := Rect(AContentRect.Left, AHeaderRect.Bottom, AOuterBorderRect.Left, AFooterRect.Top);
  ARightSideRect := Rect(AOuterBorderRect.Right, AHeaderRect.Bottom, AContentRect.Right, AFooterRect.Top);

  ACanvas.FrameRect(AInnerBorderRect, Skin.GetPartColor(DXBAR_APPLICATIONMENUCONTENTINNERBORDER));
  ACanvas.FrameRect(AOuterBorderRect, Skin.GetPartColor(DXBAR_APPLICATIONMENUCONTENTOUTERBORDER));
  Skin.DrawBackground(ACanvas.Handle, AHeaderRect, DXBAR_APPLICATIONMENUCONTENTHEADER);
  Skin.DrawBackground(ACanvas.Handle, AFooterRect, DXBAR_APPLICATIONMENUCONTENTFOOTER);
  ACanvas.FillRect(ALeftSideRect, Skin.GetPartColor(DXBAR_APPLICATIONMENUCONTENTSIDES));
  ACanvas.FillRect(ARightSideRect, Skin.GetPartColor(DXBAR_APPLICATIONMENUCONTENTSIDES));
end;

function TdxBarSkinnedPainter.ApplicationMenuGetFrameSizes: TRect;
begin
  Result := Rect(4, 16, 4, 27);
end;

procedure TdxBarSkinnedPainter.ExtraMenuControlDrawBackground(AExtraMenuControl: TCustomdxBarControl;
  ACanvas: TcxCanvas; ARect: TRect; ABrush: HBRUSH; AColor: TColor);
begin
  ExtraMenuControlDrawItemBackground(AExtraMenuControl, ACanvas, ARect);
end;

procedure TdxBarSkinnedPainter.ExtraMenuControlDrawBeginGroup(AExtraMenuControl: TCustomdxBarControl;
  ACanvas: TcxCanvas; ABeginGroupRect: TRect; AToolbarBrush: HBRUSH; AHorz: Boolean);
begin
  InternalDrawBeginGroup(ACanvas.Handle, ABeginGroupRect, AHorz, $F5F5F5, $D8D8D8);
end;

procedure TdxBarSkinnedPainter.ExtraMenuControlDrawItemBackground(AExtraMenuControl: TCustomdxBarControl;
  ACanvas: TcxCanvas; AItemRect: TRect);
var
  AExtraPaneRect, AContentRect, ASeparatorRect: TRect;
begin
  ACanvas.SaveClipRegion;
  try
    ACanvas.SetClipRegion(TcxRegion.Create(AItemRect), roIntersect);

    AExtraPaneRect := AExtraMenuControl.ClientRect;
    ASeparatorRect := Rect(AExtraPaneRect.Left, AExtraPaneRect.Top,
      AExtraPaneRect.Left + MenuSeparatorSize, AExtraPaneRect.Bottom);
    AContentRect := Rect(ASeparatorRect.Right, AExtraPaneRect.Top, AExtraPaneRect.Right, AExtraPaneRect.Bottom);
    Skin.DrawBackground(ACanvas.Handle, ASeparatorRect, DXBAR_MENUSEPARATORVERT);
    FillRectByColor(ACanvas.Handle, AContentRect, Skin.GetPartColor(DXBAR_MENUEXTRAPANE));
  finally
    ACanvas.RestoreClipRegion;
  end;
end;

function TdxBarSkinnedPainter.EditButtonAllowOffsetContent: Boolean;
begin
  Result := False;
end;

function TdxBarSkinnedPainter.EditButtonAllowCompositeFrame: Boolean;
begin
  Result := Skin.GetName = '';
end;

class function TdxBarSkinnedPainter.EditButtonAllowHotTrack(const ADrawParams: TdxBarItemControlDrawParams): Boolean;
begin
  Result := True;
end;

function TdxBarSkinnedPainter.EditButtonIsCustomBorder: Boolean;
begin
  Result := Skin.GetName = '';
end;

function TdxBarSkinnedPainter.EditButtonIsCustomBackground(AState: Integer): Boolean;
begin
  Result := True;
end;

procedure TdxBarSkinnedPainter.EditButtonCorrectDefaultWidth(var ADefaultWidth: Integer);
begin
  Dec(ADefaultWidth);
end;

procedure TdxBarSkinnedPainter.EditButtonDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams; AState: Integer;
  ARect: TRect; ABrush: HBrush);
begin
  if Skin.GetName = '' then
    Skin.DrawBackground(ADrawParams.Canvas.Handle, ARect, DXBAR_EDIT_BUTTON, AState)
  else
    FillRectByColor(ADrawParams.Canvas.Handle, ARect, EditGetBkColor(ADrawParams));
end;

procedure TdxBarSkinnedPainter.EditButtonDrawBorder(
  const ADrawParams: TdxBarItemControlDrawParams; AState: Integer; var ADrawRect: TRect; out AContentRect: TRect);
begin
  AContentRect := EditControlGetContentRect(ADrawParams.PaintType, ADrawRect);
  if (Skin.GetName = '') and (AState in [DXBAR_HOT..DXBAR_HOTCHECK]) then
    with ADrawParams do
    begin
      Canvas.SaveClipRegion;
      Canvas.SetClipRegion(TcxRegion.Create(BarItemControl.ViewInfo.Bounds), roSet);
      Canvas.SetClipRegion(TcxRegion.Create(ADrawRect), roIntersect);
      FrameRectByColor(Canvas.Handle, ADrawRect, Skin.GetPartColor(DXBAR_EDIT_BUTTON_BORDER, AState));
      Canvas.RestoreClipRegion;
      ADrawRect := AContentRect;
    end;
end;

class function TdxBarSkinnedPainter.EditControlCaptionBackgroundIsOpaque(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  Result := False;
end;

class function TdxBarSkinnedPainter.EditControlCaptionRightIndentIsOpaque(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  Result := EditControlCaptionBackgroundIsOpaque(ADrawParams);
end;

procedure TdxBarSkinnedPainter.EditControlDrawBorder(
  const ADrawParams: TdxBarEditLikeControlDrawParams; var ARect: TRect);
begin
  if not ADrawParams.IsTransparent then
    FrameRectByColor(ADrawParams.Canvas.Handle, ARect, Skin.GetPartColor(DXBAR_EDIT_BORDER, GetEditPartState(ADrawParams, ecpEdit)));
  InflateRect(ARect, -1, -1);
end;

procedure TdxBarSkinnedPainter.EditControlDrawSelectionFrame(
  const ADrawParams: TdxBarEditLikeControlDrawParams; const ARect: TRect);

  procedure DrawSelection(AState: Integer);
  begin
    with ADrawParams do
    begin
      Skin.DrawBackground(Canvas.Handle, ARect, DXBAR_SMALLBUTTON, AState);
      Canvas.DrawComplexFrame(cxRectInflate(BarEditControl.GetEditRect, 0, -1),
        Skin.GetPartColor(DXBAR_MENUEDITSEPARATOR, AState), clNone, [bLeft]);
    end;
  end;

var
  AState: Integer;
begin
  with ADrawParams do
  begin
    Canvas.SaveClipRegion;
    Canvas.SetClipRegion(TcxRegion.Create(EditControlGetContentRect(PaintType, BarEditControl.GetEditRect)), roSubtract);
    try
      if Enabled then
        AState := DXBAR_ACTIVE
      else
        AState := DXBAR_ACTIVEDISABLED;
      DrawSelection(AState);
    finally
      Canvas.RestoreClipRegion;
    end;
  end;
end;

procedure TdxBarSkinnedPainter.EditControlDrawBackground(const ADrawParams: TdxBarEditLikeControlDrawParams);
begin
  with ADrawParams do
  begin
    Canvas.SaveClipRegion;
    Canvas.ExcludeClipRect(EditControlGetContentRect(PaintType, BarEditControl.GetEditRect));
    DrawBackground(BarEditControl, Canvas.Handle, BarEditControl.ItemBounds, 0, False);
    Canvas.RestoreClipRegion;
  end;
end;

procedure TdxBarSkinnedPainter.EditGetRealLookAndFeel(ABarManager: TdxBarManager; ALookAndFeel: TcxLookAndFeel);
begin
  ALookAndFeel.NativeStyle := False;
  ALookAndFeel.SkinName := Skin.GetName;
  if Skin.GetName = '' then
    if ABarManager.FThemeAvailable then
      ALookAndFeel.SetStyle(lfsNative)
    else
      inherited EditGetRealLookAndFeel(ABarManager, ALookAndFeel);
end;

function TdxBarSkinnedPainter.EditGetBkColor(
  const ADrawParams: TdxBarEditLikeControlDrawParams): COLORREF;
begin
  Result := Skin.GetPartColor(DXBAR_EDIT_BACKGROUND, GetEditPartState(ADrawParams, ecpEdit));
end;

class function TdxBarSkinnedPainter.EditControlShowIconDefault(
  const ADrawParams: TdxBarEditLikeControlDrawParams): Boolean;
begin
  Result := True;
end;

class function TdxBarSkinnedPainter.ComboControlArrowOffset: Integer;
begin
  Result := 0;
end;

class function TdxBarSkinnedPainter.ComboControlButtonOffsets(APaintType: TdxBarPaintType): TRect;
begin
  Result := cxEmptyRect;
end;

procedure TdxBarSkinnedPainter.ComboControlDrawArrowButton(
  const ADrawParams: TdxBarEditLikeControlDrawParams; ARect: TRect;
  AInClientArea: Boolean);
begin
  InternalDrawEditButton(ADrawParams, ccpDropButton, ARect);
end;

function TdxBarSkinnedPainter.ColorComboHasCompleteFrame: Boolean;
begin
  Result := True;
end;

function TdxBarSkinnedPainter.GetCustomColorButtonWidth(APaintType: TdxBarPaintType; const ARect: TRect): Integer;
begin
  if Skin.GetName <> '' then
    Result := 19
  else
    Result := inherited GetCustomColorButtonWidth(APaintType, ARect);
end;

function TdxBarSkinnedPainter.GetCustomColorButtonIndents(APaintType: TdxBarPaintType): TRect;
begin
  Result := cxEmptyRect;
end;

procedure TdxBarSkinnedPainter.ColorComboDrawCustomButton(
  const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect);
begin
  InternalDrawEditButton(ADrawParams, clcpCustomColorButton, ARect);
end;

procedure TdxBarSkinnedPainter.ColorComboDrawCustomButtonAdjacentZone(
  const ADrawParams: TdxBarColorComboControlDrawParams; ARect: TRect);
begin
// do nothing
end;

function TdxBarSkinnedPainter.DateNavigatorHeaderColor: TColor;
begin
  Result := Skin.GetPartColor(DXBAR_DATENAVIGATOR_HEADER);
end;

class function TdxBarSkinnedPainter.InPlaceSubItemGetArrowWidth(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams): Integer;
begin
  Result := ADrawParams.ArrowSize.cx;
end;

procedure TdxBarSkinnedPainter.InPlaceSubItemControlDrawArrow(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams;
  ADirection: TcxArrowDirection; ARect: TRect);
begin
  ButtonLikeControlDrawMenuArrow(ADrawParams, ADirection, ARect);
end;

procedure TdxBarSkinnedPainter.InPlaceSubItemControlDrawBackground(const ADrawParams: TdxBarInPlaceSubItemControlDrawParams; ARect: TRect);
begin
  if ADrawParams.DrawSelected then
    DrawItemBackgroundInSubMenu(ADrawParams, ARect)
  else
    Skin.DrawBackground(ADrawParams.Canvas.Handle, ARect, DXBAR_MENUGLYPH);
end;

function TdxBarSkinnedPainter.CanUpdateBarPartly: Boolean;
begin
  Result := False;
end;

procedure TdxBarSkinnedPainter.ProgressControlDrawBackground(
  const ADrawParams: TdxBarItemControlDrawParams; var R: TRect);
begin
  inherited;
  Skin.DrawBackground(ADrawParams.Canvas.Handle, R, DXBAR_PROGRESSSUBSTRATE, DXBAR_NORMAL);
  InflateRect(R, -2, -2);
end;

procedure TdxBarSkinnedPainter.ProgressControlFillContent(
  const ADrawParams: TdxBarItemControlDrawParams; const R: TRect; ABarBrush: HBRUSH);
begin
  Skin.DrawBackground(ADrawParams.Canvas.Handle, R, DXBAR_PROGRESSSOLIDBAND, DXBAR_NORMAL);
end;

procedure TdxBarSkinnedPainter.ProgressControlFillDiscreteContent(
  const ADrawParams: TdxBarItemControlDrawParams; const R: TRect; ABarBrush: HBRUSH);
begin
  Skin.DrawBackground(ADrawParams.Canvas.Handle, R, DXBAR_PROGRESSDISCRETEBAND, DXBAR_NORMAL);
end;

function TdxBarSkinnedPainter.GetSpinEditArrowPos(
  const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer): TPoint;
var
  AYArrowOffset: Integer;
begin
  with ADrawParams do
  begin
    Result.X := ARect.Left + (cxRectWidth(ARect) div 2) - (ArrowSize.cx div 2);
    AYArrowOffset := (cxRectHeight(ARect) div 2) - (ArrowSize.cy div 2);
    if AButtonIndex = secButtonUp then
      Result.Y := ARect.Bottom - AYArrowOffset
    else
      Result.Y := ARect.Top + AYArrowOffset - 1;
  end;
end;

procedure TdxBarSkinnedPainter.SpinEditCorrectFrameRect(
  const ADrawParams: TdxBarItemControlDrawParams; var ARect: TRect);
begin
// do nothing;
end;

function TdxBarSkinnedPainter.GetSpinEditArrowSize(AHeight: Integer): TSize;
begin
  Result := Size(5, 3);
end;

function TdxBarSkinnedPainter.GetSpinEditButtonBounds(const ADrawParams: TdxBarSpinEditDrawParams; const ARect: TRect; AButton: TdxBarSpinEditButton): TRect;
begin
  Result := inherited GetSpinEditButtonBounds(ADrawParams, cxRectInflate(ARect, -1, -1), AButton);
end;

procedure TdxBarSkinnedPainter.SpinEditControlDrawButton(
  const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect; AButtonIndex: Integer);

  procedure DrawButtonFrame(AState: Integer; var ARect: TRect; out AContentRect: TRect);
  begin
    AContentRect := cxRectInflate(ARect, -1, -1);
    if AState in [DXBAR_NORMAL, DXBAR_DISABLED, DXBAR_ACTIVE, DXBAR_ACTIVEDISABLED] then
    begin
      if AButtonIndex = secButtonUp then
        Inc(ARect.Bottom)
      else
        Dec(ARect.Top);
    end
    else
      FrameRectByColor(ADrawParams.Canvas.Handle, ARect, Skin.GetPartColor(DXBAR_EDIT_BUTTON_BORDER, AState));
    InflateRect(ARect, -1, -1);
  end;

var
  AEditButtonState: Integer;
  AArrowPos: TPoint;
  AContentRect: TRect;
  APart: Integer;
begin
  with ADrawParams do
  begin
    AEditButtonState := GetSpinEditPartState(TdxBarSpinEditDrawParams(BarEditControl.DrawParams), AButtonIndex);
    if Skin.GetName = '' then
      DrawButtonFrame(AEditButtonState, ARect, AContentRect);
    EditButtonDrawBackground(ADrawParams, AEditButtonState, ARect, 0);
    if Skin.GetName <> '' then
    begin
      if AButtonIndex = secButtonUp then
        APart := DXBAR_SPINEDIT_UPBUTTON
      else
        APart := DXBAR_SPINEDIT_DOWNBUTTON;
      Skin.DrawBackground(ADrawParams.Canvas.Handle, ARect, APart, AEditButtonState);
    end
    else
    begin
      AArrowPos := GetSpinEditArrowPos(ADrawParams, AContentRect, AButtonIndex);
      DrawSpinEditArrow(ADrawParams, AArrowPos, AButtonIndex);
    end;
  end;
end;

procedure TdxBarSkinnedPainter.SpinEditControlDrawButtonsAdjacentZone(const ADrawParams: TdxBarSpinEditDrawParams; const ARect: TRect);
begin
  if Skin.GetName = '' then
    SpinEditControlDrawButtonsExternalFrame(ADrawParams, ARect);
end;

procedure TdxBarSkinnedPainter.SpinEditControlDrawButtonsExternalFrame(const ADrawParams: TdxBarSpinEditDrawParams; ARect: TRect);
var
  AEditState: Integer;
  AColor: TColor;
begin
  with ADrawParams do
  begin
    AEditState := GetEditPartState(ADrawParams, ecpEdit);

    if not (HotPartIndex in ecpHeaderParts) and (HotPartIndex <> icpNone) then
      AColor := Skin.GetPartColor(DXBAR_EDIT_BUTTON_BORDER, DXBAR_ACTIVE)
    else
      if AEditState = DXBAR_DISABLED then
        AColor := Skin.GetPartColor(DXBAR_EDIT_BACKGROUND, DXBAR_DISABLED)
      else
        AColor := Skin.GetPartColor(DXBAR_EDIT_BACKGROUND, DXBAR_NORMAL);
    FrameRectByColor(Canvas.Handle, ARect, AColor);
  end;
end;

function TdxBarSkinnedPainter.GetSpinEditButtonIndents(APaintType: TdxBarPaintType): TRect;
begin
  Result := cxEmptyRect;
end;

function TdxBarSkinnedPainter.GetSpinEditButtonWidth(APaintType: TdxBarPaintType; const ARect: TRect): Integer;
begin
  if Skin.GetName <> '' then
    Result := 17
  else
  begin
    Result := cxRectHeight(ARect) div 2 * 8 div 5 + 1;
    Result := Result - GetSpinEditButtonIndents(APaintType).Left -
      GetSpinEditButtonIndents(APaintType).Right;
  end;
end;

procedure TdxBarSkinnedPainter.DrawStaticBorder(const ADrawParams: TdxBarStaticLikeControlDrawParams; var ARect: TRect);
begin
  with ADrawParams do
  begin
    if BorderStyle = sbsNone then Exit;
    Canvas.FrameRect(ARect, Skin.GetPartColor(DXBAR_EDIT_BORDER));
    InflateRect(ARect, -1, -1);
  end;
end;

class function TdxBarSkinnedPainter.StaticBackgroundIsOpaque(const ADrawParams: TdxBarItemControlDrawParams): Boolean;
begin
  Result := False;
end;

procedure TdxBarSkinnedPainter.DrawSeparatorGlyphAndCaption(const ADrawParams: TdxBarSeparatorControlDrawParams; const ARect: TRect);
var
  ACaptionRect: TRect;
begin
  with ADrawParams do
  begin
    FillRectByColor(Canvas.Handle, ARect, Skin.GetPartColor(DXBAR_SEPARATOR_BACKGROUND));
    ACaptionRect := ARect;
    ACaptionRect.Left := ACaptionRect.Left +
      SeparatorControlGetIndents(ADrawParams, cpText).Left;
    Dec(ACaptionRect.Bottom, SubMenuGetSeparatorSize);
    if not IsTop then
      Inc(ACaptionRect.Top, SubMenuGetSeparatorSize);
    DrawItemText(BarItemControl, Canvas.Handle, Caption, ACaptionRect,
      SystemAlignmentsHorz[Alignment], Enabled, False, PaintType = ptVert, True,
      False);
  end;
end;

procedure TdxBarSkinnedPainter.ScreenTipDrawBackground(ACanvas: TcxCanvas; ARect: TRect);
begin
  Skin.DrawBackground(ACanvas.Handle, ARect, DXBAR_SCREENTIP);
end;

procedure TdxBarSkinnedPainter.ScreenTipDrawFooterLine(ACanvas: TcxCanvas; const ARect: TRect);
var
  R: TRect;
begin
  R := cxRectSetHeight(ARect, 1);
  FillRectByColor(ACanvas.Handle, R, Skin.GetPartColor(DXBAR_SCREENTIP_FOOTERLINE));
  OffsetRect(R, 0, 1);
  FillRectByColor(ACanvas.Handle, R, clWhite);
end;

procedure TdxBarSkinnedPainter.DrawToolbarContentPart(
  ABarControl: TdxBarControl; ACanvas: TcxCanvas);
var
  APrevWindowOrg: TPoint;
  DC: HDC;
begin
  DC := ACanvas.Handle;
  with ABarControl.NCOffset do
    OffsetWindowOrgEx(DC, X, Y, APrevWindowOrg);
  try
    Skin.DrawBackground(DC, ABarControl.NCRect, DXBAR_TOOLBAR, GetBarControlState(ABarControl));
  finally
    SetWindowOrgEx(DC, APrevWindowOrg.X, APrevWindowOrg.Y, nil);
  end;
end;

procedure TdxBarSkinnedPainter.DrawToolbarNonContentPart(
  ABarControl: TdxBarControl; DC: HDC);
begin
  with ABarControl.ClientBounds do
    ExcludeClipRect(DC, Left, Top, Right, Bottom);
  Skin.DrawBackground(DC, ABarControl.NCRect, DXBAR_TOOLBAR,
    GetBarControlState(ABarControl));
  DrawToolbarNonContentPartCaption(ABarControl, DC);
end;

procedure TdxBarSkinnedPainter.DrawToolbarNonContentPartCaption(
  ABarControl: TdxBarControl; DC: HDC);
var
  ACaptionRect: TRect;
begin
  ACaptionRect := Skin.GetCaptionRect(ABarControl.NCRect, DXBAR_TOOLBAR);
  if ABarControl.HasCaptionButtons then
    ACaptionRect.Right := ACaptionRect.Right -
      cxRectWidth(ABarControl.CaptionButtons.Rect) -
      Skin.GetContentOffsets(DXBAR_TOOLBAR).Right;
  Skin.DrawCaption(DC, ABarControl.GetCaption, ACaptionRect, DXBAR_TOOLBAR,
    GetBarControlState(ABarControl));
end;

class function TdxBarSkinnedPainter.GetDefaultArrowSignSize: TSize;
begin
  Result := cxSize(5, 4);
end;

class function TdxBarSkinnedPainter.GetControlTextIndents: TRect;
begin
  Result := Rect(3, 0, 2, 0);
end;

class function TdxBarSkinnedPainter.GetControlCaptionRect(const ADrawParams: TdxBarItemControlDrawParams): TRect;
begin
  if (ADrawParams.ViewSize = cvsLarge) and (ADrawParams.PaintType <> ptMenu) then
    Result := cxGetTextRect(ADrawParams.Canvas.Handle, ADrawParams.Caption + GetTextInsteadArrow(ADrawParams), GetMaxLineCount, True)
  else
    Result := inherited GetControlCaptionRect(ADrawParams);
end;

function TdxBarSkinnedPainter.GetLargeImageBounds(AItemControl: TdxBarItemControl;
  const AImageSize: TSize; const ADrawRect: TRect; APaintType: TdxBarPaintType;
  AViewStructure: TdxBarItemControlViewStructure; AGlyphLayout: TdxBarGlyphLayout): TRect;

    function GetImageOffset(const AImageSize: TSize): TSize;
    var
      ACaptionRect: TRect;
    begin
      ACaptionRect := GetControlCaptionRect(AItemControl.FDrawParams);
      Result.cx := (ADrawRect.Left + ADrawRect.Right - AImageSize.cx) div 2;
      Result.cy := (ADrawRect.Top + ADrawRect.Bottom - cxRectHeight(ACaptionRect) - AImageSize.cy) div 2;
    end;

    function GetCenterImageRect(const AImageSize: TSize): TRect;
    var
      AOffset: TSize;
    begin
      Result := Rect(0, 0, AImageSize.cx, AImageSize.cy);
      AOffset := GetImageOffset(AImageSize);
      OffsetRect(Result, AOffset.cx, AOffset.cy);
    end;

    function GetStretchImageRect: TRect;
    var
      ACaptionRect: TRect;
      AImageSize: Integer;
    begin
      ACaptionRect := GetControlCaptionRect(AItemControl.FDrawParams);
      AImageSize := Min(cxRectWidth(ADrawRect) - GetButtonBorderWidth,
        cxRectHeight(ADrawRect) - cxRectHeight(ACaptionRect) - GetButtonBorderHeight);
      Result := GetCenterImageRect(Size(AImageSize, AImageSize));
    end;

begin
{
  if AItemControl.BarManager.ImageOptions.StretchGlyphs then
    Result := GetStretchImageRect
  else
}
    Result := GetCenterImageRect(AImageSize);
end;

function TdxBarSkinnedPainter.GetSmallIconSize: Integer;
begin
  Result := DefautGlyphSize;
end;

function TdxBarSkinnedPainter.GetDefaultEnabledTextColor(
  ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean): TColor;
const
  AItemTextPartMap: array [TdxBarPaintType] of Integer = (DXBAR_ITEMTEXT, DXBAR_MENUITEMTEXT, DXBAR_ITEMTEXT);
begin
  Result := Skin.GetPartColor(AItemTextPartMap[ABarItemControl.GetPaintType], GetPartState(ABarItemControl.FDrawParams, icpControl));
end;

function TdxBarSkinnedPainter.GetEnabledTextColor(
  ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean): TColor;
begin
//  Result := ABarItemControl.Parent.Font.Color;
//  if Result = clDefault then
    Result := inherited GetEnabledTextColor(ABarItemControl, ASelected, AFlat);
end;

procedure TdxBarSkinnedPainter.GetDisabledTextColors(
  ABarItemControl: TdxBarItemControl; ASelected, AFlat: Boolean;
  var AColor1, AColor2: TColor);
begin
  AColor1 := GetDefaultEnabledTextColor(ABarItemControl, ASelected, AFlat);
  AColor2 := AColor1;
end;

function TdxBarSkinnedPainter.GetToolbarCaptionRect(
  const ARect: TRect): TRect;
begin
  Result := Skin.GetCaptionRect(ARect, DXBAR_TOOLBAR);
end;

procedure TdxBarSkinnedPainter.InflateSizeForArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; var ASize: Integer);
begin
  if (ADrawParams.PaintType <> ptMenu) and (ADrawParams.ViewSize = cvsSmall) and ADrawParams.IsDropDown then
    if ADrawParams.SplitDropDown then
      Inc(ASize, GetControlTextIndents.Right + ADrawParams.ArrowSize.cx)
    else
      Inc(ASize, ADrawParams.ArrowSize.cx);
end;

class function TdxBarSkinnedPainter.IsCompoundPainting: Boolean;
begin
  Result := True;
end;

class function TdxBarSkinnedPainter.GetButtonPartState(const ADrawParams: TdxBarButtonLikeControlDrawParams; AControlPart: Integer): Integer;
begin
  Result := DXBAR_NORMAL;
  if not ADrawParams.IsCustomizing then
    case AControlPart of
      bcpButton:
        if ADrawParams.IsPressed then
          Result := DXBAR_PRESSED
        else
        begin
          if ADrawParams.Downed then
            if ADrawParams.DroppedDown then
              Result := DXBAR_ACTIVE
            else
              if (ADrawParams.HotPartIndex = AControlPart) or
                ADrawParams.SelectedByKey and not ADrawParams.IsDropDown then
                Result := DXBAR_HOTCHECK
              else
                Result := DXBAR_CHECKED
          else
            if ADrawParams.DroppedDown then
              if ADrawParams.IsDropDown and ADrawParams.SplitDropDown then
                Result := DXBAR_ACTIVE
              else
                Result := DXBAR_DROPPEDDOWN
            else
              Result := GetPartState(ADrawParams, AControlPart);
        end;
      bcpDropButton:
        if ADrawParams.DroppedDown then
          Result := DXBAR_DROPPEDDOWN
        else
          if ADrawParams.Downed and (ADrawParams.HotPartIndex = icpNone) and not ADrawParams.SelectedByKey then
            Result := DXBAR_CHECKED
          else
            Result := GetPartState(ADrawParams, AControlPart);
    end
  else
    if ADrawParams.Downed then
      Result := DXBAR_CHECKED
    else
      if ADrawParams.DroppedDown then
        Result := DXBAR_DROPPEDDOWN;
end;

class function TdxBarSkinnedPainter.GetEditPartState(const ADrawParams: TdxBarEditLikeControlDrawParams; AControlPart: Integer): Integer;
begin
  Result := DXBAR_NORMAL;
  if not ADrawParams.IsCustomizing then
    case AControlPart of
      ecpEdit:
        if ADrawParams.DroppedDown then
          Result := DXBAR_DROPPEDDOWN
        else
          if ADrawParams.Focused then
            Result := DXBAR_FOCUSED
          else
            Result := GetPartState(ADrawParams, AControlPart, ecpHeaderParts);
      ccpDropButton:
        if ADrawParams.DroppedDown then
          Result := DXBAR_DROPPEDDOWN
        else
          if ADrawParams.IsPressed and (ADrawParams.HotPartIndex = AControlPart) or ADrawParams.Focused then
            Result := DXBAR_HOT
          else
            Result := GetPartState(ADrawParams, AControlPart, ecpHeaderParts);
      clcpCustomColorButton:
        if ADrawParams.IsPressed then
          Result := DXBAR_PRESSED
        else
          if ADrawParams.DroppedDown or ADrawParams.Focused then
            Result := DXBAR_HOT
          else
            Result := GetPartState(ADrawParams, AControlPart, ecpHeaderParts);
    end;
end;

class function TdxBarSkinnedPainter.GetSpinEditPartState(const ADrawParams: TdxBarSpinEditDrawParams;
  AControlPart: Integer): Integer;
begin
  Result := DXBAR_NORMAL;
  if not ADrawParams.IsCustomizing then
    if (AControlPart = ADrawParams.ActiveButtonIndex) and (AControlPart = ADrawParams.HotPartIndex) then
      Result := DXBAR_DROPPEDDOWN
    else
    begin
      Result := GetPartState(ADrawParams, AControlPart, ecpHeaderParts);
      if (Result = DXBAR_ACTIVE) and ((ADrawParams.HotPartIndex = icpNone) or (ADrawParams.HotPartIndex in ecpHeaderParts)) then
        Result := DXBAR_NORMAL;
    end;
end;

class function TdxBarSkinnedPainter.GetPartState(
  const ADrawParams: TdxBarItemControlDrawParams; AControlPart: Integer; AForbiddenParts: TdxByteSet): Integer;

  function IsControlSelected: Boolean;
  begin
    Result := ADrawParams.DrawSelected;
{
    Result := ADrawParams.SelectedByKey or
     (ADrawParams.HotPartIndex <> icpNone) and
       (not (ADrawParams.HotPartIndex in AForbiddenParts) or (ADrawParams.PaintType = ptMenu));
}
  end;

begin
  if (ADrawParams.HotPartIndex = AControlPart) and ADrawParams.CanSelect then
    Result := DXBAR_HOT
  else
    if ADrawParams.CanSelect and IsControlSelected or (ADrawParams.HotPartIndex <> icpNone) then
      if not ADrawParams.Enabled then
        Result := DXBAR_ACTIVEDISABLED
      else
        Result := DXBAR_ACTIVE
    else
      if not ADrawParams.Enabled then
        Result := DXBAR_DISABLED
      else
        Result := DXBAR_NORMAL;
end;

class function TdxBarSkinnedPainter.GetPartState(
  const ADrawParams: TdxBarItemControlDrawParams; AControlPart: Integer): Integer;
begin
  Result := GetPartState(ADrawParams, AControlPart, []);
end;

function TdxBarSkinnedPainter.GetBarControlState(
  ABarControl: TdxBarControl): Integer;
const
  BarControlStates: array [TdxBarViewState] of Integer =
    (DXBAR_NORMAL, DXBAR_HOT);
begin
  Result := BarControlStates[ABarControl.ViewState];
end;

function TdxBarSkinnedPainter.CreateHintViewInfo(ABarManager: TdxBarManager; AHintText: string; const AShortCut: string;
  AScreenTip: TdxBarScreenTip): TdxBarCustomHintViewInfo;
begin
  Result := dxBarCreateScreenTipViewInfo(ABarManager, AHintText, AShortCut, AScreenTip, Self);
end;

procedure TdxBarSkinnedPainter.ButtonLikeControlDoDrawCaption(const ADrawParams: TdxBarButtonLikeControlDrawParams;
  const ATextBounds: TRect; ATextAlignment, AFormat: DWORD);

  procedure DrawArrowInEnd(ALastLine: string; var ARectOut: TRect);
  var
    ATextRect, AArrowRect, ATextArrowRect: TRect;
  begin
    if ALastLine <> '' then
    begin
      ATextRect := cxGetTextRect(ADrawParams.Canvas.Handle, ALastLine, 1);

      ALastLine := ALastLine + GetTextInsteadArrow(ADrawParams);
      ATextArrowRect := cxGetTextRect(ADrawParams.Canvas.Handle, ALastLine, 1);
      
      ARectOut := cxRectOffset(ATextArrowRect,
        ARectOut.Left + (cxRectWidth(ARectOut) - cxRectWidth(ATextArrowRect)) div 2,
        ARectOut.Top);

      AArrowRect := ARectOut;
      AArrowRect.Left := AArrowRect.Right - GetDefaultArrowSignSize.cx;

      ARectOut.Right := ARectOut.Left + cxRectWidth(ATextRect);
    end
    else
      AArrowRect := ARectOut;

    DrawArrow(ADrawParams.Canvas.Handle, AArrowRect, GetButtonPartState(ADrawParams, bcpDropButton));
  end;

var
  ALines: TStrings;
  I, ATextHeight: Integer;
  ARectOut: TRect;
  AColor1, AColor2: TColor;
begin
  with ADrawParams do
  begin
    SetBkMode(Canvas.Handle, TRANSPARENT);
    if BarItemControl <> nil then
      GetTextColors(BarItemControl, Enabled, DrawSelected, IsFlatText, AColor1, AColor2)
    else
      AColor1 := Skin.GetPartColor(DXBAR_ITEMTEXT, GetPartState(ADrawParams, icpControl));
    SetTextColor(Canvas.Handle, AColor1);

    ARectOut := ATextBounds;
    if ViewSize = cvsLarge then
    begin
      ALines := TStringList.Create;
      try
        cxGetTextLines(Caption, Canvas, ATextBounds, ALines);
        for I := ALines.Count + 1 to GetMaxLineCount do
          ALines.Add('');

        ATextHeight := cxTextSize(Canvas.Handle, 'Wg').cy;
        ARectOut.Bottom := ARectOut.Top + ATextHeight;

        for I := 0 to ALines.Count - 1 do
        begin
          if (I = ALines.Count - 1) and IsDropDown then
            DrawArrowInEnd(ALines[I], ARectOut);
          cxDrawText(Canvas.Handle, ALines[I], ARectOut, ATextAlignment or AFormat);
          OffsetRect(ARectOut, 0, ATextHeight);
        end;
      finally
        ALines.Free;
      end;
    end
    else
      cxDrawText(Canvas.Handle, Caption, ARectOut, ATextAlignment or AFormat);

    SetBkMode(Canvas.Handle, OPAQUE);
  end;
end;

procedure TdxBarSkinnedPainter.ButtonLikeControlDrawMenuArrow(const ADrawParams: TdxBarButtonLikeControlDrawParams; ADirection: TcxArrowDirection;
  ARect: TRect);
var
  AArrowRect: TRect;
  ARatio: Double;
  APart: Integer;
begin
  ARatio := ADrawParams.BarItemControl.Parent.Ratio;
  ARect := GetArrowRect(ADrawParams, ARect);
  if ADirection = adRight then
  begin
    AArrowRect := Rect(0, 0, Round(4 * ARatio), Trunc(7 * ARatio));
    APart := DXBAR_MENUARROWRIGHT;
  end
  else
  begin
    AArrowRect := Rect(0, 0, Trunc(7 * ARatio), Round(4 * ARatio));
    APart := DXBAR_MENUARROWDOWN;
  end;

  AArrowRect := cxRectOffset(AArrowRect, cxRectCenter(ARect, cxRectSize(AArrowRect)).TopLeft);
  Skin.DrawBackground(ADrawParams.Canvas.Handle, AArrowRect, APart, DXBAR_NORMAL);
end;

procedure TdxBarSkinnedPainter.DrawSpinEditArrow(const ADrawParams: TdxBarSpinEditDrawParams; AArrowPos: TPoint; AButtonIndex: Integer);
var
  P: TcxArrowPoints;
  AArrowDirection: TcxArrowDirection;
begin
  case AButtonIndex of
    secButtonUp: AArrowDirection := adUp;
  else {secButtonDown}
    AArrowDirection := adDown;
  end;

  CalculateArrowPoints(ADrawParams.BarEditControl.FParts[AButtonIndex], ADrawParams.ArrowSize.cy, AArrowDirection, P);
  ADrawParams.Canvas.SaveClipRegion;
  try
    SetArrowRegion(ADrawParams.Canvas, AArrowDirection, P, roSet);
    Skin.DrawBackground(ADrawParams.Canvas.Handle, GetArrowRectByPoints(P, AArrowDirection), DXBAR_SCROLLARROW);
  finally
    ADrawParams.Canvas.RestoreClipRegion;
  end;
  SetArrowRegion(ADrawParams.Canvas, AArrowDirection, P, roSubtract);
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawMarkContent(ABarSubMenuControl: TdxBarSubMenuControl;
  DC: HDC; R: TRect; ASelected: Boolean);
begin
  Skin.DrawBackground(DC, SubMenuControlMarkContentRect(R), DXBAR_MENUMARK);
end;

procedure TdxBarSkinnedPainter.SubMenuControlDrawMarkSelection(
  ABarSubMenuControl: TdxBarSubMenuControl; ADC: HDC; const AMarkRect: TRect);
begin
  Skin.DrawBackground(ADC, AMarkRect, DXBAR_SMALLBUTTON, DXBAR_HOT);
end;

procedure TdxBarSkinnedPainter.SubMenuControlFillScrollArrow(ACanvas: TcxCanvas; ARect: TRect; AColor: TColor);
begin
  Skin.DrawBackground(ACanvas.Handle, ARect, DXBAR_SCROLLARROW);
end;

function TdxBarSkinnedPainter.SubMenuControlGetScrollBandSize(ABarSubMenuControl: TdxBarSubMenuControl): Integer;
begin
  Result := inherited SubMenuControlGetScrollBandSize(ABarSubMenuControl);
  Result := (Result - 6) * 3 div 4;
end;

class function TdxBarSkinnedPainter.SubMenuControlGetScrollArrowSize(ATextSize: Integer): Integer;
begin
  Result := ATextSize div 7;
end;

class function TdxBarSkinnedPainter.SubMenuControlUseScrollButtons: Boolean;
begin
  Result := True;
end;

function TdxBarSkinnedPainter.GetSkin: IdxSkin;
begin                     
  Supports(FSkinnedObject, IdxSkin, Result);
end;

function TdxBarSkinnedPainter.BarMarkIsOpaque: Boolean;
begin
  Result := False;
end;

procedure TdxBarSkinnedPainter.DrawBarMarkState(ABarControl: TdxBarControl;
  DC: HDC; const R: TRect; AState: TdxBarMarkState);
const
  StatesMap: array[TdxBarMarkState] of Integer =
    (DXBAR_NORMAL, DXBAR_ACTIVE, DXBAR_PRESSED);
begin
  if AState <> msNone then
    Skin.DrawBackground(DC, R, DXBAR_SMALLBUTTON, StatesMap[AState]);
end;

procedure TdxBarSkinnedPainter.DrawButtonBackground(
  const ADrawParams: TdxBarButtonLikeControlDrawParams);

  procedure InternalDrawBackground(AControlPart, ASkinPart: Integer);

    function GetButtonGroupPosition: TdxBarButtonGroupRealPosition;
    begin
      Result := ADrawParams.ButtonGroup;
      if ADrawParams.SplitDropDown and ADrawParams.IsDropDown then
        case AControlPart of
          bcpButton:
            case Result of
              bgrpFinish: Result := bgrpMember;
              bgrpSingle: Result := bgrpStart;
            end;
          bcpDropButton:
            case Result of
              bgrpStart: Result := bgrpMember;
              bgrpSingle: Result := bgrpFinish;
            end;
        end
    end;

    procedure CalculateRects(var APartRect: TRect; out ALeftBorderRect, ARightBorderRect, AMiddleButtonRect, ASplitRect: TRect);
    begin
      ALeftBorderRect := APartRect;
      ALeftBorderRect.Right := ALeftBorderRect.Left + 2;

      ASplitRect := APartRect;
      ASplitRect.Left := ASplitRect.Left - 1;
      ASplitRect.Right := ASplitRect.Left + 2;

      ARightBorderRect := APartRect;
      ARightBorderRect.Left := ARightBorderRect.Right - 2;

      AMiddleButtonRect := APartRect;
      AMiddleButtonRect.Left := AMiddleButtonRect.Right - 1;

      case GetButtonGroupPosition of
        bgrpNone:
          begin
            ALeftBorderRect := cxEmptyRect;
            ARightBorderRect := cxEmptyRect;
            ASplitRect := cxEmptyRect;
            AMiddleButtonRect := cxEmptyRect;
          end;
        bgrpStart:
          begin
            ARightBorderRect := cxEmptyRect;

            APartRect.Left := APartRect.Left + 1;
          end;
        bgrpMember:
          begin
            ALeftBorderRect := cxEmptyRect;
            ARightBorderRect := cxEmptyRect;
          end;
        bgrpFinish:
          begin
            ALeftBorderRect := cxEmptyRect;
            AMiddleButtonRect := cxEmptyRect;

            APartRect.Right := APartRect.Right - 1;
          end;
        bgrpSingle:
          begin
            AMiddleButtonRect := cxEmptyRect;

            APartRect.Left := APartRect.Left + 1;
            APartRect.Right := APartRect.Right - 1;
         end;
      end;
    end;

  var
    APartState: Integer;
    APartRect, ALeftBorderRect, ARightBorderRect, AMiddleButtonRect, ASplitRect: TRect;
  begin
    with ADrawParams do
    begin
      APartState := GetButtonPartState(ADrawParams, AControlPart);
      APartRect := BarItemControl.FParts[AControlPart];

      CalculateRects(APartRect, ALeftBorderRect, ARightBorderRect, AMiddleButtonRect, ASplitRect);
      Skin.DrawBackground(Canvas.Handle, APartRect, ASkinPart, APartState);
      Skin.DrawBackground(Canvas.Handle, ALeftBorderRect, DXBAR_BUTTONGROUPBORDERLEFT);
      Skin.DrawBackground(Canvas.Handle, ARightBorderRect, DXBAR_BUTTONGROUPBORDERRIGHT);
      if SplitDropDown and IsDropDown then
      begin
        if AControlPart = bcpDropButton then
        begin
          Skin.DrawBackground(Canvas.Handle, ASplitRect, DXBAR_BUTTONGROUPSPLITBUTTONSEPARATOR, APartState);
          Skin.DrawBackground(Canvas.Handle, AMiddleButtonRect, DXBAR_BUTTONGROUPBORDERMIDDLE, APartState);
        end;
      end
      else
        Skin.DrawBackground(Canvas.Handle, AMiddleButtonRect, DXBAR_BUTTONGROUPBORDERMIDDLE, APartState);
    end;
  end;

var
  AButtonPart, AGlyphPart, ADropButtonPart: Integer;
begin
  with ADrawParams do
  begin
    if ViewSize = cvsSmall then
    begin
      if ButtonGroup = bgrpNone then
      begin
        AButtonPart := DXBAR_SMALLBUTTON;
        AGlyphPart := DXBAR_SMALLBUTTON_GLYPH;
        ADropButtonPart := DXBAR_SMALLBUTTON_DROPBUTTON;
      end
      else
      begin
        AButtonPart := DXBAR_BUTTONGROUP;
        AGlyphPart := DXBAR_BUTTONGROUP;
        ADropButtonPart := DXBAR_BUTTONGROUP;
      end;
    end
    else
    begin
      AButtonPart := DXBAR_LARGEBUTTON;
      AGlyphPart := DXBAR_LARGEBUTTON_GLYPH;
      ADropButtonPart := DXBAR_LARGEBUTTON_DROPBUTTON;
    end;

    if SplitDropDown and IsDropDown then
    begin
      InternalDrawBackground(bcpButton, AGlyphPart);
      InternalDrawBackground(bcpDropButton, ADropButtonPart);
    end
    else
      InternalDrawBackground(bcpButton, AButtonPart);
  end;
end;

function TdxBarSkinnedPainter.GetArrowRect(const ADrawParams: TdxBarButtonLikeControlDrawParams; const ARect: TRect): TRect;
var
  AArrowRectWidth: Integer;
begin
  Result := ARect;
  AArrowRectWidth := ADrawParams.ArrowSize.cx;
  if ADrawParams.PaintType <> ptMenu then
    Result.Right := Result.Right - GetBorderSize;
  Result.Left := Result.Right - AArrowRectWidth;
end;

class function TdxBarSkinnedPainter.GetTextInsteadArrow(const ADrawParams: TdxBarItemControlDrawParams): string;
begin
  Result := '';
  if ADrawParams.IsDropDown then
  begin
    while GetDefaultArrowSignSize.cx > cxTextSize(ADrawParams.Canvas.Handle, Result).cx do
      Result := Result + '.';
    Result := ' ' + Result;
  end;
end;

class function TdxBarSkinnedPainter.GetMaxLineCount: Integer;
begin
  Result := 2;
end;

procedure TdxBarSkinnedPainter.InternalDrawBeginGroup(DC: HDC; const ABeginGroupRect: TRect; AHorz: Boolean; AColor1, AColor2: TColor);
var
  R: TRect;
begin
{
TODO: Skin.GetPartColor or Skin.DrawBackground - DXBAR_ITEMSEPARATOR
}
  if AHorz then
  begin
    R := cxRectCenter(ABeginGroupRect, cxRectWidth(ABeginGroupRect), 1);
    FillRectByColor(DC, R, AColor2);
    FillRectByColor(DC, cxRectOffset(R, 0, 1), AColor1);
  end
  else
  begin
    R := cxRectCenter(ABeginGroupRect, 1, cxRectHeight(ABeginGroupRect));
    FillRectByColor(DC, R, AColor1);
    FillRectByColor(DC, cxRectOffset(R, 1, 0), AColor2);
  end;
end;

procedure TdxBarSkinnedPainter.InternalDrawEditButton(
  const ADrawParams: TdxBarEditLikeControlDrawParams; APartIndex: Integer; ARect: TRect);
var
  AContentRect: TRect;
  AState: Integer;
begin
  AState := GetEditPartState(ADrawParams, APartIndex);
  EditButtonDrawBorder(ADrawParams, AState, ARect, AContentRect);
  EditButtonDrawBackground(ADrawParams, AState, ARect, 0);
  case APartIndex of
    ccpDropButton:
      if Skin.GetName <> '' then
        Skin.DrawBackground(ADrawParams.Canvas.Handle, AContentRect, DXBAR_EDIT_ARROWBUTTON, AState)
      else
        DrawArrow(ADrawParams.Canvas.Handle, AContentRect, AState);
    clcpCustomColorButton:
      if Skin.GetName <> '' then
        Skin.DrawBackground(ADrawParams.Canvas.Handle, AContentRect, DXBAR_EDIT_ELLIPSISBUTTON, AState)
      else
        DrawDots(ADrawParams, AContentRect);
  end;
end;

{ TRegItemRecord }

constructor TRegItemRecord.Create(AItemClass: TdxBarItemClass;
  AItemControlClass: TdxBarItemControlClass; AVisible: Boolean);
begin
  FItemClass := AItemClass;
  FItemControlClass := AItemControlClass;
  FVisible := AVisible;
end;

{ TdxBarItemList }

destructor TdxBarItemList.Destroy;
var
  I: Integer;
begin
  for I := Count - 1 downto 0 do
    Unregister(I);
  inherited Destroy;
end;

procedure TdxBarItemList.Register(AItemClass: TdxBarItemClass;
  AItemControlClass: TdxBarItemControlClass; AVisible: Boolean);
var
  ARecord: TRegItemRecord;
begin
  ARecord := TRegItemRecord.Create(AItemClass, AItemControlClass, AVisible);
  Add(ARecord);
  RegisterClass(ARecord.FItemClass);
end;

procedure TdxBarItemList.Unregister(AItemClass: TdxBarItemClass);
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
    if ItemClass[I] = AItemClass then
    begin
      Unregister(I);
      Break;
    end;
end;

procedure TdxBarItemList.Unregister(Index: Integer);
var
  ARecord: TRegItemRecord;
begin
  ARecord := Items[Index];
  UnregisterClass(ARecord.FItemClass);
  Delete(Index);
  ARecord.Free;
end;

function TdxBarItemList.GetItem(Index: Integer): TRegItemRecord;
begin
  Result := TRegItemRecord(inherited Items[Index]);
end;

function TdxBarItemList.GetItemClass(Index: Integer): TdxBarItemClass;
begin
  Result := Items[Index].FItemClass;
end;

function TdxBarItemList.GetVisibleItemCount: Integer;
var
  I: Integer;
begin
  Result := 0;
  for I := 0 to Count - 1 do
    if Items[I].FVisible then
      Inc(Result);
end;

function TdxBarItemList.GetVisibleItemClass(Index: Integer): TdxBarItemClass;
var
  VisibleIndex, I: Integer;
begin
  Result := nil;  
  VisibleIndex := -1;
  for I := 0 to Count - 1 do
    begin
      if Items[I].FVisible then
        Inc(VisibleIndex);
      if VisibleIndex = Index then
      begin
        Result := ItemClass[I];
        Exit;
      end;
    end;
end;

{ TdxBarNavigationController }

destructor TdxBarNavigationController.Destroy;
begin
  FreeAndNil(FKeyTipsShowingState.KeyTipsData);
  EndKeyTipsWaiting(False);
  inherited Destroy;
end;

procedure TdxBarNavigationController.BeginKeyTipsWaiting(
  ARootObject: IdxBarAccessibilityHelper);
begin
  if (ARootObject = nil) or IsKeyTipsWaiting and
    (ARootObject.GetHelper <> FKeyTipsWaitingRootObject.GetHelper) then
      raise EdxException.Create('');
  if KeyTipsHandlingMode then
    Exit;
  if not IsKeyTipsWaiting then
  begin
    FKeyTipsWaitingRootObject := ARootObject;
    FKeyTipsWaitingTimer := TcxTimer.Create(nil);
    FKeyTipsWaitingTimer.Interval := dxBarWaitForKeyTipsTime;
    FKeyTipsWaitingTimer.OnTimer := KeyTipsWaitingTimerHandler;
  end;
end;

procedure TdxBarNavigationController.ChangeSelectedObject(
  ASetFocus: Boolean; ANewSelectedObject: IdxBarAccessibilityHelper;
  APrevSelectedObject: IdxBarAccessibilityHelper = nil);
var
  ALockedBarManager: TdxBarManager;
begin
  if ANewSelectedObject = nil then
    Exit;
  if APrevSelectedObject = nil then
    APrevSelectedObject := SelectedObject;
  if ANewSelectedObject <> APrevSelectedObject then
  begin
    if (ANewSelectedObject <> nil) and (APrevSelectedObject <> nil) and
      (ANewSelectedObject.GetBarManager = APrevSelectedObject.GetBarManager) then
      ALockedBarManager := ANewSelectedObject.GetBarManager
    else
      ALockedBarManager := nil;

    if ALockedBarManager <> nil then
      Inc(ALockedBarManager.FChangingFocusedItemControlLockCount);
    try
      if APrevSelectedObject <> nil then
        APrevSelectedObject.Unselect(ANewSelectedObject);
      ANewSelectedObject.Select(ASetFocus);
    finally
      if ALockedBarManager <> nil then
        Dec(ALockedBarManager.FChangingFocusedItemControlLockCount);
    end;
  end;
end;

procedure TdxBarNavigationController.EndKeyTipsWaiting(
  AShowKeyTipWindows: Boolean);
var
  ANewActiveKeyTipContainer: IdxBarAccessibilityHelper;
begin
  WaitForMenu := False;
  if IsKeyTipsWaiting then
  begin
    DestroyKeyTipsWaitingTimer;
    ANewActiveKeyTipContainer := FKeyTipsWaitingRootObject;
    FKeyTipsWaitingRootObject := nil;
    if AShowKeyTipWindows then
      SetKeyTipsShowingState(ANewActiveKeyTipContainer, '');
  end;
end;

procedure TdxBarNavigationController.HandleKey(AKey: Word; AShift: TShiftState;
  ASelectedObjectParent: IdxBarAccessibilityHelper = nil;
  ASelectedObject: IdxBarAccessibilityHelper = nil);

  function GetNavigationDirection: TcxAccessibilityNavigationDirection;
  begin
    Result := andLeft;
    case AKey of
      VK_LEFT:
        Result := andLeft;
      VK_RIGHT:
        Result := andRight;
      VK_UP:
        Result := andUp;
      VK_DOWN:
        Result := andDown;
    end;
  end;

var
  AIsKeyAcceptable: Boolean;
  AKeyTargetObject, ANextSelectedObject: IdxBarAccessibilityHelper;
begin
  FHandleKey := True;
  try
    if IsKeyTipsWaiting then
    begin
      WaitForMenu := False;
      if IsKeyTipsKey(AKey, AShift, AIsKeyAcceptable) then
      begin
        if not AIsKeyAcceptable then
          Exit;
        HandleKeyTipKey(AKey, AShift);
        EndKeyTipsWaiting(False);
        Exit;
      end;
    end;

    if KeyTipsHandlingMode and (AKey <> VK_ESCAPE) then
      if IsKeyTipsKey(AKey, AShift, AIsKeyAcceptable) then
      begin
        if AIsKeyAcceptable then
          HandleKeyTipKey(AKey, AShift);
        Exit;
      end
      else
        StopKeyTipsHandlingMode;

    if ASelectedObjectParent = nil then
      ASelectedObjectParent := SelectedObjectParent;
    if ASelectedObject = nil then
      ASelectedObject := SelectedObject;
    AKeyTargetObject := ASelectedObject;
    if AKeyTargetObject = nil then
      AKeyTargetObject := ASelectedObjectParent;

    if (AKey = VK_ESCAPE) and KeyTipsHandlingMode then
      KeyTipsEscapeHandler
    else
      if AKey in [VK_MENU, VK_F10, VK_ESCAPE] then
      begin
        if not ((AKey = VK_ESCAPE) and AKeyTargetObject.HandleNavigationKey(AKey)) then
          AKeyTargetObject.Unselect(nil);
      end
      else
        if not AKeyTargetObject.HandleNavigationKey(AKey) then
        begin
          if ASelectedObject = nil then
            ANextSelectedObject := ASelectedObjectParent.GetBarHelper.GetFirstSelectableObject
          else
          begin
            if AKey = VK_TAB then
              ANextSelectedObject := ASelectedObject.LogicalNavigationGetNextAccessibleObject(GetKeyState(VK_SHIFT) >= 0)
            else
              ANextSelectedObject := ASelectedObject.GetNextAccessibleObject(GetNavigationDirection);
          end;
          ChangeSelectedObject(AKey = VK_TAB, ANextSelectedObject, ASelectedObject);
        end;
  finally
    FHandleKey := False;
  end;
end;

function TdxBarNavigationController.IsKeyTipsKey(AKey: Word; AShift: TShiftState): Boolean;
var
  AIsKeyAcceptable: Boolean;
begin
  Result := IsKeyTipsKey(AKey, AShift, AIsKeyAcceptable);
end;

function TdxBarNavigationController.IsKeyTipsWaiting: Boolean;
begin
  Result := FKeyTipsWaitingRootObject <> nil;
end;

function TdxBarNavigationController.IsNavigationBarControl(
  ABarControl: TCustomdxBarControl): Boolean;
begin
  Result := NavigationMode and (ABarControl = GetActiveBarControl);
end;

function TdxBarNavigationController.IsNavigationKey(AKey: Word): Boolean;
begin
  Result := (AKey in [VK_LEFT, VK_RIGHT, VK_UP, VK_DOWN]) or
    (AKey = VK_TAB) and (GetKeyState(VK_CONTROL) >= 0);
end;

function TdxBarNavigationController.NeedsKey(AKey: Word; AShift: TShiftState): Boolean;
begin
  Result := IsNavigationControllerKey(AKey) and (SelectedObjectParent <> nil) and SelectedObjectParent.CanNavigateToChildren(AKey) or
    (IsKeyTipsWaiting or KeyTipsHandlingMode) and IsKeyTipsKey(AKey, AShift);
end;

procedure TdxBarNavigationController.SelectDefaultObject(
  ARootObject: IdxBarAccessibilityHelper);
var
  ADefaultObject: IdxBarAccessibilityHelper;
begin
  ADefaultObject := ARootObject.GetDefaultAccessibleObject;
  if ADefaultObject <> nil then
  begin
    FNavigationMode := True;
    ADefaultObject.Select(False);
  end;
end;

procedure TdxBarNavigationController.SetKeyTipsShowingState(
  AActiveKeyTipContainer: IdxBarAccessibilityHelper;
  const AKeyTipsTypingString: string);

  function GetHelperInstance(
    AHelper: IdxBarAccessibilityHelper): TObject;
  begin
    Result := nil;
    if AHelper <> nil then
      Result := AHelper.GetBarHelper;
  end;

  procedure SynchronizeKeyTipWindows;
  var
    AKeyTipData: TdxBarKeyTipData;
    AKeyTipWindowsManager: IdxBarKeyTipWindowsManager;
    I: Integer;
  begin
    FKeyTipsShowingState.ActiveContainer.AreKeyTipsSupported(AKeyTipWindowsManager);
    for I := 0 to FKeyTipsShowingState.KeyTipsData.Count - 1 do
    begin
      AKeyTipData := TdxBarKeyTipData(FKeyTipsShowingState.KeyTipsData[I]);
      if not AKeyTipData.Visible then
        Continue;
      if (FKeyTipsShowingState.TypingString = '') or
        (Pos(FKeyTipsShowingState.TypingString, AKeyTipData.NormalizedKeyTip) = 1) then
          AKeyTipData.ShowKeyTipWindow(AKeyTipWindowsManager)
      else
        AKeyTipData.HideKeyTipWindow(AKeyTipWindowsManager);
    end;
    AKeyTipWindowsManager.Show;
  end;

var
  AKeyTipWindowsManager: IdxBarKeyTipWindowsManager;
  ANewContainer, APrevContainer: TObject;
  I: Integer;
begin
  APrevContainer := GetHelperInstance(FKeyTipsShowingState.ActiveContainer);
  ANewContainer := GetHelperInstance(AActiveKeyTipContainer);
  if ANewContainer <> APrevContainer then
  begin
    if FKeyTipsShowingState.ActiveContainer <> nil then
    begin
      FKeyTipsShowingState.ActiveContainer.AreKeyTipsSupported(AKeyTipWindowsManager);
      for I := 0 to FKeyTipsShowingState.KeyTipsData.Count - 1 do
        TdxBarKeyTipData(FKeyTipsShowingState.KeyTipsData[I]).HideKeyTipWindow(AKeyTipWindowsManager);
      FreeAndNil(FKeyTipsShowingState.KeyTipsData);
    end;
    FKeyTipsShowingState.ActiveContainer := AActiveKeyTipContainer;
    FKeyTipsShowingState.TypingString := '';
    if FKeyTipsShowingState.ActiveContainer <> nil then
    begin
      FKeyTipsShowingState.ActiveContainer.AreKeyTipsSupported(AKeyTipWindowsManager);
      FKeyTipsShowingState.TypingString := AnsiUpperCase(AKeyTipsTypingString);
      FKeyTipsShowingState.KeyTipsData := TdxObjectList.Create(True);
      FKeyTipsShowingState.ActiveContainer.GetBarHelper.GetKeyTipsData(FKeyTipsShowingState.KeyTipsData);
      SynchronizeKeyTipWindows;
    end;
  end
  else
    if not AnsiSameText(FKeyTipsShowingState.TypingString, AKeyTipsTypingString) then
    begin
      FKeyTipsShowingState.TypingString := AnsiUpperCase(AKeyTipsTypingString);
      SynchronizeKeyTipWindows;
    end;
end;

procedure TdxBarNavigationController.StopKeyboardHandling;
begin
  WaitForMenu := False;
  if SelectedObject <> nil then
    SelectedObject.GetBarManager.HideHint;
  UnselectAssignedSelectedObject;
  if SelectedObject <> nil then
    SelectedObject.Unselect(nil);
  StopKeyTipsHandlingMode;
end;

procedure TdxBarNavigationController.UnassignObject(
  AObject: IdxBarAccessibilityHelper);
begin
  if (FSelectedObject <> nil) and (AObject.GetHelper = FSelectedObject.GetHelper) then
    FSelectedObject := nil;
  if (FSelectedObjectParent <> nil) and (AObject.GetHelper = FSelectedObjectParent.GetHelper) then
  begin
    FSelectedObject := nil;
    FSelectedObjectParent := nil;
  end;
  if (FKeyTipsShowingState.ActiveContainer <> nil) and
    (FKeyTipsShowingState.ActiveContainer.GetHelper = AObject.GetHelper) then
      SetKeyTipsShowingState(nil, '');
end;

procedure TdxBarNavigationController.UnselectAssignedSelectedObject;
begin
  if BarNavigationController.AssignedSelectedObject <> nil then
    BarNavigationController.AssignedSelectedObject.Unselect(nil);
end;

procedure TdxBarNavigationController.ResetNavigationMode;
begin
  FNavigationMode := False;
end;

procedure TdxBarNavigationController.DestroyKeyTipsWaitingTimer;
begin
  FreeAndNil(FKeyTipsWaitingTimer);
end;

function TdxBarNavigationController.GetActiveBarControl: TCustomdxBarControl;
begin
  if ActiveBarControl = nil then
    Result := BarDesignController.QuickControl
  else
    if IsActiveBarControlAccessible and not ActiveBarControl.IsCustomizing then
      Result := ActiveBarControl
    else
      Result := nil;
end;

function TdxBarNavigationController.GetKeyTipsHandlingMode: Boolean;
begin
  Result := FKeyTipsShowingState.ActiveContainer <> nil;
end;

function TdxBarNavigationController.GetSelectedObject: IdxBarAccessibilityHelper;
var
  AActiveBarControl: TCustomdxBarControl;
begin
  AActiveBarControl := GetActiveBarControl;
  if AActiveBarControl <> nil then
  begin
    if AActiveBarControl.SelectedControl <> nil then
      Result := AActiveBarControl.SelectedControl.IAccessibilityHelper
    else
      Result := FSelectedObject;
  end
  else
    Result := FSelectedObject;
end;

function TdxBarNavigationController.GetSelectedObjectParent: IdxBarAccessibilityHelper;
begin
  if GetActiveBarControl <> nil then
    Result := GetActiveBarControl.IAccessibilityHelper
  else
    Result := FSelectedObjectParent;
end;

procedure TdxBarNavigationController.HandleKeyTipKey(AKey: Word; AShift: TShiftState);
var
  AIsKeyAcceptable: Boolean;
  AOnExecute: TNotifyEvent;
  AKeyTipContainer: IdxBarAccessibilityHelper;
begin
  IsKeyTipsKey(AKey, AShift, AIsKeyAcceptable, AOnExecute);
  if Assigned(AOnExecute) then
  begin
    FKeyTipsWaitingRootObject := nil;
    DestroyKeyTipsWaitingTimer;
    AOnExecute(nil);
  end
  else
  begin
    AKeyTipContainer := FKeyTipsShowingState.ActiveContainer;
    if AKeyTipContainer = nil then
    begin
      AKeyTipContainer := FKeyTipsWaitingRootObject;
      FKeyTipsWaitingRootObject := nil;
      DestroyKeyTipsWaitingTimer;
    end;
    SetKeyTipsShowingState(AKeyTipContainer, FKeyTipsShowingState.TypingString + Char(AKey));
  end;
end;

function TdxBarNavigationController.IsKeyTipsKey(AKey: Word; AShift: TShiftState;
  out AIsKeyAcceptable: Boolean; out AOnExecute: TNotifyEvent): Boolean;

  function GetKey(AKey: Word): string;
  var
    AKeyChar: Char;
  begin
    AKeyChar := GetCharFromKeyCode(AKey);
    if AKeyChar <> #0 then
      Result := AKeyChar
    else
      Result := '';
  end;

var
  AKeyTipData: TdxBarKeyTipData;
  AKeyTipsData: TdxObjectList;
  AKeyTipsTypingString: string;
  I: Integer;
begin
  Result := KeyTipsHandlingMode and (AKey = VK_ESCAPE);
  if Result then
    Exit;

  Result := IsTextCharForKeyTip(AKey);
  if not Result then
    Exit;

  if ssAlt in AShift then
    Result := False;

  AIsKeyAcceptable := False;
  AOnExecute := nil;
  AKeyTipsData := nil;
  try
    if FKeyTipsShowingState.ActiveContainer = nil then
    begin
      AKeyTipsData := TdxObjectList.Create(True);
      FKeyTipsWaitingRootObject.GetBarHelper.GetKeyTipsData(AKeyTipsData);
      AKeyTipsTypingString := '';
    end
    else
    begin
      AKeyTipsData := FKeyTipsShowingState.KeyTipsData;
      AKeyTipsTypingString := FKeyTipsShowingState.TypingString;
    end;
    AKeyTipsTypingString := AKeyTipsTypingString + AnsiUpperCase(GetKey(AKey));
    for I := 0 to AKeyTipsData.Count - 1 do
      if AnsiPos(AKeyTipsTypingString, TdxBarKeyTipData(AKeyTipsData[I]).NormalizedKeyTip) = 1 then
      begin
        AIsKeyAcceptable := True;
        AKeyTipData := TdxBarKeyTipData(AKeyTipsData[I]);
        if AnsiSameStr(AKeyTipsTypingString, AKeyTipData.NormalizedKeyTip) and AKeyTipData.Enabled then
          AOnExecute := AKeyTipData.OnExecute;
        Result := True;
        Break;
      end;
      if FHandleKey and not AIsKeyAcceptable then
        SysUtils.Beep;
  finally
    if FKeyTipsShowingState.ActiveContainer = nil then
      FreeAndNil(AKeyTipsData);
  end;
end;

function TdxBarNavigationController.IsKeyTipsKey(AKey: Word; AShift: TShiftState;
  out AIsKeyAcceptable: Boolean): Boolean;
var
  AOnExecute: TNotifyEvent;
begin
  Result := IsKeyTipsKey(AKey, AShift, AIsKeyAcceptable, AOnExecute);
end;

function TdxBarNavigationController.IsNavigationControllerKey(AKey: Word): Boolean;
begin
  Result := IsNavigationKey(AKey) or
    (ActiveBarControl = nil) and (BarDesignController.QuickControl = nil) and
    ((AKey = VK_MENU) or (AKey = VK_F10) and (SelectedObjectParent <> nil) and SelectedObjectParent.GetBarManager.UseF10ForMenu);
  if SelectedObject <> nil then
    Result := Result or SelectedObject.IsNavigationKey(AKey)
  else
    if SelectedObjectParent <> nil then
      Result := Result or SelectedObjectParent.IsNavigationKey(AKey);
end;

procedure TdxBarNavigationController.KeyTipsEscapeHandler;
begin
  HandleKeyTipsEscape(FKeyTipsShowingState.ActiveContainer);
end;

procedure TdxBarNavigationController.KeyTipsWaitingTimerHandler(Sender: TObject);
begin
  if WaitForMenu then
    EndKeyTipsWaiting(True)
  else
    DestroyKeyTipsWaitingTimer;
end;

procedure TdxBarNavigationController.StopKeyTipsHandlingMode;
begin
  EndKeyTipsWaiting(False);
  SetKeyTipsShowingState(nil, '');
end;

initialization
  FUnitIsFinalized := False; // D10 bug
  RegisterClasses([TdxBar, TdxBarGroup, TdxBarScreenTip, TdxBarScreenTipBand, TdxBarScreenTipCollection, TdxBarApplicationMenuButtons, TdxBarApplicationMenuButton]);

  FUser32DLL := LoadLibrary('USER32');
  if FUser32DLL > 32 then
  begin
    @UpdateLayeredWindow := GetProcAddress(FUser32DLL, 'UpdateLayeredWindow');
    @AnimateWindowProc := GetProcAddress(FUser32DLL, 'AnimateWindow');
    @SetLayeredWindowAttributes := GetProcAddress(FUser32DLL, 'SetLayeredWindowAttributes');
  end;
  dxBarManagerList := TdxBarManagerList.Create;
  RefreshDeviceConsts;
  CreatePatternBrush;

  FBarControls := TList.Create;
  FBarNavigationController := TdxBarNavigationController.Create;

  dxBarRegisterItem(TdxBarButton, TdxBarButtonControl, True);
  dxBarRegisterItem(TdxBarEdit, TdxBarEditControl, True);
  dxBarRegisterItem(TCustomdxBarCombo, TCustomdxBarComboControl, True);
  dxBarRegisterItem(TdxBarCombo, TdxBarComboControl, True);
  dxBarRegisterItem(TdxBarSubItem, TdxBarSubItemControl, True);
  dxBarRegisterItem(TdxBarListItem, TdxBarContainerItemControl, True);
  dxBarRegisterItem(TdxBarContainerItem, TdxBarContainerItemControl, True);
  dxBarRegisterItem(TdxBarExtraPaneListItem, TdxBarContainerItemControl, False);
  dxBarRegisterItem(TdxBarLabel, TdxBarCustomStaticControl, False);
  dxBarRegisterItem(TdxBarSeparator, TdxBarSeparatorControl, True);
  dxBarRegisterItem(TdxBarApplicationMenuButtonItem, TdxBarApplicationMenuButtonControl, False);

  dxBarRegisterItem(TdxBarQuickCustExtButton, TdxBarQuickCustExtButtonControl, False);
  dxBarRegisterItem(TdxBarQuickCustItem, TdxBarQuickCustItemControl, False);
  dxBarRegisterItem(TdxBarQuickAccessItem, TdxBarSubItemControl, False);

  dxBarRegisterItem(TSystemMenuSubItem, TSystemMenuSubItemControl, False);

  BarDesignController.RegisterBarControlEditor(TdxAddSubItemEditor);
  BarDesignController.RegisterBarControlEditor(TdxAddButtonEditor);
  BarDesignController.RegisterBarControlEditor(TdxItemsEditorEx);

  BarDesignController.RegisterBarControlDesignHelper(TdxBarControl, TdxBarControlDesignHelper);
  BarDesignController.RegisterBarControlDesignHelper(TdxBarSubMenuControl, TdxBarSubMenuControlDesignHelper);
  BarDesignController.RegisterBarControlDesignHelper(TdxBarApplicationMenuControl, TdxBarApplicationMenuControlDesignHelper);

  Screen.Cursors[crdxBarDrag] := LoadCursor(HInstance, 'DXBARDRAGCURSOR');
  Screen.Cursors[crdxBarDragCopy] := LoadCursor(HInstance, 'DXBARDRAGCOPYCURSOR');
  Screen.Cursors[crdxBarDragNoDrop] := LoadCursor(HInstance, 'DXBARDRAGNODROPCURSOR');
  Screen.Cursors[crdxBarEditSizing] := LoadCursor(HInstance, 'DXBAREDITSIZINGCURSOR');

  if not IsLibrary then
  begin
    FPrevInitProc := InitProc;
    InitProc := @dxBarInitProc;
  end;

finalization
  FUnitIsFinalized := True;
  FreeAndNil(FBarNavigationController);
  FBarControls.Free;

  FreeAndNil(FRegdxItemList);
  FreeAndNil(FBarDesignController);
  FreeAndNil(FBarCanvas);
  FreeAndNil(FBarFlatPainter);

  DeleteObject(PatternBrush);
  dxFreeAndNil(dxBarManagerList);
  if FUser32DLL > 32 then
    FreeLibrary(FUser32DLL);

end.
