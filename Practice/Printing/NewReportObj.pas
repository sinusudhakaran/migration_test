unit NewReportObj;
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
{
  Title:   New Report Object

  Written: Dec 1999
  Authors: Matthew

  Purpose: Replace the old report object with one that is more flexible.

  Notes:  The basic report object will no longer decend from a TBKReport,
          because this assumes that the report will be sent to a printer.

          The basic report object will handle the structure of the report ( columns etc)
          and the current data line.  These will be accessed from the Render Engine
          Object when output is required.  Any custom report settings will be loaded
          and saved here.  The report obj contains a pointer to the current report
          settings record being used, and the the PrintManagerObj currently being
          used.

          The report output will be generated by a Render Engine object that desends
          from a TRenderEngine object.  This allows us to create a different render
          engine object to send the output to different media, ie canvas or file.

          Process: Report To File
          ------------------------

          The new report is decended from the TBKPrintJob Object

          ------------------
          | TBKReport  |--------->   TRenderToFile
          ------------------
                  |
          ------------------
          |   TMyReport    |
          ------------------
                 .RenderDetail --------->    TRenderToFile.RenderDetail

                 .Self         <----------  TRenderToFile.Report

          A TRenderToFile object is created and all rendering requests are
          passed to in.  The RenderToFile object can see the column and header/footer
          information thru its Report property.

          To Generate the report the TBKReport obj creates a TRenderToFile object
          and then calls its own BKPrint method.  This calls the code to generate the
          detail of the report, all calls are passed on to the TRenderToFile object


          Process: Report To Canvas (print or preview)
          --------------------------

          The new report is decended from the TBKReport Object
          The TRenderToCanvas obj contains a TBKPrintJob Object which provides
          a canvas to draw on                                    ---------------
                                                                 | TBKPrintController |
                                                                 ---------------
          ------------------                                            |
          | TBKReport      |--------->   TRenderToCanvas         --------------
          ------------------                 .PrintDoc --------  | TBKPrintJob |
                  |                                              --------------
          ------------------                                       .OnPrintMethod
          |   TMyReport    |                          <--------    .OnBeforePrint
          ------------------                                       .OnNewPage

                 .RenderDetail --------->    .RenderDetail
                                                 (Paint on to .PrintDoc.Canvas)

                 .Self         <----------   .Report

           The TRenderToCanvas.Report property provides the link back to the
           Header/Footer and columns details for the Report.

           The TRenderToCanvas object handles calls routines in the BKPrinter obj
           for loading and retrieving the printer/report settings.  Report setup is
           handled by the bkPrinter obj.

           To generate a report the TBKReport obj creates a TRenderToCanvas
           obj and then calls the print or preview method of the TRenderToCanvas obj.
           This creates a TBKPrint method and calls Print or Preview.
           TBKPrintJob.Create output is called, this calls the OnBeforePrint method
           and the OnNewPage method to initialise the document and the render to
           headers and footer.  When the report is ready for the detail it calls
           the OnPrintMethod.

           The OnPrintMethod of the TBKPrintJob obj links to a CallReportOnPrint
           method in the TRenderToCanvas object.  This calls the BKPrint Method
           of the report.  This allows the TBKPrintJob object to call the code
           which creates the detail of the report.

          Process: Report Setup
          ------------------------
          To Setup a Report call the SetupReport method with an appropriate
          destination. At the moment this will only accept printer setup as
          there are currently no settings for file.

          Printer/Screen

          SetupReport will pass the call on to a TBKPrintJob object.


}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

interface

uses
   LockUtils,
   ReportTypes,
   windows,
   classes,
   graphics,
   dialogs,
   forms,
   sysutils,
   variants,
   ssRenderFax,  //?? need this to catch exception type
   printers,
   repcols,
   ladefs,
   moneydef,
   PrintMgrObj,
   RenderEngineObj,
   UserReportSettings,
   ReportDefs,
   ReportImages,
   RptParams,
   SaveReportToDlg,
   InfoMoreFrm,
   BKConst,
   Progress,
   Globals,
   SignUtils,
   BKPrintJob,
   RTFBands,
   FaxParametersObj,
   WebXOffice;

type
  TReportMargins = record
                 mtop,
                 mleft,
                 mbottom,
                 mright : longint;
  end;

type
  TCallbackProc = procedure() of object; //TNotifyevent?
  TProcedurePtr = procedure(Sender: TObject); //TNotifyevent?

type
  TBKReport = class( TObject)
  private
    FColumns            : TReportColumns;
    FHeader             : THeaderFooterCollection;
    FFooter             : THeaderFooterCollection;
    FUserReportSettings : pWindows_Report_Setting_Rec;
    FOnBKPrint          : TProcedurePtr;
    FOnBKPrintEx        : TCallbackProc;
    FReportTitle        : string;
    FFileFormats        : TFileFormatSet;
    FOriginalDest       : TReportDest;
    FIsAdmin            : Boolean;
    FFileDest           : Integer;
    FReportFile         : string;
    FFileIsSet          : Boolean;
    FReportType         : TReportType;
    FReportTypeParams   : TReportTypeParams;
    fGapWidth           : integer;

    FItemStyle: TStyleTypes;
    FBlindOn: Boolean;
    procedure SetReportTitle(const Value: string);
    procedure AddToTotals(const aCurr: Currency; const ForColumn : integer);
    procedure SetReportType(const Value: TReportType);
    procedure SetItemStyle(const Value: TStyleTypes);
    procedure SetBlindOn(const Value: Boolean);
    procedure SetReportTypeParams(const Value: TReportTypeParams);
  protected
    FReportStyle: TStyleItems;
    FOnAfterNewPage : TProcedurePtr;
    FPrintMgrToUse  : TPrintManagerObj;
    FCurrDetail     : TStringList;
    RenderEngine    : TCustomRenderEngine;  //use base class, don't know
                                            //which one we will need at creation
    function GetRendEngCanvas() : TCanvas;
    function GetTotalLineWidth() : integer;
    function PrevWordPos(aText : string; aCurrPos : integer) : integer;
    function GetLengthOfTextThatFitsIntoWidth(aText : string; aWidth : integer) : integer;

    procedure UpdateColumnCanvasWidths();
  public
    Sections: array[THFSection] of TRTFBand;
    constructor Create (RptType: TReportType); virtual;
    destructor Destroy; override;

    procedure WrapText(ColID: Integer; TextToWrap: string; var ExtraLines: TStringList);

    procedure AddHeader(aHeader : THeaderFooterLine);
    procedure AddFooter(aFooter : THeaderFooterLine);
    procedure AddColumn (aCol : TReportColumn);
    //Routines for clearing totals
    procedure ClearSubSectionTotal;
    procedure ClearSectionTotal;
    procedure ClearSubTotals;
    procedure ClearGrandTotals;
    procedure ClearRunningTotals;
    procedure ClearAllTotals;
    //Routines for adding data to current line, essentially these are formating routines
    procedure PutString(aString : string; aWrap : boolean = false);
    procedure PutStringMultipleColumns ( aString : string; aNumberOfColumns : integer);
    procedure PutInteger( aInteger : longint; aWrap : boolean = false);
    procedure PutImage( aImageName : string; aScale : integer);
    procedure PutCurrency( aCurr : currency; IncludeInTotals: Boolean = True; aWrap : boolean = false); overload;
    procedure PutCurrency( aCurr : Currency; DefaultSign : TSign; aWrap : boolean = false); overload;
    procedure PutCurrencyTotal(aCurr : currency);
    procedure PutMoney (aMoney : money; IncludeInTotals: Boolean = True; aWrap : boolean = false); overload;
    procedure PutMoney (aMoney : money; DefaultSign : TSign; aWrap : boolean = false); overload;
    procedure PutMoneyTotal (aMoney : money);
    procedure PutMoneyDontAdd (aMoney : money);
    procedure PutQuantity(aMoney : money; aWrap : boolean = false); overload;
    procedure PutQuantity(aMoney : money; DefaultSign : TSign; aWrap : boolean = false); overload;
    function FormatPercentString (const Value : Currency ) : string; overload;
    function FormatPercentString (const Value : Currency; ForCol : TReportColumn ):string; Overload;
    function RenderColumnWidth(aColIndex: integer; aText: string): integer;
    procedure PutPercentage(Value : money; AddTotals : Boolean = True; DefaultSign: TSign = NNone);
    procedure AddPercentage(Value : money; AddTotals : Boolean = True; DefaultSign: TSign = NNone);

    procedure SwitchWrapForColumn(aColumn : integer; aValue : boolean);
    procedure SkipColumn;
    procedure SkipColumns(aNumOfColumns : integer);
    //External routines for actually putting the output on the canvas, rely on protected
    //routines above, they are provided here for compatibility but could be replace in the
    //calling code with a call to RenderEngine.RenderDetailHeader etc.
    procedure RequireLines(lines :integer);
    procedure RenderDetailHeader;
    procedure RenderDetailLine(const isnewDetail: Boolean = True; Style: TStyleTypes = siDetail; aFontOverride : TFont = nil);
    procedure RenderEmptyLine();

    procedure RenderDetailSubSectionTotal(const TotalName : string); overload;
    procedure RenderDetailSubSectionTotal(const TotalName : string; DefaultSign : TSign); overload;
    procedure RenderDetailSectionTotal(const TotalName : string); overload;
    procedure RenderDetailSectionTotal(const TotalName : string; DefaultSign : TSign); overload;
    procedure RenderDetailSubTotal(const TotalName : string; NewLine: Boolean = True;
      KeepTotals: Boolean = False; TotalSubName: string = ''; Style: TStyleTypes = siSectionTotal); overload;
    procedure RenderDetailSubTotal(const TotalName : string; DefaultSign : TSign; Style: TStyleTypes = siSectionTotal ); overload;
    procedure RenderDetailGrandTotal(const TotalName : string); overload;
    procedure RenderDetailGrandTotal(const TotalName : string; DefaultSign : TSign); overload;
    //the running total is the same as a grand total, except that it is not reset after printing
    procedure RenderDetailRunningTotal(const TotalName : string); overload;
    procedure RenderDetailRunningTotal(const TotalName : string; DefaultSign : TSign); overload;
    procedure RenderColumnLine(ColNo: Integer); overload;
    procedure RenderAllVerticalColumnLines;
    procedure RenderRuledLineWithColLines(LeaveLines: integer = 0;
      aPenStyle: TPenStyle = psSolid; VertColLineType: TVertColLineType = vcFull);
    procedure RenderTitleLine(Text : string);
    procedure RenderTextLine(Text:string; Underlined : boolean = false; AddLineIfUnderlined: boolean = True);
    procedure RenderMemo( Text : string);
    procedure RenderRuledLine; overload;
    procedure RenderRuledLine(Style : TPenStyle); overload;
    procedure SingleUnderLine;
    procedure DoubleUnderLine;
    procedure ReportNewPage;

    //routines to modify font
    procedure UseCustomFont( aFontname : string; aFontSize : integer; aFontStyle : TFontStyles; aLineSize : integer = 0);
    procedure UseDefaultFont;

    //Access to Report Settings
    function LoadReportSettings(PrintMgr : TPrintManagerObj; ID:string) : pWindows_Report_Setting_Rec;
    procedure SaveReportSettings;
    //User Print settings Object
    property  UserReportSettings : pWindows_Report_Setting_Rec read FUserReportSettings;
    property  OnBKPrint          : TProcedurePtr read FOnBKPrint write FOnBKPrint;
    property  OnBKPrintEx        : TCallbackProc read FOnBKPrintEx write FOnBKPrintEx;
    property  OnAfterNewPage     : TProcedurePtr read FOnAfterNewPage write FOnAfterNewPage;
    property  ReportTitle        : string read FReportTitle write SetReportTitle;
    property  OriginalDestination : TReportDest read FOriginalDest;

    //Generate output of report
    procedure Generate(Dest : TReportDest; Params : TRptParameters = nil; Preview: Boolean = True; AskToOpen: Boolean = True); virtual;
    //Generate report to file, special case accepts filename and type.  User is not asked
    function GenerateToFile( const FileName : string; const FileFormat : integer; Params: TRptParameters = nil): Boolean;
    //Generate a report to fax using supplied parameters - windows fax service only
    function GenerateToFax(FaxParameters: TFaxParameters; const FaxTransportType: byte; Params: TRptParameters = nil) : boolean;
    //Setup report settings
    procedure SetupReport( const Dest : TReportDest);
    procedure SetCurrDetail(NewCurrDetail : TStringList);
    procedure NewDetail;
    //properties for external viewing
    property CurrDetail          : TStringList read FCurrDetail;
    property Columns             : TReportColumns read FColumns;
    property Header              : THeaderFooterCollection read FHeader;
    property Footer              : THeaderFooterCollection read FFooter;
    property FileFormats         : TFileFormatSet read FFileFormats write FFileFormats;
    property IsAdmin             : Boolean read FIsAdmin write FIsAdmin;
    property ReportType          : TReportType read FReportType write SetReportType;

    property FileDest            : Integer read FFileDest write FFileDest;
    property ReportFile          : string read FReportFile write FReportFile;
    property FileIsSet           : Boolean read FFileIsSet write FFileIsSet;
    property ReportTypeParams    : TReportTypeParams read FReportTypeParams write SetReportTypeParams;
    property ReportStyle         : TStyleItems read FReportStyle;
    property ItemStyle           : TStyleTypes read FItemStyle write SetItemStyle;
    property BlindOn: Boolean read FBlindOn write SetBlindOn;
    procedure BKPrint; virtual;
    procedure AfterNewPage(SavedDetail : Boolean); virtual;

    procedure SplitText(const Text: String; ColumnWidth: Integer; var WrappedText: TWrappedText);
    function GetTextWidth(aValue : string) : integer;
    procedure WrapTextForColumn(aColumn: integer);

    property RendEngCanvas : TCanvas read GetRendEngCanvas;
    property TotalLineWidth : integer read GetTotalLineWidth;
  end;

  TWriteColumnValue = procedure(Report: TBKReport; ColumnId: Integer; Value: Variant);

  {Provides the ability to wrap column text}
  TBKReportRecordLines = class
  private
    type
      TColumnLineValue = array of Variant;
      TColumnLines = array of TColumnLineValue;

  private
    FReport: TBKReport;
    FColumnLines: TColumnLines;
    FMaxLines: Integer;
    FWriteColumnValue: TWriteColumnValue;

    procedure PutLines;

    procedure NewLines(NumLines: Integer);

    procedure Clear;
    procedure Reset;
  public
    constructor Create(Report: TBKReport; WriteColumnValue: TWriteColumnValue);
    destructor Destroy; override;

    procedure AddColumnText(ColumnId: Integer; const Text: String; Wrap: Boolean = False); overload;
    procedure AddColumnText(ColumnId: Integer; const TextLines: array of String; Wrap: Boolean = False); overload;

    procedure AddColumnValue(ColumnId: Integer; Value: Variant);

    procedure BeginUpdate;
    procedure EndUpdate;
  end;

Const
  SKIPFIELD = '<SKIP>';
  DATEFIELD = '<DATE>';
  DATETIMEFIELD = '<DATETIME>';
  PAGEFIELD = '<PAGE>';
  IMGFIELD = '<IMG';
  IMGSCALEFIELD = '<IMGSCALE';
  STRFIELD = '<STR';
  COLSKIPFIELD = '<COLSKIP';
  ENDFIELD ='>';
  RTFBAND = '<RTF';
  MISSINGFIELD = '<MISSING>';                                      


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
implementation

uses
  ComObj,
  ShellAPI,
  GenUtils,
  glConst,
  ReportToFile,
  ReportToCanvas,
  ReportToExcel,
  UsageUtils,
  UbatchBase,
  LogUtil,
  ErrorMoreFrm,
  YesNoDlg,
  WinUtils,
  CustomFileFormats,
  AttachReportToEmailDlg,
  strutils,
  ReportFileFormat,
  MailFrm;

const
   UnitName = 'NewReportObj';

{ TBKReport }
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.AddColumn(aCol: TReportColumn);
begin
   FColumns.Insert(aCol);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.AddFooter(aFooter: THeaderFooterLine);
begin
   FFooter.Insert(aFooter);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.AddHeader(aHeader: THeaderFooterLine);
begin
   FHeader.Insert(aHeader);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.BKPrint;
begin
  fGapWidth := GetTextWidth('A');
  UpdateColumnCanvasWidths;

  if Assigned(FOnBKPrint) then
    FOnBKPrint(Self);

  if Assigned(FOnBKPrintEx) then
    FOnBKPrintEx();
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.AfterNewPage(SavedDetail : Boolean);
begin
  if Assigned(OnAfterNewPage) then
    FOnAfterNewPage(Self);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
constructor TBKReport.Create;
var I: Integer;
begin
   inherited Create;
   //Current Detail Line
   FCurrDetail := TStringList.Create;
   //Init Headers/Footers
   FHeader    := THeaderFooterCollection.Create;
   FFooter    := THeaderFooterCollection.Create;
   //Init Columns
   FColumns   := TReportColumns.Create;
   FReportTypeParams := TReportTypeParams.Create;
   FReportStyle := nil;
   ReportType := RptType;

   //load default print manager
   FPrintMgrToUse := nil;   //global object
   FUserReportSettings := nil;
   FFileFormats := [];
   FIsAdmin := False;
   RenderEngine := nil;
   FFileDest := -1;
   FReportFile := '';
   FFileIsSet := False;
   for I := integer(Low(Sections)) to integer(High(Sections)) do
      Sections[THFSection(I)] := TRTFBand.Create(FReportTypeParams.HF_Sections[ THFSection(I)]);

end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
destructor TBKReport.Destroy;
var I: Integer;
begin
    try
       if Assigned(FUserReportSettings) then
          if FUserReportSettings.s7Save_Required then
             SaveReportSettings
          else begin
             if FUserReportSettings.s7Is_Default then begin
                //Currently using default settings, they don't need to be saved
                //so must free the memory allocated when GetBkDefaultReportSettings
                //was called
                FreeMem( FUserReportSettings, Windows_Report_Setting_Rec_Size);
             end;
          end;
    finally
       FColumns.Free;
       FHeader.Free;
       FFooter.Free;
       FCurrDetail.Free;
       FReportTypeParams.Free;
       if Assigned(FReportStyle) then
          FReportStyle.Free;

       for I := integer(Low(Sections)) to integer(High(Sections)) do
          Sections[THFSection(I)].Free;
       inherited Destroy;
    end;
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure OpenExcelFile(AFileName: string);
var
  V: Variant;
begin
  //Initiate a channel to MSQuery.
  try
    V := GetActiveOleObject('Excel.Application');
  except
    V := CreateOleObject('Excel.Application');
  end;

  if not VarIsNull(V) then
    try
      V.ScreenUpdating := False;
      try
        V.Visible := True;
        V.DisplayAlerts := True;
        V.WorkBooks.OpenText( AFileName, {FileName}
                              , {Origin}
                              1, {StartRow}
                              , {DataType}
                              , {TextQualifier}
                              False, {ConsecutiveDelimiter}
                              False, {Tab}
                              False, {Semicolon}
                              False, {Comma}
                              False, {Space}
                              false, {Other}
                              '', {OtherChar}
                            ); {FieldInfo}
      finally
        V.ScreenUpdating := True;
      end;
      // Quit excel
    finally
      V := Null;
    end;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.Generate(Dest: TReportDest;Params : TRptParameters = nil; Preview: Boolean = True; AskToOpen: Boolean = True );
//Create the correct rendering engine object
const
   ThisMethodName = 'TReport.Generate';
var
  Filename     : string;
  FileFormat   : integer;
  //sMsg         : string;
  AllOK, DestinationPreChosen: Boolean;
  Title, Desc: string;
  WebID, i,CatID: Integer;
  SelectedCustomFileFormat : TCustomFileFormat;
  HasCustomDefault : boolean;
  FileCheckStatus : TFileCheckStatus;

  function GetFileType : Boolean;
  var
    CustIndex : integer;
  begin
     {$B-}
     if Assigned(Params) and
        Params.BatchSetup then
     begin
       FileFormat := Params.GetBatchInteger('_FileType',rfExcel);
       if Params.RptBatch.RunFileLocation = '' then
         FileName := UserDir + FUserReportSettings.s7Report_Name + RptFileFormat.Extensions[FileFormat]
       else
         FileName := Params.RptBatch.RunFileLocation + FUserReportSettings.s7Report_Name + RptFileFormat.Extensions[FileFormat];
     end
     else
     begin
       //Set default filename
       FileFormat := rfExcel;
       FileName := UserDir + FUserReportSettings.s7Report_Name + RptFileFormat.Extensions[FileFormat];
     end;

     if assigned(Params) then
       Result := GenerateReportTo( Filename, FileFormat, FileFormats, Title, Desc, WebID, CatID, FIsAdmin, Params.CustomFileFormats)
     else
       Result := GenerateReportTo( Filename, FileFormat, FileFormats, Title, Desc, WebID, CatID, FIsAdmin);

     if Result then
     begin
       if Assigned(Params) then
       begin
         if Params.BatchSetup then
         begin
           Params.RunReport(Dest,Filename);
           Params.SetBatchInteger('_FileType',FileFormat);
         end;
       end;
     end;
   end;

  function ShowOutput : Boolean;
  begin
     Result := AllOk;
     if Result then begin
        if not Preview then
           Result := False;
        if not assigned(Params) then
           Exit;
        if Params.BatchRun then
           Result := False;
     end;
  end;

  procedure DoError (const Msg : string; const DoLog : Boolean);
  begin
     if DoLog then
         LogUtil.LogMsg( lmError, UnitName, ThisMethodName + ' : ' + Msg );
     {$B-}                                                
     if Assigned (Params)
     and Params.BatchRun then
        Params.RptBatch.RunResult := Msg
     else
        HelpfulErrorMsg( Msg, 0 );
  end;

  procedure DoEmail;
  var
    iReportFormat: integer;
    sReportName: string;
    sFileName: string;
    sRecipient: string;
    Attachments: TStringList;
  begin
    // User cancel?
    iReportFormat := rfPDF;
    sReportName := FUserReportSettings.s7Report_Name + RptFileFormat.Extensions[iReportFormat];
    if not ShowAttachReportToEmailFrm(Application.MainForm, FileFormats,
      sReportName, iReportFormat) then
    begin
      exit;
    end;

    // Can't generate the report?
    sFileName := UserDir + sReportName;
    if not GenerateToFile(sFileName, iReportFormat) then
    begin
      DoError('Unable to generate report to file', false);
      exit;
    end;

    if assigned(Params) then
      Params.RunReport(Dest, FileName);

    Attachments := TStringList.Create;
    try
      if assigned(Params) then
        sRecipient := Params.Client.clFields.clClient_EMail_Address;

      Attachments.Add(sFilename);

      // User cancel?
      if not SendFilesTo('Send a Report', sRecipient, {Subject=}sReportName, {Body=}'', Attachments) then
        exit;
    finally
      FreeAndNil(Attachments);
    end;
  end;

begin
   SelectedCustomFileFormat := nil;
   ClearAllTotals;
   try
      try
         FOriginalDest := Dest;
         if Assigned(Params) then
         if Params.BatchRunMode = R_Batch then begin
            Dest := rdFile;
            FileDest := rfPDF;
            Preview := False;
            AskToOpen := False;
         end;


         case Dest of
            rdScreen  : begin
               if Assigned(Params) then begin
                  Params.RunReport(Dest);
                  incUsage(Params.UsageTitle(Dest));
               end else
                  incUsage(Self.ReportTitle + '(View)');
               //Show status form here because it takes some time to create the render engine and printer object
               //will be cleared by the OnAfterPrint method when printing completed
               UpdateAppStatus( 'Generating Report', Self.ReportTitle,20);
               {if (PRACINI_UseReportStyles)
               or (GLReportEditStyle > '') then begin

                  RenderEngine := TRenderToFileRTF.Create(Self, Filename, Preview);
                  RenderEngine.Generate;
               end else }begin
                  RenderEngine := TRenderToCanvasEng.Create(Self);
                  //after new page trigger
                  if (Assigned(FOnAfterNewPage)) then
                     RenderEngine.OnAfterNewPage := FOnAfterNewPage;
                  TRenderToCanvasEng(RenderEngine).ShowPreviewForm := Preview;
                  TRenderToCanvasEng(RenderEngine).Preview;
               end;
            end;
            rdPrinter : begin
               if Assigned(Params) then begin
                  Params.RunReport(Dest);
                  IncUsage(Params.UsageTitle(Dest));
               end else
                  incUsage(Self.ReportTitle + '(Print)');

               UpdateAppStatus( 'Generating Report', Self.ReportTitle,20);
               {if PRACINI_UseReportStyles
               or (GLReportEditStyle > '') then begin
                  RenderEngine := TRenderToFileRTF.Create(Self, Filename, False);
                  RenderEngine.Generate;
               end else }begin
                  RenderEngine := TRenderToCanvasEng.Create(Self);
                  //after new page trigger
                  if (Assigned(FOnAfterNewPage)) then
                     RenderEngine.OnAfterNewPage := FOnAfterNewPage;
                  TRenderToCanvasEng(RenderEngine).Print;
               end;
            end;
            rdFax : begin
               DoError ('Manual faxing not implemented',false);
               Exit;
            end;
            rdEmail : DoEmail;

            rdFile    : begin
               AllOK := True;
               //Set default filename
               if FFileDest <> -1 then
               begin
                 FileFormat := FFileDest;
                 if not FileIsSet then
                 begin
                   Filename := UserDir + FUserReportSettings.s7Report_Name + RptFileFormat.Extensions[FileFormat];
                   // generate unique filename
                   i := 1;
                   while BKFileExists(FileName) do
                   begin
                    FileName := UserDir + FUserReportSettings.s7Report_Name + IntToStr(i) + RptFileFormat.Extensions[FileFormat];
                    Inc(i);
                   end;
                 end
                 else
                   FileName := ReportFile;
               end
               else
                 FileName := UserDir + FUserReportSettings.s7Report_Name + RptFileFormat.Extensions[rfCSV];

               DestinationPreChosen := FFileDest <> -1;
               //Ask for format and filename
               if FileIsSet or
                 DestinationPreChosen or
                 GetFileType() then
               begin
                  UpdateAppStatus( 'Generating Report',  Self.ReportTitle, 50);
                  if not Preview then
                  begin
                    FFileDest := FileFormat;
                    ReportFile := FileName;
                  end;

                  case FileFormat of

                     rfCSV        : RenderEngine := TRenderToFileCSV.Create( Self, Filename);
                     rfFixedWidth : begin
                        RenderEngine := TRenderToFileFixed.Create( Self, Filename);
                        //after new page trigger
                        if (Assigned(FOnAfterNewPage)) then
                          RenderEngine.OnAfterNewPage := FOnAfterNewPage;
                        //Use reports default orientation to determine max line width
                        if GetBKReportDefaultOrientation(FUserReportSettings.s7Report_Name) = poPortrait then
                           TRenderToFileFixed(RenderEngine).MaxLineWidth := 132
                        else
                           TRenderToFileFixed(RenderEngine).MaxLineWidth := 160;
                     end;
                     //rfWord
                     rfExcel :
                     begin
                       FileCheckStatus := GetFileLockStatus(Filename);
                       if FileCheckStatus in [fcsOK,fcsCanNotFind] then
                       begin
                         try
                           RenderEngine := TRenderToFileExcel.Create( Self, Filename );
                         except // Case 8461, anything is better than 'Class not registered'
                           RenderEngine := nil;
                           // Also see OfficeFialed in ClientmanagerFrm
                           raise Exception.Create('"MS Office" options not installed or available');
                         end;
                       end
                       else
                       begin
                         case FileCheckStatus of
                           fcsException : raise EInOutError.Create('Error Opening File');
                           fcsCanNotOpen, fcsCanNotLock : raise EInOutError.Create('Check that the file is not already open and try again.');
                         end;
                       end;
                     end;
                     rfPDF,rfAcclipse :
                       begin
                         //Show status form here because it takes some time to create the render engine and printer object
                         //will be cleared by the OnAfterPrint method when printing completed
                         UpdateAppStatus( 'Generating Report', Self.ReportTitle,20);
                         RenderEngine := TRenderToCanvasEng.Create(Self);
                         //after new page trigger
                         if (Assigned(FOnAfterNewPage)) then
                           RenderEngine.OnAfterNewPage := FOnAfterNewPage;
                         AllOK := TRenderToCanvasEng(RenderEngine).PrintPDF(Filename);
                         if FileFormat = rfAcclipse then
                            NotifyQueue(WebXOffice.GetWebXDataPath(WEBX_QUEUE_FOLDER) + ExtractFilename(Filename),
                               IntToStr(WebID), IntToStr(CatID), Title, Desc, 'wx');
                       end;
                     //rfRTF   : RenderEngine := TRenderToFileRTF.Create(Self, Filename, Preview);
                    else
                    begin
                      if FileFormat > rfMax then
                      begin
                        SelectedCustomFileFormat := TCustomFileFormat(Params.CustomFileFormats.Items[FileFormat - 1 - rfMax]);
                      end;
                    end;
                  end;

                  if Assigned(SelectedCustomFileFormat) then
                  begin
                    SelectedCustomFileFormat.CustomFormatCode(FileName);
                  end
                  else
                  if Assigned( RenderEngine) then
                  begin
                     if (AllOK) then RenderEngine.Generate;

                     if Assigned(Params) then begin
                        Params.RunReport(Dest,Filename);
                        incUsage(params.UsageTitle(rdFile));

                     end else
                       incUsage(Self.ReportTitle + '(' + RptFileFormat.Names[FileFormat] + ' File)');


                     //special case for excel. the render engine must be freed
                     //before the resultant file is run otherwise the engine will
                     //load the file and then be close immediately afterwards.
                     if (FileFormat = rfExcel) then
                       FreeAndNil(RenderEngine);

                     case FileFormat of
                        rfCSV, rfFixedWidth, rfExcel, rfPDF, rfAcclipse : begin
                          //Clear Application Status window
                          ClearStatus;
                          if ShowOutput then
                          begin
                            //determine full path name of report
                            if ExtractFilePath( Filename) = '' then begin
                               //the filename has no path info so add the current path
                               Filename := GetCurrentDir + '\' + Filename;
                            end;
                            FReportFile := Filename;
                            if (AskToOpen) and (AskYesNo(RptFileFormat.Names[FileFormat], 'Report saved to "'+ FileName + '".' +
                                #13#10 + #13#10 +
                                'Do you want to view it now?', DLG_YES, 0) = DLG_YES) then
                            begin
                              if FileFormat in [rfExcel] then
                                OpenExcelFile( Filename)
                              else
                                ShellExecute(0, 'open', PChar(FileName), nil, nil, SW_SHOWMAXIMIZED);
                            end;
                          end
                          else if (not AllOK) then

                            DoError('Error generating report "' + FileName + '".' + #13#13 +
                             'Please check that the file "wPDF200A.DLL" exists on your computer.',false);
                        end;
                     end; {caseFileformat}
                  end;
               end;
            end;
         end;
      except
         on e : EInOutError do begin
            DoError(Format( 'Error saving report to "%s" - %s', [FileName, E.Message ] ), true);
         end;

         on E : EPrinter do begin
            DoError(Format( 'Error Generating Report %s - %s', [ Self.ReportTitle,
                                                                E.Message ] ),True);
         end;

         on E : EOleError do begin
            DoError(Format( 'Error Generating Report %s - %s - %s', [  Self.ReportTitle,
                                                                       '"MS Office" options not installed or available',
                                                                       E.Message ]), True);
         end;
      end;
   finally
      //Make sure memory is freed before leaving
      if Assigned(RenderEngine) then begin
        RenderEngine.Free;
        RenderEngine := nil;
      end;
      ClearStatus;
   end;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function TBKReport.LoadReportSettings(PrintMgr: TPrintManagerObj;
  ID: string) : pWindows_Report_Setting_Rec;
//the PrintMgrToUse is set here for the report.  this tells it where to save the settings
//back to later on.
//If no custom users settings are found the load default settings
begin
   FPrintMgrToUse := PrintMgr;
   //Load report settings from print mgr object, will return nil if not
   //custom settings have been defined, in that case create and load default settings
   FUserReportSettings := GetBKUserReportSettings(FPrintMgrToUse,ID);
   if not Assigned(FUserReportSettings) then begin
      FUserReportSettings := GetDefaultReportSettings( ID);
   end;
   result := FUserReportSettings;

   //Set the default report title
   FReportTitle := FUserReportSettings.s7Report_Name;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.NewDetail;
begin
   BlindOn := not FBlindOn;
   //LogMsg(lmDebug,'print',' New detal Now:' + BoolToStr(BlindOn));
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.SaveReportSettings;
begin
    with FUserReportSettings^ do begin
       if s7Is_Default then begin
          //The report was using default settings and a save has been requested
          //This means we need to add the report settings to the list of user
          //report settings being used.
          s7Is_Default    := false;
          s7Save_Required := false;
          InsertNewUserReportSettings(FPrintMgrToUse,FUserReportSettings);
       end
       else begin
          //The report settings will have been updated by the object that
          //was using them.. i.e. Printer Object
          //so nothing needs to be done except reseting the save flag
          s7Save_Required := false;
       end;
    end;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.SetupReport(const Dest: TReportDest);
//Call the correct setup routines for the destination given
const
   ThisMethodName = 'TReport.SetupReport';
var
   PrintDoc   : TBKPrintJob;
begin

   case Dest of
      rdScreen, rdPrinter, rdFax  : begin
         UpdateAppStatus('Loading Report Settings', FUserReportSettings.s7Report_Name,20);
         PrintDoc := TBKPrintJob.Create;
         try
            PrintDoc.LoadSettingsFrom( FUserReportSettings);
            //Clear previous status;
            ClearStatus;
            // If faxing then disable the printer selection panel
            PrintDoc.SetupReport(Dest = rdFax);
            //update settings if changed
            if PrintDoc.ReportSettingsChanged then begin
              //Update report settings with values from PrintDoc object
              PrintDoc.SaveSettingsTo( FUserReportSettings);
              //Set save flag
              FUserReportSettings.s7Save_Required := true;
            end;
         finally
            PrintDoc.Free;
         end;
      end;

      rdFile    : begin
         //Nothing to setup for file yet
      end;
   end;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.SetBlindOn(const Value: Boolean);
begin
  FBlindOn := Value;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.SetCurrDetail(NewCurrDetail : TStringList);
begin
  FCurrDetail.Clear;
  FCurrDetail.Text := NewCurrDetail.Text;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function TBKReport.GetLengthOfTextThatFitsIntoWidth(aText: string; aWidth: integer): integer;
var
  TextWidth : integer;
  StrLen : integer;
  ResLen : integer;
  StrSection : string;
begin
  TextWidth := GetTextWidth(aText);

  // Does the text not fit into the width?
  if TextWidth > aWidth then
  begin
    StrLen := Length(aText);
    // Loop backward through each word until it fits.
    // if there is only one word in the front and it does not fit then go one
    // character at a time rather than one word at a time.
    while (TextWidth > aWidth) do
    begin
      ResLen := PrevWordPos(aText, StrLen);
      if ResLen = -1 then
        break;

      StrSection := LeftStr(aText, ResLen);
      TextWidth := GetTextWidth(StrSection);
      StrLen := ResLen;
    end;
    Result := Length(StrSection);
  end
  else
    Result := Length(aText);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function TBKReport.GetRendEngCanvas: TCanvas;
begin
  if (RenderEngine is TRenderToCanvasEng) then
    result := TRenderToCanvasEng(RenderEngine).OutputBuilder.Canvas
  else
    result := nil;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function TBKReport.GetTextWidth(aValue : string): integer;
begin
  if (RenderEngine is TRenderToCanvasEng) then
    result := TRenderToCanvasEng(RenderEngine).GetTextLength(aValue)
  else
    result := 0;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function TBKReport.GetTotalLineWidth : integer;
begin
  if (RenderEngine is TRenderToCanvasEng) then
    result := TRenderToCanvasEng(RenderEngine).OutputBuilder.OutputAreaWidth
  else
    result := 0;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function TBKReport.PrevWordPos(aText: string; aCurrPos : integer): integer;
var
  Index : integer;
  Found : boolean;
  StrLen : integer;
begin
  // gets the previous word from a set position, if there is no next word go one
  // character or if there is an error return a -1
  Result := -1;
  StrLen := length(aText);

  if (StrLen = 0) or
     (aCurrPos < 1) or
     (aCurrPos > StrLen) then
    Exit;

  Found := false;
  Index := aCurrPos;
  while (not Found and (Index > 1) ) do
  begin
    if (aText[Index] = ' ') and not
       (aText[Index-1] = ' ')  then
      Found := true;

    dec(Index);
  end;

  if Found then
    Result := Index
  else
    Result := aCurrPos-1;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.UpdateColumnCanvasWidths;
var
  ColIndex : integer;
  TotalLineWidth : integer;
  ReportColumn : TReportColumn;
begin
  TotalLineWidth := GetTotalLineWidth();

  for ColIndex := 0 to Columns.ItemCount - 1 do
  begin
    ReportColumn := Columns.Report_Column_At(ColIndex);

    if Assigned(ReportColumn) then
      ReportColumn.CanvasWidth := trunc(TotalLineWidth * (ReportColumn.WidthPercent/100)) - fGapWidth;
  end;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.SetItemStyle(const Value: TStyleTypes);
begin
  if FItemStyle <> Value then begin
     FItemStyle := Value;
     BlindOn := True;
     //LogMsg(lmDebug,'print',' TypeChange on');
     if assigned(RenderEngine) then
        RenderEngine.SetItemStyle(FItemStyle);
  end;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.SetReportTitle(const Value: string);
begin
  FReportTitle := Value;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.SetReportType(const Value: TReportType);
begin
   FReportType := Value;
   if FileLocking.ObtainLock(ltPracHeaderFooterImg, TimeToWaitForPracLogo) then try
      ReadReportParams(FReportTypeParams, FReportType);
      AddReportTypeToList(FReportType, FReportTypeParams);

      if not Assigned(FReportStyle) then
         FReportStyle := TStyleItems.Create(FReportTypeParams.HF_Style);

   finally
     FileLocking.ReleaseLock(ltPracHeaderFooterImg);
   end;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.SetReportTypeParams(const Value: TReportTypeParams);
var I: Integer;
begin
   FReportTypeParams.Assign (Value);
   for I := integer(Low(Sections)) to integer(High(Sections)) do
      Sections[THFSection(I)].Load ( FReportTypeParams.HF_Sections[ THFSection(I)]);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.AddToTotals(const aCurr: Currency; const ForColumn : integer);
var
  aCol : TReportColumn;
begin
  aCol := FColumns.Report_Column_At( ForColumn);

  aCol.SubSectionTotal := aCol.SubSectionTotal + aCurr;
  aCol.SubTotal     := aCol.SubTotal + aCurr;
  aCol.RunningTotal := aCol.RunningTotal + aCurr;
  aCol.GrandTotal   := aCol.GrandTotal + aCurr;

  aCol.SectionTotal := aCol.SectionTotal + aCurr;

end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.PutCurrency(aCurr: currency; IncludeInTotals: Boolean; aWrap : boolean);
var
  newIndex : integer;
begin
  newIndex := FCurrDetail.Count;  { 1 more than the last}
  with FColumns.Report_Column_At(newIndex) do
  begin
    PutString(FormatFloat(FormatString,aCurr), aWrap);

    if IncludeInTotals then
      AddToTotals( aCurr, NewIndex);
  end;
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function TBKReport.FormatPercentString(const Value: Currency): string;
//var a : Currency;
begin
//   a := abs(value);
   Result := FormatFloat('#0.00',Value);
   (*
   if a >= 100.0 then
      // 100 .... 9,999,999....
      Result := FormatFloat('#,##0',Value)
   else if a >= 10.0 then
      //10.0 ... 99.9
      Result := FormatFloat('#0.0',Value)
   else if a >= 1.0 then
      // 1.00 ... 9.99
      Result := FormatFloat('0.00',Value)
   else if a = 0 then
      Result := '-'
   else
      //0.01 .. 0.99
      Result := FormatFloat('0.00',Value)
      { Is Too dangourous.. the . gets missed.. also reads too big..

      // .001 ... .999
      Result := FormatFloat('.000"%"',Value)
      }
   *)   
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function TBKReport.FormatPercentString(const Value: Currency;
  ForCol: TReportColumn): string;
begin
   if (ForCol.PercentReference <> 0) then
     Result := FormatPercentString(100 * Value/(ForCol.PercentReference))
   else
     Result := ''; //FormatPercentString(0); not the same as 0 .. just no ref
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.PutCurrency(aCurr: Currency; DefaultSign: TSign; aWrap : boolean);
//this overloaded procedure is used when the sign of the value when displayed
//is different to the sign of the value for the totals
var
  newIndex : integer;
  DisplayAmount : Currency;
  MoneyValue : Money;
begin
  if DefaultSign in [Credit, Debit] then
  begin
    DisplayAmount := Abs( aCurr );
    MoneyValue := Double2Money(aCurr);
    If SignOf( MoneyValue) <> DefaultSign then
      DisplayAmount := -DisplayAmount;
  end else
    DisplayAmount := aCurr;

  newIndex := FCurrDetail.Count;  { 1 more than the last}
  with FColumns.Report_Column_At(newIndex) do
  begin
    PutString(FormatFloat(FormatString, DisplayAmount), aWrap);
    AddToTotals( aCurr, NewIndex);
  end;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.PutCurrencyTotal(aCurr: currency);
var
   newIndex : integer;
begin
    newIndex := FCurrDetail.Count;  { 1 more than the last}
    with FColumns.Report_Column_At(newIndex) do
    begin
      FCurrDetail.add(FormatFloat(TotalFormat,aCurr));
      AddToTotals( aCurr, NewIndex);
    end;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.PutImage(aImageName : string; aScale : integer);
var
  Column : integer;
begin
  Column := FCurrDetail.Add(IMGFIELD + ' ' + aImageName + ENDFIELD +
                            IMGSCALEFIELD + ' ' + inttostr(aScale) + ENDFIELD);
  SwitchWrapForColumn(Column, false);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.PutInteger(aInteger: Integer; aWrap : boolean);
begin
  PutString(inttoStr(aInteger), aWrap);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.PutMoney(aMoney: money; IncludeInTotals: Boolean; aWrap : boolean);
var
  currAmount : currency;
begin
  currAmount := aMoney/100;
  PutCurrency(currAmount, IncludeInTotals, aWrap);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.PutMoney(aMoney: money; DefaultSign: TSign; aWrap : boolean);
var
  currAmount : currency;
begin
  currAmount := aMoney/100;
  PutCurrency(currAmount, DefaultSign, aWrap);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.PutMoneyDontAdd(aMoney: money);
var
  newIndex : integer;
begin
  newIndex := FCurrDetail.Count;  { 1 more than the last}
  with FColumns.Report_Column_At(newIndex) do
    FCurrDetail.add(FormatFloat(FormatString,aMoney/100));
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.PutMoneyTotal(aMoney: money);
var
   currAmount : currency;
begin
   currAmount := aMoney/100;
   PutCurrencyTotal(currAmount);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.PutPercentage(Value: money; AddTotals : Boolean = True; DefaultSign: TSign = NNone);
var
   currAmount : currency;
begin

   currAmount := Value/100;
   if AddTotals then
      AddToTotals( currAmount, FCurrDetail.Count);
   if DefaultSign <> NNone then begin
      if DefaultSign = SignOf(Value) then
         FCurrDetail.add(formatPercentString(Abs(currAmount),FColumns.Report_Column_At(FCurrDetail.Count)))
      else
         FCurrDetail.add(formatPercentString(-Abs(currAmount),FColumns.Report_Column_At(FCurrDetail.Count)))
   end else
      FCurrDetail.add(formatPercentString(currAmount,FColumns.Report_Column_At(FCurrDetail.Count)))
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.AddPercentage(Value: money; AddTotals: Boolean;
  DefaultSign: TSign);
begin
   if AddTotals then begin
      AddToTotals(Value/100, FCurrDetail.Count);
   end;
   SkipColumn;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.PutQuantity(aMoney: money; aWrap : boolean);
var
   currAmount : currency;
begin
   currAmount := aMoney/10000;
   PutCurrency(currAmount, true, aWrap);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.PutQuantity(aMoney : money; DefaultSign : TSign; aWrap : boolean);
var
   currAmount : currency;
begin
   currAmount := aMoney/10000;
   PutCurrency(currAmount, DefaultSign, aWrap);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.PutString(aString: string; aWrap : boolean);
var
  Column : integer;
begin
  Column := FCurrDetail.Add(aString);
  if aWrap then
    WrapTextForColumn(Column)
  else
    SwitchWrapForColumn(Column, false);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.PutStringMultipleColumns(aString: string; aNumberOfColumns: integer);
var
  Column : integer;
begin
  Column := FCurrDetail.Add(STRFIELD + ' ' + aString + ENDFIELD +
                            COLSKIPFIELD + ' ' + inttostr(aNumberOfColumns) + ENDFIELD);
  SwitchWrapForColumn(Column, false);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.SkipColumn;
var
  Column : integer;
begin
  Column := FCurrDetail.Add('');
  SwitchWrapForColumn(Column, false);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.SkipColumns(aNumOfColumns: integer);
var
  index : integer;
begin
  for index := 1 to aNumOfColumns do
    SkipColumn;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.SplitText(const Text: String; ColumnWidth: Integer; var WrappedText: TWrappedText);
begin
  RenderEngine.SplitText(Text, ColumnWidth, WrappedText);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.SwitchWrapForColumn(aColumn : integer; aValue: boolean);
var
  ReportColumn : TReportColumn;
begin
  if aColumn >= Columns.ItemCount then
    Exit;

  if aColumn < 0 then
    Exit;

  ReportColumn := Columns.Report_Column_At(aColumn);
  if Assigned(ReportColumn) then
    ReportColumn.DoWrapStr := aValue;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderDetailGrandTotal(const TotalName : string);
begin
   RenderEngine.RenderDetailGrandTotal( TotalName);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderDetailGrandTotal(const TotalName : string;DefaultSign: TSign);
//need to temporarily alter the sign on totals
var
  i : integer;
  NewAmount : Currency;
  ReportCol : TReportColumn;
begin
  for i := 0 to Pred( FColumns.ItemCount) do begin
    ReportCol := FColumns.Report_Column_At( i);
    if ReportCol.isTotalCol
    or ReportCol.isPercentageCol then begin
       NewAmount := ReportCol.GrandTotal;
       if DefaultSign in [Credit, Debit] then begin
         NewAmount := Abs( ReportCol.GrandTotal );
         If SignOf_Curr( ReportCol.GrandTotal) <> DefaultSign then
            NewAmount := -NewAmount;
       end;
       ReportCol.GrandTotal := NewAmount;
    end;
  end;
  //now render amounts
  RenderDetailGrandTotal( TotalName);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderDetailHeader;
begin
   RenderEngine.RenderDetailHeader;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderDetailLine(const isnewDetail: Boolean = True; Style: TStyleTypes = siDetail; aFontOverride : TFont = nil);
begin
  ItemStyle := Style;

  if Assigned(aFontOverride) then
    TRenderToCanvasEng(RenderEngine).OutputBuilder.Canvas.Font := aFontOverride;

  RenderEngine.RenderDetailLine;
  if isNewDetail then
    NewDetail;
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderDetailSubSectionTotal(const TotalName: string);
begin
  RenderEngine.RenderDetailSubSectionTotal( TotalName);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderDetailSubSectionTotal(const TotalName: string;
  DefaultSign: TSign);
var
  i : integer;
  NewAmount : Currency;
  ReportCol : TReportColumn;
begin
  for i := 0 to Pred( FColumns.ItemCount) do begin
    ReportCol := FColumns.Report_Column_At( i);
    if ReportCol.isTotalCol
    or ReportCol.IsPercentageCol then begin
       NewAmount := ReportCol.SubSectionTotal;
       if DefaultSign in [Credit, Debit] then begin
         NewAmount := Abs( ReportCol.SubSectionTotal );
         If SignOf_Curr( ReportCol.SubSectionTotal) <> DefaultSign then
            NewAmount := -NewAmount;
       end;
       ReportCol.SubSectionTotal := NewAmount;
    end;
  end;
  //now render amounts
  RenderDetailSubSectionTotal( TotalName);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.ClearSubSectionTotal;
var
  i : integer;
begin
  for i := 0 to Pred(FColumns.ItemCount) do
    with Columns.Report_Column_At(i) do
      SubSectionTotal := 0;
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderDetailSectionTotal(const TotalName : string);
begin
   RenderEngine.RenderDetailSectionTotal( TotalName);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderDetailSectionTotal(const TotalName : string;DefaultSign: TSign);
//need to temporarily alter the sign on totals
var
  i : integer;
  NewAmount : Currency;
  ReportCol : TReportColumn;
begin
  for i := 0 to Pred( FColumns.ItemCount) do begin
    ReportCol := FColumns.Report_Column_At( i);
    if ReportCol.isTotalCol
    or ReportCol.IsPercentageCol then begin
       NewAmount := ReportCol.SectionTotal;
       if DefaultSign in [Credit, Debit] then begin
         NewAmount := Abs( ReportCol.SectionTotal );
         If SignOf_Curr( ReportCol.SectionTotal) <> DefaultSign then
            NewAmount := -NewAmount;
       end;
       ReportCol.SectionTotal := NewAmount;
    end;
  end;
  //now render amounts
  RenderDetailSectionTotal( TotalName);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderDetailSubTotal(
  const TotalName : string; NewLine: Boolean = True;
        KeepTotals: Boolean = False; TotalSubName: string = '';
        Style: TStyleTypes = siSectionTotal);
begin
   RenderEngine.RenderDetailSubTotal( TotalName, NewLine, KeepTotals, TotalSubName, Style);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderDetailSubTotal(const TotalName : string;DefaultSign: TSign; Style: TStyleTypes = siSectionTotal);
var
  i : integer;
  NewAmount : Currency;
  ReportCol : TReportColumn;
begin
  for i := 0 to Pred( FColumns.ItemCount) do begin
    ReportCol := FColumns.Report_Column_At( i);
    if ReportCol.IsTotalCol
    or ReportCol.IsPercentageCol then begin
       NewAmount := ReportCol.SubTotal;
       if DefaultSign in [Credit, Debit] then begin
         NewAmount := Abs( ReportCol.SubTotal );
         If SignOf_Curr( ReportCol.SubTotal) <> DefaultSign then
            NewAmount := -NewAmount;
       end;
       ReportCol.SubTotal := NewAmount;
    end;
  end;
  //now render amounts

  RenderDetailSubTotal(TotalName,True,False,'', Style);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderEmptyLine;
begin
  RenderEngine.RenderEmptyLine;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderRuledLine;
begin
   RenderEngine.RenderRuledLine;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderRuledLine(Style : TPenStyle);
begin
   RenderEngine.RenderRuledLine(Style);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderRuledLineWithColLines(LeaveLines: integer; aPenStyle: TPenStyle;
  VertColLineType: TVertColLineType);
begin
  RenderEngine.RenderRuledLineWithColLines(LeaveLines, aPenStyle, VertColLineType);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderTextLine(Text: string; Underlined : boolean = false; AddLineIfUnderlined: boolean = True);
begin
   RenderEngine.RenderTextLine( Text, Underlined, AddLineIfUnderlined);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderTitleLine(Text: string);
begin
   RenderEngine.RenderTitleLine( Text);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.ReportNewPage;
begin
   RenderEngine.ReportNewPage;
   BlindOn := True;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.SingleUnderLine;
begin
   RenderEngine.SingleUnderLine;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.DoubleUnderLine;
begin
   RenderEngine.DoubleUnderLine;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RequireLines(lines: integer);
begin
   RenderEngine.RequireLines( lines);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function TBKReport.GenerateToFile(const FileName: string; const FileFormat: Integer; Params: TRptParameters = nil): Boolean;
//Create the file rendering object.  Assumes that valid filename and format are given
//Called when generating scheduled reports for delivery via email
const
   ThisMethodName = 'TReport.GenerateToFile';
var
   sMsg       : string;
begin
   ClearAllTotals;
   Result := True;
   try
      try
         FOriginalDest := rdFile;

         UpdateAppStatus( 'Generating Report',  Self.ReportTitle, 50);
         //create correct rendering object for selected file format
         case FileFormat of
            rfCSV        : RenderEngine := TRenderToFileCSV.Create( Self, Filename);
            rfFixedWidth : begin
               RenderEngine := TRenderToFileFixed.Create( Self, Filename);
               //after new page trigger
               if (Assigned(FOnAfterNewPage)) then
                 RenderEngine.OnAfterNewPage := FOnAfterNewPage;
               //Use reports default orientation to determine max line width
               if GetBKReportDefaultOrientation(FUserReportSettings.s7Report_Name) = poPortrait then
                  TRenderToFileFixed( RenderEngine).MaxLineWidth := 132
               else
                  TRenderToFileFixed( RenderEngine).MaxLineWidth := 160;
            end;
            //rfWord
            rfExcel :
              begin
                try
                  RenderEngine := TRenderToFileExcel.Create( Self, Filename );
               except // Case 8461, anything is better than 'Class not registered'
                  RenderEngine := nil;
                  // Also see OfficeFialed in ClientmanagerFrm
                  raise Exception.Create('"MS Office" options not installed or available');
               end;
              end;
            rfPDF :
              begin
                RenderEngine := TRenderToCanvasEng.Create(Self);
                //after new page trigger
                if (Assigned(FOnAfterNewPage)) then
                  RenderEngine.OnAfterNewPage := FOnAfterNewPage;
                Result := TRenderToCanvasEng(RenderEngine).PrintPDF(Filename);
              end;
         end;
         if Assigned( RenderEngine) then begin
            if Result then begin
              RenderEngine.Generate;
              if assigned(Params) then begin
                 Params.RunReport(rdFile,Filename);
                 incUsage(params.UsageTitle(rdFile));
              end else
                 incUsage(Self.ReportTitle + '(File)');
            end;
            //Clear Application Status window
            ClearStatus;
         end;
      except
         on e : EInOutError do begin
            sMsg := Format( 'Error saving report to "%s" - %s', [FileName, E.Message ] );
            LogUtil.LogMsg( lmError, UnitName, ThisMethodName + ' : ' + sMsg );
         end;
      end;
   finally
      //Make sure memory is freed before leaving
      if Assigned( RenderEngine) then begin
        RenderEngine.Free;
        RenderEngine := nil;
      end;
      ClearStatus;
   end;
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function TBKReport.GenerateToFax(FaxParameters: TFaxParameters; const FaxTransportType: byte; Params: TRptParameters = nil) : boolean;
const
   ThisMethodName = 'TReport.GenerateToFax';
var
   sMsg       : string;
begin
   result := false;
   ClearAllTotals;
   try
     UpdateAppStatus( 'Generating Report',  Self.ReportTitle, 50);
     //create correct rendering object for selected file format
     RenderEngine := TRenderToCanvasEng.Create(Self);
     //after new page trigger
     if (Assigned(FOnAfterNewPage)) then
       RenderEngine.OnAfterNewPage := FOnAfterNewPage;

     try
       case FaxTransportType of
         fxtWindowsFaxService :
             result := TRenderToCanvasEng(RenderEngine).PrintToFax(FaxParameters);
         fxtWinFax :
             TRenderToCanvasEng(RenderEngine).Print;
       else
         raise Exception.Create('Unknown Fax Transport');
       end;

       if assigned(Params) then begin
          Params.RunReport(rdfax);
          incUsage(params.UsageTitle(rdFax));
       end else
          incUsage(Self.ReportTitle + '(Fax)');

     except
       On E : ESSRenderFaxError do
       begin
         sMsg := Format( 'Error generating fax report to "%s" - %s', [ FaxParameters.FaxNumber, E.Message ] );
            LogUtil.LogMsg( lmError, UnitName, ThisMethodName + ' : ' + sMsg );
       end;

       on E : EPrinter do begin
         sMsg := Format( 'Error Generating Report %s - %s', [ Self.ReportTitle,
                                                                E.Message ] );
         LogUtil.LogMsg( lmError, UnitName, ThisMethodName + ' : ' + sMsg );
         HelpfulErrorMsg( sMsg, 0 );
       end;

       on E : EOleError do begin
         sMsg := Format( 'Error generating fax report %s - %s', [ FaxParameters.FaxNumber, E.Message ]  );
         LogUtil.LogMsg( lmError, UnitName, ThisMethodName + ' : ' + sMsg );
         HelpfulErrorMsg( sMsg, 0 );
       end;

     end;
   finally
     //Make sure memory is freed before leaving
     if Assigned( RenderEngine) then begin
       RenderEngine.Free;
       RenderEngine := nil;
     end;
     ClearStatus;
   end;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderMemo(Text: string);
begin
   RenderEngine.RenderMemo( Text);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.ClearGrandTotals;
var
  i : integer;
begin
  ClearSubTotals;
  for i := 0 to Pred(FColumns.ItemCount) do
    with Columns.Report_Column_At(i) do begin
      GrandTotal := 0;
      PercentReference := 0;
    end;
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.ClearSectionTotal;
var
  i : integer;
begin
  ClearSubSectionTotal;
  for i := 0 to Pred(FColumns.ItemCount) do
    with Columns.Report_Column_At(i) do
         SectionTotal := 0;
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.ClearSubTotals;
var
  i : integer;
begin
  ClearSectionTotal;
  for i := 0 to Pred(FColumns.ItemCount) do
    with Columns.Report_Column_At(i) do
      SubTotal := 0;
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.ClearAllTotals;
begin
  ClearSubSectionTotal;
  ClearSectionTotal;
  ClearSubTotals;
  ClearGrandTotals;

  ClearRunningTotals;
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.ClearRunningTotals;
var i : integer;
begin
  for i := 0 to Pred(FColumns.ItemCount) do
    with Columns.Report_Column_At(i) do
      RunningTotal := 0;
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderDetailRunningTotal(const TotalName : string);
begin
  RenderEngine.RenderDetailRunningTotal( TotalName);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderDetailRunningTotal(const TotalName : string; DefaultSign: TSign);
var
  i : integer;
  NewAmount : Currency;
  ReportCol : TReportColumn;
  OriginalValue : array of Currency;
begin
  SetLength( OriginalValue, FColumns.ItemCount);
  for i := 0 to Pred( FColumns.ItemCount) do
     OriginalValue[i] := 0;
  //reverse total temporarily if required
  try
    for i := 0 to Pred( FColumns.ItemCount) do begin
      ReportCol := FColumns.Report_Column_At( i);
      if ReportCol.IsTotalCol
      or ReportCol.IsPercentageCol then begin
         OriginalValue[i] := ReportCol.RunningTotal;
         //correct the sign of the amount so it will be displayed correctly,
         //unfortunately the design of the reporting system doesn't allow
         //us to specify a display amount and a real amount for totals
         NewAmount := ReportCol.RunningTotal;
         if DefaultSign in [Credit, Debit] then begin
           NewAmount := Abs( ReportCol.RunningTotal );
           If SignOf_Curr( ReportCol.RunningTotal) <> DefaultSign then begin
              NewAmount := -NewAmount;
           end;
         end;
         ReportCol.RunningTotal := NewAmount;
      end;
    end;

    //now render amounts
    RenderDetailRunningTotal( TotalName);

  finally
    //because this is a running total we need to reverse it back so that
    //other items can be added
    for i := 0 to Pred( FColumns.ItemCount) do begin
      ReportCol := FColumns.Report_Column_At( i);
      if ReportCol.IsTotalCol
      or ReportCol.IsPercentageCol then begin
         ReportCol.RunningTotal := OriginalValue[i];
      end;
    end;
  end;
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderAllVerticalColumnLines;
begin
  RenderEngine.RenderAllVerticalColumnLines;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.RenderColumnLine(ColNo: Integer);
begin
  RenderEngine.RenderColumnLine(ColNo);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function TBKReport.RenderColumnWidth(aColIndex: integer;
  aText: string): integer;
begin
  Result := RenderEngine.RenderColumnWidth(aColIndex, aText);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.UseCustomFont(aFontname: string; aFontSize: integer; aFontStyle: TFontStyles; aLineSize : integer = 0);
begin
  RenderEngine.UseCustomFont( aFontname, aFontsize, aFontStyle, aLineSize);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.UseDefaultFont;
begin
  RenderEngine.UseDefaultFont;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.WrapText(ColID: Integer; TextToWrap: string;
  var ExtraLines: TStringList);
var
  j, ColWidth, OldWidth : Integer;
  TextList: TStringList;
  MaxLines: Integer;
begin
  MaxLines := 5;
  ExtraLines.Clear;
  if (TextToWrap = '') then
    SkipColumn
  else
  begin
    TextList := TStringList.Create;
    try
      TextList.Text := TextToWrap;
      j := 0;
      repeat
        ColWidth := RenderEngine.RenderColumnWidth(ColID, TextList[ j]);
        if (ColWidth < Length(TextList[j])) then
        begin
          //line needs to be split
          OldWidth := ColWidth; //store
          while (ColWidth > 0) and (TextList[j][ColWidth] <> ' ') do
            Dec(ColWidth);
          if (ColWidth = 0) then
            ColWidth := OldWidth; //unexpected!
          TextList.Insert(j + 1, Copy(TextList[j], ColWidth + 1, Length(TextList[j]) - ColWidth + 1));
          TextList[j] := Copy(TextList[j], 1, ColWidth);
        end;
        if j = 0 then
          PutString( TextList[ j])
        else
          ExtraLines.Add(TextList[j]);
        Inc( j);
      until ( j >= TextList.Count) or ( j >= MaxLines);
    finally
       TextList.Free;
    end;
  end;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReport.WrapTextForColumn(aColumn: integer);
var
  ColIndex : integer;
  TotalLineWidth : integer;
  ReportColumn : TReportColumn;
  ColomnWidth : integer;
  TextWidth : integer;
  CurrentText : string;
  LineText : string;
  CurrStrWidth : integer;
  StrWidth : integer;
  FullText : string;
begin
  if aColumn >= Columns.ItemCount then
    Exit;

  if aColumn < 0 then
    Exit;

  if aColumn >=  CurrDetail.Count then
    Exit;

  ReportColumn := Columns.Report_Column_At(aColumn);
  if Assigned(ReportColumn) then
  begin
    // Get String Data from Column
    FullText := CurrDetail.Strings[aColumn];

    ReportColumn.WrappedStr.Clear;
    ReportColumn.DoWrapStr := true;
    ColomnWidth := ReportColumn.CanvasWidth;

    // Check if the Full text fits into the column
    TextWidth := GetTextWidth(FullText);
    if TextWidth <= ColomnWidth then
    begin
      ReportColumn.WrappedStr.Add(FullText);
    end
    else
    begin
      // Loop through Text and add text that fits into string list
      CurrentText := FullText;
      repeat
        StrWidth := length(CurrentText);
        CurrStrWidth := GetLengthOfTextThatFitsIntoWidth(CurrentText, ColomnWidth);
        LineText := leftstr(CurrentText, CurrStrWidth);

        ReportColumn.WrappedStr.Add(LineText);

        if (StrWidth > CurrStrWidth) then
          CurrentText := rightStr(CurrentText, StrWidth-CurrStrWidth);
      until (StrWidth <= CurrStrWidth);
    end;
  end;
end;

{ TBKReportRecordLines }
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReportRecordLines.AddColumnText(ColumnId: Integer; const Text: String; Wrap: Boolean = False);
begin
  AddColumnText(ColumnId, [Text], Wrap);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReportRecordLines.AddColumnText(ColumnId: Integer; const TextLines: array of String; Wrap: Boolean = False);

  function GetFirstUnassigned(ColumnId: Integer): Integer;
  var
    Index: Integer;
  begin
    Result := 0;
    
    for Index := 0 to Length(FColumnLines[ColumnId]) - 1 do
    begin
      if VarIsEmpty(FColumnLines[ColumnId][Index]) then
      begin
        Result := Index;

        Break;
      end;
    end;
  end;
  
var
  Index: Integer;
  IIndex: Integer;
  WrappedText: TWrappedText;
  StartLine: Integer;
begin
  if Wrap then
  begin
    StartLine := GetFirstUnassigned(ColumnId);
      
    for Index := 0 to Length(TextLines) - 1 do
    begin
      FReport.SplitText(TextLines[Index], FReport.Columns.Report_Column_At(ColumnId).Width, WrappedText); 
            
      if Length(FColumnLines[ColumnId]) - StartLine < Length(WrappedText) then
      begin
        NewLines(Length(WrappedText) - (Length(FColumnLines[ColumnId]) - StartLine));
      end;
  
      for IIndex := 0 to Length(WrappedText) -1 do
      begin
        FColumnLines[ColumnId][StartLine + IIndex] := WrappedText[IIndex];
      end;

      Inc(StartLine, Length(WrappedText));

      SetLength(WrappedText, 0);
    end;
  end
  else
  begin
    for Index := 0 to Length(TextLines) - 1 do
    begin
      if Length(FColumnLines[ColumnId]) < Length(TextLines) then
      begin
        NewLines(Length(TextLines) - Length(FColumnLines[ColumnId]));
      end;
      
      FColumnLines[ColumnId][Index] := TextLines[Index];
    end;  
  end;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReportRecordLines.AddColumnValue(ColumnId: Integer; Value: Variant);
begin
  FColumnLines[ColumnId][0] := Value;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReportRecordLines.BeginUpdate;
begin
  Reset;
  
  NewLines(1);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReportRecordLines.Clear;
var
  Index: Integer;
begin
  for Index := 0 to Length(FColumnLines) - 1 do
  begin
    SetLength(FColumnLines[Index], 0);
  end;

  SetLength(FColumnLines, 0);

  FMaxLines := 0;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
constructor TBKReportRecordLines.Create(Report: TBKReport; WriteColumnValue: TWriteColumnValue);
begin
  FReport := Report;
  FMaxLines := 1;

  FWriteColumnValue := WriteColumnValue;
  
  SetLength(FColumnLines, 0);
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
destructor TBKReportRecordLines.Destroy;
begin
  SetLength(FColumnLines, 0);
  
  inherited;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReportRecordLines.EndUpdate;
begin
  PutLines;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReportRecordLines.NewLines(NumLines: Integer);
var
  Index: Integer;
  IIndex: Integer;
  StartLine: Integer;
begin
  for Index := 0 to FReport.Columns.ItemCount - 1 do
  begin
    StartLine := Length(FColumnLines[Index]);
    
    SetLength(FColumnLines[Index], Length(FColumnLines[Index]) + NumLines);

    for IIndex := StartLine to Length(FColumnLines[Index]) -1 do
    begin
      FColumnLines[Index][IIndex] := Unassigned;
    end;
    
    if Length(FColumnLines[Index]) > FMaxLines then
    begin
      FMaxLines := Length(FColumnLines[Index]);
    end;
  end;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReportRecordLines.PutLines;
var
  ColumnLineIndex: Integer;
  ColumnValueIndex: Integer;
begin
  if Assigned(FWriteColumnValue) then
  begin
    for ColumnValueIndex := 0 to FMaxLines - 1 do
    begin
      for ColumnLineIndex := 0 to Length(FColumnLines) - 1 do
      begin
        if not VarIsEmpty(FColumnLines[ColumnLineIndex][ColumnValueIndex]) then
        begin
          FWriteColumnValue(FReport, ColumnLineIndex, FColumnLines[ColumnLineIndex][ColumnValueIndex]);
        end
        else
        begin
          FReport.SkipColumn;
        end;
      end;

      FReport.RenderDetailLine;
    end;
  end;
end;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
procedure TBKReportRecordLines.Reset;
begin
  Clear;

  SetLength(FColumnLines, FReport.Columns.ItemCount);
end;

end.
